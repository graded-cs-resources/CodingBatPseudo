(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var micromatch = require('micromatch');
var normalize = require('normalize-path');
var path = require('path'); // required for tests.
var arrify = function(a) { return a == null ? [] : (Array.isArray(a) ? a : [a]); };

var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
  criteria = arrify(criteria);
  value = arrify(value);
  if (arguments.length === 1) {
    return anymatch.bind(null, criteria.map(function(criterion) {
      return typeof criterion === 'string' && criterion[0] !== '!' ?
        micromatch.matcher(criterion) : criterion;
    }));
  }
  startIndex = startIndex || 0;
  var string = value[0];
  var altString, altValue;
  var matched = false;
  var matchIndex = -1;
  function testCriteria(criterion, index) {
    var result;
    switch (Object.prototype.toString.call(criterion)) {
    case '[object String]':
      result = string === criterion || altString && altString === criterion;
      result = result || micromatch.isMatch(string, criterion);
      break;
    case '[object RegExp]':
      result = criterion.test(string) || altString && criterion.test(altString);
      break;
    case '[object Function]':
      result = criterion.apply(null, value);
      result = result || altValue && criterion.apply(null, altValue);
      break;
    default:
      result = false;
    }
    if (result) {
      matchIndex = index + startIndex;
    }
    return result;
  }
  var crit = criteria;
  var negGlobs = crit.reduce(function(arr, criterion, index) {
    if (typeof criterion === 'string' && criterion[0] === '!') {
      if (crit === criteria) {
        // make a copy before modifying
        crit = crit.slice();
      }
      crit[index] = null;
      arr.push(criterion.substr(1));
    }
    return arr;
  }, []);
  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
    if (path.sep === '\\' && typeof string === 'string') {
      altString = normalize(string);
      altString = altString === string ? null : altString;
      if (altString) altValue = [altString].concat(value.slice(1));
    }
    matched = crit.slice(startIndex, endIndex).some(testCriteria);
  }
  return returnIndex === true ? matchIndex : matched;
};

module.exports = anymatch;

},{"micromatch":102,"normalize-path":115,"path":207}],2:[function(require,module,exports){
/*!
 * arr-diff <https://github.com/jonschlinkert/arr-diff>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function diff(arr/*, arrays*/) {
  var len = arguments.length;
  var idx = 0;
  while (++idx < len) {
    arr = diffArray(arr, arguments[idx]);
  }
  return arr;
};

function diffArray(one, two) {
  if (!Array.isArray(two)) {
    return one.slice();
  }

  var tlen = two.length
  var olen = one.length;
  var idx = -1;
  var arr = [];

  while (++idx < olen) {
    var ele = one[idx];

    var hasEle = false;
    for (var i = 0; i < tlen; i++) {
      var val = two[i];

      if (ele === val) {
        hasEle = true;
        break;
      }
    }

    if (hasEle === false) {
      arr.push(ele);
    }
  }
  return arr;
}

},{}],3:[function(require,module,exports){
/*!
 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function (arr) {
  return flat(arr, []);
};

function flat(arr, res) {
  var i = 0, cur;
  var len = arr.length;
  for (; i < len; i++) {
    cur = arr[i];
    Array.isArray(cur) ? flat(cur, res) : res.push(cur);
  }
  return res;
}

},{}],4:[function(require,module,exports){
'use strict';

module.exports = function union(init) {
  if (!Array.isArray(init)) {
    throw new TypeError('arr-union expects the first argument to be an array.');
  }

  var len = arguments.length;
  var i = 0;

  while (++i < len) {
    var arg = arguments[i];
    if (!arg) continue;

    if (!Array.isArray(arg)) {
      arg = [arg];
    }

    for (var j = 0; j < arg.length; j++) {
      var ele = arg[j];

      if (init.indexOf(ele) >= 0) {
        continue;
      }
      init.push(ele);
    }
  }
  return init;
};

},{}],5:[function(require,module,exports){
/*!
 * array-unique <https://github.com/jonschlinkert/array-unique>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function unique(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }

  var len = arr.length;
  var i = -1;

  while (i++ < len) {
    var j = i + 1;

    for (; j < arr.length; ++j) {
      if (arr[i] === arr[j]) {
        arr.splice(j--, 1);
      }
    }
  }
  return arr;
};

module.exports.immutable = function uniqueImmutable(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }

  var arrLen = arr.length;
  var newArr = new Array(arrLen);

  for (var i = 0; i < arrLen; i++) {
    newArr[i] = arr[i];
  }

  return module.exports(newArr);
};

},{}],6:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":116,"util/":9}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],9:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":8,"_process":128,"inherits":7}],10:[function(require,module,exports){
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function(receiver, objects) {
  if (receiver === null || typeof receiver === 'undefined') {
    throw new TypeError('expected first argument to be an object.');
  }

  if (typeof objects === 'undefined' || typeof Symbol === 'undefined') {
    return receiver;
  }

  if (typeof Object.getOwnPropertySymbols !== 'function') {
    return receiver;
  }

  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var target = Object(receiver);
  var len = arguments.length, i = 0;

  while (++i < len) {
    var provider = Object(arguments[i]);
    var names = Object.getOwnPropertySymbols(provider);

    for (var j = 0; j < names.length; j++) {
      var key = names[j];

      if (isEnumerable.call(provider, key)) {
        target[key] = provider[key];
      }
    }
  }
  return target;
};

},{}],11:[function(require,module,exports){
// async-each MIT license (by Paul Miller from https://paulmillr.com).
(function(globals) {
  'use strict';
  var each = function(items, next, callback) {
    if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
    if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
    if (typeof callback !== 'function') callback = Function.prototype; // no-op

    if (items.length === 0) return callback(undefined, items);

    var transformed = new Array(items.length);
    var count = 0;
    var returned = false;

    items.forEach(function(item, index) {
      next(item, function(error, transformedItem) {
        if (returned) return;
        if (error) {
          returned = true;
          return callback(error);
        }
        transformed[index] = transformedItem;
        count += 1;
        if (count === items.length) return callback(undefined, transformed);
      });
    });
  };

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return each;
    }); // RequireJS
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = each; // CommonJS
  } else {
    globals.asyncEach = each; // <script>
  }
})(this);

},{}],12:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],13:[function(require,module,exports){
'use strict';

var util = require('util');
var define = require('define-property');
var CacheBase = require('cache-base');
var Emitter = require('component-emitter');
var isObject = require('isobject');
var merge = require('mixin-deep');
var pascal = require('pascalcase');
var cu = require('class-utils');

/**
 * Optionally define a custom `cache` namespace to use.
 */

function namespace(name) {
  var Cache = name ? CacheBase.namespace(name) : CacheBase;
  var fns = [];

  /**
   * Create an instance of `Base` with the given `config` and `options`.
   *
   * ```js
   * // initialize with `config` and `options`
   * var app = new Base({isApp: true}, {abc: true});
   * app.set('foo', 'bar');
   *
   * // values defined with the given `config` object will be on the root of the instance
   * console.log(app.baz); //=> undefined
   * console.log(app.foo); //=> 'bar'
   * // or use `.get`
   * console.log(app.get('isApp')); //=> true
   * console.log(app.get('foo')); //=> 'bar'
   *
   * // values defined with the given `options` object will be on `app.options
   * console.log(app.options.abc); //=> true
   * ```
   *
   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.
   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.
   * @api public
   */

  function Base(config, options) {
    if (!(this instanceof Base)) {
      return new Base(config, options);
    }
    Cache.call(this, config);
    this.is('base');
    this.initBase(config, options);
  }

  /**
   * Inherit cache-base
   */

  util.inherits(Base, Cache);

  /**
   * Add static emitter methods
   */

  Emitter(Base);

  /**
   * Initialize `Base` defaults with the given `config` object
   */

  Base.prototype.initBase = function(config, options) {
    this.options = merge({}, this.options, options);
    this.cache = this.cache || {};
    this.define('registered', {});
    if (name) this[name] = {};

    // make `app._callbacks` non-enumerable
    this.define('_callbacks', this._callbacks);
    if (isObject(config)) {
      this.visit('set', config);
    }
    Base.run(this, 'use', fns);
  };

  /**
   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing
   * lookups in plugins.
   *
   * ```js
   * app.is('foo');
   * console.log(app._name);
   * //=> 'foo'
   * console.log(app.isFoo);
   * //=> true
   * app.is('bar');
   * console.log(app.isFoo);
   * //=> true
   * console.log(app.isBar);
   * //=> true
   * console.log(app._name);
   * //=> 'bar'
   * ```
   * @name .is
   * @param {String} `name`
   * @return {Boolean}
   * @api public
   */

  Base.prototype.is = function(name) {
    if (typeof name !== 'string') {
      throw new TypeError('expected name to be a string');
    }
    this.define('is' + pascal(name), true);
    this.define('_name', name);
    this.define('_appname', name);
    return this;
  };

  /**
   * Returns true if a plugin has already been registered on an instance.
   *
   * Plugin implementors are encouraged to use this first thing in a plugin
   * to prevent the plugin from being called more than once on the same
   * instance.
   *
   * ```js
   * var base = new Base();
   * base.use(function(app) {
   *   if (app.isRegistered('myPlugin')) return;
   *   // do stuff to `app`
   * });
   *
   * // to also record the plugin as being registered
   * base.use(function(app) {
   *   if (app.isRegistered('myPlugin', true)) return;
   *   // do stuff to `app`
   * });
   * ```
   * @name .isRegistered
   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.
   * @param {String} `name` The plugin name.
   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.
   * @return {Boolean} Returns true if a plugin is already registered.
   * @api public
   */

  Base.prototype.isRegistered = function(name, register) {
    if (this.registered.hasOwnProperty(name)) {
      return true;
    }
    if (register !== false) {
      this.registered[name] = true;
      this.emit('plugin', name);
    }
    return false;
  };

  /**
   * Define a plugin function to be called immediately upon init. Plugins are chainable
   * and expose the following arguments to the plugin function:
   *
   * - `app`: the current instance of `Base`
   * - `base`: the [first ancestor instance](#base) of `Base`
   *
   * ```js
   * var app = new Base()
   *   .use(foo)
   *   .use(bar)
   *   .use(baz)
   * ```
   * @name .use
   * @param {Function} `fn` plugin function to call
   * @return {Object} Returns the item instance for chaining.
   * @api public
   */

  Base.prototype.use = function(fn) {
    fn.call(this, this);
    return this;
  };

  /**
   * The `.define` method is used for adding non-enumerable property on the instance.
   * Dot-notation is **not supported** with `define`.
   *
   * ```js
   * // arbitrary `render` function using lodash `template`
   * app.define('render', function(str, locals) {
   *   return _.template(str)(locals);
   * });
   * ```
   * @name .define
   * @param {String} `key` The name of the property to define.
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Base.prototype.define = function(key, val) {
    if (isObject(key)) {
      return this.visit('define', key);
    }
    define(this, key, val);
    return this;
  };

  /**
   * Mix property `key` onto the Base prototype. If base is inherited using
   * `Base.extend` this method will be overridden by a new `mixin` method that will
   * only add properties to the prototype of the inheriting application.
   *
   * ```js
   * app.mixin('foo', function() {
   *   // do stuff
   * });
   * ```
   * @name .mixin
   * @param {String} `key`
   * @param {Object|Array} `val`
   * @return {Object} Returns the `base` instance for chaining.
   * @api public
   */

  Base.prototype.mixin = function(key, val) {
    Base.prototype[key] = val;
    return this;
  };

  /**
   * Non-enumberable mixin array, used by the static [Base.mixin]() method.
   */

  Base.prototype.mixins = Base.prototype.mixins || [];

  /**
   * Getter/setter used when creating nested instances of `Base`, for storing a reference
   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`
   * property of a "child" instance. The `base` property defaults to the current instance if
   * no `parent` property is defined.
   *
   * ```js
   * // create an instance of `Base`, this is our first ("base") instance
   * var first = new Base();
   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later
   *
   * // create another instance
   * var second = new Base();
   * // create a reference to the first instance (`first`)
   * second.parent = first;
   *
   * // create another instance
   * var third = new Base();
   * // create a reference to the previous instance (`second`)
   * // repeat this pattern every time a "child" instance is created
   * third.parent = second;
   *
   * // we can always access the first instance using the `base` property
   * console.log(first.base.foo);
   * //=> 'bar'
   * console.log(second.base.foo);
   * //=> 'bar'
   * console.log(third.base.foo);
   * //=> 'bar'
   * // and now you know how to get to third base ;)
   * ```
   * @name .base
   * @api public
   */

  Object.defineProperty(Base.prototype, 'base', {
    configurable: true,
    get: function() {
      return this.parent ? this.parent.base : this;
    }
  });

  /**
   * Static method for adding global plugin functions that will
   * be added to an instance when created.
   *
   * ```js
   * Base.use(function(app) {
   *   app.foo = 'bar';
   * });
   * var app = new Base();
   * console.log(app.foo);
   * //=> 'bar'
   * ```
   * @name #use
   * @param {Function} `fn` Plugin function to use on each instance.
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'use', function(fn) {
    fns.push(fn);
    return Base;
  });

  /**
   * Run an array of functions by passing each function
   * to a method on the given object specified by the given property.
   *
   * @param  {Object} `obj` Object containing method to use.
   * @param  {String} `prop` Name of the method on the object to use.
   * @param  {Array} `arr` Array of functions to pass to the method.
   */

  define(Base, 'run', function(obj, prop, arr) {
    var len = arr.length, i = 0;
    while (len--) {
      obj[prop](arr[i++]);
    }
    return Base;
  });

  /**
   * Static method for inheriting the prototype and static methods of the `Base` class.
   * This method greatly simplifies the process of creating inheritance-based applications.
   * See [static-extend][] for more details.
   *
   * ```js
   * var extend = cu.extend(Parent);
   * Parent.extend(Child);
   *
   * // optional methods
   * Parent.extend(Child, {
   *   foo: function() {},
   *   bar: function() {}
   * });
   * ```
   * @name #extend
   * @param {Function} `Ctor` constructor to extend
   * @param {Object} `methods` Optional prototype properties to mix in.
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'extend', cu.extend(Base, function(Ctor, Parent) {
    Ctor.prototype.mixins = Ctor.prototype.mixins || [];

    define(Ctor, 'mixin', function(fn) {
      var mixin = fn(Ctor.prototype, Ctor);
      if (typeof mixin === 'function') {
        Ctor.prototype.mixins.push(mixin);
      }
      return Ctor;
    });

    define(Ctor, 'mixins', function(Child) {
      Base.run(Child, 'mixin', Ctor.prototype.mixins);
      return Ctor;
    });

    Ctor.prototype.mixin = function(key, value) {
      Ctor.prototype[key] = value;
      return this;
    };
    return Base;
  }));

  /**
   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.
   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`
   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is
   * called (e.g. `Base.mixins(Child)`).
   *
   * ```js
   * Base.mixin(function(proto) {
   *   proto.foo = function(msg) {
   *     return 'foo ' + msg;
   *   };
   * });
   * ```
   * @name #mixin
   * @param {Function} `fn` Function to call
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'mixin', function(fn) {
    var mixin = fn(Base.prototype, Base);
    if (typeof mixin === 'function') {
      Base.prototype.mixins.push(mixin);
    }
    return Base;
  });

  /**
   * Static method for running global mixin functions against a child constructor.
   * Mixins must be registered before calling this method.
   *
   * ```js
   * Base.extend(Child);
   * Base.mixins(Child);
   * ```
   * @name #mixins
   * @param {Function} `Child` Constructor function of a child class
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'mixins', function(Child) {
    Base.run(Child, 'mixin', Base.prototype.mixins);
    return Base;
  });

  /**
   * Similar to `util.inherit`, but copies all static properties, prototype properties, and
   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.
   *
   * ```js
   * Base.inherit(Foo, Bar);
   * ```
   * @name #inherit
   * @param {Function} `Receiver` Receiving (child) constructor
   * @param {Function} `Provider` Providing (parent) constructor
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'inherit', cu.inherit);
  define(Base, 'bubble', cu.bubble);
  return Base;
}

/**
 * Expose `Base` with default settings
 */

module.exports = namespace();

/**
 * Allow users to define a namespace
 */

module.exports.namespace = namespace;

},{"cache-base":27,"class-utils":32,"component-emitter":37,"define-property":14,"isobject":97,"mixin-deep":107,"pascalcase":123,"util":211}],14:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isDescriptor = require('is-descriptor');

module.exports = function defineProperty(obj, prop, val) {
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('expected an object or function.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('expected `prop` to be a string.');
  }

  if (isDescriptor(val) && ('set' in val || 'get' in val)) {
    return Object.defineProperty(obj, prop, val);
  }

  return Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
};

},{"is-descriptor":17}],15:[function(require,module,exports){
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// accessor descriptor properties
var accessor = {
  get: 'function',
  set: 'function',
  configurable: 'boolean',
  enumerable: 'boolean'
};

function isAccessorDescriptor(obj, prop) {
  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (has(obj, 'value') || has(obj, 'writable')) {
    return false;
  }

  if (!has(obj, 'get') || typeof obj.get !== 'function') {
    return false;
  }

  // tldr: it's valid to have "set" be undefined
  // "set" might be undefined if `Object.getOwnPropertyDescriptor`
  // was used to get the value, and only `get` was defined by the user
  if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
    return false;
  }

  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === accessor[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

function has(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}

/**
 * Expose `isAccessorDescriptor`
 */

module.exports = isAccessorDescriptor;

},{"kind-of":99}],16:[function(require,module,exports){
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function isDataDescriptor(obj, prop) {
  // data descriptor properties
  var data = {
    configurable: 'boolean',
    enumerable: 'boolean',
    writable: 'boolean'
  };

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (!('value' in obj) && !('writable' in obj)) {
    return false;
  }

  for (var key in obj) {
    if (key === 'value') continue;

    if (!data.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === data[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
};

},{"kind-of":99}],17:[function(require,module,exports){
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');
var isAccessor = require('is-accessor-descriptor');
var isData = require('is-data-descriptor');

module.exports = function isDescriptor(obj, key) {
  if (typeOf(obj) !== 'object') {
    return false;
  }
  if ('get' in obj) {
    return isAccessor(obj, key);
  }
  return isData(obj, key);
};

},{"is-accessor-descriptor":15,"is-data-descriptor":16,"kind-of":99}],18:[function(require,module,exports){
module.exports=[
	"3dm",
	"3ds",
	"3g2",
	"3gp",
	"7z",
	"a",
	"aac",
	"adp",
	"ai",
	"aif",
	"aiff",
	"alz",
	"ape",
	"apk",
	"ar",
	"arj",
	"asf",
	"au",
	"avi",
	"bak",
	"baml",
	"bh",
	"bin",
	"bk",
	"bmp",
	"btif",
	"bz2",
	"bzip2",
	"cab",
	"caf",
	"cgm",
	"class",
	"cmx",
	"cpio",
	"cr2",
	"cur",
	"dat",
	"dcm",
	"deb",
	"dex",
	"djvu",
	"dll",
	"dmg",
	"dng",
	"doc",
	"docm",
	"docx",
	"dot",
	"dotm",
	"dra",
	"DS_Store",
	"dsk",
	"dts",
	"dtshd",
	"dvb",
	"dwg",
	"dxf",
	"ecelp4800",
	"ecelp7470",
	"ecelp9600",
	"egg",
	"eol",
	"eot",
	"epub",
	"exe",
	"f4v",
	"fbs",
	"fh",
	"fla",
	"flac",
	"fli",
	"flv",
	"fpx",
	"fst",
	"fvt",
	"g3",
	"gh",
	"gif",
	"graffle",
	"gz",
	"gzip",
	"h261",
	"h263",
	"h264",
	"icns",
	"ico",
	"ief",
	"img",
	"ipa",
	"iso",
	"jar",
	"jpeg",
	"jpg",
	"jpgv",
	"jpm",
	"jxr",
	"key",
	"ktx",
	"lha",
	"lib",
	"lvp",
	"lz",
	"lzh",
	"lzma",
	"lzo",
	"m3u",
	"m4a",
	"m4v",
	"mar",
	"mdi",
	"mht",
	"mid",
	"midi",
	"mj2",
	"mka",
	"mkv",
	"mmr",
	"mng",
	"mobi",
	"mov",
	"movie",
	"mp3",
	"mp4",
	"mp4a",
	"mpeg",
	"mpg",
	"mpga",
	"mxu",
	"nef",
	"npx",
	"numbers",
	"nupkg",
	"o",
	"oga",
	"ogg",
	"ogv",
	"otf",
	"pages",
	"pbm",
	"pcx",
	"pdb",
	"pdf",
	"pea",
	"pgm",
	"pic",
	"png",
	"pnm",
	"pot",
	"potm",
	"potx",
	"ppa",
	"ppam",
	"ppm",
	"pps",
	"ppsm",
	"ppsx",
	"ppt",
	"pptm",
	"pptx",
	"psd",
	"pya",
	"pyc",
	"pyo",
	"pyv",
	"qt",
	"rar",
	"ras",
	"raw",
	"resources",
	"rgb",
	"rip",
	"rlc",
	"rmf",
	"rmvb",
	"rtf",
	"rz",
	"s3m",
	"s7z",
	"scpt",
	"sgi",
	"shar",
	"sil",
	"sketch",
	"slk",
	"smv",
	"snk",
	"so",
	"stl",
	"suo",
	"sub",
	"swf",
	"tar",
	"tbz",
	"tbz2",
	"tga",
	"tgz",
	"thmx",
	"tif",
	"tiff",
	"tlz",
	"ttc",
	"ttf",
	"txz",
	"udf",
	"uvh",
	"uvi",
	"uvm",
	"uvp",
	"uvs",
	"uvu",
	"viv",
	"vob",
	"war",
	"wav",
	"wax",
	"wbmp",
	"wdp",
	"weba",
	"webm",
	"webp",
	"whl",
	"wim",
	"wm",
	"wma",
	"wmv",
	"wmx",
	"woff",
	"woff2",
	"wrm",
	"wvx",
	"xbm",
	"xif",
	"xla",
	"xlam",
	"xls",
	"xlsb",
	"xlsm",
	"xlsx",
	"xlt",
	"xltm",
	"xltx",
	"xm",
	"xmind",
	"xpi",
	"xpm",
	"xwd",
	"xz",
	"z",
	"zip",
	"zipx"
]

},{}],19:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var toRegex = require('to-regex');
var unique = require('array-unique');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Braces = require('./lib/braces');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;
var cache = {};

/**
 * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces('{a,b,c}'));
 * //=> ['(a|b|c)']
 *
 * console.log(braces('{a,b,c}', {expand: true}));
 * //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

function braces(pattern, options) {
  var key = utils.createKey(String(pattern), options);
  var arr = [];

  var disabled = options && options.cache === false;
  if (!disabled && cache.hasOwnProperty(key)) {
    return cache[key];
  }

  if (Array.isArray(pattern)) {
    for (var i = 0; i < pattern.length; i++) {
      arr.push.apply(arr, braces.create(pattern[i], options));
    }
  } else {
    arr = braces.create(pattern, options);
  }

  if (options && options.nodupes === true) {
    arr = unique(arr);
  }

  if (!disabled) {
    cache[key] = arr;
  }
  return arr;
}

/**
 * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = function(pattern, options) {
  return braces.create(pattern, extend({}, options, {expand: true}));
};

/**
 * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.optimize = function(pattern, options) {
  return braces.create(pattern, options);
};

/**
 * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }

  function create() {
    if (pattern === '' || pattern.length < 3) {
      return [pattern];
    }

    if (utils.isEmptySets(pattern)) {
      return [];
    }

    if (utils.isQuotedString(pattern)) {
      return [pattern.slice(1, -1)];
    }

    var proto = new Braces(options);
    var result = !options || options.expand !== true
      ? proto.optimize(pattern, options)
      : proto.expand(pattern, options);

    // get the generated pattern(s)
    var arr = result.output;

    // filter out empty strings if specified
    if (options && options.noempty === true) {
      arr = arr.filter(Boolean);
    }

    // filter out duplicates if specified
    if (options && options.nodupes === true) {
      arr = unique(arr);
    }

    Object.defineProperty(arr, 'result', {
      enumerable: false,
      value: result
    });

    return arr;
  }

  return memoize('create', pattern, options, create);
};

/**
 * Create a regular expression from the given string `pattern`.
 *
 * ```js
 * var braces = require('braces');
 *
 * console.log(braces.makeRe('id-{200..300}'));
 * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

braces.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }

  function makeRe() {
    var arr = braces(pattern, options);
    var opts = extend({strictErrors: false}, options);
    return toRegex(arr, opts);
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `pattern` Brace pattern to parse
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = function(pattern, options) {
  var proto = new Braces(options);
  return proto.parse(pattern, options);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(braces.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

braces.compile = function(ast, options) {
  var proto = new Braces(options);
  return proto.compile(ast, options);
};

/**
 * Clear the regex cache.
 *
 * ```js
 * braces.clearCache();
 * ```
 * @api public
 */

braces.clearCache = function() {
  cache = braces.cache = {};
};

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the method name, pattern, and user-defined options. Set
 * options.memoize to false to disable.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + ':' + pattern, options);
  var disabled = options && options.cache === false;
  if (disabled) {
    braces.clearCache();
    return fn(pattern, options);
  }

  if (cache.hasOwnProperty(key)) {
    return cache[key];
  }

  var res = fn(pattern, options);
  cache[key] = res;
  return res;
}

/**
 * Expose `Braces` constructor and methods
 * @type {Function}
 */

braces.Braces = Braces;
braces.compilers = compilers;
braces.parsers = parsers;
braces.cache = cache;

/**
 * Expose `braces`
 * @type {Function}
 */

module.exports = braces;

},{"./lib/braces":20,"./lib/compilers":21,"./lib/parsers":22,"./lib/utils":23,"array-unique":5,"extend-shallow":24,"to-regex":195}],20:[function(require,module,exports){
'use strict';

var extend = require('extend-shallow');
var Snapdragon = require('snapdragon');
var compilers = require('./compilers');
var parsers = require('./parsers');
var utils = require('./utils');

/**
 * Customize Snapdragon parser and renderer
 */

function Braces(options) {
  this.options = extend({}, options);
}

/**
 * Initialize braces
 */

Braces.prototype.init = function(options) {
  if (this.isInitialized) return;
  this.isInitialized = true;
  var opts = utils.createOptions({}, this.options, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon, opts);
  parsers(this.snapdragon, opts);

  /**
   * Call Snapdragon `.parse` method. When AST is returned, we check to
   * see if any unclosed braces are left on the stack and, if so, we iterate
   * over the stack and correct the AST so that compilers are called in the correct
   * order and unbalance braces are properly escaped.
   */

  utils.define(this.snapdragon, 'parse', function(pattern, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    this.parser.ast.input = pattern;

    var stack = this.parser.stack;
    while (stack.length) {
      addParent({type: 'brace.close', val: ''}, stack.pop());
    }

    function addParent(node, parent) {
      utils.define(node, 'parent', parent);
      parent.nodes.push(node);
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });
};

/**
 * Decorate `.parse` method
 */

Braces.prototype.parse = function(ast, options) {
  if (ast && typeof ast === 'object' && ast.nodes) return ast;
  this.init(options);
  return this.snapdragon.parse(ast, options);
};

/**
 * Decorate `.compile` method
 */

Braces.prototype.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = this.parse(ast, options);
  } else {
    this.init(options);
  }
  return this.snapdragon.compile(ast, options);
};

/**
 * Expand
 */

Braces.prototype.expand = function(pattern) {
  var ast = this.parse(pattern, {expand: true});
  return this.compile(ast, {expand: true});
};

/**
 * Optimize
 */

Braces.prototype.optimize = function(pattern) {
  var ast = this.parse(pattern, {optimize: true});
  return this.compile(ast, {optimize: true});
};

/**
 * Expose `Braces`
 */

module.exports = Braces;

},{"./compilers":21,"./parsers":22,"./utils":23,"extend-shallow":24,"snapdragon":166}],21:[function(require,module,exports){
'use strict';

var utils = require('./utils');

module.exports = function(braces, options) {
  braces.compiler

    /**
     * bos
     */

    .set('bos', function() {
      if (this.output) return;
      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
      this.ast.count = 1;
    })

    /**
     * Square brackets
     */

    .set('bracket', function(node) {
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;

      inner = inner.replace(/\\(?=[\\\w]|$)/g, '\\\\');
      if (inner === ']-') {
        inner = '\\]\\-';
      }

      if (negated && inner.indexOf('.') === -1) {
        inner += '.';
      }
      if (negated && inner.indexOf('/') === -1) {
        inner += '/';
      }

      var val = open + negated + inner + close;
      var queue = node.parent.queue;
      var last = utils.arrayify(queue.pop());

      queue.push(utils.join(last, val));
      queue.push.apply(queue, []);
    })

    /**
     * Brace
     */

    .set('brace', function(node) {
      node.queue = isEscaped(node) ? [node.val] : [];
      node.count = 1;
      return this.mapVisit(node.nodes);
    })

    /**
     * Open
     */

    .set('brace.open', function(node) {
      node.parent.open = node.val;
    })

    /**
     * Inner
     */

    .set('text', function(node) {
      var queue = node.parent.queue;
      var escaped = node.escaped;
      var segs = [node.val];

      if (node.optimize === false) {
        options = utils.extend({}, options, {optimize: false});
      }

      if (node.multiplier > 1) {
        node.parent.count *= node.multiplier;
      }

      if (options.quantifiers === true && utils.isQuantifier(node.val)) {
        escaped = true;

      } else if (node.val.length > 1) {
        if (isType(node.parent, 'brace') && !isEscaped(node)) {
          var expanded = utils.expand(node.val, options);
          segs = expanded.segs;

          if (expanded.isOptimized) {
            node.parent.isOptimized = true;
          }

          // if nothing was expanded, we probably have a literal brace
          if (!segs.length) {
            var val = (expanded.val || node.val);
            if (options.unescape !== false) {
              // unescape unexpanded brace sequence/set separators
              val = val.replace(/\\([,.])/g, '$1');
              // strip quotes
              val = val.replace(/["'`]/g, '');
            }

            segs = [val];
            escaped = true;
          }
        }

      } else if (node.val === ',') {
        if (options.expand) {
          node.parent.queue.push(['']);
          segs = [''];
        } else {
          segs = ['|'];
        }
      } else {
        escaped = true;
      }

      if (escaped && isType(node.parent, 'brace')) {
        if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
          node.parent.escaped = true;
        } else if (node.parent.length <= 3) {
          node.parent.escaped = true;
        }
      }

      if (!hasQueue(node.parent)) {
        node.parent.queue = segs;
        return;
      }

      var last = utils.arrayify(queue.pop());
      if (node.parent.count > 1 && options.expand) {
        last = multiply(last, node.parent.count);
        node.parent.count = 1;
      }

      queue.push(utils.join(utils.flatten(last), segs.shift()));
      queue.push.apply(queue, segs);
    })

    /**
     * Close
     */

    .set('brace.close', function(node) {
      var queue = node.parent.queue;
      var prev = node.parent.parent;
      var last = prev.queue.pop();
      var open = node.parent.open;
      var close = node.val;

      if (open && close && isOptimized(node, options)) {
        open = '(';
        close = ')';
      }

      // if a close brace exists, and the previous segment is one character
      // don't wrap the result in braces or parens
      var ele = utils.last(queue);
      if (node.parent.count > 1 && options.expand) {
        ele = multiply(queue.pop(), node.parent.count);
        node.parent.count = 1;
        queue.push(ele);
      }

      if (close && typeof ele === 'string' && ele.length === 1) {
        open = '';
        close = '';
      }

      if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
        queue.push(utils.join(open, queue.pop() || ''));
        queue = utils.flatten(utils.join(queue, close));
      }

      if (typeof last === 'undefined') {
        prev.queue = [queue];
      } else {
        prev.queue.push(utils.flatten(utils.join(last, queue)));
      }
    })

    /**
     * eos
     */

    .set('eos', function(node) {
      if (this.input) return;

      if (options.optimize !== false) {
        this.output = utils.last(utils.flatten(this.ast.queue));
      } else if (Array.isArray(utils.last(this.ast.queue))) {
        this.output = utils.flatten(this.ast.queue.pop());
      } else {
        this.output = utils.flatten(this.ast.queue);
      }

      if (node.parent.count > 1 && options.expand) {
        this.output = multiply(this.output, node.parent.count);
      }

      this.output = utils.arrayify(this.output);
      this.ast.queue = [];
    });

};

/**
 * Multiply the segments in the current brace level
 */

function multiply(queue, n, options) {
  return utils.flatten(utils.repeat(utils.arrayify(queue), n));
}

/**
 * Return true if `node` is escaped
 */

function isEscaped(node) {
  return node.escaped === true;
}

/**
 * Returns true if regex parens should be used for sets. If the parent `type`
 * is not `brace`, then we're on a root node, which means we should never
 * expand segments and open/close braces should be `{}` (since this indicates
 * a brace is missing from the set)
 */

function isOptimized(node, options) {
  if (node.parent.isOptimized) return true;
  return isType(node.parent, 'brace')
    && !isEscaped(node.parent)
    && options.expand !== true;
}

/**
 * Returns true if the value in `node` should be wrapped in a literal brace.
 * @return {Boolean}
 */

function isLiteralBrace(node, options) {
  return isEscaped(node.parent) || options.optimize !== false;
}

/**
 * Returns true if the given `node` does not have an inner value.
 * @return {Boolean}
 */

function noInner(node, type) {
  if (node.parent.queue.length === 1) {
    return true;
  }
  var nodes = node.parent.nodes;
  return nodes.length === 3
    && isType(nodes[0], 'brace.open')
    && !isType(nodes[1], 'text')
    && isType(nodes[2], 'brace.close');
}

/**
 * Returns true if the given `node` is the given `type`
 * @return {Boolean}
 */

function isType(node, type) {
  return typeof node !== 'undefined' && node.type === type;
}

/**
 * Returns true if the given `node` has a non-empty queue.
 * @return {Boolean}
 */

function hasQueue(node) {
  return Array.isArray(node.queue) && node.queue.length;
}

},{"./utils":23}],22:[function(require,module,exports){
'use strict';

var Node = require('snapdragon-node');
var utils = require('./utils');

/**
 * Braces parsers
 */

module.exports = function(braces, options) {
  braces.parser
    .set('bos', function() {
      if (!this.parsed) {
        this.ast = this.nodes[0] = new Node(this.ast);
      }
    })

    /**
     * Character parsers
     */

    .set('escape', function() {
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|\$\{)/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        val: m[0]
      }));

      if (node.val === '\\\\') {
        return node;
      }

      if (node.val === '${') {
        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          node.val += ch;
          if (ch === '\\') {
            node.val += str[++idx];
            continue;
          }
          if (ch === '}') {
            break;
          }
        }
      }

      if (this.options.unescape !== false) {
        node.val = node.val.replace(/\\([{}])/g, '$1');
      }

      if (last.val === '"' && this.input.charAt(0) === '"') {
        last.val = node.val;
        this.consume(1);
        return;
      }

      return concatNodes.call(this, pos, node, prev, options);
    })

    /**
     * Brackets: "[...]" (basic, this is overridden by
     * other parsers in more advanced implementations)
     */

    .set('bracket', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = m[2] || '';
      var close = m[3] || '';

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') {
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          if (ch === ']') {
            close = ch;
            break;
          }
          inner += ch;
        }
      }

      return pos(new Node({
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      }));
    })

    /**
     * Empty braces (we capture these early to
     * speed up processing in the compiler)
     */

    .set('multiplier', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\{((?:,|\{,+\})+)\}/);
      if (!m) return;

      this.multiplier = true;
      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        match: m,
        val: val
      }));

      return concatNodes.call(this, pos, node, prev, options);
    })

    /**
     * Open
     */

    .set('brace.open', function() {
      var pos = this.position();
      var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      // if the last parsed character was an extglob character
      // we need to _not optimize_ the brace pattern because
      // it might be mistaken for an extglob by a downstream parser
      if (last && last.val && isExtglobChar(last.val.slice(-1))) {
        last.optimize = false;
      }

      var open = pos(new Node({
        type: 'brace.open',
        val: m[0]
      }));

      var node = pos(new Node({
        type: 'brace',
        nodes: []
      }));

      node.push(open);
      prev.push(node);
      this.push('brace', node);
    })

    /**
     * Close
     */

    .set('brace.close', function() {
      var pos = this.position();
      var m = this.match(/^\}/);
      if (!m || !m[0]) return;

      var brace = this.pop('brace');
      var node = pos(new Node({
        type: 'brace.close',
        val: m[0]
      }));

      if (!this.isType(brace, 'brace')) {
        if (this.options.strict) {
          throw new Error('missing opening "{"');
        }
        node.type = 'text';
        node.multiplier = 0;
        node.escaped = true;
        return node;
      }

      var prev = this.prev();
      var last = utils.last(prev.nodes);
      if (last.text) {
        var lastNode = utils.last(last.nodes);
        if (lastNode.val === ')' && /[!@*?+]\(/.test(last.text)) {
          var open = last.nodes[0];
          var text = last.nodes[1];
          if (open.type === 'brace.open' && text && text.type === 'text') {
            text.optimize = false;
          }
        }
      }

      if (brace.nodes.length > 2) {
        var first = brace.nodes[1];
        if (first.type === 'text' && first.val === ',') {
          brace.nodes.splice(1, 1);
          brace.nodes.push(first);
        }
      }

      brace.push(node);
    })

    /**
     * Capture boundary characters
     */

    .set('boundary', function() {
      var pos = this.position();
      var m = this.match(/^[$^](?!\{)/);
      if (!m) return;
      return pos(new Node({
        type: 'text',
        val: m[0]
      }));
    })

    /**
     * One or zero, non-comma characters wrapped in braces
     */

    .set('nobrace', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\{[^,]?\}/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      return pos(new Node({
        type: 'text',
        multiplier: 0,
        val: val
      }));
    })

    /**
     * Text
     */

    .set('text', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^((?!\\)[^${}[\]])+/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        val: val
      }));

      return concatNodes.call(this, pos, node, prev, options);
    });
};

/**
 * Returns true if the character is an extglob character.
 */

function isExtglobChar(ch) {
  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';
}

/**
 * Combine text nodes, and calculate empty sets (`{,,}`)
 * @param {Function} `pos` Function to calculate node position
 * @param {Object} `node` AST node
 * @return {Object}
 */

function concatNodes(pos, node, parent, options) {
  node.orig = node.val;
  var prev = this.prev();
  var last = utils.last(prev.nodes);
  var isEscaped = false;

  if (node.val.length > 1) {
    var a = node.val.charAt(0);
    var b = node.val.slice(-1);

    isEscaped = (a === '"' && b === '"')
      || (a === "'" && b === "'")
      || (a === '`' && b === '`');
  }

  if (isEscaped && options.unescape !== false) {
    node.val = node.val.slice(1, node.val.length - 1);
    node.escaped = true;
  }

  if (node.match) {
    var match = node.match[1];
    if (!match || match.indexOf('}') === -1) {
      match = node.match[0];
    }

    // replace each set with a single ","
    var val = match.replace(/\{/g, ',').replace(/\}/g, '');
    node.multiplier *= val.length;
    node.val = '';
  }

  var simpleText = last.type === 'text'
    && last.multiplier === 1
    && node.multiplier === 1
    && node.val;

  if (simpleText) {
    last.val += node.val;
    return;
  }

  prev.push(node);
}

},{"./utils":23,"snapdragon-node":159}],23:[function(require,module,exports){
'use strict';

var splitString = require('split-string');
var utils = module.exports;

/**
 * Module dependencies
 */

utils.extend = require('extend-shallow');
utils.flatten = require('arr-flatten');
utils.isObject = require('isobject');
utils.fillRange = require('fill-range');
utils.repeat = require('repeat-element');
utils.unique = require('array-unique');

utils.define = function(obj, key, val) {
  Object.defineProperty(obj, key, {
    writable: true,
    configurable: true,
    enumerable: false,
    value: val
  });
};

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isEmptySets = function(str) {
  return /^(?:\{,\})+$/.test(str);
};

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isQuotedString = function(str) {
  var open = str.charAt(0);
  if (open === '\'' || open === '"' || open === '`') {
    return str.slice(-1) === open;
  }
  return false;
};

/**
 * Create the key to use for memoization. The unique key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  var id = pattern;
  if (typeof options === 'undefined') {
    return id;
  }
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    id += ';' + key + '=' + String(options[key]);
  }
  return id;
};

/**
 * Normalize options
 */

utils.createOptions = function(options) {
  var opts = utils.extend.apply(null, arguments);
  if (typeof opts.expand === 'boolean') {
    opts.optimize = !opts.expand;
  }
  if (typeof opts.optimize === 'boolean') {
    opts.expand = !opts.optimize;
  }
  if (opts.optimize === true) {
    opts.makeRe = true;
  }
  return opts;
};

/**
 * Join patterns in `a` to patterns in `b`
 */

utils.join = function(a, b, options) {
  options = options || {};
  a = utils.arrayify(a);
  b = utils.arrayify(b);

  if (!a.length) return b;
  if (!b.length) return a;

  var len = a.length;
  var idx = -1;
  var arr = [];

  while (++idx < len) {
    var val = a[idx];
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        val[i] = utils.join(val[i], b, options);
      }
      arr.push(val);
      continue;
    }

    for (var j = 0; j < b.length; j++) {
      var bval = b[j];

      if (Array.isArray(bval)) {
        arr.push(utils.join(val, bval, options));
      } else {
        arr.push(val + bval);
      }
    }
  }
  return arr;
};

/**
 * Split the given string on `,` if not escaped.
 */

utils.split = function(str, options) {
  var opts = utils.extend({sep: ','}, options);
  if (typeof opts.keepQuotes !== 'boolean') {
    opts.keepQuotes = true;
  }
  if (opts.unescape === false) {
    opts.keepEscaping = true;
  }
  return splitString(str, opts, utils.escapeBrackets(opts));
};

/**
 * Expand ranges or sets in the given `pattern`.
 *
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object}
 */

utils.expand = function(str, options) {
  var opts = utils.extend({rangeLimit: 10000}, options);
  var segs = utils.split(str, opts);
  var tok = { segs: segs };

  if (utils.isQuotedString(str)) {
    return tok;
  }

  if (opts.rangeLimit === true) {
    opts.rangeLimit = 10000;
  }

  if (segs.length > 1) {
    if (opts.optimize === false) {
      tok.val = segs[0];
      return tok;
    }

    tok.segs = utils.stringifyArray(tok.segs);
  } else if (segs.length === 1) {
    var arr = str.split('..');

    if (arr.length === 1) {
      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
      tok.segs = [];
      return tok;
    }

    if (arr.length === 2 && arr[0] === arr[1]) {
      tok.escaped = true;
      tok.val = arr[0];
      tok.segs = [];
      return tok;
    }

    if (arr.length > 1) {
      if (opts.optimize !== false) {
        opts.optimize = true;
        delete opts.expand;
      }

      if (opts.optimize !== true) {
        var min = Math.min(arr[0], arr[1]);
        var max = Math.max(arr[0], arr[1]);
        var step = arr[2] || 1;

        if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) {
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        }
      }

      arr.push(opts);
      tok.segs = utils.fillRange.apply(null, arr);

      if (!tok.segs.length) {
        tok.escaped = true;
        tok.val = str;
        return tok;
      }

      if (opts.optimize === true) {
        tok.segs = utils.stringifyArray(tok.segs);
      }

      if (tok.segs === '') {
        tok.val = str;
      } else {
        tok.val = tok.segs[0];
      }
      return tok;
    }
  } else {
    tok.val = str;
  }
  return tok;
};

/**
 * Ensure commas inside brackets and parens are not split.
 * @param {Object} `tok` Token from the `split-string` module
 * @return {undefined}
 */

utils.escapeBrackets = function(options) {
  return function(tok) {
    if (tok.escaped && tok.val === 'b') {
      tok.val = '\\b';
      return;
    }

    if (tok.val !== '(' && tok.val !== '[') return;
    var opts = utils.extend({}, options);
    var brackets = [];
    var parens = [];
    var stack = [];
    var val = tok.val;
    var str = tok.str;
    var i = tok.idx - 1;

    while (++i < str.length) {
      var ch = str[i];

      if (ch === '\\') {
        val += (opts.keepEscaping === false ? '' : ch) + str[++i];
        continue;
      }

      if (ch === '(') {
        parens.push(ch);
        stack.push(ch);
      }

      if (ch === '[') {
        brackets.push(ch);
        stack.push(ch);
      }

      if (ch === ')') {
        parens.pop();
        stack.pop();
        if (!stack.length) {
          val += ch;
          break;
        }
      }

      if (ch === ']') {
        brackets.pop();
        stack.pop();
        if (!stack.length) {
          val += ch;
          break;
        }
      }
      val += ch;
    }

    tok.split = false;
    tok.val = val.slice(1);
    tok.idx = i;
  };
};

/**
 * Returns true if the given string looks like a regex quantifier
 * @return {Boolean}
 */

utils.isQuantifier = function(str) {
  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
};

/**
 * Cast `val` to an array.
 * @param {*} `val`
 */

utils.stringifyArray = function(arr) {
  return [utils.arrayify(arr).join('|')];
};

/**
 * Cast `val` to an array.
 * @param {*} `val`
 */

utils.arrayify = function(arr) {
  if (typeof arr === 'undefined') {
    return [];
  }
  if (typeof arr === 'string') {
    return [arr];
  }
  return arr;
};

/**
 * Returns true if the given `str` is a non-empty string
 * @return {Boolean}
 */

utils.isString = function(str) {
  return str != null && typeof str === 'string';
};

/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

utils.escapeRegex = function(str) {
  return str.replace(/\\?([!^*?()[\]{}+?/])/g, '\\$1');
};

},{"arr-flatten":3,"array-unique":5,"extend-shallow":24,"fill-range":65,"isobject":97,"repeat-element":148,"split-string":187}],24:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');

module.exports = function extend(o/*, objects*/) {
  if (!isObject(o)) { o = {}; }

  var len = arguments.length;
  for (var i = 1; i < len; i++) {
    var obj = arguments[i];

    if (isObject(obj)) {
      assign(o, obj);
    }
  }
  return o;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

},{"is-extendable":89}],25:[function(require,module,exports){

},{}],26:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":12,"buffer":26,"ieee754":79}],27:[function(require,module,exports){
'use strict';

var isObject = require('isobject');
var Emitter = require('component-emitter');
var visit = require('collection-visit');
var toPath = require('to-object-path');
var union = require('union-value');
var del = require('unset-value');
var get = require('get-value');
var has = require('has-value');
var set = require('set-value');

/**
 * Create a `Cache` constructor that when instantiated will
 * store values on the given `prop`.
 *
 * ```js
 * var Cache = require('cache-base').namespace('data');
 * var cache = new Cache();
 *
 * cache.set('foo', 'bar');
 * //=> {data: {foo: 'bar'}}
 * ```
 * @param {String} `prop` The property name to use for storing values.
 * @return {Function} Returns a custom `Cache` constructor
 * @api public
 */

function namespace(prop) {

  /**
   * Create a new `Cache`. Internally the `Cache` constructor is created using
   * the `namespace` function, with `cache` defined as the storage object.
   *
   * ```js
   * var app = new Cache();
   * ```
   * @param {Object} `cache` Optionally pass an object to initialize with.
   * @constructor
   * @api public
   */

  function Cache(cache) {
    if (prop) {
      this[prop] = {};
    }
    if (cache) {
      this.set(cache);
    }
  }

  /**
   * Inherit Emitter
   */

  Emitter(Cache.prototype);

  /**
   * Assign `value` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.on('set', function(key, val) {
   *   // do something when `set` is emitted
   * });
   *
   * app.set(key, value);
   *
   * // also takes an object or array
   * app.set({name: 'Halle'});
   * app.set([{foo: 'bar'}, {baz: 'quux'}]);
   * console.log(app);
   * //=> {name: 'Halle', foo: 'bar', baz: 'quux'}
   * ```
   *
   * @name .set
   * @emits `set` with `key` and `value` as arguments.
   * @param {String} `key`
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.set = function(key, val) {
    if (Array.isArray(key) && arguments.length === 2) {
      key = toPath(key);
    }
    if (isObject(key) || Array.isArray(key)) {
      this.visit('set', key);
    } else {
      set(prop ? this[prop] : this, key, val);
      this.emit('set', key, val);
    }
    return this;
  };

  /**
   * Union `array` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.union('a.b', ['foo']);
   * app.union('a.b', ['bar']);
   * console.log(app.get('a'));
   * //=> {b: ['foo', 'bar']}
   * ```
   * @name .union
   * @param {String} `key`
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.union = function(key, val) {
    if (Array.isArray(key) && arguments.length === 2) {
      key = toPath(key);
    }
    var ctx = prop ? this[prop] : this;
    union(ctx, key, arrayify(val));
    this.emit('union', val);
    return this;
  };

  /**
   * Return the value of `key`. Dot notation may be used
   * to get [nested property values][get-value].
   *
   * ```js
   * app.set('a.b.c', 'd');
   * app.get('a.b');
   * //=> {c: 'd'}
   *
   * app.get(['a', 'b']);
   * //=> {c: 'd'}
   * ```
   *
   * @name .get
   * @emits `get` with `key` and `value` as arguments.
   * @param {String} `key` The name of the property to get. Dot-notation may be used.
   * @return {any} Returns the value of `key`
   * @api public
   */

  Cache.prototype.get = function(key) {
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    this.emit('get', key, val);
    return val;
  };

  /**
   * Return true if app has a stored value for `key`,
   * false only if value is `undefined`.
   *
   * ```js
   * app.set('foo', 'bar');
   * app.has('foo');
   * //=> true
   * ```
   *
   * @name .has
   * @emits `has` with `key` and true or false as arguments.
   * @param {String} `key`
   * @return {Boolean}
   * @api public
   */

  Cache.prototype.has = function(key) {
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    var has = typeof val !== 'undefined';
    this.emit('has', key, has);
    return has;
  };

  /**
   * Delete one or more properties from the instance.
   *
   * ```js
   * app.del(); // delete all
   * // or
   * app.del('foo');
   * // or
   * app.del(['foo', 'bar']);
   * ```
   * @name .del
   * @emits `del` with the `key` as the only argument.
   * @param {String|Array} `key` Property name or array of property names.
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.del = function(key) {
    if (Array.isArray(key)) {
      this.visit('del', key);
    } else {
      del(prop ? this[prop] : this, key);
      this.emit('del', key);
    }
    return this;
  };

  /**
   * Reset the entire cache to an empty object.
   *
   * ```js
   * app.clear();
   * ```
   * @api public
   */

  Cache.prototype.clear = function() {
    if (prop) {
      this[prop] = {};
    }
  };

  /**
   * Visit `method` over the properties in the given object, or map
   * visit over the object-elements in an array.
   *
   * @name .visit
   * @param {String} `method` The name of the `base` method to call.
   * @param {Object|Array} `val` The object or array to iterate over.
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.visit = function(method, val) {
    visit(this, method, val);
    return this;
  };

  return Cache;
}

/**
 * Cast val to an array
 */

function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
}

/**
 * Expose `Cache`
 */

module.exports = namespace();

/**
 * Expose `Cache.namespace`
 */

module.exports.namespace = namespace;

},{"collection-visit":36,"component-emitter":37,"get-value":69,"has-value":76,"isobject":97,"set-value":157,"to-object-path":192,"union-value":196,"unset-value":197}],28:[function(require,module,exports){
(function (process){(function (){
'use strict';
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var sysPath = require('path');
var asyncEach = require('async-each');
var anymatch = require('anymatch');
var globParent = require('glob-parent');
var isGlob = require('is-glob');
var isAbsolute = require('path-is-absolute');
var inherits = require('inherits');
var braces = require('braces');
var normalizePath = require('normalize-path');
var upath = require('upath');

var NodeFsHandler = require('./lib/nodefs-handler');
var FsEventsHandler = require('./lib/fsevents-handler');

var arrify = function(value) {
  if (value == null) return [];
  return Array.isArray(value) ? value : [value];
};

var flatten = function(list, result) {
  if (result == null) result = [];
  list.forEach(function(item) {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

// Little isString util for use in Array#every.
var isString = function(thing) {
  return typeof thing === 'string';
};

// Public: Main class.
// Watches files & directories for changes.
//
// * _opts - object, chokidar options hash
//
// Emitted events:
// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
//
// Examples
//
//  var watcher = new FSWatcher()
//    .add(directories)
//    .on('add', path => console.log('File', path, 'was added'))
//    .on('change', path => console.log('File', path, 'was changed'))
//    .on('unlink', path => console.log('File', path, 'was removed'))
//    .on('all', (event, path) => console.log(path, ' emitted ', event))
//
function FSWatcher(_opts) {
  EventEmitter.call(this);
  var opts = {};
  // in case _opts that is passed in is a frozen object
  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
  this._watched = Object.create(null);
  this._closers = Object.create(null);
  this._ignoredPaths = Object.create(null);
  Object.defineProperty(this, '_globIgnored', {
    get: function() { return Object.keys(this._ignoredPaths); }
  });
  this.closed = false;
  this._throttled = Object.create(null);
  this._symlinkPaths = Object.create(null);

  function undef(key) {
    return opts[key] === undefined;
  }

  // Set up default options.
  if (undef('persistent')) opts.persistent = true;
  if (undef('ignoreInitial')) opts.ignoreInitial = false;
  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef('interval')) opts.interval = 100;
  if (undef('binaryInterval')) opts.binaryInterval = 300;
  if (undef('disableGlobbing')) opts.disableGlobbing = false;
  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs.watch.
  if (undef('usePolling') && !opts.useFsEvents) {
    opts.usePolling = process.platform === 'darwin';
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  var envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    var envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower
    }
  }
  var envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = parseInt(envInterval);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = Object.create(null);

  if (undef('followSymlinks')) opts.followSymlinks = true;

  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  var awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;

    this._pendingWrites = Object.create(null);
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  this._isntIgnored = function(path, stat) {
    return !this._isIgnored(path, stat);
  }.bind(this);

  var readyCalls = 0;
  this._emitReady = function() {
    if (++readyCalls >= this._readyCount) {
      this._emitReady = Function.prototype;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(this.emit.bind(this, 'ready'));
    }
  }.bind(this);

  this.options = opts;

  // Youre frozen when your hearts not open.
  Object.freeze(opts);
}

inherits(FSWatcher, EventEmitter);

// Common helpers
// --------------

// Private method: Normalize and emit events
//
// * event     - string, type of event
// * path      - string, file or directory path
// * val[1..3] - arguments to be passed with event
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
  var args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  var awf = this.options.awaitWriteFinish;
  if (awf && this._pendingWrites[path]) {
    this._pendingWrites[path].lastChange = new Date();
    return this;
  }

  if (this.options.atomic) {
    if (event === 'unlink') {
      this._pendingUnlinks[path] = args;
      setTimeout(function() {
        Object.keys(this._pendingUnlinks).forEach(function(path) {
          this.emit.apply(this, this._pendingUnlinks[path]);
          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
          delete this._pendingUnlinks[path];
        }.bind(this));
      }.bind(this), typeof this.options.atomic === "number"
        ? this.options.atomic
        : 100);
      return this;
    } else if (event === 'add' && this._pendingUnlinks[path]) {
      event = args[0] = 'change';
      delete this._pendingUnlinks[path];
    }
  }

  var emitEvent = function() {
    this.emit.apply(this, args);
    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
  }.bind(this);

  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {
    var awfEmit = function(err, stats) {
      if (err) {
        event = args[0] = 'error';
        args[1] = err;
        emitEvent();
      } else if (stats) {
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) {
          args[2] = stats;
        } else {
          args.push(stats);
        }
        emitEvent();
      }
    };

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
  }

  if (event === 'change') {
    if (!this._throttle('change', path, 50)) return this;
  }

  if (
    this.options.alwaysStat && val1 === undefined &&
    (event === 'add' || event === 'addDir' || event === 'change')
  ) {
    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;
    fs.stat(fullPath, function(error, stats) {
      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'
      if (error || !stats) return;

      args.push(stats);
      emitEvent();
    });
  } else {
    emitEvent();
  }

  return this;
};

// Private method: Common handler for errors
//
// * error  - object, Error instance
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._handleError = function(error) {
  var code = error && error.code;
  var ipe = this.options.ignorePermissionErrors;
  if (error &&
    code !== 'ENOENT' &&
    code !== 'ENOTDIR' &&
    (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
  ) this.emit('error', error);
  return error || this.closed;
};

// Private method: Helper utility for throttling
//
// * action  - string, type of action being throttled
// * path    - string, path being acted upon
// * timeout - int, duration of time to suppress duplicate actions
//
// Returns throttle tracking object or false if action should be suppressed
FSWatcher.prototype._throttle = function(action, path, timeout) {
  if (!(action in this._throttled)) {
    this._throttled[action] = Object.create(null);
  }
  var throttled = this._throttled[action];
  if (path in throttled) {
    throttled[path].count++;
    return false;
  }
  function clear() {
    var count = throttled[path] ? throttled[path].count : 0;
    delete throttled[path];
    clearTimeout(timeoutObject);
    return count;
  }
  var timeoutObject = setTimeout(clear, timeout);
  throttled[path] = {timeoutObject: timeoutObject, clear: clear, count: 0};
  return throttled[path];
};

// Private method: Awaits write operation to finish
//
// * path    - string, path being acted upon
// * threshold - int, time in milliseconds a file size must be fixed before
//                    acknowledging write operation is finished
// * awfEmit - function, to be called when ready for event to be emitted
// Polls a newly created file for size variations. When files size does not
// change for 'threshold' milliseconds calls callback.
FSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {
  var timeoutHandler;

  var fullPath = path;
  if (this.options.cwd && !isAbsolute(path)) {
    fullPath = sysPath.join(this.options.cwd, path);
  }

  var now = new Date();

  var awaitWriteFinish = (function (prevStat) {
    fs.stat(fullPath, function(err, curStat) {
      if (err || !(path in this._pendingWrites)) {
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
      }

      var now = new Date();

      if (prevStat && curStat.size != prevStat.size) {
        this._pendingWrites[path].lastChange = now;
      }

      if (now - this._pendingWrites[path].lastChange >= threshold) {
        delete this._pendingWrites[path];
        awfEmit(null, curStat);
      } else {
        timeoutHandler = setTimeout(
          awaitWriteFinish.bind(this, curStat),
          this.options.awaitWriteFinish.pollInterval
        );
      }
    }.bind(this));
  }.bind(this));

  if (!(path in this._pendingWrites)) {
    this._pendingWrites[path] = {
      lastChange: now,
      cancelWait: function() {
        delete this._pendingWrites[path];
        clearTimeout(timeoutHandler);
        return event;
      }.bind(this)
    };
    timeoutHandler = setTimeout(
      awaitWriteFinish.bind(this),
      this.options.awaitWriteFinish.pollInterval
    );
  }
};

// Private method: Determines whether user has asked to ignore this path
//
// * path  - string, path to file or directory
// * stats - object, result of fs.stat
//
// Returns boolean
var dotRe = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
FSWatcher.prototype._isIgnored = function(path, stats) {
  if (this.options.atomic && dotRe.test(path)) return true;

  if (!this._userIgnored) {
    var cwd = this.options.cwd;
    var ignored = this.options.ignored;
    if (cwd && ignored) {
      ignored = ignored.map(function (path) {
        if (typeof path !== 'string') return path;
        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));
      });
    }
    var paths = arrify(ignored)
      .filter(function(path) {
        return typeof path === 'string' && !isGlob(path);
      }).map(function(path) {
        return path + '/**';
      });
    this._userIgnored = anymatch(
      this._globIgnored.concat(ignored).concat(paths)
    );
  }

  return this._userIgnored([path, stats]);
};

// Private method: Provides a set of common helpers and properties relating to
// symlink and glob handling
//
// * path - string, file, directory, or glob pattern being watched
// * depth - int, at any depth > 0, this isn't a glob
//
// Returns object containing helpers for this path
var replacerRe = /^\.[\/\\]/;
FSWatcher.prototype._getWatchHelpers = function(path, depth) {
  path = path.replace(replacerRe, '');
  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  var fullWatchPath = sysPath.resolve(watchPath);
  var hasGlob = watchPath !== path;
  var globFilter = hasGlob ? anymatch(path) : false;
  var follow = this.options.followSymlinks;
  var globSymlink = hasGlob && follow ? null : false;

  var checkGlobSymlink = function(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === ''
    if (globSymlink == null) {
      globSymlink = entry.fullParentDir === fullWatchPath ? false : {
        realPath: entry.fullParentDir,
        linkPath: fullWatchPath
      };
    }

    if (globSymlink) {
      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);
    }

    return entry.fullPath;
  };

  var entryPath = function(entry) {
    return sysPath.join(watchPath,
      sysPath.relative(watchPath, checkGlobSymlink(entry))
    );
  };

  var filterPath = function(entry) {
    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);
    var resolvedPath = entryPath(entry);
    return (!hasGlob || globFilter(resolvedPath)) &&
      this._isntIgnored(resolvedPath, entry.stat) &&
      (this.options.ignorePermissionErrors ||
        this._hasReadPermissions(entry.stat));
  }.bind(this);

  var getDirParts = function(path) {
    if (!hasGlob) return false;
    var parts = [];
    var expandedPath = braces.expand(path);
    expandedPath.forEach(function(path) {
      parts.push(sysPath.relative(watchPath, path).split(/[\/\\]/));
    });
    return parts;
  };

  var dirParts = getDirParts(path);
  if (dirParts) {
    dirParts.forEach(function(parts) {
      if (parts.length > 1) parts.pop();
    });
  }
  var unmatchedGlob;

  var filterDir = function(entry) {
    if (hasGlob) {
      var entryParts = getDirParts(checkGlobSymlink(entry));
      var globstar = false;
      unmatchedGlob = !dirParts.some(function(parts) {
        return parts.every(function(part, i) {
          if (part === '**') globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);
        });
      });
    }
    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
  }.bind(this);

  return {
    followSymlinks: follow,
    statMethod: follow ? 'stat' : 'lstat',
    path: path,
    watchPath: watchPath,
    entryPath: entryPath,
    hasGlob: hasGlob,
    globFilter: globFilter,
    filterPath: filterPath,
    filterDir: filterDir
  };
};

// Directory helpers
// -----------------

// Private method: Provides directory tracking objects
//
// * directory - string, path of the directory
//
// Returns the directory's tracking object
FSWatcher.prototype._getWatchedDir = function(directory) {
  var dir = sysPath.resolve(directory);
  var watcherRemove = this._remove.bind(this);
  if (!(dir in this._watched)) this._watched[dir] = {
    _items: Object.create(null),
    add: function(item) {
      if (item !== '.' && item !== '..') this._items[item] = true;
    },
    remove: function(item) {
      delete this._items[item];
      if (!this.children().length) {
        fs.readdir(dir, function(err) {
          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
        });
      }
    },
    has: function(item) {return item in this._items;},
    children: function() {return Object.keys(this._items);}
  };
  return this._watched[dir];
};

// File helpers
// ------------

// Private method: Check for read permissions
// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
//
// * stats - object, result of fs.stat
//
// Returns boolean
FSWatcher.prototype._hasReadPermissions = function(stats) {
  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
};

// Private method: Handles emitting unlink events for
// files and directories, and via recursion, for
// files and directories within directories that are unlinked
//
// * directory - string, directory within which the following item is located
// * item      - string, base path of item/directory
//
// Returns nothing
FSWatcher.prototype._remove = function(directory, item) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  var path = sysPath.join(directory, item);
  var fullPath = sysPath.resolve(path);
  var isDirectory = this._watched[path] || this._watched[fullPath];

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  var watchedDirs = Object.keys(this._watched);
  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  var nestedDirectoryChildren = this._getWatchedDir(path).children();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(function(nestedItem) {
    this._remove(path, nestedItem);
  }, this);

  // Check if item was on the watched list and remove it
  var parent = this._getWatchedDir(directory);
  var wasTracked = parent.has(item);
  parent.remove(item);

  // If we wait for this file to be fully written, cancel the wait.
  var relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {
    var event = this._pendingWrites[relPath].cancelWait();
    if (event === 'add') return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  delete this._watched[path];
  delete this._watched[fullPath];
  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
};

FSWatcher.prototype._closePath = function(path) {
  if (!this._closers[path]) return;
  this._closers[path].forEach(function(closer) {
    closer();
  });
  delete this._closers[path];
  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));
}

// Public method: Adds paths to be watched on an existing FSWatcher instance

// * paths     - string or array of strings, file/directory paths and/or globs
// * _origAdd  - private boolean, for handling non-existent paths to be watched
// * _internal - private boolean, indicates a non-user add

// Returns an instance of FSWatcher for chaining.
FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
  var disableGlobbing = this.options.disableGlobbing;
  var cwd = this.options.cwd;
  this.closed = false;
  paths = flatten(arrify(paths));

  if (!paths.every(isString)) {
    throw new TypeError('Non-string provided as watch path: ' + paths);
  }

  if (cwd) paths = paths.map(function(path) {
    var absPath;
    if (isAbsolute(path)) {
      absPath = path;
    } else if (path[0] === '!') {
      absPath = '!' + sysPath.join(cwd, path.substring(1));
    } else {
      absPath = sysPath.join(cwd, path);
    }

    // Check `path` instead of `absPath` because the cwd portion can't be a glob
    if (disableGlobbing || !isGlob(path)) {
      return absPath;
    } else {
      return normalizePath(absPath);
    }
  });

  // set aside negated glob strings
  paths = paths.filter(function(path) {
    if (path[0] === '!') {
      this._ignoredPaths[path.substring(1)] = true;
    } else {
      // if a path is being added that was previously ignored, stop ignoring it
      delete this._ignoredPaths[path];
      delete this._ignoredPaths[path + '/**'];

      // reset the cached userIgnored anymatch fn
      // to make ignoredPaths changes effective
      this._userIgnored = null;

      return true;
    }
  }, this);

  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount *= 2;
    paths.forEach(this._addToFsEvents, this);
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    asyncEach(paths, function(path, next) {
      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
        if (res) this._emitReady();
        next(err, res);
      }.bind(this));
    }.bind(this), function(error, results) {
      results.forEach(function(item) {
        if (!item || this.closed) return;
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
      }, this);
    }.bind(this));
  }

  return this;
};

// Public method: Close watchers or start ignoring events from specified paths.

// * paths     - string or array of strings, file/directory paths and/or globs

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.unwatch = function(paths) {
  if (this.closed) return this;
  paths = flatten(arrify(paths));

  paths.forEach(function(path) {
    // convert to absolute path unless relative path already matches
    if (!isAbsolute(path) && !this._closers[path]) {
      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);
      path = sysPath.resolve(path);
    }

    this._closePath(path);

    this._ignoredPaths[path] = true;
    if (path in this._watched) {
      this._ignoredPaths[path + '/**'] = true;
    }

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = null;
  }, this);

  return this;
};

// Public method: Close watchers and remove all listeners from watched paths.

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.close = function() {
  if (this.closed) return this;

  this.closed = true;
  Object.keys(this._closers).forEach(function(watchPath) {
    this._closers[watchPath].forEach(function(closer) {
      closer();
    });
    delete this._closers[watchPath];
  }, this);
  this._watched = Object.create(null);

  this.removeAllListeners();
  return this;
};

// Public method: Expose list of watched paths

// Returns object w/ dir paths as keys and arrays of contained paths as values.
FSWatcher.prototype.getWatched = function() {
  var watchList = {};
  Object.keys(this._watched).forEach(function(dir) {
    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();
  }.bind(this));
  return watchList;
};

// Attach watch handler prototype methods
function importHandler(handler) {
  Object.keys(handler.prototype).forEach(function(method) {
    FSWatcher.prototype[method] = handler.prototype[method];
  });
}
importHandler(NodeFsHandler);
if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

// Public function: Instantiates watcher with paths to be tracked.

// * paths     - string or array of strings, file/directory paths and/or globs
// * options   - object, chokidar options

// Returns an instance of FSWatcher for chaining.
exports.watch = function(paths, options) {
  return new FSWatcher(options).add(paths);
};

}).call(this)}).call(this,require('_process'))

},{"./lib/fsevents-handler":29,"./lib/nodefs-handler":30,"_process":128,"anymatch":1,"async-each":11,"braces":19,"events":206,"fs":205,"glob-parent":70,"inherits":80,"is-glob":91,"normalize-path":31,"path":207,"path-is-absolute":125,"upath":201}],29:[function(require,module,exports){
'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var fsevents;
// try { fsevents = require('fsevents'); } catch (error) {
//   if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error)
// }

// fsevents instance helper functions

// object to hold per-process fsevents instances
// (may be shared across chokidar FSWatcher instances)
var FSEventsWatchers = Object.create(null);

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
var consolidateThreshhold = 10;

// Private function: Instantiates the fsevents interface

// * path       - string, path to be watched
// * callback   - function, called when fsevents is bound and ready

// Returns new fsevents instance
function createFSEventsInstance(path, callback) {
  return (new fsevents(path)).on('fsevent', callback).start();
}

// Private function: Instantiates the fsevents interface or binds listeners
// to an existing one covering the same file tree

// * path       - string, path to be watched
// * realPath   - string, real path (in case of symlinks)
// * listener   - function, called when fsevents emits events
// * rawEmitter - function, passes data to listeners of the 'raw' event

// Returns close function
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  var watchContainer;
  var parentPath = sysPath.dirname(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;
  function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  }

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  function watchedParent() {
    return Object.keys(FSEventsWatchers).some(function (watchedPath) {
      // condition is met when indexOf returns 0
      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
        watchPath = watchedPath;
        return true;
      }
    });
  }

  if (watchPath in FSEventsWatchers || watchedParent()) {
    watchContainer = FSEventsWatchers[watchPath];
    watchContainer.listeners.push(filteredListener);
  } else {
    watchContainer = FSEventsWatchers[watchPath] = {
      listeners: [filteredListener],
      rawEmitters: [rawEmitter],
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        var info = fsevents.getInfo(fullPath, flags);
        watchContainer.listeners.forEach(function (listener) {
          listener(fullPath, flags, info);
        });
        watchContainer.rawEmitters.forEach(function (emitter) {
          emitter(info.event, fullPath, info);
        });
      })
    };
  }
  var listenerIndex = watchContainer.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return function close() {
    delete watchContainer.listeners[listenerIndex];
    delete watchContainer.rawEmitters[listenerIndex];
    if (!Object.keys(watchContainer.listeners).length) {
      watchContainer.watcher.stop();
      delete FSEventsWatchers[watchPath];
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
function couldConsolidate(path) {
  var keys = Object.keys(FSEventsWatchers);
  var count = 0;

  for (var i = 0, len = keys.length; i < len; ++i) {
    var watchPath = keys[i];
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
}

function isConstructor(obj) {
  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;
}

// returns boolean indicating whether fsevents can be used
function canUse() {
  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);
}

// determines subdirectory traversal levels from root to path
function depth(path, root) {
  var i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
}

// fake constructor for attaching fsevents-specific prototype methods that
// will be copied to FSWatcher's prototype
function FsEventsHandler() { }

// Private method: Handle symlinks encountered during directory scan

// * watchPath  - string, file/dir path to be watched with fsevents
// * realPath   - string, real path (in case of symlinks)
// * transform  - function, path transformer
// * globFilter - function, path filter in case a glob pattern was provided

// Returns close function for the watcher instance
FsEventsHandler.prototype._watchWithFsEvents =
  function (watchPath, realPath, transform, globFilter) {
    if (this._isIgnored(watchPath)) return;
    var watchCallback = function (fullPath, flags, info) {
      if (
        this.options.depth !== undefined &&
        depth(fullPath, realPath) > this.options.depth
      ) return;
      var path = transform(sysPath.join(
        watchPath, sysPath.relative(watchPath, fullPath)
      ));
      if (globFilter && !globFilter(path)) return;
      // ensure directories are tracked
      var parent = sysPath.dirname(path);
      var item = sysPath.basename(path);
      var watchedDir = this._getWatchedDir(
        info.type === 'directory' ? path : parent
      );
      var checkIgnored = function (stats) {
        if (this._isIgnored(path, stats)) {
          this._ignoredPaths[path] = true;
          if (stats && stats.isDirectory()) {
            this._ignoredPaths[path + '/**/*'] = true;
          }
          return true;
        } else {
          delete this._ignoredPaths[path];
          delete this._ignoredPaths[path + '/**/*'];
        }
      }.bind(this);

      var handleEvent = function (event) {
        if (checkIgnored()) return;

        if (event === 'unlink') {
          // suppress unlink events on never before seen files
          if (info.type === 'directory' || watchedDir.has(item)) {
            this._remove(parent, item);
          }
        } else {
          if (event === 'add') {
            // track new directories
            if (info.type === 'directory') this._getWatchedDir(path);

            if (info.type === 'symlink' && this.options.followSymlinks) {
              // push symlinks back to the top of the stack to get handled
              var curDepth = this.options.depth === undefined ?
                undefined : depth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            } else {
              // track new paths
              // (other than symlinks being followed, which will be tracked soon)
              this._getWatchedDir(parent).add(item);
            }
          }
          var eventName = info.type === 'directory' ? event + 'Dir' : event;
          this._emit(eventName, path);
          if (eventName === 'addDir') this._addToFsEvents(path, false, true);
        }
      }.bind(this);

      function addOrChange() {
        handleEvent(watchedDir.has(item) ? 'change' : 'add');
      }
      function checkFd() {
        fs.open(path, 'r', function (error, fd) {
          if (error) {
            error.code !== 'EACCES' ?
              handleEvent('unlink') : addOrChange();
          } else {
            fs.close(fd, function (err) {
              err && err.code !== 'EACCES' ?
                handleEvent('unlink') : addOrChange();
            });
          }
        });
      }
      // correct for wrong events emitted
      var wrongEventFlags = [
        69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
      ];
      if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {
        if (typeof this.options.ignored === 'function') {
          fs.stat(path, function (error, stats) {
            if (checkIgnored(stats)) return;
            stats ? addOrChange() : handleEvent('unlink');
          });
        } else {
          checkFd();
        }
      } else {
        switch (info.event) {
          case 'created':
          case 'modified':
            return addOrChange();
          case 'deleted':
          case 'moved':
            return checkFd();
        }
      }
    }.bind(this);

    var closer = setFSEventsListener(
      watchPath,
      realPath,
      watchCallback,
      this.emit.bind(this, 'raw')
    );

    this._emitReady();
    return closer;
  };

// Private method: Handle symlinks encountered during directory scan

// * linkPath   - string, path to symlink
// * fullPath   - string, absolute path to the symlink
// * transform  - function, pre-existing path transformer
// * curDepth   - int, level of subdirectories traversed to where symlink is

// Returns nothing
FsEventsHandler.prototype._handleFsEventsSymlink =
  function (linkPath, fullPath, transform, curDepth) {
    // don't follow the same symlink more than once
    if (this._symlinkPaths[fullPath]) return;
    else this._symlinkPaths[fullPath] = true;

    this._readyCount++;

    fs.realpath(linkPath, function (error, linkTarget) {
      if (this._handleError(error) || this._isIgnored(linkTarget)) {
        return this._emitReady();
      }

      this._readyCount++;

      // add the linkTarget for watching with a wrapper for transform
      // that causes emitted paths to incorporate the link's path
      this._addToFsEvents(linkTarget || linkPath, function (path) {
        var dotSlash = '.' + sysPath.sep;
        var aliasedPath = linkPath;
        if (linkTarget && linkTarget !== dotSlash) {
          aliasedPath = path.replace(linkTarget, linkPath);
        } else if (path !== dotSlash) {
          aliasedPath = sysPath.join(linkPath, path);
        }
        return transform(aliasedPath);
      }, false, curDepth);
    }.bind(this));
  };

// Private method: Handle added path with fsevents

// * path       - string, file/directory path or glob pattern
// * transform  - function, converts working path to what the user expects
// * forceAdd   - boolean, ensure add is emitted
// * priorDepth - int, level of subdirectories already traversed

// Returns nothing
FsEventsHandler.prototype._addToFsEvents =
  function (path, transform, forceAdd, priorDepth) {

    // applies transform if provided, otherwise returns same value
    var processPath = typeof transform === 'function' ?
      transform : function (val) { return val; };

    var emitAdd = function (newPath, stats) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();
      var dirObj = this._getWatchedDir(sysPath.dirname(pp));
      var base = sysPath.basename(pp);

      // ensure empty dirs get tracked
      if (isDir) this._getWatchedDir(pp);

      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!this.options.ignoreInitial || forceAdd === true) {
        this._emit(isDir ? 'addDir' : 'add', pp, stats);
      }
    }.bind(this);

    var wh = this._getWatchHelpers(path);

    // evaluate what is at the path we're being asked to watch
    fs[wh.statMethod](wh.watchPath, function (error, stats) {
      if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
        this._emitReady();
        return this._emitReady();
      }

      if (stats.isDirectory()) {
        // emit addDir unless this is a glob parent
        if (!wh.globFilter) emitAdd(processPath(path), stats);

        // don't recurse further if it would exceed depth setting
        if (priorDepth && priorDepth > this.options.depth) return;

        // scan the contents of the dir
        readdirp({
          root: wh.watchPath,
          entryType: 'all',
          fileFilter: wh.filterPath,
          directoryFilter: wh.filterDir,
          lstat: true,
          depth: this.options.depth - (priorDepth || 0)
        }).on('data', function (entry) {
          // need to check filterPath on dirs b/c filterDir is less restrictive
          if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;

          var joinedPath = sysPath.join(wh.watchPath, entry.path);
          var fullPath = entry.fullPath;

          if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
            // preserve the current depth here since it can't be derived from
            // real paths past the symlink
            var curDepth = this.options.depth === undefined ?
              undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
          } else {
            emitAdd(joinedPath, entry.stat);
          }
        }.bind(this)).on('error', function () {
          // Ignore readdirp errors
        }).on('end', this._emitReady);
      } else {
        emitAdd(wh.watchPath, stats);
        this._emitReady();
      }
    }.bind(this));

    if (this.options.persistent && forceAdd !== true) {
      var initWatch = function (error, realPath) {
        if (this.closed) return;
        var closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        if (closer) {
          this._closers[path] = this._closers[path] || [];
          this._closers[path].push(closer);
        }
      }.bind(this);

      if (typeof transform === 'function') {
        // realpath has already been resolved
        initWatch();
      } else {
        fs.realpath(wh.watchPath, initWatch);
      }
    }
  };

module.exports = FsEventsHandler;
module.exports.canUse = canUse;

},{"fs":205,"path":207,"readdirp":144}],30:[function(require,module,exports){
(function (process){(function (){
'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var isBinaryPath = require('is-binary-path');

// fs.watch helpers

// object to hold per-process fs.watch instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchInstances = Object.create(null);


// Private function: Instantiates the fs.watch interface

// * path       - string, path to be watched
// * options    - object, options to be passed to fs.watch
// * listener   - function, main event handler
// * errHandler - function, handler which emits info about errors
// * emitRaw    - function, handler which emits raw event data

// Returns new fsevents instance
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

// Private function: Helper for passing fs.watch event data to a
// collection of listeners

// * fullPath   - string, absolute path bound to the fs.watch instance
// * type       - string, listener type
// * val[1..3]  - arguments to be passed to listeners

// Returns nothing
function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  if (!FsWatchInstances[fullPath]) return;
  FsWatchInstances[fullPath][type].forEach(function(listener) {
    listener(val1, val2, val3);
  });
}

// Private function: Instantiates the fs.watch interface or binds listeners
// to an existing one covering the same file system entry

// * path       - string, path to be watched
// * fullPath   - string, absolute path
// * options    - object, options to be passed to fs.watch
// * handlers   - object, container for event listener functions

// Returns close function
function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener;
  var errHandler = handlers.errHandler;
  var rawEmitter = handlers.rawEmitter;
  var container = FsWatchInstances[fullPath];
  var watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (!container) {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, 'listeners'),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
    );
    if (!watcher) return;
    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
    watcher.on('error', function(error) {
      container.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (process.platform === 'win32' && error.code === 'EPERM') {
        fs.open(path, 'r', function(err, fd) {
          if (!err) fs.close(fd, function(err) {
            if (!err) broadcastErr(error);
          });
        });
      } else {
        broadcastErr(error);
      }
    });
    container = FsWatchInstances[fullPath] = {
      listeners: [listener],
      errHandlers: [errHandler],
      rawEmitters: [rawEmitter],
      watcher: watcher
    };
  } else {
    container.listeners.push(listener);
    container.errHandlers.push(errHandler);
    container.rawEmitters.push(rawEmitter);
  }
  var listenerIndex = container.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fs.watch
  // instance if there are no more listeners left
  return function close() {
    delete container.listeners[listenerIndex];
    delete container.errHandlers[listenerIndex];
    delete container.rawEmitters[listenerIndex];
    if (!Object.keys(container.listeners).length) {
      if (!container.watcherUnusable) { // check to protect against issue #730
        container.watcher.close();
      }
      delete FsWatchInstances[fullPath];
    }
  };
}

// fs.watchFile helpers

// object to hold per-process fs.watchFile instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchFileInstances = Object.create(null);

// Private function: Instantiates the fs.watchFile interface or binds listeners
// to an existing one covering the same file system entry

// * path       - string, path to be watched
// * fullPath   - string, absolute path
// * options    - object, options to be passed to fs.watchFile
// * handlers   - object, container for event listener functions

// Returns close function
function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener;
  var rawEmitter = handlers.rawEmitter;
  var container = FsWatchFileInstances[fullPath];
  var listeners = [];
  var rawEmitters = [];
  if (
    container && (
      container.options.persistent < options.persistent ||
      container.options.interval > options.interval
    )
  ) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = container.listeners;
    rawEmitters = container.rawEmitters;
    fs.unwatchFile(fullPath);
    container = false;
  }
  if (!container) {
    listeners.push(listener);
    rawEmitters.push(rawEmitter);
    container = FsWatchFileInstances[fullPath] = {
      listeners: listeners,
      rawEmitters: rawEmitters,
      options: options,
      watcher: fs.watchFile(fullPath, options, function(curr, prev) {
        container.rawEmitters.forEach(function(rawEmitter) {
          rawEmitter('change', fullPath, {curr: curr, prev: prev});
        });
        var currmtime = curr.mtime.getTime();
        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
          container.listeners.forEach(function(listener) {
            listener(path, curr);
          });
        }
      })
    };
  } else {
    container.listeners.push(listener);
    container.rawEmitters.push(rawEmitter);
  }
  var listenerIndex = container.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fs.watchFile
  // instance if there are no more listeners left
  return function close() {
    delete container.listeners[listenerIndex];
    delete container.rawEmitters[listenerIndex];
    if (!Object.keys(container.listeners).length) {
      fs.unwatchFile(fullPath);
      delete FsWatchFileInstances[fullPath];
    }
  };
}

// fake constructor for attaching nodefs-specific prototype methods that
// will be copied to FSWatcher's prototype
function NodeFsHandler() {}

// Private method: Watch file for changes with fs.watchFile or fs.watch.

// * path     - string, path to file or directory.
// * listener - function, to be executed on fs change.

// Returns close function for the watcher instance
NodeFsHandler.prototype._watchWithNodeFs =
function(path, listener) {
  var directory = sysPath.dirname(path);
  var basename = sysPath.basename(path);
  var parent = this._getWatchedDir(directory);
  parent.add(basename);
  var absolutePath = sysPath.resolve(path);
  var options = {persistent: this.options.persistent};
  if (!listener) listener = Function.prototype; // empty function

  var closer;
  if (this.options.usePolling) {
    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?
      this.options.binaryInterval : this.options.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener: listener,
      rawEmitter: this.emit.bind(this, 'raw')
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener: listener,
      errHandler: this._handleError.bind(this),
      rawEmitter: this.emit.bind(this, 'raw')
    });
  }
  return closer;
};

// Private method: Watch a file and emit add event if warranted

// * file       - string, the file's path
// * stats      - object, result of fs.stat
// * initialAdd - boolean, was the file added at watch instantiation?
// * callback   - function, called when done processing as a newly seen file

// Returns close function for the watcher instance
NodeFsHandler.prototype._handleFile =
function(file, stats, initialAdd, callback) {
  var dirname = sysPath.dirname(file);
  var basename = sysPath.basename(file);
  var parent = this._getWatchedDir(dirname);
  // stats is always present
  var prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return callback();

  // kick off the watcher
  var closer = this._watchWithNodeFs(file, function(path, newStats) {
    if (!this._throttle('watch', file, 5)) return;
    if (!newStats || newStats && newStats.mtime.getTime() === 0) {
      fs.stat(file, function(error, newStats) {
        // Fix issues where mtime is null but file is still present
        if (error) {
          this._remove(dirname, basename);
        } else {
          // Check that change event was not fired because of changed only accessTime.
          var at = newStats.atime.getTime();
          var mt = newStats.mtime.getTime();
          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {
            this._emit('change', file, newStats);
          }
          prevStats = newStats;
        }
      }.bind(this));
    // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      var at = newStats.atime.getTime();
      var mt = newStats.mtime.getTime();
      if (!at || at <= mt ||  mt !== prevStats.mtime.getTime()) {
        this._emit('change', file, newStats);
      }
      prevStats = newStats;
    }
  }.bind(this));

  // emit an add event if we're supposed to
  if (!(initialAdd && this.options.ignoreInitial)) {
    if (!this._throttle('add', file, 0)) return;
    this._emit('add', file, stats);
  }

  if (callback) callback();
  return closer;
};

// Private method: Handle symlinks encountered while reading a dir

// * entry      - object, entry object returned by readdirp
// * directory  - string, path of the directory being read
// * path       - string, path of this item
// * item       - string, basename of this item

// Returns true if no more processing is needed for this entry.
NodeFsHandler.prototype._handleSymlink =
function(entry, directory, path, item) {
  var full = entry.fullPath;
  var dir = this._getWatchedDir(directory);

  if (!this.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this._readyCount++;
    fs.realpath(path, function(error, linkPath) {
      if (dir.has(item)) {
        if (this._symlinkPaths[full] !== linkPath) {
          this._symlinkPaths[full] = linkPath;
          this._emit('change', path, entry.stat);
        }
      } else {
        dir.add(item);
        this._symlinkPaths[full] = linkPath;
        this._emit('add', path, entry.stat);
      }
      this._emitReady();
    }.bind(this));
    return true;
  }

  // don't follow the same symlink more than once
  if (this._symlinkPaths[full]) return true;
  else this._symlinkPaths[full] = true;
};

// Private method: Read directory to add / remove files from `@watched` list
// and re-read it on change.

// * dir        - string, fs path.
// * stats      - object, result of fs.stat
// * initialAdd - boolean, was the file added at watch instantiation?
// * depth      - int, depth relative to user-supplied path
// * target     - string, child path actually targeted for watch
// * wh         - object, common watch helpers for this path
// * callback   - function, called when dir scan is complete

// Returns close function for the watcher instance
NodeFsHandler.prototype._handleDir =
function(dir, stats, initialAdd, depth, target, wh, callback) {
  var parentDir = this._getWatchedDir(sysPath.dirname(dir));
  var tracked = parentDir.has(sysPath.basename(dir));
  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath.basename(dir));
  this._getWatchedDir(dir);

  var read = function(directory, initialAdd, done) {
    // Normalize the directory name on Windows
    directory = sysPath.join(directory, '');

    if (!wh.hasGlob) {
      var throttler = this._throttle('readdir', directory, 1000);
      if (!throttler) return;
    }

    var previous = this._getWatchedDir(wh.path);
    var current = [];

    readdirp({
      root: directory,
      entryType: 'all',
      fileFilter: wh.filterPath,
      directoryFilter: wh.filterDir,
      depth: 0,
      lstat: true
    }).on('data', function(entry) {
      var item = entry.path;
      var path = sysPath.join(directory, item);
      current.push(item);

      if (entry.stat.isSymbolicLink() &&
        this._handleSymlink(entry, directory, path, item)) return;

      // Files that present in current directory snapshot
      // but absent in previous are added to watch list and
      // emit `add` event.
      if (item === target || !target && !previous.has(item)) {
        this._readyCount++;

        // ensure relativeness of path is preserved in case of watcher reuse
        path = sysPath.join(dir, sysPath.relative(dir, path));

        this._addToNodeFs(path, initialAdd, wh, depth + 1);
      }
    }.bind(this)).on('end', function() {
      var wasThrottled = throttler ? throttler.clear() : false;
      if (done) done();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.children().filter(function(item) {
        return item !== directory &&
          current.indexOf(item) === -1 &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
      }).forEach(function(item) {
        this._remove(directory, item);
      }, this);

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) read(directory, false);
    }.bind(this)).on('error', this._handleError.bind(this));
  }.bind(this);

  var closer;

  if (this.options.depth == null || depth <= this.options.depth) {
    if (!target) read(dir, initialAdd, callback);
    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {
      // if current directory is removed, do nothing
      if (stats && stats.mtime.getTime() === 0) return;

      read(dirPath, false);
    });
  } else {
    callback();
  }
  return closer;
};

// Private method: Handle added file, directory, or glob pattern.
// Delegates call to _handleFile / _handleDir after checks.

// * path       - string, path to file or directory.
// * initialAdd - boolean, was the file added at watch instantiation?
// * depth      - int, depth relative to user-supplied path
// * target     - string, child path actually targeted for watch
// * callback   - function, indicates whether the path was found or not

// Returns nothing
NodeFsHandler.prototype._addToNodeFs =
function(path, initialAdd, priorWh, depth, target, callback) {
  if (!callback) callback = Function.prototype;
  var ready = this._emitReady;
  if (this._isIgnored(path) || this.closed) {
    ready();
    return callback(null, false);
  }

  var wh = this._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = priorWh.filterPath;
    wh.filterDir = priorWh.filterDir;
  }

  // evaluate what is at the path we're being asked to watch
  fs[wh.statMethod](wh.watchPath, function(error, stats) {
    if (this._handleError(error)) return callback(null, path);
    if (this._isIgnored(wh.watchPath, stats)) {
      ready();
      return callback(null, false);
    }

    var initDir = function(dir, target) {
      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);
    }.bind(this);

    var closer;
    if (stats.isDirectory()) {
      closer = initDir(wh.watchPath, target);
    } else if (stats.isSymbolicLink()) {
      var parent = sysPath.dirname(wh.watchPath);
      this._getWatchedDir(parent).add(wh.watchPath);
      this._emit('add', wh.watchPath, stats);
      closer = initDir(parent, path);

      // preserve this symlink's target path
      fs.realpath(path, function(error, targetPath) {
        this._symlinkPaths[sysPath.resolve(path)] = targetPath;
        ready();
      }.bind(this));
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
    }

    if (closer) {
      this._closers[path] = this._closers[path] || [];
      this._closers[path].push(closer);
    }
    callback(null, false);
  }.bind(this));
};

module.exports = NodeFsHandler;

}).call(this)}).call(this,require('_process'))

},{"_process":128,"fs":205,"is-binary-path":83,"path":207,"readdirp":144}],31:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};

},{}],32:[function(require,module,exports){
'use strict';

var util = require('util');
var union = require('arr-union');
var define = require('define-property');
var staticExtend = require('static-extend');
var isObj = require('isobject');

/**
 * Expose class utils
 */

var cu = module.exports;

/**
 * Expose class utils: `cu`
 */

cu.isObject = function isObject(val) {
  return isObj(val) || typeof val === 'function';
};

/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * cu.has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * cu.has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * cu.has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 * @api public
 */

cu.has = function has(obj, val) {
  val = cu.arrayify(val);
  var len = val.length;

  if (cu.isObject(obj)) {
    for (var key in obj) {
      if (val.indexOf(key) > -1) {
        return true;
      }
    }

    var keys = cu.nativeKeys(obj);
    return cu.has(keys, val);
  }

  if (Array.isArray(obj)) {
    var arr = obj;
    while (len--) {
      if (arr.indexOf(val[len]) > -1) {
        return true;
      }
    }
    return false;
  }

  throw new TypeError('expected an array or object.');
};

/**
 * Returns true if an array or object has all of the given values.
 *
 * ```js
 * cu.hasAll(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * cu.hasAll(['a', 'b', 'c'], ['c', 'z']);
 * //=> false
 *
 * cu.hasAll({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> false
 * ```
 * @param {Object|Array} `val`
 * @param {String|Array} `values`
 * @return {Boolean}
 * @api public
 */

cu.hasAll = function hasAll(val, values) {
  values = cu.arrayify(values);
  var len = values.length;
  while (len--) {
    if (!cu.has(val, values[len])) {
      return false;
    }
  }
  return true;
};

/**
 * Cast the given value to an array.
 *
 * ```js
 * cu.arrayify('foo');
 * //=> ['foo']
 *
 * cu.arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 * @api public
 */

cu.arrayify = function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Noop
 */

cu.noop = function noop() {
  return;
};

/**
 * Returns the first argument passed to the function.
 */

cu.identity = function identity(val) {
  return val;
};

/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * cu.hasConstructor({});
 * //=> true
 *
 * cu.hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 * @api public
 */

cu.hasConstructor = function hasConstructor(val) {
  return cu.isObject(val) && typeof val.constructor !== 'undefined';
};

/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * cu.nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * cu.nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 * @api public
 */

cu.nativeKeys = function nativeKeys(val) {
  if (!cu.hasConstructor(val)) return [];
  var keys = Object.getOwnPropertyNames(val);
  if ('caller' in val) keys.push('caller');
  return keys;
};

/**
 * Returns property descriptor `key` if it's an "own" property
 * of the given object.
 *
 * ```js
 * function App() {}
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this).length;
 *   }
 * });
 * cu.getDescriptor(App.prototype, 'count');
 * // returns:
 * // {
 * //   get: [Function],
 * //   set: undefined,
 * //   enumerable: false,
 * //   configurable: false
 * // }
 * ```
 *
 * @param {Object} `obj`
 * @param {String} `key`
 * @return {Object} Returns descriptor `key`
 * @api public
 */

cu.getDescriptor = function getDescriptor(obj, key) {
  if (!cu.isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (typeof key !== 'string') {
    throw new TypeError('expected key to be a string.');
  }
  return Object.getOwnPropertyDescriptor(obj, key);
};

/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {}
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this).length;
 *   }
 * });
 * var obj = {};
 * cu.copyDescriptor(obj, App.prototype, 'count');
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String} `name`
 * @return {Object}
 * @api public
 */

cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }
  if (typeof name !== 'string') {
    throw new TypeError('expected name to be a string.');
  }

  var val = cu.getDescriptor(provider, name);
  if (val) Object.defineProperty(receiver, name, val);
};

/**
 * Copy static properties, prototype properties, and descriptors
 * from one object to another.
 *
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

cu.copy = function copy(receiver, provider, omit) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }
  var props = Object.getOwnPropertyNames(provider);
  var keys = Object.keys(provider);
  var len = props.length,
    key;
  omit = cu.arrayify(omit);

  while (len--) {
    key = props[len];

    if (cu.has(keys, key)) {
      define(receiver, key, provider[key]);
    } else if (!(key in receiver) && !cu.has(omit, key)) {
      cu.copyDescriptor(receiver, provider, key);
    }
  }
};

/**
 * Inherit the static properties, prototype properties, and descriptors
 * from of an object.
 *
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

cu.inherit = function inherit(receiver, provider, omit) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }

  var keys = [];
  for (var key in provider) {
    keys.push(key);
    receiver[key] = provider[key];
  }

  keys = keys.concat(cu.arrayify(omit));

  var a = provider.prototype || provider;
  var b = receiver.prototype || receiver;
  cu.copy(b, a, keys);
};

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = cu.extend(Parent);
 * Parent.extend(Child);
 *
 * // optional methods
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */

cu.extend = function() {
  // keep it lazy, instead of assigning to `cu.extend`
  return staticExtend.apply(null, arguments);
};

/**
 * Bubble up events emitted from static methods on the Parent ctor.
 *
 * @param {Object} `Parent`
 * @param {Array} `events` Event names to bubble up
 * @api public
 */

cu.bubble = function(Parent, events) {
  events = events || [];
  Parent.bubble = function(Child, arr) {
    if (Array.isArray(arr)) {
      events = union([], events, arr);
    }
    var len = events.length;
    var idx = -1;
    while (++idx < len) {
      var name = events[idx];
      Parent.on(name, Child.emit.bind(Child, name));
    }
    cu.bubble(Child, events);
  };
};

},{"arr-union":4,"define-property":33,"isobject":97,"static-extend":188,"util":211}],33:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isDescriptor = require('is-descriptor');

module.exports = function defineProperty(obj, prop, val) {
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('expected an object or function.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('expected `prop` to be a string.');
  }

  if (isDescriptor(val) && ('set' in val || 'get' in val)) {
    return Object.defineProperty(obj, prop, val);
  }

  return Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
};

},{"is-descriptor":87}],34:[function(require,module,exports){
'use strict';(function(k){"object"==typeof exports&&"object"==typeof module?k(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],k):k(CodeMirror)})(function(k){function u(a,d,b){var e=a.getLineHandle(d.line),c=d.ch-1,g=b&&b.afterCursor;null==g&&(g=/(^| )cm-fat-cursor($| )/.test(a.getWrapperElement().className));var h=b&&b.bracketRegex||/[(){}[\]]/;e=!g&&0<=c&&h.test(e.text.charAt(c))&&t[e.text.charAt(c)]||h.test(e.text.charAt(c+1))&&t[e.text.charAt(++c)];
if(!e)return null;g=">"==e.charAt(1)?1:-1;if(b&&b.strict&&0<g!=(c==d.ch))return null;h=a.getTokenTypeAt(n(d.line,c+1));a=v(a,n(d.line,c+(0<g?1:0)),g,h||null,b);return null==a?null:{from:n(d.line,c),to:a&&a.pos,match:a&&a.ch==e.charAt(0),forward:0<g}}function v(a,d,b,e,c){var g=c&&c.maxScanLineLength||1E4,h=c&&c.maxScanLines||1E3,f=[];c=c&&c.bracketRegex||/[(){}[\]]/;h=0<b?Math.min(d.line+h,a.lastLine()+1):Math.max(a.firstLine()-1,d.line-h);for(var l=d.line;l!=h;l+=b){var m=a.getLine(l);if(m){var p=
0<b?0:m.length-1,y=0<b?m.length:-1;if(!(m.length>g))for(l==d.line&&(p=d.ch-(0>b?1:0));p!=y;p+=b){var q=m.charAt(p);if(c.test(q)&&(void 0===e||a.getTokenTypeAt(n(l,p+1))==e)){var w=t[q];if(w&&">"==w.charAt(1)==0<b)f.push(q);else if(f.length)f.pop();else return{pos:n(l,p),ch:q}}}}}return l-b==(0<b?a.lastLine():a.firstLine())?!1:null}function x(a,d,b){for(var e=a.state.matchBrackets.maxHighlightLineLength||1E3,c=[],g=a.listSelections(),h=0;h<g.length;h++){var f=g[h].empty()&&u(a,g[h].head,b);if(f&&a.getLine(f.from.line).length<=
e){var l=f.match?"CodeMirror-matchingbracket":"CodeMirror-nonmatchingbracket";c.push(a.markText(f.from,n(f.from.line,f.from.ch+1),{className:l}));f.to&&a.getLine(f.to.line).length<=e&&c.push(a.markText(f.to,n(f.to.line,f.to.ch+1),{className:l}))}}if(c.length)if(z&&a.state.focused&&a.focus(),b=function(){a.operation(function(){for(var m=0;m<c.length;m++)c[m].clear()})},d)setTimeout(b,800);else return b}function r(a){a.operation(function(){a.state.matchBrackets.currentlyHighlighted&&(a.state.matchBrackets.currentlyHighlighted(),
a.state.matchBrackets.currentlyHighlighted=null);a.state.matchBrackets.currentlyHighlighted=x(a,!1,a.state.matchBrackets)})}var z=/MSIE \d/.test(navigator.userAgent)&&(null==document.documentMode||8>document.documentMode),n=k.Pos,t={"(":")>",")":"(<","[":"]>","]":"[<","{":"}>","}":"{<","<":">>",">":"<<"};k.defineOption("matchBrackets",!1,function(a,d,b){function e(c){c.state.matchBrackets&&c.state.matchBrackets.currentlyHighlighted&&(c.state.matchBrackets.currentlyHighlighted(),c.state.matchBrackets.currentlyHighlighted=
null)}b&&b!=k.Init&&(a.off("cursorActivity",r),a.off("focus",r),a.off("blur",e),e(a));d&&(a.state.matchBrackets="object"==typeof d?d:{},a.on("cursorActivity",r),a.on("focus",r),a.on("blur",e))});k.defineExtension("matchBrackets",function(){x(this,!0)});k.defineExtension("findMatchingBracket",function(a,d,b){if(b||"boolean"==typeof d)b?(b.strict=d,d=b):d=d?{strict:!0}:null;return u(this,a,d)});k.defineExtension("scanForBracket",function(a,d,b,e){return v(this,a,d,b,e)})});

},{"../../lib/codemirror":35}],35:[function(require,module,exports){
(function (global){(function (){
'use strict';var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(y,E,D){y instanceof String&&(y=String(y));for(var v=y.length,K=0;K<v;K++){var ka=y[K];if(E.call(D,ka,K,y))return{i:K,v:ka}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.ENABLE_UNHANDLED_REJECTION_POLYFILL=!0;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(y,E,D){if(y==Array.prototype||y==Object.prototype)return y;y[E]=D.value;return y};$jscomp.getGlobal=function(y){y=["object"==typeof globalThis&&globalThis,y,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var E=0;E<y.length;++E){var D=y[E];if(D&&D.Math==Math)return D}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(y,E){var D=$jscomp.propertyToPolyfillSymbol[E];if(null==D)return y[E];D=y[D];return void 0!==D?D:y[E]};
$jscomp.polyfill=function(y,E,D,v){E&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(y,E,D,v):$jscomp.polyfillUnisolated(y,E,D,v))};$jscomp.polyfillUnisolated=function(y,E,D,v){D=$jscomp.global;y=y.split(".");for(v=0;v<y.length-1;v++){var K=y[v];if(!(K in D))return;D=D[K]}y=y[y.length-1];v=D[y];E=E(v);E!=v&&null!=E&&$jscomp.defineProperty(D,y,{configurable:!0,writable:!0,value:E})};
$jscomp.polyfillIsolated=function(y,E,D,v){var K=y.split(".");y=1===K.length;v=K[0];v=!y&&v in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var ka=0;ka<K.length-1;ka++){var va=K[ka];if(!(va in v))return;v=v[va]}K=K[K.length-1];D=$jscomp.IS_SYMBOL_NATIVE&&"es6"===D?v[K]:null;E=E(D);null!=E&&(y?$jscomp.defineProperty($jscomp.polyfills,K,{configurable:!0,writable:!0,value:E}):E!==D&&($jscomp.propertyToPolyfillSymbol[K]=$jscomp.IS_SYMBOL_NATIVE?$jscomp.global.Symbol(K):$jscomp.POLYFILL_PREFIX+
K,K=$jscomp.propertyToPolyfillSymbol[K],$jscomp.defineProperty(v,K,{configurable:!0,writable:!0,value:E})))};$jscomp.polyfill("Array.prototype.find",function(y){return y?y:function(E,D){return $jscomp.findInternal(this,E,D).v}},"es6","es3");
(function(y,E){"object"===typeof exports&&"undefined"!==typeof module?module.exports=E():"function"===typeof define&&define.amd?define(E):(y=y||self,y.CodeMirror=E())})(this,function(){function y(a){return new RegExp("(^|\\s)"+a+"(?:$|\\s)\\s*")}function E(a){for(var b=a.childNodes.length;0<b;--b)a.removeChild(a.firstChild);return a}function D(a,b){return E(a).appendChild(b)}function v(a,b,d,c){a=document.createElement(a);d&&(a.className=d);c&&(a.style.cssText=c);if("string"==typeof b)a.appendChild(document.createTextNode(b));
else if(b)for(d=0;d<b.length;++d)a.appendChild(b[d]);return a}function K(a,b,d,c){a=v(a,b,d,c);a.setAttribute("role","presentation");return a}function ka(a,b){3==b.nodeType&&(b=b.parentNode);if(a.contains)return a.contains(b);do if(11==b.nodeType&&(b=b.host),b==a)return!0;while(b=b.parentNode)}function va(){try{var a=document.activeElement}catch(b){a=document.body||null}for(;a&&a.shadowRoot&&a.shadowRoot.activeElement;)a=a.shadowRoot.activeElement;return a}function Wa(a,b){var d=a.className;y(b).test(d)||
(a.className+=(d?" ":"")+b)}function cd(a,b){a=a.split(" ");for(var d=0;d<a.length;d++)a[d]&&!y(a[d]).test(b)&&(b+=" "+a[d]);return b}function dd(a){var b=Array.prototype.slice.call(arguments,1);return function(){return a.apply(null,b)}}function Xa(a,b,d){b||(b={});for(var c in a)!a.hasOwnProperty(c)||!1===d&&b.hasOwnProperty(c)||(b[c]=a[c]);return b}function wa(a,b,d,c,e){null==b&&(b=a.search(/[^\s\u00a0]/),-1==b&&(b=a.length));c=c||0;for(e=e||0;;){var f=a.indexOf("\t",c);if(0>f||f>=b)return e+(b-
c);e+=f-c;e+=d-e%d;c=f+1}}function ea(a,b){for(var d=0;d<a.length;++d)if(a[d]==b)return d;return-1}function ed(a,b,d){for(var c=0,e=0;;){var f=a.indexOf("\t",c);-1==f&&(f=a.length);var g=f-c;if(f==a.length||e+g>=b)return c+Math.min(g,b-e);e+=f-c;e+=d-e%d;c=f+1;if(e>=b)return c}}function fd(a){for(;uc.length<=a;)uc.push(L(uc)+" ");return uc[a]}function L(a){return a[a.length-1]}function vc(a,b){for(var d=[],c=0;c<a.length;c++)d[c]=b(a[c],c);return d}function wg(a,b,d){for(var c=0,e=d(b);c<a.length&&
d(a[c])<=e;)c++;a.splice(c,0,b)}function me(){}function ne(a,b){Object.create?a=Object.create(a):(me.prototype=a,a=new me);b&&Xa(b,a);return a}function gd(a){return/\w/.test(a)||"\u0080"<a&&(a.toUpperCase()!=a.toLowerCase()||xg.test(a))}function wc(a,b){return b?-1<b.source.indexOf("\\w")&&gd(a)?!0:b.test(a):gd(a)}function oe(a){for(var b in a)if(a.hasOwnProperty(b)&&a[b])return!1;return!0}function hd(a){return 768<=a.charCodeAt(0)&&yg.test(a)}function pe(a,b,d){for(;(0>d?0<b:b<a.length)&&hd(a.charAt(b));)b+=
d;return b}function Hb(a,b,d){for(var c=b>d?-1:1;;){if(b==d)return b;var e=(b+d)/2;e=0>c?Math.ceil(e):Math.floor(e);if(e==b)return a(e)?b:d;a(e)?d=e:b=e+c}}function zg(a,b,d,c){if(!a)return c(b,d,"ltr",0);for(var e=!1,f=0;f<a.length;++f){var g=a[f];if(g.from<d&&g.to>b||b==d&&g.to==b)c(Math.max(g.from,b),Math.min(g.to,d),1==g.level?"rtl":"ltr",f),e=!0}e||c(b,d,"ltr")}function Ib(a,b,d){var c;Jb=null;for(var e=0;e<a.length;++e){var f=a[e];if(f.from<b&&f.to>b)return e;f.to==b&&(f.from!=f.to&&"before"==
d?c=e:Jb=e);f.from==b&&(f.from!=f.to&&"before"!=d?c=e:Jb=e)}return null!=c?c:Jb}function Ja(a,b){var d=a.order;null==d&&(d=a.order=Ag(a.text,b));return d}function ra(a,b,d){if(a.removeEventListener)a.removeEventListener(b,d,!1);else if(a.detachEvent)a.detachEvent("on"+b,d);else{var c=(a=a._handlers)&&a[b];c&&(d=ea(c,d),-1<d&&(a[b]=c.slice(0,d).concat(c.slice(d+1))))}}function X(a,b){var d=a._handlers&&a._handlers[b]||xc;if(d.length)for(var c=Array.prototype.slice.call(arguments,2),e=0;e<d.length;++e)d[e].apply(null,
c)}function Z(a,b,d){"string"==typeof b&&(b={type:b,preventDefault:function(){this.defaultPrevented=!0}});X(a,d||b.type,a,b);return id(b)||b.codemirrorIgnore}function qe(a){var b=a._handlers&&a._handlers.cursorActivity;if(b){a=a.curOp.cursorActivityHandlers||(a.curOp.cursorActivityHandlers=[]);for(var d=0;d<b.length;++d)-1==ea(a,b[d])&&a.push(b[d])}}function xa(a,b){return 0<(a._handlers&&a._handlers[b]||xc).length}function nb(a){a.prototype.on=function(b,d){z(this,b,d)};a.prototype.off=function(b,
d){ra(this,b,d)}}function la(a){a.preventDefault?a.preventDefault():a.returnValue=!1}function re(a){a.stopPropagation?a.stopPropagation():a.cancelBubble=!0}function id(a){return null!=a.defaultPrevented?a.defaultPrevented:0==a.returnValue}function Kb(a){la(a);re(a)}function se(a){var b=a.which;null==b&&(a.button&1?b=1:a.button&2?b=3:a.button&4&&(b=2));ya&&a.ctrlKey&&1==b&&(b=3);return b}function Bg(a){if(null==jd){var b=v("span","\u200b");D(a,v("span",[b,document.createTextNode("x")]));0!=a.firstChild.offsetHeight&&
(jd=1>=b.offsetWidth&&2<b.offsetHeight&&!(G&&8>U))}a=jd?v("span","\u200b"):v("span","\u00a0",null,"display: inline-block; width: 1px; margin-right: -1px");a.setAttribute("cm-text","");return a}function Cg(a,b){2<arguments.length&&(b.dependencies=Array.prototype.slice.call(arguments,2));kd[a]=b}function yc(a){if("string"==typeof a&&ob.hasOwnProperty(a))a=ob[a];else if(a&&"string"==typeof a.name&&ob.hasOwnProperty(a.name)){var b=ob[a.name];"string"==typeof b&&(b={name:b});a=ne(b,a);a.name=b.name}else{if("string"==
typeof a&&/^[\w\-]+\/[\w\-]+\+xml$/.test(a))return yc("application/xml");if("string"==typeof a&&/^[\w\-]+\/[\w\-]+\+json$/.test(a))return yc("application/json")}return"string"==typeof a?{name:a}:a||{name:"null"}}function ld(a,b){b=yc(b);var d=kd[b.name];if(!d)return ld(a,"text/plain");a=d(a,b);if(pb.hasOwnProperty(b.name)){d=pb[b.name];for(var c in d)d.hasOwnProperty(c)&&(a.hasOwnProperty(c)&&(a["_"+c]=a[c]),a[c]=d[c])}a.name=b.name;b.helperType&&(a.helperType=b.helperType);if(b.modeProps)for(var e in b.modeProps)a[e]=
b.modeProps[e];return a}function Dg(a,b){a=pb.hasOwnProperty(a)?pb[a]:pb[a]={};Xa(b,a)}function Ya(a,b){if(!0===b)return b;if(a.copyState)return a.copyState(b);a={};for(var d in b){var c=b[d];c instanceof Array&&(c=c.concat([]));a[d]=c}return a}function md(a,b){for(var d;a.innerMode;){d=a.innerMode(b);if(!d||d.mode==a)break;b=d.state;a=d.mode}return d||{mode:a,state:b}}function te(a,b,d){return a.startState?a.startState(b,d):!0}function w(a,b){b-=a.first;if(0>b||b>=a.size)throw Error("There is no line "+
(b+a.first)+" in the document.");for(;!a.lines;)for(var d=0;;++d){var c=a.children[d],e=c.chunkSize();if(b<e){a=c;break}b-=e}return a.lines[b]}function Za(a,b,d){var c=[],e=b.line;a.iter(b.line,d.line+1,function(f){f=f.text;e==d.line&&(f=f.slice(0,d.ch));e==b.line&&(f=f.slice(b.ch));c.push(f);++e});return c}function nd(a,b,d){var c=[];a.iter(b,d,function(e){c.push(e.text)});return c}function Da(a,b){if(b-=a.height)for(;a;a=a.parent)a.height+=b}function O(a){if(null==a.parent)return null;var b=a.parent;
a=ea(b.lines,a);for(var d=b.parent;d;b=d,d=d.parent)for(var c=0;d.children[c]!=b;++c)a+=d.children[c].chunkSize();return a+b.first}function $a(a,b){var d=a.first;a:do{for(var c=0;c<a.children.length;++c){var e=a.children[c],f=e.height;if(b<f){a=e;continue a}b-=f;d+=e.chunkSize()}return d}while(!a.lines);for(c=0;c<a.lines.length;++c){e=a.lines[c].height;if(b<e)break;b-=e}return d+c}function Lb(a,b){return b>=a.first&&b<a.first+a.size}function od(a,b){return String(a.lineNumberFormatter(b+a.firstLineNumber))}
function t(a,b,d){void 0===d&&(d=null);if(!(this instanceof t))return new t(a,b,d);this.line=a;this.ch=b;this.sticky=d}function B(a,b){return a.line-b.line||a.ch-b.ch}function pd(a,b){return a.sticky==b.sticky&&0==B(a,b)}function qd(a){return t(a.line,a.ch)}function zc(a,b){return 0>B(a,b)?b:a}function Ac(a,b){return 0>B(a,b)?a:b}function C(a,b){if(b.line<a.first)return t(a.first,0);var d=a.first+a.size-1;if(b.line>d)return t(d,w(a,d).text.length);a=w(a,b.line).text.length;d=b.ch;b=null==d||d>a?t(b.line,
a):0>d?t(b.line,0):b;return b}function ue(a,b){for(var d=[],c=0;c<b.length;c++)d[c]=C(a,b[c]);return d}function ve(a,b,d,c){var e=[a.state.modeGen],f={};we(a,b.text,a.doc.mode,d,function(k,l){return e.push(k,l)},f,c);var g=d.state;c=function(k){d.baseTokens=e;var l=a.state.overlays[k],m=1,q=0;d.state=!0;we(a,b.text,l.mode,d,function(n,p){for(var r=m;q<n;){var u=e[m];u>n&&e.splice(m,1,n,e[m+1],u);m+=2;q=Math.min(n,u)}if(p)if(l.opaque)e.splice(r,m-r,n,"overlay "+p),m=r+2;else for(;r<m;r+=2)n=e[r+1],
e[r+1]=(n?n+" ":"")+"overlay "+p},f);d.state=g;d.baseTokens=null;d.baseTokenPos=1};for(var h=0;h<a.state.overlays.length;++h)c(h);return{styles:e,classes:f.bgClass||f.textClass?f:null}}function xe(a,b,d){if(!b.styles||b.styles[0]!=a.state.modeGen){var c=Mb(a,O(b)),e=b.text.length>a.options.maxHighlightLength&&Ya(a.doc.mode,c.state),f=ve(a,b,c);e&&(c.state=e);b.stateAfter=c.save(!e);b.styles=f.styles;f.classes?b.styleClasses=f.classes:b.styleClasses&&(b.styleClasses=null);d===a.doc.highlightFrontier&&
(a.doc.modeFrontier=Math.max(a.doc.modeFrontier,++a.doc.highlightFrontier))}return b.styles}function Mb(a,b,d){var c=a.doc,e=a.display;if(!c.mode.startState)return new Ea(c,!0,b);var f=Eg(a,b,d),g=f>c.first&&w(c,f-1).stateAfter,h=g?Ea.fromSaved(c,g,f):new Ea(c,te(c.mode),f);c.iter(f,b,function(k){rd(a,k.text,h);var l=h.line;k.stateAfter=l==b-1||0==l%5||l>=e.viewFrom&&l<e.viewTo?h.save():null;h.nextLine()});d&&(c.modeFrontier=h.line);return h}function rd(a,b,d,c){var e=a.doc.mode;a=new Y(b,a.options.tabSize,
d);a.start=a.pos=c||0;for(""==b&&ye(e,d.state);!a.eol();)sd(e,a,d.state),a.start=a.pos}function ye(a,b){if(a.blankLine)return a.blankLine(b);if(a.innerMode&&(a=md(a,b),a.mode.blankLine))return a.mode.blankLine(a.state)}function sd(a,b,d,c){for(var e=0;10>e;e++){c&&(c[0]=md(a,d).mode);var f=a.token(b,d);if(b.pos>b.start)return f}throw Error("Mode "+a.name+" failed to advance stream.");}function ze(a,b,d,c){var e=a.doc,f=e.mode;b=C(e,b);var g=w(e,b.line);d=Mb(a,b.line,d);a=new Y(g.text,a.options.tabSize,
d);var h;for(c&&(h=[]);(c||a.pos<b.ch)&&!a.eol();){a.start=a.pos;var k=sd(f,a,d.state);c&&h.push(new Ae(a,k,Ya(e.mode,d.state)))}return c?h:new Ae(a,k,d.state)}function Be(a,b){if(a)for(;;){var d=a.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!d)break;a=a.slice(0,d.index)+a.slice(d.index+d[0].length);var c=d[1]?"bgClass":"textClass";null==b[c]?b[c]=d[2]:(new RegExp("(?:^|\\s)"+d[2]+"(?:$|\\s)")).test(b[c])||(b[c]+=" "+d[2])}return a}function we(a,b,d,c,e,f,g){var h=d.flattenSpans;null==h&&(h=a.options.flattenSpans);
var k=0,l=null,m=new Y(b,a.options.tabSize,c),q=a.options.addModeClass&&[null];for(""==b&&Be(ye(d,c.state),f);!m.eol();){if(m.pos>a.options.maxHighlightLength){h=!1;g&&rd(a,b,c,m.pos);m.pos=b.length;var n=null}else n=Be(sd(d,m,c.state,q),f);if(q){var p=q[0].name;p&&(n="m-"+(n?p+" "+n:p))}if(!h||l!=n){for(;k<m.start;)k=Math.min(m.start,k+5E3),e(k,l);l=n}m.start=m.pos}for(;k<m.pos;)a=Math.min(m.pos,k+5E3),e(a,l),k=a}function Eg(a,b,d){for(var c,e,f=a.doc,g=d?-1:b-(a.doc.mode.innerMode?1E3:100);b>g;--b){if(b<=
f.first)return f.first;var h=w(f,b-1),k=h.stateAfter;if(k&&(!d||b+(k instanceof Bc?k.lookAhead:0)<=f.modeFrontier))return b;h=wa(h.text,null,a.options.tabSize);if(null==e||c>h)e=b-1,c=h}return e}function Fg(a,b){a.modeFrontier=Math.min(a.modeFrontier,b);if(!(a.highlightFrontier<b-10)){for(var d=a.first,c=b-1;c>d;c--){var e=w(a,c).stateAfter;if(e&&(!(e instanceof Bc)||c+e.lookAhead<b)){d=c+1;break}}a.highlightFrontier=Math.min(a.highlightFrontier,d)}}function Cc(a,b,d){this.marker=a;this.from=b;this.to=
d}function Nb(a,b){if(a)for(var d=0;d<a.length;++d){var c=a[d];if(c.marker==b)return c}}function td(a,b){if(b.full)return null;var d=Lb(a,b.from.line)&&w(a,b.from.line).markedSpans,c=Lb(a,b.to.line)&&w(a,b.to.line).markedSpans;if(!d&&!c)return null;a=b.from.ch;var e=b.to.ch,f=0==B(b.from,b.to),g;if(d)for(var h=0;h<d.length;++h){var k=d[h],l=k.marker;if(null==k.from||(l.inclusiveLeft?k.from<=a:k.from<a)||!(k.from!=a||"bookmark"!=l.type||f&&k.marker.insertLeft)){var m=null==k.to||(l.inclusiveRight?
k.to>=a:k.to>a);(g||(g=[])).push(new Cc(l,k.from,m?null:k.to))}}d=g;var q;if(c)for(g=0;g<c.length;++g)if(h=c[g],k=h.marker,null==h.to||(k.inclusiveRight?h.to>=e:h.to>e)||h.from==e&&"bookmark"==k.type&&(!f||h.marker.insertLeft))l=null==h.from||(k.inclusiveLeft?h.from<=e:h.from<e),(q||(q=[])).push(new Cc(k,l?null:h.from-e,null==h.to?null:h.to-e));c=1==b.text.length;e=L(b.text).length+(c?a:0);if(d)for(f=0;f<d.length;++f)if(g=d[f],null==g.to)(h=Nb(q,g.marker),h)?c&&(g.to=null==h.to?null:h.to+e):g.to=
a;if(q)for(a=0;a<q.length;++a)f=q[a],null!=f.to&&(f.to+=e),null==f.from?Nb(d,f.marker)||(f.from=e,c&&(d||(d=[])).push(f)):(f.from+=e,c&&(d||(d=[])).push(f));d&&(d=Ce(d));q&&q!=d&&(q=Ce(q));a=[d];if(!c){b=b.text.length-2;var n;if(0<b&&d)for(c=0;c<d.length;++c)null==d[c].to&&(n||(n=[])).push(new Cc(d[c].marker,null,null));for(d=0;d<b;++d)a.push(n);a.push(q)}return a}function Ce(a){for(var b=0;b<a.length;++b){var d=a[b];null!=d.from&&d.from==d.to&&!1!==d.marker.clearWhenEmpty&&a.splice(b--,1)}return a.length?
a:null}function Gg(a,b,d){var c=null;a.iter(b.line,d.line+1,function(m){if(m.markedSpans)for(var q=0;q<m.markedSpans.length;++q){var n=m.markedSpans[q].marker;!n.readOnly||c&&-1!=ea(c,n)||(c||(c=[])).push(n)}});if(!c)return null;a=[{from:b,to:d}];for(b=0;b<c.length;++b){d=c[b];for(var e=d.find(0),f=0;f<a.length;++f){var g=a[f];if(!(0>B(g.to,e.from)||0<B(g.from,e.to))){var h=[f,1],k=B(g.from,e.from),l=B(g.to,e.to);(0>k||!d.inclusiveLeft&&!k)&&h.push({from:g.from,to:e.from});(0<l||!d.inclusiveRight&&
!l)&&h.push({from:e.to,to:g.to});a.splice.apply(a,h);f+=h.length-3}}}return a}function De(a){var b=a.markedSpans;if(b){for(var d=0;d<b.length;++d)b[d].marker.detachLine(a);a.markedSpans=null}}function Ee(a,b){if(b){for(var d=0;d<b.length;++d)b[d].marker.attachLine(a);a.markedSpans=b}}function ud(a,b){var d=a.lines.length-b.lines.length;if(0!=d)return d;d=a.find();var c=b.find(),e=B(d.from,c.from)||(a.inclusiveLeft?-1:0)-(b.inclusiveLeft?-1:0);return e?-e:(d=B(d.to,c.to)||(a.inclusiveRight?1:0)-(b.inclusiveRight?
1:0))?d:b.id-a.id}function qb(a,b){a=Ka&&a.markedSpans;if(a)for(var d,c=0;c<a.length;++c)if(d=a[c],d.marker.collapsed&&null==(b?d.from:d.to)&&(!e||0>ud(e,d.marker)))var e=d.marker;return e}function Fe(a,b,d,c,e){a=w(a,b);if(a=Ka&&a.markedSpans)for(b=0;b<a.length;++b){var f=a[b];if(f.marker.collapsed){var g=f.marker.find(0),h=B(g.from,d)||(f.marker.inclusiveLeft?-1:0)-(e.inclusiveLeft?-1:0),k=B(g.to,c)||(f.marker.inclusiveRight?1:0)-(e.inclusiveRight?1:0);if(!(0<=h&&0>=k||0>=h&&0<=k)&&(0>=h&&(f.marker.inclusiveRight&&
e.inclusiveLeft?0<=B(g.to,d):0<B(g.to,d))||0<=h&&(f.marker.inclusiveRight&&e.inclusiveLeft?0>=B(g.from,c):0>B(g.from,c))))return!0}}}function Fa(a){for(var b;b=qb(a,!0);)a=b.find(-1,!0).line;return a}function vd(a,b){a=w(a,b);var d=Fa(a);return a==d?b:O(d)}function Ge(a,b){if(b>a.lastLine())return b;var d=w(a,b);if(!Oa(a,d))return b;for(;a=qb(d,!1);)d=a.find(1,!0).line;return O(d)+1}function Oa(a,b){var d=Ka&&b.markedSpans;if(d)for(var c,e=0;e<d.length;++e)if(c=d[e],c.marker.collapsed&&(null==c.from||
!c.marker.widgetNode&&0==c.from&&c.marker.inclusiveLeft&&wd(a,b,c)))return!0}function wd(a,b,d){if(null==d.to)return b=d.marker.find(1,!0),wd(a,b.line,Nb(b.line.markedSpans,d.marker));if(d.marker.inclusiveRight&&d.to==b.text.length)return!0;for(var c,e=0;e<b.markedSpans.length;++e)if(c=b.markedSpans[e],c.marker.collapsed&&!c.marker.widgetNode&&c.from==d.to&&(null==c.to||c.to!=d.from)&&(c.marker.inclusiveLeft||d.marker.inclusiveRight)&&wd(a,b,c))return!0}function Ga(a){a=Fa(a);for(var b=0,d=a.parent,
c=0;c<d.lines.length;++c){var e=d.lines[c];if(e==a)break;else b+=e.height}for(a=d.parent;a;d=a,a=d.parent)for(c=0;c<a.children.length&&(e=a.children[c],e!=d);++c)b+=e.height;return b}function Dc(a){if(0==a.height)return 0;for(var b=a.text.length,d,c=a;d=qb(c,!0);)d=d.find(0,!0),c=d.from.line,b+=d.from.ch-d.to.ch;for(c=a;d=qb(c,!1);)a=d.find(0,!0),b-=c.text.length-a.from.ch,c=a.to.line,b+=c.text.length-a.to.ch;return b}function xd(a){var b=a.display;a=a.doc;b.maxLine=w(a,a.first);b.maxLineLength=Dc(b.maxLine);
b.maxLineChanged=!0;a.iter(function(d){var c=Dc(d);c>b.maxLineLength&&(b.maxLineLength=c,b.maxLine=d)})}function He(a,b){if(!a||/^\s*$/.test(a))return null;b=b.addModeClass?Hg:Ig;return b[a]||(b[a]=a.replace(/\S+/g,"cm-$&"))}function Ie(a,b){var d=K("span",null,null,fa?"padding-right: .1px":null);d={pre:K("pre",[d],"CodeMirror-line"),content:d,col:0,pos:0,cm:a,trailingSpace:!1,splitSpaces:a.getOption("lineWrapping")};b.measure={};for(var c=0;c<=(b.rest?b.rest.length:0);c++){var e=c?b.rest[c-1]:b.line,
f=void 0;d.pos=0;d.addToken=Jg;var g=a.display.measure;if(null!=yd)g=yd;else{var h=D(g,document.createTextNode("A\u062eA")),k=Ob(h,0,1).getBoundingClientRect();h=Ob(h,1,2).getBoundingClientRect();E(g);g=k&&k.left!=k.right?yd=3>h.right-k.right:!1}g&&(f=Ja(e,a.doc.direction))&&(d.addToken=Kg(d.addToken,f));d.map=[];var l=b!=a.display.externalMeasured&&O(e);a:{var m=h=k=g=void 0,q=void 0,n=void 0,p=void 0;f=d;l=xe(a,e,l);var r=e.markedSpans,u=e.text,A=0;if(r)for(var H=u.length,x=0,Q=1,M="",R=0;;){if(R==
x){q=m=h=n="";k=g=null;R=Infinity;for(var T=[],F=void 0,S=0;S<r.length;++S){var I=r[S],N=I.marker;if("bookmark"==N.type&&I.from==x&&N.widgetNode)T.push(N);else if(I.from<=x&&(null==I.to||I.to>x||N.collapsed&&I.to==x&&I.from==x)){null!=I.to&&I.to!=x&&R>I.to&&(R=I.to,m="");N.className&&(q+=" "+N.className);N.css&&(n=(n?n+";":"")+N.css);N.startStyle&&I.from==x&&(h+=" "+N.startStyle);N.endStyle&&I.to==R&&(F||(F=[])).push(N.endStyle,I.to);N.title&&((g||(g={})).title=N.title);if(N.attributes)for(var ha in N.attributes)(g||
(g={}))[ha]=N.attributes[ha];N.collapsed&&(!k||0>ud(k.marker,N))&&(k=I)}else I.from>x&&R>I.from&&(R=I.from)}if(F)for(S=0;S<F.length;S+=2)F[S+1]==R&&(m+=" "+F[S]);if(!k||k.from==x)for(F=0;F<T.length;++F)Je(f,0,T[F]);if(k&&(k.from||0)==x){Je(f,(null==k.to?H+1:k.to)-x,k.marker,null==k.from);if(null==k.to)break a;k.to==x&&(k=!1)}}if(x>=H)break;for(T=Math.min(H,R);;){if(M){F=x+M.length;k||(S=F>T?M.slice(0,T-x):M,f.addToken(f,S,p?p+q:q,h,x+S.length==R?m:"",n,g));if(F>=T){M=M.slice(T-x);x=T;break}x=F;h=
""}M=u.slice(A,A=l[Q++]);p=He(l[Q++],f.cm.options)}}else for(g=1;g<l.length;g+=2)f.addToken(f,u.slice(A,A=l[g]),He(l[g+1],f.cm.options))}e.styleClasses&&(e.styleClasses.bgClass&&(d.bgClass=cd(e.styleClasses.bgClass,d.bgClass||"")),e.styleClasses.textClass&&(d.textClass=cd(e.styleClasses.textClass,d.textClass||"")));0==d.map.length&&d.map.push(0,0,d.content.appendChild(Bg(a.display.measure)));0==c?(b.measure.map=d.map,b.measure.cache={}):((b.measure.maps||(b.measure.maps=[])).push(d.map),(b.measure.caches||
(b.measure.caches=[])).push({}))}fa&&(ha=d.content.lastChild,/\bcm-tab\b/.test(ha.className)||ha.querySelector&&ha.querySelector(".cm-tab"))&&(d.content.className="cm-tab-wrap-hack");X(a,"renderLine",a,b.line,d.pre);d.pre.className&&(d.textClass=cd(d.pre.className,d.textClass||""));return d}function Lg(a){var b=v("span","\u2022","cm-invalidchar");b.title="\\u"+a.charCodeAt(0).toString(16);b.setAttribute("aria-label",b.title);return b}function Jg(a,b,d,c,e,f,g){if(b){if(a.splitSpaces){var h=a.trailingSpace;
if(1<b.length&&!/  /.test(b))h=b;else{for(var k="",l=0;l<b.length;l++){var m=b.charAt(l);" "!=m||!h||l!=b.length-1&&32!=b.charCodeAt(l+1)||(m="\u00a0");k+=m;h=" "==m}h=k}}else h=b;k=h;l=a.cm.state.specialChars;m=!1;if(l.test(b)){h=document.createDocumentFragment();for(var q=0;;){l.lastIndex=q;var n=l.exec(b),p=n?n.index-q:b.length-q;if(p){var r=document.createTextNode(k.slice(q,q+p));G&&9>U?h.appendChild(v("span",[r])):h.appendChild(r);a.map.push(a.pos,a.pos+p,r);a.col+=p;a.pos+=p}if(!n)break;q+=
p+1;"\t"==n[0]?(n=a.cm.options.tabSize,n-=a.col%n,p=h.appendChild(v("span",fd(n),"cm-tab")),p.setAttribute("role","presentation"),p.setAttribute("cm-text","\t"),a.col+=n):("\r"==n[0]||"\n"==n[0]?(p=h.appendChild(v("span","\r"==n[0]?"\u240d":"\u2424","cm-invalidchar")),p.setAttribute("cm-text",n[0])):(p=a.cm.options.specialCharPlaceholder(n[0]),p.setAttribute("cm-text",n[0]),G&&9>U?h.appendChild(v("span",[p])):h.appendChild(p)),a.col+=1);a.map.push(a.pos,a.pos+1,p);a.pos++}}else a.col+=b.length,h=
document.createTextNode(k),a.map.push(a.pos,a.pos+b.length,h),G&&9>U&&(m=!0),a.pos+=b.length;a.trailingSpace=32==k.charCodeAt(b.length-1);if(d||c||e||m||f||g){b=d||"";c&&(b+=c);e&&(b+=e);c=v("span",[h],b,f);if(g)for(var u in g)g.hasOwnProperty(u)&&"style"!=u&&"class"!=u&&c.setAttribute(u,g[u]);return a.content.appendChild(c)}a.content.appendChild(h)}}function Kg(a,b){return function(d,c,e,f,g,h,k){e=e?e+" cm-force-border":"cm-force-border";for(var l=d.pos,m=l+c.length;;){for(var q=void 0,n=0;n<b.length&&
!(q=b[n],q.to>l&&q.from<=l);n++);if(q.to>=m)return a(d,c,e,f,g,h,k);a(d,c.slice(0,q.to-l),e,f,null,h,k);f=null;c=c.slice(q.to-l);l=q.to}}}function Je(a,b,d,c){var e=!c&&d.widgetNode;e&&a.map.push(a.pos,a.pos+b,e);!c&&a.cm.display.input.needsContentAttribute&&(e||(e=a.content.appendChild(document.createElement("span"))),e.setAttribute("cm-marker",d.id));e&&(a.cm.display.input.setUneditable(e),a.content.appendChild(e));a.pos+=b;a.trailingSpace=!1}function Ke(a,b,d){for(var c=this.line=b,e;c=qb(c,!1);)c=
c.find(1,!0).line,(e||(e=[])).push(c);this.size=(this.rest=e)?O(L(this.rest))-d+1:1;this.node=this.text=null;this.hidden=Oa(a,b)}function Ec(a,b,d){var c=[],e;for(e=b;e<d;)b=new Ke(a.doc,w(a.doc,e),e),e+=b.size,c.push(b);return c}function Mg(a,b){if(a=a.ownsGroup)try{var d=a.delayedCallbacks,c=0;do{for(;c<d.length;c++)d[c].call(null);for(var e=0;e<a.ops.length;e++){var f=a.ops[e];if(f.cursorActivityHandlers)for(;f.cursorActivityCalled<f.cursorActivityHandlers.length;)f.cursorActivityHandlers[f.cursorActivityCalled++].call(null,
f.cm)}}while(c<d.length)}finally{rb=null,b(a)}}function ca(a,b){var d=a._handlers&&a._handlers[b]||xc;if(d.length){var c=Array.prototype.slice.call(arguments,2);if(rb)var e=rb.delayedCallbacks;else Pb?e=Pb:(e=Pb=[],setTimeout(Ng,0));for(var f=function(h){e.push(function(){return d[h].apply(null,c)})},g=0;g<d.length;++g)f(g)}}function Ng(){var a=Pb;Pb=null;for(var b=0;b<a.length;++b)a[b]()}function Le(a,b,d,c){for(var e=0;e<b.changes.length;e++){var f=b.changes[e];if("text"==f){f=a;var g=b,h=g.text.className,
k=Me(f,g);g.text==g.node&&(g.node=k.pre);g.text.parentNode.replaceChild(k.pre,g.text);g.text=k.pre;k.bgClass!=g.bgClass||k.textClass!=g.textClass?(g.bgClass=k.bgClass,g.textClass=k.textClass,zd(f,g)):h&&(g.text.className=h)}else if("gutter"==f)Ne(a,b,d,c);else if("class"==f)zd(a,b);else if("widget"==f){f=a;g=b;h=c;g.alignable&&(g.alignable=null);k=y("CodeMirror-linewidget");for(var l=g.node.firstChild,m;l;l=m)m=l.nextSibling,k.test(l.className)&&g.node.removeChild(l);Oe(f,g,h)}}b.changes=null}function Qb(a){a.node==
a.text&&(a.node=v("div",null,null,"position: relative"),a.text.parentNode&&a.text.parentNode.replaceChild(a.node,a.text),a.node.appendChild(a.text),G&&8>U&&(a.node.style.zIndex=2));return a.node}function Me(a,b){var d=a.display.externalMeasured;return d&&d.line==b.line?(a.display.externalMeasured=null,b.measure=d.measure,d.built):Ie(a,b)}function zd(a,b){var d=b.bgClass?b.bgClass+" "+(b.line.bgClass||""):b.line.bgClass;d&&(d+=" CodeMirror-linebackground");if(b.background)d?b.background.className=
d:(b.background.parentNode.removeChild(b.background),b.background=null);else if(d){var c=Qb(b);b.background=c.insertBefore(v("div",null,d),c.firstChild);a.display.input.setUneditable(b.background)}b.line.wrapClass?Qb(b).className=b.line.wrapClass:b.node!=b.text&&(b.node.className="");b.text.className=(b.textClass?b.textClass+" "+(b.line.textClass||""):b.line.textClass)||""}function Ne(a,b,d,c){b.gutter&&(b.node.removeChild(b.gutter),b.gutter=null);b.gutterBackground&&(b.node.removeChild(b.gutterBackground),
b.gutterBackground=null);if(b.line.gutterClass){var e=Qb(b);b.gutterBackground=v("div",null,"CodeMirror-gutter-background "+b.line.gutterClass,"left: "+(a.options.fixedGutter?c.fixedPos:-c.gutterTotalWidth)+"px; width: "+c.gutterTotalWidth+"px");a.display.input.setUneditable(b.gutterBackground);e.insertBefore(b.gutterBackground,b.text)}e=b.line.gutterMarkers;if(a.options.lineNumbers||e){var f=Qb(b),g=b.gutter=v("div",null,"CodeMirror-gutter-wrapper","left: "+(a.options.fixedGutter?c.fixedPos:-c.gutterTotalWidth)+
"px");a.display.input.setUneditable(g);f.insertBefore(g,b.text);b.line.gutterClass&&(g.className+=" "+b.line.gutterClass);!a.options.lineNumbers||e&&e["CodeMirror-linenumbers"]||(b.lineNumber=g.appendChild(v("div",od(a.options,d),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+c.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+a.display.lineNumInnerWidth+"px")));if(e)for(b=0;b<a.display.gutterSpecs.length;++b)d=a.display.gutterSpecs[b].className,(f=e.hasOwnProperty(d)&&e[d])&&g.appendChild(v("div",
[f],"CodeMirror-gutter-elt","left: "+c.gutterLeft[d]+"px; width: "+c.gutterWidth[d]+"px"))}}function Og(a,b,d,c){var e=Me(a,b);b.text=b.node=e.pre;e.bgClass&&(b.bgClass=e.bgClass);e.textClass&&(b.textClass=e.textClass);zd(a,b);Ne(a,b,d,c);Oe(a,b,c);return b.node}function Oe(a,b,d){Pe(a,b.line,b,d,!0);if(b.rest)for(var c=0;c<b.rest.length;c++)Pe(a,b.rest[c],b,d,!1)}function Pe(a,b,d,c,e){if(b.widgets){var f=Qb(d),g=0;for(b=b.widgets;g<b.length;++g){var h=b[g],k=v("div",[h.node],"CodeMirror-linewidget"+
(h.className?" "+h.className:""));h.handleMouseEvents||k.setAttribute("cm-ignore-events","true");var l=h,m=k,q=c;if(l.noHScroll){(d.alignable||(d.alignable=[])).push(m);var n=q.wrapperWidth;m.style.left=q.fixedPos+"px";l.coverGutter||(n-=q.gutterTotalWidth,m.style.paddingLeft=q.gutterTotalWidth+"px");m.style.width=n+"px"}l.coverGutter&&(m.style.zIndex=5,m.style.position="relative",l.noHScroll||(m.style.marginLeft=-q.gutterTotalWidth+"px"));a.display.input.setUneditable(k);e&&h.above?f.insertBefore(k,
d.gutter||d.text):f.appendChild(k);ca(h,"redraw")}}}function Rb(a){if(null!=a.height)return a.height;var b=a.doc.cm;if(!b)return 0;if(!ka(document.body,a.node)){var d="position: relative;";a.coverGutter&&(d+="margin-left: -"+b.display.gutters.offsetWidth+"px;");a.noHScroll&&(d+="width: "+b.display.wrapper.clientWidth+"px;");D(b.display.measure,v("div",[a.node],null,d))}return a.height=a.node.parentNode.offsetHeight}function La(a,b){for(b=b.target||b.srcElement;b!=a.wrapper;b=b.parentNode)if(!b||1==
b.nodeType&&"true"==b.getAttribute("cm-ignore-events")||b.parentNode==a.sizer&&b!=a.mover)return!0}function Ad(a){return a.mover.offsetHeight-a.lineSpace.offsetHeight}function Qe(a){if(a.cachedPaddingH)return a.cachedPaddingH;var b=D(a.measure,v("pre","x","CodeMirror-line-like"));b=window.getComputedStyle?window.getComputedStyle(b):b.currentStyle;b={left:parseInt(b.paddingLeft),right:parseInt(b.paddingRight)};isNaN(b.left)||isNaN(b.right)||(a.cachedPaddingH=b);return b}function Ha(a){return 50-a.display.nativeBarWidth}
function ab(a){return a.display.scroller.clientWidth-Ha(a)-a.display.barWidth}function Bd(a){return a.display.scroller.clientHeight-Ha(a)-a.display.barHeight}function Re(a,b,d){if(a.line==b)return{map:a.measure.map,cache:a.measure.cache};for(var c=0;c<a.rest.length;c++)if(a.rest[c]==b)return{map:a.measure.maps[c],cache:a.measure.caches[c]};for(b=0;b<a.rest.length;b++)if(O(a.rest[b])>d)return{map:a.measure.maps[b],cache:a.measure.caches[b],before:!0}}function Cd(a,b){if(b>=a.display.viewFrom&&b<a.display.viewTo)return a.display.view[bb(a,
b)];if((a=a.display.externalMeasured)&&b>=a.lineN&&b<a.lineN+a.size)return a}function cb(a,b){var d=O(b),c=Cd(a,d);c&&!c.text?c=null:c&&c.changes&&(Le(a,c,d,Dd(a)),a.curOp.forceUpdate=!0);if(!c){var e=Fa(b);c=O(e);e=a.display.externalMeasured=new Ke(a.doc,e,c);e.lineN=c;c=e.built=Ie(a,e);e.text=c.pre;D(a.display.lineMeasure,c.pre);c=e}a=Re(c,b,d);return{line:b,view:c,rect:null,map:a.map,cache:a.cache,before:a.before,hasHeights:!1}}function za(a,b,d,c,e){b.before&&(d=-1);var f=d+(c||"");if(b.cache.hasOwnProperty(f))a=
b.cache[f];else{b.rect||(b.rect=b.view.text.getBoundingClientRect());if(!b.hasHeights){var g=b.view,h=b.rect,k=a.options.lineWrapping,l=k&&ab(a);if(!g.measure.heights||k&&g.measure.width!=l){var m=g.measure.heights=[];if(k)for(g.measure.width=l,g=g.text.firstChild.getClientRects(),k=0;k<g.length-1;k++){l=g[k];var q=g[k+1];2<Math.abs(l.bottom-q.bottom)&&m.push((l.bottom+q.top)/2-h.top)}m.push(h.bottom-h.top)}b.hasHeights=!0}m=c;g=Se(b.map,d,m);c=g.node;h=g.start;k=g.end;d=g.collapse;if(3==c.nodeType){for(var n=
0;4>n;n++){for(;h&&hd(b.line.text.charAt(g.coverStart+h));)--h;for(;g.coverStart+k<g.coverEnd&&hd(b.line.text.charAt(g.coverStart+k));)++k;if(G&&9>U&&0==h&&k==g.coverEnd-g.coverStart)var p=c.parentNode.getBoundingClientRect();else{p=Ob(c,h,k).getClientRects();k=Te;if("left"==m)for(l=0;l<p.length&&(k=p[l]).left==k.right;l++);else for(l=p.length-1;0<=l&&(k=p[l]).left==k.right;l--);p=k}if(p.left||p.right||0==h)break;k=h;--h;d="right"}G&&11>U&&((n=!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==
screen.deviceXDPI)||(null!=Ed?n=Ed:(m=D(a.display.measure,v("span","x")),n=m.getBoundingClientRect(),m=Ob(m,0,1).getBoundingClientRect(),n=Ed=1<Math.abs(n.left-m.left)),n=!n),n||(n=screen.logicalXDPI/screen.deviceXDPI,m=screen.logicalYDPI/screen.deviceYDPI,p={left:p.left*n,right:p.right*n,top:p.top*m,bottom:p.bottom*m}))}else 0<h&&(d=m="right"),p=a.options.lineWrapping&&1<(n=c.getClientRects()).length?n["right"==m?n.length-1:0]:c.getBoundingClientRect();!(G&&9>U)||h||p&&(p.left||p.right)||(p=(p=c.parentNode.getClientRects()[0])?
{left:p.left,right:p.left+sb(a.display),top:p.top,bottom:p.bottom}:Te);c=p.top-b.rect.top;h=p.bottom-b.rect.top;n=(c+h)/2;m=b.view.measure.heights;for(g=0;g<m.length-1&&!(n<m[g]);g++);d={left:("right"==d?p.right:p.left)-b.rect.left,right:("left"==d?p.left:p.right)-b.rect.left,top:g?m[g-1]:0,bottom:m[g]};p.left||p.right||(d.bogus=!0);a.options.singleCursorHeightPerLine||(d.rtop=c,d.rbottom=h);a=d;a.bogus||(b.cache[f]=a)}return{left:a.left,right:a.right,top:e?a.rtop:a.top,bottom:e?a.rbottom:a.bottom}}
function Se(a,b,d){for(var c,e,f,g,h,k,l=0;l<a.length;l+=3){h=a[l];k=a[l+1];if(b<h)e=0,f=1,g="left";else if(b<k)e=b-h,f=e+1;else if(l==a.length-3||b==k&&a[l+3]>b)f=k-h,e=f-1,b>=k&&(g="right");if(null!=e){c=a[l+2];h==k&&d==(c.insertLeft?"left":"right")&&(g=d);if("left"==d&&0==e)for(;l&&a[l-2]==a[l-3]&&a[l-1].insertLeft;)c=a[(l-=3)+2],g="left";if("right"==d&&e==k-h)for(;l<a.length-3&&a[l+3]==a[l+4]&&!a[l+5].insertLeft;)c=a[(l+=3)+2],g="right";break}}return{node:c,start:e,end:f,collapse:g,coverStart:h,
coverEnd:k}}function Ue(a){if(a.measure&&(a.measure.cache={},a.measure.heights=null,a.rest))for(var b=0;b<a.rest.length;b++)a.measure.caches[b]={}}function Ve(a){a.display.externalMeasure=null;E(a.display.lineMeasure);for(var b=0;b<a.display.view.length;b++)Ue(a.display.view[b])}function Sb(a){Ve(a);a.display.cachedCharWidth=a.display.cachedTextHeight=a.display.cachedPaddingH=null;a.options.lineWrapping||(a.display.maxLineChanged=!0);a.display.lineNumChars=null}function We(){return Fc&&Gc?-(document.body.getBoundingClientRect().left-
parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function Xe(){return Fc&&Gc?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function Fd(a){var b=0;if(a.widgets)for(var d=0;d<a.widgets.length;++d)a.widgets[d].above&&(b+=Rb(a.widgets[d]));return b}function Hc(a,b,d,c,e){e||(e=Fd(b),d.top+=e,d.bottom+=e);
if("line"==c)return d;c||(c="local");b=Ga(b);b="local"==c?b+a.display.lineSpace.offsetTop:b-a.display.viewOffset;if("page"==c||"window"==c)a=a.display.lineSpace.getBoundingClientRect(),b+=a.top+("window"==c?0:Xe()),c=a.left+("window"==c?0:We()),d.left+=c,d.right+=c;d.top+=b;d.bottom+=b;return d}function Ye(a,b,d){if("div"==d)return b;var c=b.left;b=b.top;"page"==d?(c-=We(),b-=Xe()):"local"!=d&&d||(d=a.display.sizer.getBoundingClientRect(),c+=d.left,b+=d.top);a=a.display.lineSpace.getBoundingClientRect();
return{left:c-a.left,top:b-a.top}}function Gd(a,b,d,c,e){c||(c=w(a.doc,b.line));var f=c;b=b.ch;c=za(a,cb(a,c),b,e);return Hc(a,f,c,d)}function Aa(a,b,d,c,e,f){function g(n,p){n=za(a,e,n,p?"right":"left",f);p?n.left=n.right:n.right=n.left;return Hc(a,c,n,d)}function h(n,p,r){return g(r?n-1:n,1==k[p].level!=r)}c=c||w(a.doc,b.line);e||(e=cb(a,c));var k=Ja(c,a.doc.direction),l=b.ch;b=b.sticky;l>=c.text.length?(l=c.text.length,b="before"):0>=l&&(l=0,b="after");if(!k)return g("before"==b?l-1:l,"before"==
b);var m=Ib(k,l,b),q=Jb;m=h(l,m,"before"==b);null!=q&&(m.other=h(l,q,"before"!=b));return m}function Ze(a,b){var d=0;b=C(a.doc,b);a.options.lineWrapping||(d=sb(a.display)*b.ch);b=w(a.doc,b.line);a=Ga(b)+a.display.lineSpace.offsetTop;return{left:d,right:d,top:a,bottom:a+b.height}}function Hd(a,b,d,c,e){a=t(a,b,d);a.xRel=e;c&&(a.outside=c);return a}function Id(a,b,d){var c=a.doc;d+=a.display.viewOffset;if(0>d)return Hd(c.first,0,null,-1,-1);var e=$a(c,d),f=c.first+c.size-1;if(e>f)return Hd(c.first+
c.size-1,w(c,f).text.length,null,1,1);0>b&&(b=0);for(var g=w(c,e);;){f=Pg(a,g,e,b,d);var h=void 0;var k=f.ch+(0<f.xRel||0<f.outside?1:0);if(g=Ka&&g.markedSpans)for(var l=0;l<g.length;++l){var m=g[l];m.marker.collapsed&&(null==m.from||m.from<k)&&(null==m.to||m.to>k)&&(!h||0>ud(h,m.marker))&&(h=m.marker)}if(!h)return f;f=h.find(1);if(f.line==e)return f;g=w(c,e=f.line)}}function $e(a,b,d,c){c-=Fd(b);b=b.text.length;var e=Hb(function(f){return za(a,d,f-1).bottom<=c},b,0);b=Hb(function(f){return za(a,
d,f).top>c},e,b);return{begin:e,end:b}}function af(a,b,d,c){d||(d=cb(a,b));c=Hc(a,b,za(a,d,c),"line").top;return $e(a,b,d,c)}function Jd(a,b,d,c){return a.bottom<=d?!1:a.top>d?!0:(c?a.left:a.right)>b}function Pg(a,b,d,c,e){e-=Ga(b);var f=cb(a,b),g=Fd(b),h=0,k=b.text.length,l=!0,m=Ja(b,a.doc.direction);m&&(m=(a.options.lineWrapping?Qg:Rg)(a,b,d,f,m,c,e),h=(l=1!=m.level)?m.from:m.to-1,k=l?m.to:m.from-1);var q=null,n=null;m=Hb(function(r){var u=za(a,f,r);u.top+=g;u.bottom+=g;if(!Jd(u,c,e,!1))return!1;
u.top<=e&&u.left<=c&&(q=r,n=u);return!0},h,k);var p=!1;n?(h=c-n.left<n.right-c,l=h==l,m=q+(l?0:1),l=l?"after":"before",h=h?n.left:n.right):(l||m!=k&&m!=h||m++,l=0==m?"after":m==b.text.length?"before":za(a,f,m-(l?1:0)).bottom+g<=e==l?"after":"before",p=Aa(a,t(d,m,l),"line",b,f),h=p.left,p=e<p.top?-1:e>=p.bottom?1:0);m=pe(b.text,m,1);return Hd(d,m,l,p,c-h)}function Rg(a,b,d,c,e,f,g){var h=Hb(function(m){m=e[m];var q=1!=m.level;return Jd(Aa(a,t(d,q?m.to:m.from,q?"before":"after"),"line",b,c),f,g,!0)},
0,e.length-1),k=e[h];if(0<h){var l=1!=k.level;l=Aa(a,t(d,l?k.from:k.to,l?"after":"before"),"line",b,c);Jd(l,f,g,!0)&&l.top>g&&(k=e[h-1])}return k}function Qg(a,b,d,c,e,f,g){g=$e(a,b,c,g);d=g.begin;g=g.end;/\s/.test(b.text.charAt(g-1))&&g--;for(var h=b=null,k=0;k<e.length;k++){var l=e[k];if(!(l.from>=g||l.to<=d)){var m=za(a,c,1!=l.level?Math.min(g,l.to)-1:Math.max(d,l.from)).right;m=m<f?f-m+1E9:m-f;if(!b||h>m)b=l,h=m}}b||(b=e[e.length-1]);b.from<d&&(b={from:d,to:b.to,level:b.level});b.to>g&&(b={from:b.from,
to:g,level:b.level});return b}function tb(a){if(null!=a.cachedTextHeight)return a.cachedTextHeight;if(null==db){db=v("pre",null,"CodeMirror-line-like");for(var b=0;49>b;++b)db.appendChild(document.createTextNode("x")),db.appendChild(v("br"));db.appendChild(document.createTextNode("x"))}D(a.measure,db);b=db.offsetHeight/50;3<b&&(a.cachedTextHeight=b);E(a.measure);return b||1}function sb(a){if(null!=a.cachedCharWidth)return a.cachedCharWidth;var b=v("span","xxxxxxxxxx"),d=v("pre",[b],"CodeMirror-line-like");
D(a.measure,d);b=b.getBoundingClientRect();b=(b.right-b.left)/10;2<b&&(a.cachedCharWidth=b);return b||10}function Dd(a){for(var b=a.display,d={},c={},e=b.gutters.clientLeft,f=b.gutters.firstChild,g=0;f;f=f.nextSibling,++g){var h=a.display.gutterSpecs[g].className;d[h]=f.offsetLeft+f.clientLeft+e;c[h]=f.clientWidth}return{fixedPos:Kd(b),gutterTotalWidth:b.gutters.offsetWidth,gutterLeft:d,gutterWidth:c,wrapperWidth:b.wrapper.clientWidth}}function Kd(a){return a.scroller.getBoundingClientRect().left-
a.sizer.getBoundingClientRect().left}function bf(a){var b=tb(a.display),d=a.options.lineWrapping,c=d&&Math.max(5,a.display.scroller.clientWidth/sb(a.display)-3);return function(e){if(Oa(a.doc,e))return 0;var f=0;if(e.widgets)for(var g=0;g<e.widgets.length;g++)e.widgets[g].height&&(f+=e.widgets[g].height);return d?f+(Math.ceil(e.text.length/c)||1)*b:f+b}}function Ld(a){var b=a.doc,d=bf(a);b.iter(function(c){var e=d(c);e!=c.height&&Da(c,e)})}function eb(a,b,d,c){var e=a.display;if(!d&&"true"==(b.target||
b.srcElement).getAttribute("cm-not-content"))return null;d=e.lineSpace.getBoundingClientRect();try{var f=b.clientX-d.left;var g=b.clientY-d.top}catch(k){return null}b=Id(a,f,g);var h;c&&0<b.xRel&&(h=w(a.doc,b.line).text).length==b.ch&&(c=wa(h,h.length,a.options.tabSize)-h.length,b=t(b.line,Math.max(0,Math.round((f-Qe(a.display).left)/sb(a.display))-c)));return b}function bb(a,b){if(b>=a.display.viewTo)return null;b-=a.display.viewFrom;if(0>b)return null;a=a.display.view;for(var d=0;d<a.length;d++)if(b-=
a[d].size,0>b)return d}function ma(a,b,d,c){null==b&&(b=a.doc.first);null==d&&(d=a.doc.first+a.doc.size);c||(c=0);var e=a.display;c&&d<e.viewTo&&(null==e.updateLineNumbers||e.updateLineNumbers>b)&&(e.updateLineNumbers=b);a.curOp.viewChanged=!0;if(b>=e.viewTo)Ka&&vd(a.doc,b)<e.viewTo&&Pa(a);else if(d<=e.viewFrom)Ka&&Ge(a.doc,d+c)>e.viewFrom?Pa(a):(e.viewFrom+=c,e.viewTo+=c);else if(b<=e.viewFrom&&d>=e.viewTo)Pa(a);else if(b<=e.viewFrom){var f=Ic(a,d,d+c,1);f?(e.view=e.view.slice(f.index),e.viewFrom=
f.lineN,e.viewTo+=c):Pa(a)}else if(d>=e.viewTo)(f=Ic(a,b,b,-1))?(e.view=e.view.slice(0,f.index),e.viewTo=f.lineN):Pa(a);else{f=Ic(a,b,b,-1);var g=Ic(a,d,d+c,1);f&&g?(e.view=e.view.slice(0,f.index).concat(Ec(a,f.lineN,g.lineN)).concat(e.view.slice(g.index)),e.viewTo+=c):Pa(a)}if(a=e.externalMeasured)d<a.lineN?a.lineN+=c:b<a.lineN+a.size&&(e.externalMeasured=null)}function Qa(a,b,d){a.curOp.viewChanged=!0;var c=a.display,e=a.display.externalMeasured;e&&b>=e.lineN&&b<e.lineN+e.size&&(c.externalMeasured=
null);b<c.viewFrom||b>=c.viewTo||(a=c.view[bb(a,b)],null!=a.node&&(a=a.changes||(a.changes=[]),-1==ea(a,d)&&a.push(d)))}function Pa(a){a.display.viewFrom=a.display.viewTo=a.doc.first;a.display.view=[];a.display.viewOffset=0}function Ic(a,b,d,c){var e=bb(a,b),f=a.display.view;if(!Ka||d==a.doc.first+a.doc.size)return{index:e,lineN:d};for(var g=a.display.viewFrom,h=0;h<e;h++)g+=f[h].size;if(g!=b){if(0<c){if(e==f.length-1)return null;b=g+f[e].size-b;e++}else b=g-b;d+=b}for(;vd(a.doc,d)!=d;){if(e==(0>
c?0:f.length-1))return null;d+=c*f[e-(0>c?1:0)].size;e+=c}return{index:e,lineN:d}}function cf(a){a=a.display.view;for(var b=0,d=0;d<a.length;d++){var c=a[d];c.hidden||c.node&&!c.changes||++b}return b}function Tb(a){a.display.input.showSelection(a.display.input.prepareSelection())}function df(a,b){void 0===b&&(b=!0);for(var d=a.doc,c={},e=c.cursors=document.createDocumentFragment(),f=c.selection=document.createDocumentFragment(),g=0;g<d.sel.ranges.length;g++)if(b||g!=d.sel.primIndex){var h=d.sel.ranges[g];
if(!(h.from().line>=a.display.viewTo||h.to().line<a.display.viewFrom)){var k=h.empty();(k||a.options.showCursorWhenSelecting)&&ef(a,h.head,e);k||Sg(a,h,f)}}return c}function ef(a,b,d){b=Aa(a,b,"div",null,null,!a.options.singleCursorHeightPerLine);var c=d.appendChild(v("div","\u00a0","CodeMirror-cursor"));c.style.left=b.left+"px";c.style.top=b.top+"px";c.style.height=Math.max(0,b.bottom-b.top)*a.options.cursorHeight+"px";b.other&&(a=d.appendChild(v("div","\u00a0","CodeMirror-cursor CodeMirror-secondarycursor")),
a.style.display="",a.style.left=b.other.left+"px",a.style.top=b.other.top+"px",a.style.height=.85*(b.other.bottom-b.other.top)+"px")}function Jc(a,b){return a.top-b.top||a.left-b.left}function Sg(a,b,d){function c(p,r,u,A){0>r&&(r=0);r=Math.round(r);A=Math.round(A);h.appendChild(v("div",null,"CodeMirror-selected","position: absolute; left: "+p+"px;\n                             top: "+r+"px; width: "+(null==u?m-p:u)+"px;\n                             height: "+(A-r)+"px"))}function e(p,r,u){function A(F,
S){return Gd(a,t(p,F),"div",x,S)}function H(F,S,I){F=af(a,x,null,F);S="ltr"==S==("after"==I)?"left":"right";I="after"==I?F.begin:F.end-(/\s/.test(x.text.charAt(F.end-1))?2:1);return A(I,S)[S]}var x=w(g,p),Q=x.text.length,M,R,T=Ja(x,g.direction);zg(T,r||0,null==u?Q:u,function(F,S,I,N){var ha="ltr"==I,na=A(F,ha?"left":"right"),sa=A(S-1,ha?"right":"left"),fb=null==r&&0==F,gb=null==u&&S==Q,Md=0==N;N=!T||N==T.length-1;3>=sa.top-na.top?(S=(q?fb:gb)&&Md?l:(ha?na:sa).left,c(S,na.top,((q?gb:fb)&&N?m:(ha?sa:
na).right)-S,na.bottom)):(ha?(ha=q&&fb&&Md?l:na.left,fb=q?m:H(F,I,"before"),F=q?l:H(S,I,"after"),gb=q&&gb&&N?m:sa.right):(ha=q?H(F,I,"before"):l,fb=!q&&fb&&Md?m:na.right,F=!q&&gb&&N?l:sa.left,gb=q?H(S,I,"after"):m),c(ha,na.top,fb-ha,na.bottom),na.bottom<sa.top&&c(l,na.bottom,null,sa.top),c(F,sa.top,gb-F,sa.bottom));if(!M||0>Jc(na,M))M=na;0>Jc(sa,M)&&(M=sa);if(!R||0>Jc(na,R))R=na;0>Jc(sa,R)&&(R=sa)});return{start:M,end:R}}var f=a.display,g=a.doc,h=document.createDocumentFragment(),k=Qe(a.display),
l=k.left,m=Math.max(f.sizerWidth,ab(a)-f.sizer.offsetLeft)-k.right,q="ltr"==g.direction;f=b.from();b=b.to();if(f.line==b.line)e(f.line,f.ch,b.ch);else{var n=w(g,f.line);k=w(g,b.line);k=Fa(n)==Fa(k);f=e(f.line,f.ch,k?n.text.length+1:null).end;b=e(b.line,k?0:null,b.ch).start;k&&(f.top<b.top-2?(c(f.right,f.top,null,f.bottom),c(l,b.top,b.left,b.bottom)):c(f.right,f.top,b.left-f.right,f.bottom));f.bottom<b.top&&c(l,f.bottom,null,b.top)}d.appendChild(h)}function Nd(a){if(a.state.focused){var b=a.display;
clearInterval(b.blinker);var d=!0;b.cursorDiv.style.visibility="";0<a.options.cursorBlinkRate?b.blinker=setInterval(function(){a.hasFocus()||ub(a);b.cursorDiv.style.visibility=(d=!d)?"":"hidden"},a.options.cursorBlinkRate):0>a.options.cursorBlinkRate&&(b.cursorDiv.style.visibility="hidden")}}function ff(a){a.state.focused||(a.display.input.focus(),Od(a))}function gf(a){a.state.delayingBlurEvent=!0;setTimeout(function(){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1,ub(a))},100)}function Od(a,
b){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1);"nocursor"!=a.options.readOnly&&(a.state.focused||(X(a,"focus",a,b),a.state.focused=!0,Wa(a.display.wrapper,"CodeMirror-focused"),a.curOp||a.display.selForContextMenu==a.doc.sel||(a.display.input.reset(),fa&&setTimeout(function(){return a.display.input.reset(!0)},20)),a.display.input.receivedFocus()),Nd(a))}function ub(a,b){a.state.delayingBlurEvent||(a.state.focused&&(X(a,"blur",a,b),a.state.focused=!1,hb(a.display.wrapper,"CodeMirror-focused")),
clearInterval(a.display.blinker),setTimeout(function(){a.state.focused||(a.display.shift=!1)},150))}function Kc(a){for(var b=a.display,d=b.lineDiv.offsetTop,c=0;c<b.view.length;c++){var e=b.view[c],f=a.options.lineWrapping,g=0;if(!e.hidden){if(G&&8>U){f=e.node.offsetTop+e.node.offsetHeight;var h=f-d;d=f}else{var k=e.node.getBoundingClientRect();h=k.bottom-k.top;!f&&e.text.firstChild&&(g=e.text.firstChild.getBoundingClientRect().right-k.left-1)}f=e.line.height-h;if(.005<f||-.005>f)if(Da(e.line,h),
hf(e.line),e.rest)for(h=0;h<e.rest.length;h++)hf(e.rest[h]);g>a.display.sizerWidth&&(g=Math.ceil(g/sb(a.display)),g>a.display.maxLineLength&&(a.display.maxLineLength=g,a.display.maxLine=e.line,a.display.maxLineChanged=!0))}}}function hf(a){if(a.widgets)for(var b=0;b<a.widgets.length;++b){var d=a.widgets[b],c=d.node.parentNode;c&&(d.height=c.offsetHeight)}}function Lc(a,b,d){var c=d&&null!=d.top?Math.max(0,d.top):a.scroller.scrollTop;c=Math.floor(c-a.lineSpace.offsetTop);var e=d&&null!=d.bottom?d.bottom:
c+a.wrapper.clientHeight;c=$a(b,c);e=$a(b,e);if(d&&d.ensure){var f=d.ensure.from.line;d=d.ensure.to.line;f<c?(c=f,e=$a(b,Ga(w(b,f))+a.wrapper.clientHeight)):Math.min(d,b.lastLine())>=e&&(c=$a(b,Ga(w(b,d))-a.wrapper.clientHeight),e=d)}return{from:c,to:Math.max(e,c+1)}}function Pd(a,b){var d=a.display,c=tb(a.display);0>b.top&&(b.top=0);var e=a.curOp&&null!=a.curOp.scrollTop?a.curOp.scrollTop:d.scroller.scrollTop,f=Bd(a),g={};b.bottom-b.top>f&&(b.bottom=b.top+f);var h=a.doc.height+Ad(d),k=b.top<c;c=
b.bottom>h-c;b.top<e?g.scrollTop=k?0:b.top:b.bottom>e+f&&(f=Math.min(b.top,(c?h:b.bottom)-f),f!=e&&(g.scrollTop=f));e=a.curOp&&null!=a.curOp.scrollLeft?a.curOp.scrollLeft:d.scroller.scrollLeft;a=ab(a)-(a.options.fixedGutter?d.gutters.offsetWidth:0);if(d=b.right-b.left>a)b.right=b.left+a;10>b.left?g.scrollLeft=0:b.left<e?g.scrollLeft=Math.max(0,b.left-(d?0:10)):b.right>a+e-3&&(g.scrollLeft=b.right+(d?0:10)-a);return g}function Mc(a,b){null!=b&&(Nc(a),a.curOp.scrollTop=(null==a.curOp.scrollTop?a.doc.scrollTop:
a.curOp.scrollTop)+b)}function vb(a){Nc(a);var b=a.getCursor();a.curOp.scrollToPos={from:b,to:b,margin:a.options.cursorScrollMargin}}function Ub(a,b,d){null==b&&null==d||Nc(a);null!=b&&(a.curOp.scrollLeft=b);null!=d&&(a.curOp.scrollTop=d)}function Nc(a){var b=a.curOp.scrollToPos;if(b){a.curOp.scrollToPos=null;var d=Ze(a,b.from),c=Ze(a,b.to);jf(a,d,c,b.margin)}}function jf(a,b,d,c){b=Pd(a,{left:Math.min(b.left,d.left),top:Math.min(b.top,d.top)-c,right:Math.max(b.right,d.right),bottom:Math.max(b.bottom,
d.bottom)+c});Ub(a,b.scrollLeft,b.scrollTop)}function Vb(a,b){2>Math.abs(a.doc.scrollTop-b)||(Ma||Qd(a,{top:b}),kf(a,b,!0),Ma&&Qd(a),Wb(a,100))}function kf(a,b,d){b=Math.max(0,Math.min(a.display.scroller.scrollHeight-a.display.scroller.clientHeight,b));if(a.display.scroller.scrollTop!=b||d)a.doc.scrollTop=b,a.display.scrollbars.setScrollTop(b),a.display.scroller.scrollTop!=b&&(a.display.scroller.scrollTop=b)}function ib(a,b,d,c){b=Math.max(0,Math.min(b,a.display.scroller.scrollWidth-a.display.scroller.clientWidth));
(d?b==a.doc.scrollLeft:2>Math.abs(a.doc.scrollLeft-b))&&!c||(a.doc.scrollLeft=b,lf(a),a.display.scroller.scrollLeft!=b&&(a.display.scroller.scrollLeft=b),a.display.scrollbars.setScrollLeft(b))}function Xb(a){var b=a.display,d=b.gutters.offsetWidth,c=Math.round(a.doc.height+Ad(a.display));return{clientHeight:b.scroller.clientHeight,viewHeight:b.wrapper.clientHeight,scrollWidth:b.scroller.scrollWidth,clientWidth:b.scroller.clientWidth,viewWidth:b.wrapper.clientWidth,barLeft:a.options.fixedGutter?d:
0,docHeight:c,scrollHeight:c+Ha(a)+b.barHeight,nativeBarWidth:b.nativeBarWidth,gutterWidth:d}}function wb(a,b){b||(b=Xb(a));var d=a.display.barWidth,c=a.display.barHeight;mf(a,b);for(b=0;4>b&&d!=a.display.barWidth||c!=a.display.barHeight;b++)d!=a.display.barWidth&&a.options.lineWrapping&&Kc(a),mf(a,Xb(a)),d=a.display.barWidth,c=a.display.barHeight}function mf(a,b){var d=a.display,c=d.scrollbars.update(b);d.sizer.style.paddingRight=(d.barWidth=c.right)+"px";d.sizer.style.paddingBottom=(d.barHeight=
c.bottom)+"px";d.heightForcer.style.borderBottom=c.bottom+"px solid transparent";c.right&&c.bottom?(d.scrollbarFiller.style.display="block",d.scrollbarFiller.style.height=c.bottom+"px",d.scrollbarFiller.style.width=c.right+"px"):d.scrollbarFiller.style.display="";c.bottom&&a.options.coverGutterNextToScrollbar&&a.options.fixedGutter?(d.gutterFiller.style.display="block",d.gutterFiller.style.height=c.bottom+"px",d.gutterFiller.style.width=b.gutterWidth+"px"):d.gutterFiller.style.display=""}function nf(a){a.display.scrollbars&&
(a.display.scrollbars.clear(),a.display.scrollbars.addClass&&hb(a.display.wrapper,a.display.scrollbars.addClass));a.display.scrollbars=new of[a.options.scrollbarStyle](function(b){a.display.wrapper.insertBefore(b,a.display.scrollbarFiller);z(b,"mousedown",function(){a.state.focused&&setTimeout(function(){return a.display.input.focus()},0)});b.setAttribute("cm-not-content","true")},function(b,d){"horizontal"==d?ib(a,b):Vb(a,b)},a);a.display.scrollbars.addClass&&Wa(a.display.wrapper,a.display.scrollbars.addClass)}
function jb(a){a.curOp={cm:a,viewChanged:!1,startHeight:a.doc.height,forceUpdate:!1,updateInput:0,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++Tg};a=a.curOp;rb?rb.ops.push(a):a.ownsGroup=rb={ops:[a],delayedCallbacks:[]}}function kb(a){(a=a.curOp)&&Mg(a,function(b){for(var d=0;d<b.ops.length;d++)b.ops[d].cm.curOp=null;b=b.ops;for(d=0;d<b.length;d++){var c=b[d],e=c.cm,f=
e.display,g=e.display;!g.scrollbarsClipped&&g.scroller.offsetWidth&&(g.nativeBarWidth=g.scroller.offsetWidth-g.scroller.clientWidth,g.heightForcer.style.height=Ha(e)+"px",g.sizer.style.marginBottom=-g.nativeBarWidth+"px",g.sizer.style.borderRightWidth=Ha(e)+"px",g.scrollbarsClipped=!0);c.updateMaxLine&&xd(e);c.mustUpdate=c.viewChanged||c.forceUpdate||null!=c.scrollTop||c.scrollToPos&&(c.scrollToPos.from.line<f.viewFrom||c.scrollToPos.to.line>=f.viewTo)||f.maxLineChanged&&e.options.lineWrapping;c.update=
c.mustUpdate&&new Oc(e,c.mustUpdate&&{top:c.scrollTop,ensure:c.scrollToPos},c.forceUpdate)}for(d=0;d<b.length;d++)c=b[d],c.updatedDisplay=c.mustUpdate&&Rd(c.cm,c.update);for(d=0;d<b.length;d++)if(c=b[d],e=c.cm,f=e.display,c.updatedDisplay&&Kc(e),c.barMeasure=Xb(e),f.maxLineChanged&&!e.options.lineWrapping&&(g=f.maxLine.text.length,g=za(e,cb(e,f.maxLine),g,void 0),c.adjustWidthTo=g.left+3,e.display.sizerWidth=c.adjustWidthTo,c.barMeasure.scrollWidth=Math.max(f.scroller.clientWidth,f.sizer.offsetLeft+
c.adjustWidthTo+Ha(e)+e.display.barWidth),c.maxScrollLeft=Math.max(0,f.sizer.offsetLeft+c.adjustWidthTo-ab(e))),c.updatedDisplay||c.selectionChanged)c.preparedSelection=f.input.prepareSelection();for(d=0;d<b.length;d++)c=b[d],e=c.cm,null!=c.adjustWidthTo&&(e.display.sizer.style.minWidth=c.adjustWidthTo+"px",c.maxScrollLeft<e.doc.scrollLeft&&ib(e,Math.min(e.display.scroller.scrollLeft,c.maxScrollLeft),!0),e.display.maxLineChanged=!1),f=c.focus&&c.focus==va(),c.preparedSelection&&e.display.input.showSelection(c.preparedSelection,
f),(c.updatedDisplay||c.startHeight!=e.doc.height)&&wb(e,c.barMeasure),c.updatedDisplay&&Sd(e,c.barMeasure),c.selectionChanged&&Nd(e),e.state.focused&&c.updateInput&&e.display.input.reset(c.typing),f&&ff(c.cm);for(d=0;d<b.length;d++){var h=void 0;c=b[d];e=c.cm;f=e.display;g=e.doc;c.updatedDisplay&&pf(e,c.update);null==f.wheelStartX||null==c.scrollTop&&null==c.scrollLeft&&!c.scrollToPos||(f.wheelStartX=f.wheelStartY=null);null!=c.scrollTop&&kf(e,c.scrollTop,c.forceScroll);null!=c.scrollLeft&&ib(e,
c.scrollLeft,!0,!0);if(c.scrollToPos){var k=C(g,c.scrollToPos.from);var l=C(g,c.scrollToPos.to);var m=c.scrollToPos.margin;null==m&&(m=0);e.options.lineWrapping||k!=l||(k=k.ch?t(k.line,"before"==k.sticky?k.ch-1:k.ch,"after"):k,l="before"==k.sticky?t(k.line,k.ch+1,"before"):k);for(var q=0;5>q;q++){var n=!1;h=Aa(e,k);var p=l&&l!=k?Aa(e,l):h;h={left:Math.min(h.left,p.left),top:Math.min(h.top,p.top)-m,right:Math.max(h.left,p.left),bottom:Math.max(h.bottom,p.bottom)+m};p=Pd(e,h);var r=e.doc.scrollTop,
u=e.doc.scrollLeft;null!=p.scrollTop&&(Vb(e,p.scrollTop),1<Math.abs(e.doc.scrollTop-r)&&(n=!0));null!=p.scrollLeft&&(ib(e,p.scrollLeft),1<Math.abs(e.doc.scrollLeft-u)&&(n=!0));if(!n)break}l=h;Z(e,"scrollCursorIntoView")||(m=e.display,q=m.sizer.getBoundingClientRect(),k=null,0>l.top+q.top?k=!0:l.bottom+q.top>(window.innerHeight||document.documentElement.clientHeight)&&(k=!1),null==k||Ug||(l=v("div","\u200b",null,"position: absolute;\n                         top: "+(l.top-m.viewOffset-e.display.lineSpace.offsetTop)+
"px;\n                         height: "+(l.bottom-l.top+Ha(e)+m.barHeight)+"px;\n                         left: "+l.left+"px; width: "+Math.max(2,l.right-l.left)+"px;"),e.display.lineSpace.appendChild(l),l.scrollIntoView(k),e.display.lineSpace.removeChild(l)))}l=c.maybeHiddenMarkers;k=c.maybeUnhiddenMarkers;if(l)for(m=0;m<l.length;++m)l[m].lines.length||X(l[m],"hide");if(k)for(l=0;l<k.length;++l)k[l].lines.length&&X(k[l],"unhide");f.wrapper.offsetHeight&&(g.scrollTop=e.display.scroller.scrollTop);
c.changeObjs&&X(e,"changes",e,c.changeObjs);c.update&&c.update.finish()}})}function pa(a,b){if(a.curOp)return b();jb(a);try{return b()}finally{kb(a)}}function aa(a,b){return function(){if(a.curOp)return b.apply(a,arguments);jb(a);try{return b.apply(a,arguments)}finally{kb(a)}}}function ia(a){return function(){if(this.curOp)return a.apply(this,arguments);jb(this);try{return a.apply(this,arguments)}finally{kb(this)}}}function ba(a){return function(){var b=this.cm;if(!b||b.curOp)return a.apply(this,
arguments);jb(b);try{return a.apply(this,arguments)}finally{kb(b)}}}function Wb(a,b){a.doc.highlightFrontier<a.display.viewTo&&a.state.highlight.set(b,dd(Vg,a))}function Vg(a){var b=a.doc;if(!(b.highlightFrontier>=a.display.viewTo)){var d=+new Date+a.options.workTime,c=Mb(a,b.highlightFrontier),e=[];b.iter(c.line,Math.min(b.first+b.size,a.display.viewTo+500),function(f){if(c.line>=a.display.viewFrom){var g=f.styles,h=f.text.length>a.options.maxHighlightLength?Ya(b.mode,c.state):null,k=ve(a,f,c,!0);
h&&(c.state=h);f.styles=k.styles;h=f.styleClasses;(k=k.classes)?f.styleClasses=k:h&&(f.styleClasses=null);k=!g||g.length!=f.styles.length||h!=k&&(!h||!k||h.bgClass!=k.bgClass||h.textClass!=k.textClass);for(h=0;!k&&h<g.length;++h)k=g[h]!=f.styles[h];k&&e.push(c.line);f.stateAfter=c.save()}else f.text.length<=a.options.maxHighlightLength&&rd(a,f.text,c),f.stateAfter=0==c.line%5?c.save():null;c.nextLine();if(+new Date>d)return Wb(a,a.options.workDelay),!0});b.highlightFrontier=c.line;b.modeFrontier=
Math.max(b.modeFrontier,c.line);e.length&&pa(a,function(){for(var f=0;f<e.length;f++)Qa(a,e[f],"text")})}}function Rd(a,b){var d=a.display,c=a.doc;if(b.editorIsHidden)return Pa(a),!1;if(!b.force&&b.visible.from>=d.viewFrom&&b.visible.to<=d.viewTo&&(null==d.updateLineNumbers||d.updateLineNumbers>=d.viewTo)&&d.renderedView==d.view&&0==cf(a))return!1;qf(a)&&(Pa(a),b.dims=Dd(a));var e=c.first+c.size,f=Math.max(b.visible.from-a.options.viewportMargin,c.first),g=Math.min(e,b.visible.to+a.options.viewportMargin);
d.viewFrom<f&&20>f-d.viewFrom&&(f=Math.max(c.first,d.viewFrom));d.viewTo>g&&20>d.viewTo-g&&(g=Math.min(e,d.viewTo));Ka&&(f=vd(a.doc,f),g=Ge(a.doc,g));c=f!=d.viewFrom||g!=d.viewTo||d.lastWrapHeight!=b.wrapperHeight||d.lastWrapWidth!=b.wrapperWidth;e=a.display;0==e.view.length||f>=e.viewTo||g<=e.viewFrom?(e.view=Ec(a,f,g),e.viewFrom=f):(e.viewFrom>f?e.view=Ec(a,f,e.viewFrom).concat(e.view):e.viewFrom<f&&(e.view=e.view.slice(bb(a,f))),e.viewFrom=f,e.viewTo<g?e.view=e.view.concat(Ec(a,e.viewTo,g)):e.viewTo>
g&&(e.view=e.view.slice(0,bb(a,g))));e.viewTo=g;d.viewOffset=Ga(w(a.doc,d.viewFrom));a.display.mover.style.top=d.viewOffset+"px";g=cf(a);if(!c&&0==g&&!b.force&&d.renderedView==d.view&&(null==d.updateLineNumbers||d.updateLineNumbers>=d.viewTo))return!1;a.hasFocus()?f=null:(f=va())&&ka(a.display.lineDiv,f)?(f={activeElt:f},window.getSelection&&(e=window.getSelection(),e.anchorNode&&e.extend&&ka(a.display.lineDiv,e.anchorNode)&&(f.anchorNode=e.anchorNode,f.anchorOffset=e.anchorOffset,f.focusNode=e.focusNode,
f.focusOffset=e.focusOffset))):f=null;4<g&&(d.lineDiv.style.display="none");Wg(a,d.updateLineNumbers,b.dims);4<g&&(d.lineDiv.style.display="");d.renderedView=d.view;(g=f)&&g.activeElt&&g.activeElt!=va()&&(g.activeElt.focus(),!/^(INPUT|TEXTAREA)$/.test(g.activeElt.nodeName)&&g.anchorNode&&ka(document.body,g.anchorNode)&&ka(document.body,g.focusNode)&&(f=window.getSelection(),e=document.createRange(),e.setEnd(g.anchorNode,g.anchorOffset),e.collapse(!1),f.removeAllRanges(),f.addRange(e),f.extend(g.focusNode,
g.focusOffset)));E(d.cursorDiv);E(d.selectionDiv);d.gutters.style.height=d.sizer.style.minHeight=0;c&&(d.lastWrapHeight=b.wrapperHeight,d.lastWrapWidth=b.wrapperWidth,Wb(a,400));d.updateLineNumbers=null;return!0}function pf(a,b){for(var d=b.viewport,c=!0;;c=!1){if(c&&a.options.lineWrapping&&b.oldDisplayWidth!=ab(a))c&&(b.visible=Lc(a.display,a.doc,d));else if(d&&null!=d.top&&(d={top:Math.min(a.doc.height+Ad(a.display)-Bd(a),d.top)}),b.visible=Lc(a.display,a.doc,d),b.visible.from>=a.display.viewFrom&&
b.visible.to<=a.display.viewTo)break;if(!Rd(a,b))break;Kc(a);c=Xb(a);Tb(a);wb(a,c);Sd(a,c);b.force=!1}b.signal(a,"update",a);if(a.display.viewFrom!=a.display.reportedViewFrom||a.display.viewTo!=a.display.reportedViewTo)b.signal(a,"viewportChange",a,a.display.viewFrom,a.display.viewTo),a.display.reportedViewFrom=a.display.viewFrom,a.display.reportedViewTo=a.display.viewTo}function Qd(a,b){b=new Oc(a,b);if(Rd(a,b)){Kc(a);pf(a,b);var d=Xb(a);Tb(a);wb(a,d);Sd(a,d);b.finish()}}function Wg(a,b,d){function c(n){var p=
n.nextSibling;fa&&ya&&a.display.currentWheelTarget==n?n.style.display="none":n.parentNode.removeChild(n);return p}var e=a.display,f=a.options.lineNumbers,g=e.lineDiv,h=g.firstChild,k=e.view;e=e.viewFrom;for(var l=0;l<k.length;l++){var m=k[l];if(!m.hidden)if(m.node&&m.node.parentNode==g){for(;h!=m.node;)h=c(h);h=f&&null!=b&&b<=e&&m.lineNumber;m.changes&&(-1<ea(m.changes,"gutter")&&(h=!1),Le(a,m,e,d));h&&(E(m.lineNumber),m.lineNumber.appendChild(document.createTextNode(od(a.options,e))));h=m.node.nextSibling}else{var q=
Og(a,m,e,d);g.insertBefore(q,h)}e+=m.size}for(;h;)h=c(h)}function Td(a){a.sizer.style.marginLeft=a.gutters.offsetWidth+"px"}function Sd(a,b){a.display.sizer.style.minHeight=b.docHeight+"px";a.display.heightForcer.style.top=b.docHeight+"px";a.display.gutters.style.height=b.docHeight+a.display.barHeight+Ha(a)+"px"}function lf(a){var b=a.display,d=b.view;if(b.alignWidgets||b.gutters.firstChild&&a.options.fixedGutter){for(var c=Kd(b)-b.scroller.scrollLeft+a.doc.scrollLeft,e=b.gutters.offsetWidth,f=c+
"px",g=0;g<d.length;g++)if(!d[g].hidden){a.options.fixedGutter&&(d[g].gutter&&(d[g].gutter.style.left=f),d[g].gutterBackground&&(d[g].gutterBackground.style.left=f));var h=d[g].alignable;if(h)for(var k=0;k<h.length;k++)h[k].style.left=f}a.options.fixedGutter&&(b.gutters.style.left=c+e+"px")}}function qf(a){if(!a.options.lineNumbers)return!1;var b=a.doc;b=od(a.options,b.first+b.size-1);var d=a.display;if(b.length!=d.lineNumChars){var c=d.measure.appendChild(v("div",[v("div",b)],"CodeMirror-linenumber CodeMirror-gutter-elt")),
e=c.firstChild.offsetWidth;c=c.offsetWidth-e;d.lineGutter.style.width="";d.lineNumInnerWidth=Math.max(e,d.lineGutter.offsetWidth-c)+1;d.lineNumWidth=d.lineNumInnerWidth+c;d.lineNumChars=d.lineNumInnerWidth?b.length:-1;d.lineGutter.style.width=d.lineNumWidth+"px";Td(a.display);return!0}return!1}function Ud(a,b){for(var d=[],c=!1,e=0;e<a.length;e++){var f=a[e],g=null;"string"!=typeof f&&(g=f.style,f=f.className);if("CodeMirror-linenumbers"==f)if(b)c=!0;else continue;d.push({className:f,style:g})}b&&
!c&&d.push({className:"CodeMirror-linenumbers",style:null});return d}function rf(a){var b=a.gutters,d=a.gutterSpecs;E(b);a.lineGutter=null;for(var c=0;c<d.length;++c){var e=d[c],f=e.className;e=e.style;var g=b.appendChild(v("div",null,"CodeMirror-gutter "+f));e&&(g.style.cssText=e);"CodeMirror-linenumbers"==f&&(a.lineGutter=g,g.style.width=(a.lineNumWidth||1)+"px")}b.style.display=d.length?"":"none";Td(a)}function Yb(a){rf(a.display);ma(a);lf(a)}function Xg(a,b,d,c){this.input=d;this.scrollbarFiller=
v("div",null,"CodeMirror-scrollbar-filler");this.scrollbarFiller.setAttribute("cm-not-content","true");this.gutterFiller=v("div",null,"CodeMirror-gutter-filler");this.gutterFiller.setAttribute("cm-not-content","true");this.lineDiv=K("div",null,"CodeMirror-code");this.selectionDiv=v("div",null,null,"position: relative; z-index: 1");this.cursorDiv=v("div",null,"CodeMirror-cursors");this.measure=v("div",null,"CodeMirror-measure");this.lineMeasure=v("div",null,"CodeMirror-measure");this.lineSpace=K("div",
[this.measure,this.lineMeasure,this.selectionDiv,this.cursorDiv,this.lineDiv],null,"position: relative; outline: none");var e=K("div",[this.lineSpace],"CodeMirror-lines");this.mover=v("div",[e],null,"position: relative");this.sizer=v("div",[this.mover],"CodeMirror-sizer");this.sizerWidth=null;this.heightForcer=v("div",null,null,"position: absolute; height: 50px; width: 1px;");this.gutters=v("div",null,"CodeMirror-gutters");this.lineGutter=null;this.scroller=v("div",[this.sizer,this.heightForcer,this.gutters],
"CodeMirror-scroll");this.scroller.setAttribute("tabIndex","-1");this.wrapper=v("div",[this.scrollbarFiller,this.gutterFiller,this.scroller],"CodeMirror");G&&8>U&&(this.gutters.style.zIndex=-1,this.scroller.style.paddingRight=0);fa||Ma&&Zb||(this.scroller.draggable=!0);a&&(a.appendChild?a.appendChild(this.wrapper):a(this.wrapper));this.reportedViewFrom=this.reportedViewTo=this.viewFrom=this.viewTo=b.first;this.view=[];this.externalMeasured=this.renderedView=null;this.lastWrapHeight=this.lastWrapWidth=
this.viewOffset=0;this.updateLineNumbers=null;this.nativeBarWidth=this.barHeight=this.barWidth=0;this.scrollbarsClipped=!1;this.lineNumWidth=this.lineNumInnerWidth=this.lineNumChars=null;this.alignWidgets=!1;this.maxLine=this.cachedCharWidth=this.cachedTextHeight=this.cachedPaddingH=null;this.maxLineLength=0;this.maxLineChanged=!1;this.wheelDX=this.wheelDY=this.wheelStartX=this.wheelStartY=null;this.shift=!1;this.activeTouch=this.selForContextMenu=null;this.gutterSpecs=Ud(c.gutters,c.lineNumbers);
rf(this);d.init(this)}function sf(a){var b=a.wheelDeltaX,d=a.wheelDeltaY;null==b&&a.detail&&a.axis==a.HORIZONTAL_AXIS&&(b=a.detail);null==d&&a.detail&&a.axis==a.VERTICAL_AXIS?d=a.detail:null==d&&(d=a.wheelDelta);return{x:b,y:d}}function Yg(a){a=sf(a);a.x*=ta;a.y*=ta;return a}function tf(a,b){var d=sf(b),c=d.x;d=d.y;var e=a.display,f=e.scroller,g=f.scrollWidth>f.clientWidth,h=f.scrollHeight>f.clientHeight;if(c&&g||d&&h){if(d&&ya&&fa){g=b.target;var k=e.view;a:for(;g!=f;g=g.parentNode)for(var l=0;l<
k.length;l++)if(k[l].node==g){a.display.currentWheelTarget=g;break a}}!c||Ma||Ba||null==ta?(d&&null!=ta&&(b=d*ta,h=a.doc.scrollTop,g=h+e.wrapper.clientHeight,0>b?h=Math.max(0,h+b-50):g=Math.min(a.doc.height,g+b+50),Qd(a,{top:h,bottom:g})),20>Pc&&(null==e.wheelStartX?(e.wheelStartX=f.scrollLeft,e.wheelStartY=f.scrollTop,e.wheelDX=c,e.wheelDY=d,setTimeout(function(){if(null!=e.wheelStartX){var m=f.scrollLeft-e.wheelStartX,q=f.scrollTop-e.wheelStartY;m=q&&e.wheelDY&&q/e.wheelDY||m&&e.wheelDX&&m/e.wheelDX;
e.wheelStartX=e.wheelStartY=null;m&&(ta=(ta*Pc+m)/(Pc+1),++Pc)}},200)):(e.wheelDX+=c,e.wheelDY+=d))):(d&&h&&Vb(a,Math.max(0,f.scrollTop+d*ta)),ib(a,Math.max(0,f.scrollLeft+c*ta)),(!d||d&&h)&&la(b),e.wheelStartX=null)}}function Ca(a,b,d){a=a&&a.options.selectionsMayTouch;d=b[d];b.sort(function(k,l){return B(k.from(),l.from())});d=ea(b,d);for(var c=1;c<b.length;c++){var e=b[c],f=b[c-1],g=B(f.to(),e.from());if(a&&!e.empty()?0<g:0<=g){g=Ac(f.from(),e.from());var h=zc(f.to(),e.to());e=f.empty()?e.from()==
e.head:f.from()==f.head;c<=d&&--d;b.splice(--c,2,new J(e?h:g,e?g:h))}}return new ua(b,d)}function Na(a,b){return new ua([new J(a,b||a)],0)}function Ra(a){return a.text?t(a.from.line+a.text.length-1,L(a.text).length+(1==a.text.length?a.from.ch:0)):a.to}function uf(a,b){if(0>B(a,b.from))return a;if(0>=B(a,b.to))return Ra(b);var d=a.line+b.text.length-(b.to.line-b.from.line)-1,c=a.ch;a.line==b.to.line&&(c+=Ra(b).ch-b.to.ch);return t(d,c)}function Vd(a,b){for(var d=[],c=0;c<a.sel.ranges.length;c++){var e=
a.sel.ranges[c];d.push(new J(uf(e.anchor,b),uf(e.head,b)))}return Ca(a.cm,d,a.sel.primIndex)}function vf(a,b,d){return a.line==b.line?t(d.line,a.ch-b.ch+d.ch):t(d.line+(a.line-b.line),a.ch)}function Wd(a){a.doc.mode=ld(a.options,a.doc.modeOption);$b(a)}function $b(a){a.doc.iter(function(b){b.stateAfter&&(b.stateAfter=null);b.styles&&(b.styles=null)});a.doc.modeFrontier=a.doc.highlightFrontier=a.doc.first;Wb(a,100);a.state.modeGen++;a.curOp&&ma(a)}function wf(a,b){return 0==b.from.ch&&0==b.to.ch&&
""==L(b.text)&&(!a.cm||a.cm.options.wholeLineUpdateBefore)}function Xd(a,b,d,c){function e(r,u,A){r.text=u;r.stateAfter&&(r.stateAfter=null);r.styles&&(r.styles=null);null!=r.order&&(r.order=null);De(r);Ee(r,A);u=c?c(r):1;u!=r.height&&Da(r,u);ca(r,"change",r,b)}function f(r,u){for(var A=[];r<u;++r)A.push(new xb(k[r],d?d[r]:null,c));return A}var g=b.from,h=b.to,k=b.text,l=w(a,g.line),m=w(a,h.line),q=L(k),n=d?d[k.length-1]:null,p=h.line-g.line;b.full?(a.insert(0,f(0,k.length)),a.remove(k.length,a.size-
k.length)):wf(a,b)?(h=f(0,k.length-1),e(m,m.text,n),p&&a.remove(g.line,p),h.length&&a.insert(g.line,h)):l==m?1==k.length?e(l,l.text.slice(0,g.ch)+q+l.text.slice(h.ch),n):(p=f(1,k.length-1),p.push(new xb(q+l.text.slice(h.ch),n,c)),e(l,l.text.slice(0,g.ch)+k[0],d?d[0]:null),a.insert(g.line+1,p)):1==k.length?(e(l,l.text.slice(0,g.ch)+k[0]+m.text.slice(h.ch),d?d[0]:null),a.remove(g.line+1,p)):(e(l,l.text.slice(0,g.ch)+k[0],d?d[0]:null),e(m,q+m.text.slice(h.ch),n),n=f(1,k.length-1),1<p&&a.remove(g.line+
1,p-1),a.insert(g.line+1,n));ca(a,"change",a,b)}function Sa(a,b,d){function c(e,f,g){if(e.linked)for(var h=0;h<e.linked.length;++h){var k=e.linked[h];if(k.doc!=f){var l=g&&k.sharedHist;if(!d||l)b(k.doc,l),c(k.doc,e,l)}}}c(a,null,!0)}function xf(a,b){if(b.cm)throw Error("This document is already in use.");a.doc=b;b.cm=a;Ld(a);Wd(a);yf(a);a.options.lineWrapping||xd(a);a.options.mode=b.modeOption;ma(a)}function yf(a){("rtl"==a.doc.direction?Wa:hb)(a.display.lineDiv,"CodeMirror-rtl")}function Zg(a){pa(a,
function(){yf(a);ma(a)})}function Qc(a){this.done=[];this.undone=[];this.undoDepth=Infinity;this.lastModTime=this.lastSelTime=0;this.lastOrigin=this.lastSelOrigin=this.lastOp=this.lastSelOp=null;this.generation=this.maxGeneration=a||1}function Yd(a,b){var d={from:qd(b.from),to:Ra(b),text:Za(a,b.from,b.to)};zf(a,d,b.from.line,b.to.line+1);Sa(a,function(c){return zf(c,d,b.from.line,b.to.line+1)},!0);return d}function Af(a){for(;a.length;)if(L(a).ranges)a.pop();else break}function Bf(a,b,d,c){var e=
a.history;e.undone.length=0;var f=+new Date,g;if(g=e.lastOp==c||e.lastOrigin==b.origin&&b.origin&&("+"==b.origin.charAt(0)&&e.lastModTime>f-(a.cm?a.cm.options.historyEventDelay:500)||"*"==b.origin.charAt(0))){if(e.lastOp==c){Af(e.done);var h=L(e.done)}else e.done.length&&!L(e.done).ranges?h=L(e.done):1<e.done.length&&!e.done[e.done.length-2].ranges?(e.done.pop(),h=L(e.done)):h=void 0;g=h}if(g){var k=L(h.changes);0==B(b.from,b.to)&&0==B(b.from,k.to)?k.to=Ra(b):h.changes.push(Yd(a,b))}else for((h=L(e.done))&&
h.ranges||Rc(a.sel,e.done),h={changes:[Yd(a,b)],generation:e.generation},e.done.push(h);e.done.length>e.undoDepth;)e.done.shift(),e.done[0].ranges||e.done.shift();e.done.push(d);e.generation=++e.maxGeneration;e.lastModTime=e.lastSelTime=f;e.lastOp=e.lastSelOp=c;e.lastOrigin=e.lastSelOrigin=b.origin;k||X(a,"historyAdded")}function Rc(a,b){var d=L(b);d&&d.ranges&&d.equals(a)||b.push(a)}function zf(a,b,d,c){var e=b["spans_"+a.id],f=0;a.iter(Math.max(a.first,d),Math.min(a.first+a.size,c),function(g){g.markedSpans&&
((e||(e=b["spans_"+a.id]={}))[f]=g.markedSpans);++f})}function $g(a){if(!a)return null;for(var b,d=0;d<a.length;++d)a[d].marker.explicitlyCleared?b||(b=a.slice(0,d)):b&&b.push(a[d]);return b?b.length?b:null:a}function Cf(a,b){var d;if(d=b["spans_"+a.id]){for(var c=[],e=0;e<b.text.length;++e)c.push($g(d[e]));d=c}else d=null;a=td(a,b);if(!d)return a;if(!a)return d;for(b=0;b<d.length;++b)if(c=d[b],e=a[b],c&&e){var f=0;a:for(;f<e.length;++f){for(var g=e[f],h=0;h<c.length;++h)if(c[h].marker==g.marker)continue a;
c.push(g)}}else e&&(d[b]=e);return d}function yb(a,b,d){for(var c=[],e=0;e<a.length;++e){var f=a[e];if(f.ranges)c.push(d?ua.prototype.deepCopy.call(f):f);else{f=f.changes;var g=[];c.push({changes:g});for(var h=0;h<f.length;++h){var k=f[h],l;g.push({from:k.from,to:k.to,text:k.text});if(b)for(var m in k)(l=m.match(/^spans_(\d+)$/))&&-1<ea(b,Number(l[1]))&&(L(g)[m]=k[m],delete k[m])}}}return c}function Zd(a,b,d,c){return c?(a=a.anchor,d&&(c=0>B(b,a),c!=0>B(d,a)?(a=b,b=d):c!=0>B(b,d)&&(b=d)),new J(a,
b)):new J(d||b,b)}function Sc(a,b,d,c,e){null==e&&(e=a.cm&&(a.cm.display.shift||a.extend));da(a,new ua([Zd(a.sel.primary(),b,d,e)],0),c)}function Df(a,b,d){for(var c=[],e=a.cm&&(a.cm.display.shift||a.extend),f=0;f<a.sel.ranges.length;f++)c[f]=Zd(a.sel.ranges[f],b[f],null,e);b=Ca(a.cm,c,a.sel.primIndex);da(a,b,d)}function $d(a,b,d,c){var e=a.sel.ranges.slice(0);e[b]=d;da(a,Ca(a.cm,e,a.sel.primIndex),c)}function ah(a,b,d){d={ranges:b.ranges,update:function(c){this.ranges=[];for(var e=0;e<c.length;e++)this.ranges[e]=
new J(C(a,c[e].anchor),C(a,c[e].head))},origin:d&&d.origin};X(a,"beforeSelectionChange",a,d);a.cm&&X(a.cm,"beforeSelectionChange",a.cm,d);return d.ranges!=b.ranges?Ca(a.cm,d.ranges,d.ranges.length-1):b}function Ef(a,b,d){var c=a.history.done,e=L(c);e&&e.ranges?(c[c.length-1]=b,Tc(a,b,d)):da(a,b,d)}function da(a,b,d){Tc(a,b,d);b=a.sel;var c=a.cm?a.cm.curOp.id:NaN,e=a.history,f=d&&d.origin,g;if(!(g=c==e.lastSelOp)&&(g=f&&e.lastSelOrigin==f)&&!(g=e.lastModTime==e.lastSelTime&&e.lastOrigin==f)){g=L(e.done);
var h=f.charAt(0);g="*"==h||"+"==h&&g.ranges.length==b.ranges.length&&g.somethingSelected()==b.somethingSelected()&&new Date-a.history.lastSelTime<=(a.cm?a.cm.options.historyEventDelay:500)}g?e.done[e.done.length-1]=b:Rc(b,e.done);e.lastSelTime=+new Date;e.lastSelOrigin=f;e.lastSelOp=c;d&&!1!==d.clearRedo&&Af(e.undone)}function Tc(a,b,d){if(xa(a,"beforeSelectionChange")||a.cm&&xa(a.cm,"beforeSelectionChange"))b=ah(a,b,d);var c=d&&d.bias||(0>B(b.primary().head,a.sel.primary().head)?-1:1);Ff(a,Gf(a,
b,c,!0));d&&!1===d.scroll||!a.cm||vb(a.cm)}function Ff(a,b){b.equals(a.sel)||(a.sel=b,a.cm&&(a.cm.curOp.updateInput=1,a.cm.curOp.selectionChanged=!0,qe(a.cm)),ca(a,"cursorActivity",a))}function Hf(a){Ff(a,Gf(a,a.sel,null,!1))}function Gf(a,b,d,c){for(var e,f=0;f<b.ranges.length;f++){var g=b.ranges[f],h=b.ranges.length==a.sel.ranges.length&&a.sel.ranges[f],k=Uc(a,g.anchor,h&&h.anchor,d,c);h=Uc(a,g.head,h&&h.head,d,c);if(e||k!=g.anchor||h!=g.head)e||(e=b.ranges.slice(0,f)),e[f]=new J(k,h)}return e?
Ca(a.cm,e,b.primIndex):b}function zb(a,b,d,c,e){var f=w(a,b.line);if(f.markedSpans)for(var g=0;g<f.markedSpans.length;++g){var h=f.markedSpans[g],k=h.marker,l="selectLeft"in k?!k.selectLeft:k.inclusiveLeft,m="selectRight"in k?!k.selectRight:k.inclusiveRight;if((null==h.from||(l?h.from<=b.ch:h.from<b.ch))&&(null==h.to||(m?h.to>=b.ch:h.to>b.ch))){if(e&&(X(k,"beforeCursorEnter"),k.explicitlyCleared))if(f.markedSpans){--g;continue}else break;if(k.atomic){if(d){g=k.find(0>c?1:-1);h=void 0;if(0>c?m:l)g=
If(a,g,-c,g&&g.line==b.line?f:null);if(g&&g.line==b.line&&(h=B(g,d))&&(0>c?0>h:0<h))return zb(a,g,b,c,e)}d=k.find(0>c?-1:1);if(0>c?l:m)d=If(a,d,c,d.line==b.line?f:null);return d?zb(a,d,b,c,e):null}}}return b}function Uc(a,b,d,c,e){c=c||1;b=zb(a,b,d,c,e)||!e&&zb(a,b,d,c,!0)||zb(a,b,d,-c,e)||!e&&zb(a,b,d,-c,!0);return b?b:(a.cantEdit=!0,t(a.first,0))}function If(a,b,d,c){return 0>d&&0==b.ch?b.line>a.first?C(a,t(b.line-1)):null:0<d&&b.ch==(c||w(a,b.line)).text.length?b.line<a.first+a.size-1?t(b.line+
1,0):null:new t(b.line,b.ch+d)}function Jf(a){a.setSelection(t(a.firstLine(),0),t(a.lastLine()),Ia)}function Kf(a,b,d){var c={canceled:!1,from:b.from,to:b.to,text:b.text,origin:b.origin,cancel:function(){return c.canceled=!0}};d&&(c.update=function(e,f,g,h){e&&(c.from=C(a,e));f&&(c.to=C(a,f));g&&(c.text=g);void 0!==h&&(c.origin=h)});X(a,"beforeChange",a,c);a.cm&&X(a.cm,"beforeChange",a.cm,c);return c.canceled?(a.cm&&(a.cm.curOp.updateInput=2),null):{from:c.from,to:c.to,text:c.text,origin:c.origin}}
function Ab(a,b,d){if(a.cm){if(!a.cm.curOp)return aa(a.cm,Ab)(a,b,d);if(a.cm.state.suppressEdits)return}if(xa(a,"beforeChange")||a.cm&&xa(a.cm,"beforeChange"))if(b=Kf(a,b,!0),!b)return;if(d=Lf&&!d&&Gg(a,b.from,b.to))for(var c=d.length-1;0<=c;--c)Mf(a,{from:d[c].from,to:d[c].to,text:c?[""]:b.text,origin:b.origin});else Mf(a,b)}function Mf(a,b){if(1!=b.text.length||""!=b.text[0]||0!=B(b.from,b.to)){var d=Vd(a,b);Bf(a,b,d,a.cm?a.cm.curOp.id:NaN);ac(a,b,d,td(a,b));var c=[];Sa(a,function(e,f){f||-1!=ea(c,
e.history)||(Nf(e.history,b),c.push(e.history));ac(e,b,null,td(e,b))})}}function Vc(a,b,d){var c=a.cm&&a.cm.state.suppressEdits;if(!c||d){for(var e=a.history,f,g=a.sel,h="undo"==b?e.done:e.undone,k="undo"==b?e.undone:e.done,l=0;l<h.length&&(f=h[l],d?!f.ranges||f.equals(a.sel):f.ranges);l++);if(l!=h.length){for(e.lastOrigin=e.lastSelOrigin=null;;)if(f=h.pop(),f.ranges){Rc(f,k);if(d&&!f.equals(a.sel)){da(a,f,{clearRedo:!1});return}g=f}else{if(c){h.push(f);return}break}var m=[];Rc(g,k);k.push({changes:m,
generation:e.generation});e.generation=f.generation||++e.maxGeneration;var q=xa(a,"beforeChange")||a.cm&&xa(a.cm,"beforeChange");d=function(n){var p=f.changes[n];p.origin=b;if(q&&!Kf(a,p,!1))return h.length=0,{};m.push(Yd(a,p));var r=n?Vd(a,p):L(h);ac(a,p,r,Cf(a,p));!n&&a.cm&&a.cm.scrollIntoView({from:p.from,to:Ra(p)});var u=[];Sa(a,function(A,H){H||-1!=ea(u,A.history)||(Nf(A.history,p),u.push(A.history));ac(A,p,null,Cf(A,p))})};for(c=f.changes.length-1;0<=c;--c)if(e=d(c))return e.v}}}function Of(a,
b){if(0!=b&&(a.first+=b,a.sel=new ua(vc(a.sel.ranges,function(e){return new J(t(e.anchor.line+b,e.anchor.ch),t(e.head.line+b,e.head.ch))}),a.sel.primIndex),a.cm)){ma(a.cm,a.first,a.first-b,b);for(var d=a.cm.display,c=d.viewFrom;c<d.viewTo;c++)Qa(a.cm,c,"gutter")}}function ac(a,b,d,c){if(a.cm&&!a.cm.curOp)return aa(a.cm,ac)(a,b,d,c);if(b.to.line<a.first)Of(a,b.text.length-1-(b.to.line-b.from.line));else if(!(b.from.line>a.lastLine())){if(b.from.line<a.first){var e=b.text.length-1-(a.first-b.from.line);
Of(a,e);b={from:t(a.first,0),to:t(b.to.line+e,b.to.ch),text:[L(b.text)],origin:b.origin}}e=a.lastLine();b.to.line>e&&(b={from:b.from,to:t(e,w(a,e).text.length),text:[b.text[0]],origin:b.origin});b.removed=Za(a,b.from,b.to);d||(d=Vd(a,b));a.cm?bh(a.cm,b,c):Xd(a,b,c);Tc(a,d,Ia);a.cantEdit&&Uc(a,t(a.firstLine(),0))&&(a.cantEdit=!1)}}function bh(a,b,d){var c=a.doc,e=a.display,f=b.from,g=b.to,h=!1,k=f.line;a.options.lineWrapping||(k=O(Fa(w(c,f.line))),c.iter(k,g.line+1,function(l){if(l==e.maxLine)return h=
!0}));-1<c.sel.contains(b.from,b.to)&&qe(a);Xd(c,b,d,bf(a));a.options.lineWrapping||(c.iter(k,f.line+b.text.length,function(l){var m=Dc(l);m>e.maxLineLength&&(e.maxLine=l,e.maxLineLength=m,e.maxLineChanged=!0,h=!1)}),h&&(a.curOp.updateMaxLine=!0));Fg(c,f.line);Wb(a,400);d=b.text.length-(g.line-f.line)-1;b.full?ma(a):f.line!=g.line||1!=b.text.length||wf(a.doc,b)?ma(a,f.line,g.line+1,d):Qa(a,f.line,"text");d=xa(a,"changes");if((c=xa(a,"change"))||d)b={from:f,to:g,text:b.text,removed:b.removed,origin:b.origin},
c&&ca(a,"change",a,b),d&&(a.curOp.changeObjs||(a.curOp.changeObjs=[])).push(b);a.display.selForContextMenu=null}function Bb(a,b,d,c,e){c||(c=d);0>B(c,d)&&(c=[c,d],d=c[0],c=c[1]);"string"==typeof b&&(b=a.splitLines(b));Ab(a,{from:d,to:c,text:b,origin:e})}function Pf(a,b,d,c){d<a.line?a.line+=c:b<a.line&&(a.line=b,a.ch=0)}function Qf(a,b,d,c){for(var e=0;e<a.length;++e){var f=a[e],g=!0;if(f.ranges)for(f.copied||(f=a[e]=f.deepCopy(),f.copied=!0),g=0;g<f.ranges.length;g++)Pf(f.ranges[g].anchor,b,d,c),
Pf(f.ranges[g].head,b,d,c);else{for(var h=0;h<f.changes.length;++h){var k=f.changes[h];if(d<k.from.line)k.from=t(k.from.line+c,k.from.ch),k.to=t(k.to.line+c,k.to.ch);else if(b<=k.to.line){g=!1;break}}g||(a.splice(0,e+1),e=0)}}}function Nf(a,b){var d=b.from.line,c=b.to.line;b=b.text.length-(c-d)-1;Qf(a.done,d,c,b);Qf(a.undone,d,c,b)}function bc(a,b,d,c){var e=b,f=b;"number"==typeof b?f=w(a,Math.max(a.first,Math.min(b,a.first+a.size-1))):e=O(b);if(null==e)return null;c(f,e)&&a.cm&&Qa(a.cm,e,d);return f}
function cc(a){this.lines=a;this.parent=null;for(var b=0,d=0;d<a.length;++d)a[d].parent=this,b+=a[d].height;this.height=b}function dc(a){this.children=a;for(var b=0,d=0,c=0;c<a.length;++c){var e=a[c];b+=e.chunkSize();d+=e.height;e.parent=this}this.size=b;this.height=d;this.parent=null}function ch(a,b,d,c){var e=new ec(a,d,c),f=a.cm;f&&e.noHScroll&&(f.display.alignWidgets=!0);bc(a,b,"widget",function(g){var h=g.widgets||(g.widgets=[]);null==e.insertAt?h.push(e):h.splice(Math.min(h.length-1,Math.max(0,
e.insertAt)),0,e);e.line=g;f&&!Oa(a,g)&&(h=Ga(g)<a.scrollTop,Da(g,g.height+Rb(e)),h&&Mc(f,e.height),f.curOp.forceUpdate=!0);return!0});f&&ca(f,"lineWidgetAdded",f,e,"number"==typeof b?b:O(b));return e}function Cb(a,b,d,c,e){if(c&&c.shared)return dh(a,b,d,c,e);if(a.cm&&!a.cm.curOp)return aa(a.cm,Cb)(a,b,d,c,e);var f=new Ta(a,e);e=B(b,d);c&&Xa(c,f,!1);if(0<e||0==e&&!1!==f.clearWhenEmpty)return f;f.replacedWith&&(f.collapsed=!0,f.widgetNode=K("span",[f.replacedWith],"CodeMirror-widget"),c.handleMouseEvents||
f.widgetNode.setAttribute("cm-ignore-events","true"),c.insertLeft&&(f.widgetNode.insertLeft=!0));if(f.collapsed){if(Fe(a,b.line,b,d,f)||b.line!=d.line&&Fe(a,d.line,b,d,f))throw Error("Inserting collapsed marker partially overlapping an existing one");Ka=!0}f.addToHistory&&Bf(a,{from:b,to:d,origin:"markText"},a.sel,NaN);var g=b.line,h=a.cm,k;a.iter(g,d.line+1,function(l){h&&f.collapsed&&!h.options.lineWrapping&&Fa(l)==h.display.maxLine&&(k=!0);f.collapsed&&g!=b.line&&Da(l,0);var m=new Cc(f,g==b.line?
b.ch:null,g==d.line?d.ch:null);l.markedSpans=l.markedSpans?l.markedSpans.concat([m]):[m];m.marker.attachLine(l);++g});f.collapsed&&a.iter(b.line,d.line+1,function(l){Oa(a,l)&&Da(l,0)});f.clearOnEnter&&z(f,"beforeCursorEnter",function(){return f.clear()});f.readOnly&&(Lf=!0,(a.history.done.length||a.history.undone.length)&&a.clearHistory());f.collapsed&&(f.id=++Rf,f.atomic=!0);if(h){k&&(h.curOp.updateMaxLine=!0);if(f.collapsed)ma(h,b.line,d.line+1);else if(f.className||f.startStyle||f.endStyle||f.css||
f.attributes||f.title)for(c=b.line;c<=d.line;c++)Qa(h,c,"text");f.atomic&&Hf(h.doc);ca(h,"markerAdded",h,f)}return f}function dh(a,b,d,c,e){c=Xa(c);c.shared=!1;var f=[Cb(a,b,d,c,e)],g=f[0],h=c.widgetNode;Sa(a,function(k){h&&(c.widgetNode=h.cloneNode(!0));f.push(Cb(k,C(k,b),C(k,d),c,e));for(var l=0;l<k.linked.length;++l)if(k.linked[l].isParent)return;g=L(f)});return new fc(f,g)}function Sf(a){return a.findMarks(t(a.first,0),a.clipPos(t(a.lastLine())),function(b){return b.parent})}function eh(a){for(var b=
function(c){c=a[c];var e=[c.primary.doc];Sa(c.primary.doc,function(h){return e.push(h)});for(var f=0;f<c.markers.length;f++){var g=c.markers[f];-1==ea(e,g.doc)&&(g.parent=null,c.markers.splice(f--,1))}},d=0;d<a.length;d++)b(d)}function fh(a){var b=this;Tf(b);if(!Z(b,a)&&!La(b.display,a)){la(a);G&&(Uf=+new Date);var d=eb(b,a,!0),c=a.dataTransfer.files;if(d&&!b.isReadOnly())if(c&&c.length&&window.FileReader&&window.File)for(var e=c.length,f=Array(e),g=0,h=function(){++g==e&&aa(b,function(){d=C(b.doc,
d);var m={from:d,to:d,text:b.doc.splitLines(f.filter(function(q){return null!=q}).join(b.doc.lineSeparator())),origin:"paste"};Ab(b.doc,m);Ef(b.doc,Na(C(b.doc,d),C(b.doc,Ra(m))))})()},k=function(m,q){if(b.options.allowDropFileTypes&&-1==ea(b.options.allowDropFileTypes,m.type))h();else{var n=new FileReader;n.onerror=function(){return h()};n.onload=function(){var p=n.result;/[\x00-\x08\x0e-\x1f]{2}/.test(p)||(f[q]=p);h()};n.readAsText(m)}},l=0;l<c.length;l++)k(c[l],l);else if(b.state.draggingText&&
-1<b.doc.sel.contains(d))b.state.draggingText(a),setTimeout(function(){return b.display.input.focus()},20);else try{if(k=a.dataTransfer.getData("Text")){b.state.draggingText&&!b.state.draggingText.copy&&(l=b.listSelections());Tc(b.doc,Na(d,d));if(l)for(c=0;c<l.length;++c)Bb(b.doc,"",l[c].anchor,l[c].head,"drag");b.replaceSelection(k,"around","paste");b.display.input.focus()}}catch(m){}}}function Tf(a){a.display.dragCursor&&(a.display.lineSpace.removeChild(a.display.dragCursor),a.display.dragCursor=
null)}function Vf(a){if(document.getElementsByClassName){for(var b=document.getElementsByClassName("CodeMirror"),d=[],c=0;c<b.length;c++){var e=b[c].CodeMirror;e&&d.push(e)}d.length&&d[0].operation(function(){for(var f=0;f<d.length;f++)a(d[f])})}}function gh(){var a;z(window,"resize",function(){null==a&&(a=setTimeout(function(){a=null;Vf(hh)},100))});z(window,"blur",function(){return Vf(ub)})}function hh(a){var b=a.display;b.cachedCharWidth=b.cachedTextHeight=b.cachedPaddingH=null;b.scrollbarsClipped=
!1;a.setSize()}function ih(a){var b=a.split(/-(?!$)/);a=b[b.length-1];for(var d,c,e,f,g=0;g<b.length-1;g++){var h=b[g];if(/^(cmd|meta|m)$/i.test(h))f=!0;else if(/^a(lt)?$/i.test(h))d=!0;else if(/^(c|ctrl|control)$/i.test(h))c=!0;else if(/^s(hift)?$/i.test(h))e=!0;else throw Error("Unrecognized modifier name: "+h);}d&&(a="Alt-"+a);c&&(a="Ctrl-"+a);f&&(a="Cmd-"+a);e&&(a="Shift-"+a);return a}function jh(a){var b={},d;for(d in a)if(a.hasOwnProperty(d)){var c=a[d];if(!/^(name|fallthrough|(de|at)tach)$/.test(d)){if("..."!=
c)for(var e=vc(d.split(" "),ih),f=0;f<e.length;f++){if(f==e.length-1){var g=e.join(" ");var h=c}else g=e.slice(0,f+1).join(" "),h="...";var k=b[g];if(!k)b[g]=h;else if(k!=h)throw Error("Inconsistent bindings for "+g);}delete a[d]}}for(var l in b)a[l]=b[l];return a}function Db(a,b,d,c){b=Wc(b);var e=b.call?b.call(a,c):b[a];if(!1===e)return"nothing";if("..."===e)return"multi";if(null!=e&&d(e))return"handled";if(b.fallthrough){if("[object Array]"!=Object.prototype.toString.call(b.fallthrough))return Db(a,
b.fallthrough,d,c);for(e=0;e<b.fallthrough.length;e++){var f=Db(a,b.fallthrough[e],d,c);if(f)return f}}}function Wf(a){a="string"==typeof a?a:Ua[a.keyCode];return"Ctrl"==a||"Alt"==a||"Shift"==a||"Mod"==a}function Xf(a,b,d){var c=a;b.altKey&&"Alt"!=c&&(a="Alt-"+a);(Yf?b.metaKey:b.ctrlKey)&&"Ctrl"!=c&&(a="Ctrl-"+a);(Yf?b.ctrlKey:b.metaKey)&&"Mod"!=c&&(a="Cmd-"+a);!d&&b.shiftKey&&"Shift"!=c&&(a="Shift-"+a);return a}function Zf(a,b){if(Ba&&34==a.keyCode&&a["char"])return!1;var d=Ua[a.keyCode];if(null==
d||a.altGraphKey)return!1;3==a.keyCode&&a.code&&(d=a.code);return Xf(d,a,b)}function Wc(a){return"string"==typeof a?gc[a]:a}function Eb(a,b){for(var d=a.doc.sel.ranges,c=[],e=0;e<d.length;e++){for(var f=b(d[e]);c.length&&0>=B(f.from,L(c).to);){var g=c.pop();if(0>B(g.from,f.from)){f.from=g.from;break}}c.push(f)}pa(a,function(){for(var h=c.length-1;0<=h;h--)Bb(a.doc,"",c[h].from,c[h].to,"+delete");vb(a)})}function ae(a,b,d){b=pe(a.text,b+d,d);return 0>b||b>a.text.length?null:b}function be(a,b,d){a=
ae(a,b.ch,d);return null==a?null:new t(b.line,a,0>d?"after":"before")}function ce(a,b,d,c,e){if(a&&("rtl"==b.doc.direction&&(e=-e),a=Ja(d,b.doc.direction))){a=0>e?L(a):a[0];var f=0>e==(1==a.level)?"after":"before";if(0<a.level||"rtl"==b.doc.direction){var g=cb(b,d);var h=0>e?d.text.length-1:0;var k=za(b,g,h).top;h=Hb(function(l){return za(b,g,l).top==k},0>e==(1==a.level)?a.from:a.to-1,h);"before"==f&&(h=ae(d,h,1))}else h=0>e?a.to:a.from;return new t(c,h,f)}return new t(c,0>e?d.text.length:0,0>e?"before":
"after")}function kh(a,b,d,c){var e=Ja(b,a.doc.direction);if(!e)return be(b,d,c);d.ch>=b.text.length?(d.ch=b.text.length,d.sticky="before"):0>=d.ch&&(d.ch=0,d.sticky="after");var f=Ib(e,d.ch,d.sticky),g=e[f];if("ltr"==a.doc.direction&&0==g.level%2&&(0<c?g.to>d.ch:g.from<d.ch))return be(b,d,c);var h=function(p,r){return ae(b,p instanceof t?p.ch:p,r)},k,l=function(p){if(!a.options.lineWrapping)return{begin:0,end:b.text.length};k=k||cb(a,b);return af(a,b,k,p)},m=l("before"==d.sticky?h(d,-1):d.ch);if("rtl"==
a.doc.direction||1==g.level){var q=1==g.level==0>c,n=h(d,q?1:-1);if(null!=n&&(q?n<=g.to&&n<=m.end:n>=g.from&&n>=m.begin))return new t(d.line,n,q?"before":"after")}g=function(p,r,u){for(var A=function(M,R){return R?new t(d.line,h(M,1),"before"):new t(d.line,M,"after")};0<=p&&p<e.length;p+=r){var H=e[p],x=0<r==(1!=H.level),Q=x?u.begin:h(u.end,-1);if(H.from<=Q&&Q<H.to)return A(Q,x);Q=x?H.from:h(H.to,-1);if(u.begin<=Q&&Q<u.end)return A(Q,x)}};if(f=g(f+c,c,m))return f;m=0<c?m.end:h(m.begin,-1);return null==
m||0<c&&m==b.text.length||!(f=g(0<c?0:e.length-1,c,l(m)))?null:f}function $f(a,b){var d=w(a.doc,b),c=Fa(d);c!=d&&(b=O(c));return ce(!0,a,c,b,1)}function ag(a,b){var d=$f(a,b.line),c=w(a.doc,d.line);a=Ja(c,a.doc.direction);return a&&0!=a[0].level?d:(c=Math.max(d.ch,c.text.search(/\S/)),t(d.line,b.line==d.line&&b.ch<=c&&b.ch?0:c,d.sticky))}function Xc(a,b,d){if("string"==typeof b&&(b=hc[b],!b))return!1;a.display.input.ensurePolled();var c=a.display.shift,e=!1;try{a.isReadOnly()&&(a.state.suppressEdits=
!0),d&&(a.display.shift=!1),e=b(a)!=Yc}finally{a.display.shift=c,a.state.suppressEdits=!1}return e}function ic(a,b,d,c){var e=a.state.keySeq;if(e){if(Wf(b))return"handled";/'$/.test(b)?a.state.keySeq=null:lh.set(50,function(){a.state.keySeq==e&&(a.state.keySeq=null,a.display.input.reset())});if(bg(a,e+" "+b,d,c))return!0}return bg(a,b,d,c)}function bg(a,b,d,c){a:{for(var e=0;e<a.state.keyMaps.length;e++){var f=Db(b,a.state.keyMaps[e],c,a);if(f){c=f;break a}}c=a.options.extraKeys&&Db(b,a.options.extraKeys,
c,a)||Db(b,a.options.keyMap,c,a)}"multi"==c&&(a.state.keySeq=b);"handled"==c&&ca(a,"keyHandled",a,b,d);if("handled"==c||"multi"==c)la(d),Nd(a);return!!c}function cg(a,b){var d=Zf(b,!0);return d?b.shiftKey&&!a.state.keySeq?ic(a,"Shift-"+d,b,function(c){return Xc(a,c,!0)})||ic(a,d,b,function(c){if("string"==typeof c?/^go[A-Z]/.test(c):c.motion)return Xc(a,c)}):ic(a,d,b,function(c){return Xc(a,c)}):!1}function mh(a,b,d){return ic(a,"'"+d+"'",b,function(c){return Xc(a,c,!0)})}function dg(a){if(!a.target||
a.target==this.display.input.getField())if(this.curOp.focus=va(),!Z(this,a)){G&&11>U&&27==a.keyCode&&(a.returnValue=!1);var b=a.keyCode;this.display.shift=16==b||a.shiftKey;var d=cg(this,a);Ba&&(de=d?b:null,!d&&88==b&&!nh&&(ya?a.metaKey:a.ctrlKey)&&this.replaceSelection("",null,"cut"));Ma&&!ya&&!d&&46==b&&a.shiftKey&&!a.ctrlKey&&document.execCommand&&document.execCommand("cut");18!=b||/\bCodeMirror-crosshair\b/.test(this.display.lineDiv.className)||oh(this)}}function oh(a){function b(c){18!=c.keyCode&&
c.altKey||(hb(d,"CodeMirror-crosshair"),ra(document,"keyup",b),ra(document,"mouseover",b))}var d=a.display.lineDiv;Wa(d,"CodeMirror-crosshair");z(document,"keyup",b);z(document,"mouseover",b)}function eg(a){16==a.keyCode&&(this.doc.sel.shift=!1);Z(this,a)}function fg(a){if(!(a.target&&a.target!=this.display.input.getField()||La(this.display,a)||Z(this,a)||a.ctrlKey&&!a.altKey||ya&&a.metaKey)){var b=a.keyCode,d=a.charCode;if(Ba&&b==de)de=null,la(a);else if(!Ba||a.which&&!(10>a.which)||!cg(this,a))if(b=
String.fromCharCode(null==d?b:d),"\b"!=b&&!mh(this,a,b))this.display.input.onKeyPress(a)}}function ph(a,b){var d=+new Date;if(jc&&jc.compare(d,a,b))return kc=jc=null,"triple";if(kc&&kc.compare(d,a,b))return jc=new ee(d,a,b),kc=null,"double";kc=new ee(d,a,b);jc=null;return"single"}function gg(a){var b=this.display;if(!(Z(this,a)||b.activeTouch&&b.input.supportsTouch()))if(b.input.ensurePolled(),b.shift=a.shiftKey,La(b,a))fa||(b.scroller.draggable=!1,setTimeout(function(){return b.scroller.draggable=
!0},100));else if(!Zc(this,a,"gutterClick",!0)){var d=eb(this,a),c=se(a),e=d?ph(d,c):"single";window.focus();1==c&&this.state.selectingText&&this.state.selectingText(a);if(!d||!qh(this,c,d,e,a))if(1==c)d?rh(this,d,e,a):(a.target||a.srcElement)==b.scroller&&la(a);else if(2==c)d&&Sc(this.doc,d),setTimeout(function(){return b.input.focus()},20);else if(3==c)if(fe)this.display.input.onContextMenu(a);else gf(this)}}function qh(a,b,d,c,e){var f="Click";"double"==c?f="Double"+f:"triple"==c&&(f="Triple"+
f);return ic(a,Xf((1==b?"Left":2==b?"Middle":"Right")+f,e),e,function(g){"string"==typeof g&&(g=hc[g]);if(!g)return!1;var h=!1;try{a.isReadOnly()&&(a.state.suppressEdits=!0),h=g(a,d)!=Yc}finally{a.state.suppressEdits=!1}return h})}function rh(a,b,d,c){G?setTimeout(dd(ff,a),0):a.curOp.focus=va();var e=a.getOption("configureMouse");e=e?e(a,d,c):{};null==e.unit&&(e.unit=(sh?c.shiftKey&&c.metaKey:c.altKey)?"rectangle":"single"==d?"char":"double"==d?"word":"line");if(null==e.extend||a.doc.extend)e.extend=
a.doc.extend||c.shiftKey;null==e.addNew&&(e.addNew=ya?c.metaKey:c.ctrlKey);null==e.moveOnDrag&&(e.moveOnDrag=!(ya?c.altKey:c.ctrlKey));var f=a.doc.sel,g;a.options.dragDrop&&th&&!a.isReadOnly()&&"single"==d&&-1<(g=f.contains(b))&&(0>B((g=f.ranges[g]).from(),b)||0<b.xRel)&&(0<B(g.to(),b)||0>b.xRel)?uh(a,c,b,e):vh(a,c,b,e)}function uh(a,b,d,c){var e=a.display,f=!1,g=aa(a,function(l){fa&&(e.scroller.draggable=!1);a.state.draggingText=!1;ra(e.wrapper.ownerDocument,"mouseup",g);ra(e.wrapper.ownerDocument,
"mousemove",h);ra(e.scroller,"dragstart",k);ra(e.scroller,"drop",g);f||(la(l),c.addNew||Sc(a.doc,d,null,null,c.extend),fa&&!ge||G&&9==U?setTimeout(function(){e.wrapper.ownerDocument.body.focus({preventScroll:!0});e.input.focus()},20):e.input.focus())}),h=function(l){f=f||10<=Math.abs(b.clientX-l.clientX)+Math.abs(b.clientY-l.clientY)},k=function(){return f=!0};fa&&(e.scroller.draggable=!0);a.state.draggingText=g;g.copy=!c.moveOnDrag;e.scroller.dragDrop&&e.scroller.dragDrop();z(e.wrapper.ownerDocument,
"mouseup",g);z(e.wrapper.ownerDocument,"mousemove",h);z(e.scroller,"dragstart",k);z(e.scroller,"drop",g);gf(a);setTimeout(function(){return e.input.focus()},20)}function hg(a,b,d){if("char"==d)return new J(b,b);if("word"==d)return a.findWordAt(b);if("line"==d)return new J(t(b.line,0),C(a.doc,t(b.line+1,0)));a=d(a,b);return new J(a.from,a.to)}function vh(a,b,d,c){function e(x){if(0!=B(p,x))if(p=x,"rectangle"==c.unit){var Q=[],M=a.options.tabSize,R=wa(w(k,d.line).text,d.ch,M),T=wa(w(k,x.line).text,
x.ch,M),F=Math.min(R,T);R=Math.max(R,T);T=Math.min(d.line,x.line);for(var S=Math.min(a.lastLine(),Math.max(d.line,x.line));T<=S;T++){var I=w(k,T).text,N=ed(I,F,M);F==R?Q.push(new J(t(T,N),t(T,N))):I.length>N&&Q.push(new J(t(T,N),t(T,ed(I,R,M))))}Q.length||Q.push(new J(d,d));da(k,Ca(a,l.ranges.slice(0,q).concat(Q),q),{origin:"*mouse",scroll:!1});a.scrollIntoView(x)}else Q=n,F=hg(a,x,c.unit),x=Q.anchor,0<B(F.anchor,x)?(M=F.head,x=Ac(Q.from(),F.anchor)):(M=F.anchor,x=zc(Q.to(),F.head)),Q=l.ranges.slice(0),
Q[q]=wh(a,new J(C(k,x),M)),da(k,Ca(a,Q,q),he)}function f(x){var Q=++u,M=eb(a,x,!0,"rectangle"==c.unit);if(M)if(0!=B(M,p)){a.curOp.focus=va();e(M);var R=Lc(h,k);(M.line>=R.to||M.line<R.from)&&setTimeout(aa(a,function(){u==Q&&f(x)}),150)}else{var T=x.clientY<r.top?-20:x.clientY>r.bottom?20:0;T&&setTimeout(aa(a,function(){u==Q&&(h.scroller.scrollTop+=T,f(x))}),50)}}function g(x){a.state.selectingText=!1;u=Infinity;x&&(la(x),h.input.focus());ra(h.wrapper.ownerDocument,"mousemove",A);ra(h.wrapper.ownerDocument,
"mouseup",H);k.history.lastSelOrigin=null}var h=a.display,k=a.doc;la(b);var l=k.sel,m=l.ranges;if(c.addNew&&!c.extend){var q=k.sel.contains(d);var n=-1<q?m[q]:new J(d,d)}else n=k.sel.primary(),q=k.sel.primIndex;"rectangle"==c.unit?(c.addNew||(n=new J(d,d)),d=eb(a,b,!0,!0),q=-1):(b=hg(a,d,c.unit),n=c.extend?Zd(n,b.anchor,b.head,c.extend):b);c.addNew?-1==q?(q=m.length,da(k,Ca(a,m.concat([n]),q),{scroll:!1,origin:"*mouse"})):1<m.length&&m[q].empty()&&"char"==c.unit&&!c.extend?(da(k,Ca(a,m.slice(0,q).concat(m.slice(q+
1)),0),{scroll:!1,origin:"*mouse"}),l=k.sel):$d(k,q,n,he):(q=0,da(k,new ua([n],0),he),l=k.sel);var p=d,r=h.wrapper.getBoundingClientRect(),u=0,A=aa(a,function(x){0!==x.buttons&&se(x)?f(x):g(x)}),H=aa(a,g);a.state.selectingText=H;z(h.wrapper.ownerDocument,"mousemove",A);z(h.wrapper.ownerDocument,"mouseup",H)}function wh(a,b){var d=b.anchor,c=b.head,e=w(a.doc,d.line);if(0==B(d,c)&&d.sticky==c.sticky)return b;e=Ja(e);if(!e)return b;var f=Ib(e,d.ch,d.sticky),g=e[f];if(g.from!=d.ch&&g.to!=d.ch)return b;
var h=f+(g.from==d.ch==(1!=g.level)?0:1);if(0==h||h==e.length)return b;c.line!=d.line?a=0<(c.line-d.line)*("ltr"==a.doc.direction?1:-1):(a=Ib(e,c.ch,c.sticky),f=a-f||(c.ch-d.ch)*(1==g.level?-1:1),a=a==h-1||a==h?0>f:0<f);e=e[h+(a?-1:0)];e=(h=a==(1==e.level))?e.from:e.to;h=h?"after":"before";return d.ch==e&&d.sticky==h?b:new J(new t(d.line,e,h),c)}function Zc(a,b,d,c){if(b.touches){var e=b.touches[0].clientX;var f=b.touches[0].clientY}else try{e=b.clientX,f=b.clientY}catch(k){return!1}if(e>=Math.floor(a.display.gutters.getBoundingClientRect().right))return!1;
c&&la(b);c=a.display;var g=c.lineDiv.getBoundingClientRect();if(f>g.bottom||!xa(a,d))return id(b);f-=g.top-c.viewOffset;for(g=0;g<a.display.gutterSpecs.length;++g){var h=c.gutters.childNodes[g];if(h&&h.getBoundingClientRect().right>=e)return e=$a(a.doc,f),X(a,d,a,e,a.display.gutterSpecs[g].className,b),id(b)}}function ig(a,b){var d;(d=La(a.display,b))||(d=xa(a,"gutterContextMenu")?Zc(a,b,"gutterContextMenu",!1):!1);if(!d&&!Z(a,b,"contextmenu")&&!fe)a.display.input.onContextMenu(b)}function jg(a){a.display.wrapper.className=
a.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+a.options.theme.replace(/(^|\s)\s*/g," cm-s-");Sb(a)}function xh(a,b,d){!b!=!(d&&d!=Fb)&&(d=a.display.dragFunctions,b=b?z:ra,b(a.display.scroller,"dragstart",d.start),b(a.display.scroller,"dragenter",d.enter),b(a.display.scroller,"dragover",d.over),b(a.display.scroller,"dragleave",d.leave),b(a.display.scroller,"drop",d.drop))}function yh(a){a.options.lineWrapping?(Wa(a.display.wrapper,"CodeMirror-wrap"),a.display.sizer.style.minWidth="",a.display.sizerWidth=
null):(hb(a.display.wrapper,"CodeMirror-wrap"),xd(a));Ld(a);ma(a);Sb(a);setTimeout(function(){return wb(a)},100)}function V(a,b){var d=this;if(!(this instanceof V))return new V(a,b);this.options=b=b?Xa(b):{};Xa(kg,b,!1);var c=b.value;"string"==typeof c?c=new oa(c,b.mode,null,b.lineSeparator,b.direction):b.mode&&(c.modeOption=b.mode);this.doc=c;var e=new V.inputStyles[b.inputStyle](this);a=this.display=new Xg(a,c,e,b);a.wrapper.CodeMirror=this;jg(this);b.lineWrapping&&(this.display.wrapper.className+=
" CodeMirror-wrap");nf(this);this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:-1,cutIncoming:-1,selectingText:!1,draggingText:!1,highlight:new Va,keySeq:null,specialChars:null};b.autofocus&&!Zb&&a.input.focus();G&&11>U&&setTimeout(function(){return d.display.input.reset(!0)},20);zh(this);lg||(gh(),lg=!0);jb(this);this.curOp.forceUpdate=!0;xf(this,c);b.autofocus&&!Zb||this.hasFocus()?setTimeout(function(){d.hasFocus()&&!d.state.focused&&
Od(d)},20):ub(this);for(var f in $c)if($c.hasOwnProperty(f))$c[f](this,b[f],Fb);qf(this);b.finishInit&&b.finishInit(this);for(c=0;c<ie.length;++c)ie[c](this);kb(this);fa&&b.lineWrapping&&"optimizelegibility"==getComputedStyle(a.lineDiv).textRendering&&(a.lineDiv.style.textRendering="auto")}function zh(a){function b(){c.activeTouch&&(e=setTimeout(function(){return c.activeTouch=null},1E3),f=c.activeTouch,f.end=+new Date)}function d(h,k){if(null==k.left)return!0;var l=k.left-h.left;h=k.top-h.top;return 400<
l*l+h*h}var c=a.display;z(c.scroller,"mousedown",aa(a,gg));G&&11>U?z(c.scroller,"dblclick",aa(a,function(h){if(!Z(a,h)){var k=eb(a,h);!k||Zc(a,h,"gutterClick",!0)||La(a.display,h)||(la(h),h=a.findWordAt(k),Sc(a.doc,h.anchor,h.head))}})):z(c.scroller,"dblclick",function(h){return Z(a,h)||la(h)});z(c.scroller,"contextmenu",function(h){return ig(a,h)});z(c.input.getField(),"contextmenu",function(h){c.scroller.contains(h.target)||ig(a,h)});var e,f={end:0};z(c.scroller,"touchstart",function(h){var k;if(k=
!Z(a,h))1!=h.touches.length?k=!1:(k=h.touches[0],k=1>=k.radiusX&&1>=k.radiusY),k=!k;k&&!Zc(a,h,"gutterClick",!0)&&(c.input.ensurePolled(),clearTimeout(e),k=+new Date,c.activeTouch={start:k,moved:!1,prev:300>=k-f.end?f:null},1==h.touches.length&&(c.activeTouch.left=h.touches[0].pageX,c.activeTouch.top=h.touches[0].pageY))});z(c.scroller,"touchmove",function(){c.activeTouch&&(c.activeTouch.moved=!0)});z(c.scroller,"touchend",function(h){var k=c.activeTouch;if(k&&!La(c,h)&&null!=k.left&&!k.moved&&300>
new Date-k.start){var l=a.coordsChar(c.activeTouch,"page");k=!k.prev||d(k,k.prev)?new J(l,l):!k.prev.prev||d(k,k.prev.prev)?a.findWordAt(l):new J(t(l.line,0),C(a.doc,t(l.line+1,0)));a.setSelection(k.anchor,k.head);a.focus();la(h)}b()});z(c.scroller,"touchcancel",b);z(c.scroller,"scroll",function(){c.scroller.clientHeight&&(Vb(a,c.scroller.scrollTop),ib(a,c.scroller.scrollLeft,!0),X(a,"scroll",a))});z(c.scroller,"mousewheel",function(h){return tf(a,h)});z(c.scroller,"DOMMouseScroll",function(h){return tf(a,
h)});z(c.wrapper,"scroll",function(){return c.wrapper.scrollTop=c.wrapper.scrollLeft=0});c.dragFunctions={enter:function(h){Z(a,h)||Kb(h)},over:function(h){if(!Z(a,h)){var k=eb(a,h);if(k){var l=document.createDocumentFragment();ef(a,k,l);a.display.dragCursor||(a.display.dragCursor=v("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),a.display.lineSpace.insertBefore(a.display.dragCursor,a.display.cursorDiv));D(a.display.dragCursor,l)}Kb(h)}},start:function(h){if(G&&(!a.state.draggingText||100>
+new Date-Uf))Kb(h);else if(!Z(a,h)&&!La(a.display,h)&&(h.dataTransfer.setData("Text",a.getSelection()),h.dataTransfer.effectAllowed="copyMove",h.dataTransfer.setDragImage&&!ge)){var k=v("img",null,null,"position: fixed; left: 0; top: 0;");k.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";Ba&&(k.width=k.height=1,a.display.wrapper.appendChild(k),k._top=k.offsetTop);h.dataTransfer.setDragImage(k,0,0);Ba&&k.parentNode.removeChild(k)}},drop:aa(a,fh),leave:function(h){Z(a,
h)||Tf(a)}};var g=c.input.getField();z(g,"keyup",function(h){return eg.call(a,h)});z(g,"keydown",aa(a,dg));z(g,"keypress",aa(a,fg));z(g,"focus",function(h){return Od(a,h)});z(g,"blur",function(h){return ub(a,h)})}function lc(a,b,d,c){var e=a.doc,f;null==d&&(d="add");"smart"==d&&(e.mode.indent?f=Mb(a,b).state:d="prev");var g=a.options.tabSize,h=w(e,b),k=wa(h.text,null,g);h.stateAfter&&(h.stateAfter=null);var l=h.text.match(/^\s*/)[0];if(!c&&!/\S/.test(h.text)){var m=0;d="not"}else if("smart"==d&&(m=
e.mode.indent(f,h.text.slice(l.length),h.text),m==Yc||150<m)){if(!c)return;d="prev"}"prev"==d?m=b>e.first?wa(w(e,b-1).text,null,g):0:"add"==d?m=k+a.options.indentUnit:"subtract"==d?m=k-a.options.indentUnit:"number"==typeof d&&(m=k+d);m=Math.max(0,m);d="";c=0;if(a.options.indentWithTabs)for(a=Math.floor(m/g);a;--a)c+=g,d+="\t";c<m&&(d+=fd(m-c));if(d!=l)return Bb(e,d,t(b,0),t(b,l.length),"+input"),h.stateAfter=null,!0;for(g=0;g<e.sel.ranges.length;g++)if(h=e.sel.ranges[g],h.head.line==b&&h.head.ch<
l.length){b=t(b,l.length);$d(e,g,new J(b,b));break}}function je(a,b,d,c,e){var f=a.doc;a.display.shift=!1;c||(c=f.sel);var g=+new Date-200,h="paste"==e||a.state.pasteIncoming>g,k=ke(b),l=null;if(h&&1<c.ranges.length)if(qa&&qa.text.join("\n")==b){if(0==c.ranges.length%qa.text.length){l=[];for(var m=0;m<qa.text.length;m++)l.push(f.splitLines(qa.text[m]))}}else k.length==c.ranges.length&&a.options.pasteLinesPerSelection&&(l=vc(k,function(u){return[u]}));m=a.curOp.updateInput;for(var q=c.ranges.length-
1;0<=q;q--){var n=c.ranges[q],p=n.from(),r=n.to();n.empty()&&(d&&0<d?p=t(p.line,p.ch-d):a.state.overwrite&&!h?r=t(r.line,Math.min(w(f,r.line).text.length,r.ch+L(k).length)):h&&qa&&qa.lineWise&&qa.text.join("\n")==k.join("\n")&&(p=r=t(p.line,0)));n={from:p,to:r,text:l?l[q%l.length]:k,origin:e||(h?"paste":a.state.cutIncoming>g?"cut":"+input")};Ab(a.doc,n);ca(a,"inputRead",a,n)}b&&!h&&mg(a,b);vb(a);2>a.curOp.updateInput&&(a.curOp.updateInput=m);a.curOp.typing=!0;a.state.pasteIncoming=a.state.cutIncoming=
-1}function ng(a,b){var d=a.clipboardData&&a.clipboardData.getData("Text");if(d)return a.preventDefault(),b.isReadOnly()||b.options.disableInput||pa(b,function(){return je(b,d,0,null,"paste")}),!0}function mg(a,b){if(a.options.electricChars&&a.options.smartIndent)for(var d=a.doc.sel,c=d.ranges.length-1;0<=c;c--){var e=d.ranges[c];if(!(100<e.head.ch||c&&d.ranges[c-1].head.line==e.head.line)){var f=a.getModeAt(e.head),g=!1;if(f.electricChars)for(var h=0;h<f.electricChars.length;h++){if(-1<b.indexOf(f.electricChars.charAt(h))){g=
lc(a,e.head.line,"smart");break}}else f.electricInput&&f.electricInput.test(w(a.doc,e.head.line).text.slice(0,e.head.ch))&&(g=lc(a,e.head.line,"smart"));g&&ca(a,"electricInput",a,e.head.line)}}}function og(a){for(var b=[],d=[],c=0;c<a.doc.sel.ranges.length;c++){var e=a.doc.sel.ranges[c].head.line;e={anchor:t(e,0),head:t(e+1,0)};d.push(e);b.push(a.getRange(e.anchor,e.head))}return{text:b,ranges:d}}function pg(a,b,d,c){a.setAttribute("autocorrect",d?"":"off");a.setAttribute("autocapitalize",c?"":"off");
a.setAttribute("spellcheck",!!b)}function qg(){var a=v("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),b=v("div",[a],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");fa?a.style.width="1000px":a.setAttribute("wrap","off");mc&&(a.style.border="1px solid black");pg(a);return b}function le(a,b,d,c,e){function f(u){if("codepoint"==c){var A=k.text.charCodeAt(b.ch+(0<c?0:-1));A=isNaN(A)?null:new t(b.line,Math.max(0,Math.min(k.text.length,
b.ch+d*(55296<=A&&56320>A?2:1))),-d)}else A=e?kh(a.cm,k,b,d):be(k,b,d);if(null==A){if(u=!u)u=b.line+l,u<a.first||u>=a.first+a.size?u=!1:(b=new t(u,b.ch,b.sticky),u=k=w(a,u));if(u)b=ce(e,a.cm,k,b.line,l);else return!1}else b=A;return!0}var g=b,h=d,k=w(a,b.line),l=e&&"rtl"==a.direction?-d:d;if("char"==c||"codepoint"==c)f();else if("column"==c)f(!0);else if("word"==c||"group"==c)for(var m=null,q="group"==c,n=a.cm&&a.cm.getHelper(b,"wordChars"),p=!0;!(0>d)||f(!p);p=!1){var r=k.text.charAt(b.ch)||"\n";
r=wc(r,n)?"w":q&&"\n"==r?"n":!q||/\s/.test(r)?null:"p";!q||p||r||(r="s");if(m&&m!=r){0>d&&(d=1,f(),b.sticky="after");break}r&&(m=r);if(0<d&&!f(!p))break}h=Uc(a,b,g,h,!0);pd(g,h)&&(h.hitSide=!0);return h}function rg(a,b,d,c){var e=a.doc,f=b.left;if("page"==c){var g=Math.max(Math.min(a.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight)-.5*tb(a.display),3);g=(0<d?b.bottom:b.top)+d*g}else"line"==c&&(g=0<d?b.bottom+3:b.top-3);for(;;){b=Id(a,f,g);if(!b.outside)break;
if(0>d?0>=g:g>=e.height){b.hitSide=!0;break}g+=5*d}return b}function sg(a,b){var d=Cd(a,b.line);if(!d||d.hidden)return null;var c=w(a.doc,b.line);d=Re(d,c,b.line);a=Ja(c,a.doc.direction);c="left";a&&(c=Ib(a,b.ch)%2?"right":"left");b=Se(d.map,b.ch,c);b.offset="right"==b.collapse?b.end:b.start;return b}function Ah(a){for(;a;a=a.parentNode)if(/CodeMirror-gutter-wrapper/.test(a.className))return!0;return!1}function Gb(a,b){b&&(a.bad=!0);return a}function Bh(a,b,d,c,e){function f(p){return function(r){return r.id==
p}}function g(){m&&(l+=q,n&&(l+=q),m=n=!1)}function h(p){p&&(g(),l+=p)}function k(p){if(1==p.nodeType){var r=p.getAttribute("cm-text");if(r)h(r);else{r=p.getAttribute("cm-marker");var u;if(r)p=a.findMarks(t(c,0),t(e+1,0),f(+r)),p.length&&(u=p[0].find(0))&&h(Za(a.doc,u.from,u.to).join(q));else if("false"!=p.getAttribute("contenteditable")&&(u=/^(pre|div|p|li|table|br)$/i.test(p.nodeName),/^br$/i.test(p.nodeName)||0!=p.textContent.length)){u&&g();for(r=0;r<p.childNodes.length;r++)k(p.childNodes[r]);
/^(pre|p)$/i.test(p.nodeName)&&(n=!0);u&&(m=!0)}}}else 3==p.nodeType&&h(p.nodeValue.replace(/\u200b/g,"").replace(/\u00a0/g," "))}for(var l="",m=!1,q=a.doc.lineSeparator(),n=!1;;){k(b);if(b==d)break;b=b.nextSibling;n=!1}return l}function ad(a,b,d){if(b==a.display.lineDiv){var c=a.display.lineDiv.childNodes[d];if(!c)return Gb(a.clipPos(t(a.display.viewTo-1)),!0);b=null;d=0}else for(c=b;;c=c.parentNode){if(!c||c==a.display.lineDiv)return null;if(c.parentNode&&c.parentNode==a.display.lineDiv)break}for(var e=
0;e<a.display.view.length;e++){var f=a.display.view[e];if(f.node==c)return Ch(f,b,d)}}function Ch(a,b,d){function c(m,q,n){for(var p=-1;p<(l?l.length:0);p++)for(var r=0>p?k.map:l[p],u=0;u<r.length;u+=3){var A=r[u+2];if(A==m||A==q){q=O(0>p?a.line:a.rest[p]);p=r[u]+n;if(0>n||A!=m)p=r[u+(n?1:0)];return t(q,p)}}}var e=a.text.firstChild,f=!1;if(!b||!ka(e,b))return Gb(t(O(a.line),0),!0);if(b==e&&(f=!0,b=e.childNodes[d],d=0,!b))return d=a.rest?L(a.rest):a.line,Gb(t(O(d),d.text.length),f);var g=3==b.nodeType?
b:null,h=b;g||1!=b.childNodes.length||3!=b.firstChild.nodeType||(g=b.firstChild,d&&(d=g.nodeValue.length));for(;h.parentNode!=e;)h=h.parentNode;var k=a.measure,l=k.maps;if(b=c(g,h,d))return Gb(b,f);e=h.nextSibling;for(g=g?g.nodeValue.length-d:0;e;e=e.nextSibling){if(b=c(e,e.firstChild,0))return Gb(t(b.line,b.ch-g),f);g+=e.textContent.length}for(h=h.previousSibling;h;h=h.previousSibling){if(b=c(h,h.firstChild,-1))return Gb(t(b.line,b.ch+d),f);d+=h.textContent.length}}var ja=navigator.userAgent,tg=
navigator.platform,Ma=/gecko\/\d/i.test(ja),ug=/MSIE \d/.test(ja),vg=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ja),nc=/Edge\/(\d+)/.exec(ja),G=ug||vg||nc,U=G&&(ug?document.documentMode||6:+(nc||vg)[1]),fa=!nc&&/WebKit\//.test(ja),Dh=fa&&/Qt\/\d+\.\d+/.test(ja),Fc=!nc&&/Chrome\//.test(ja),Ba=/Opera\//.test(ja),ge=/Apple Computer/.test(navigator.vendor),Eh=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ja),Ug=/PhantomJS/.test(ja),mc=!nc&&/AppleWebKit/.test(ja)&&/Mobile\/\w+/.test(ja),Gc=/Android/.test(ja),
Zb=mc||Gc||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ja),ya=mc||/Mac/.test(tg),sh=/\bCrOS\b/.test(ja),Fh=/win/i.test(tg),lb=Ba&&ja.match(/Version\/(\d*\.\d*)/);lb&&(lb=Number(lb[1]));lb&&15<=lb&&(Ba=!1,fa=!0);var Yf=ya&&(Dh||Ba&&(null==lb||12.11>lb)),fe=Ma||G&&9<=U,hb=function(a,b){var d=a.className;if(b=y(b).exec(d)){var c=d.slice(b.index+b[0].length);a.className=d.slice(0,b.index)+(c?b[1]+c:"")}};var Ob=document.createRange?function(a,b,d,c){var e=document.createRange();e.setEnd(c||
a,d);e.setStart(a,b);return e}:function(a,b,d){var c=document.body.createTextRange();try{c.moveToElementText(a.parentNode)}catch(e){return c}c.collapse(!0);c.moveEnd("character",d);c.moveStart("character",b);return c};var oc=function(a){a.select()};mc?oc=function(a){a.selectionStart=0;a.selectionEnd=a.value.length}:G&&(oc=function(a){try{a.select()}catch(b){}});var Va=function(){this.f=this.id=null;this.time=0;this.handler=dd(this.onTimeout,this)};Va.prototype.onTimeout=function(a){a.id=0;a.time<=
+new Date?a.f():setTimeout(a.handler,a.time-+new Date)};Va.prototype.set=function(a,b){this.f=b;b=+new Date+a;if(!this.id||b<this.time)clearTimeout(this.id),this.id=setTimeout(this.handler,a),this.time=b};var Yc={toString:function(){return"CodeMirror.Pass"}},Ia={scroll:!1},he={origin:"*mouse"},pc={origin:"+move"},uc=[""],xg=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,yg=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,
Jb=null,Ag=function(){function a(h){return 247>=h?"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(h):1424<=h&&1524>=h?"R":1536<=h&&1785>=h?"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(h-
1536):1774<=h&&2220>=h?"r":8192<=h&&8203>=h?"w":8204==h?"b":"L"}function b(h,k,l){this.level=h;this.from=k;this.to=l}var d=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,c=/[stwN]/,e=/[LRr]/,f=/[Lb1n]/,g=/[1n]/;return function(h,k){var l="ltr"==k?"L":"R";if(0==h.length||"ltr"==k&&!d.test(h))return!1;for(var m=h.length,q=[],n=0;n<m;++n)q.push(a(h.charCodeAt(n)));n=0;for(var p=l;n<m;++n){var r=q[n];"m"==r?q[n]=p:p=r}n=0;for(p=l;n<m;++n)r=q[n],"1"==r&&"r"==p?q[n]="n":e.test(r)&&(p=r,"r"==r&&(q[n]="R"));
n=1;for(p=q[0];n<m-1;++n)r=q[n],"+"==r&&"1"==p&&"1"==q[n+1]?q[n]="1":","!=r||p!=q[n+1]||"1"!=p&&"n"!=p||(q[n]=p),p=r;for(n=0;n<m;++n)if(p=q[n],","==p)q[n]="N";else if("%"==p){for(p=n+1;p<m&&"%"==q[p];++p);for(r=n&&"!"==q[n-1]||p<m&&"1"==q[p]?"1":"N";n<p;++n)q[n]=r;n=p-1}n=0;for(p=l;n<m;++n)r=q[n],"L"==p&&"1"==r?q[n]="L":e.test(r)&&(p=r);for(p=0;p<m;++p)if(c.test(q[p])){for(n=p+1;n<m&&c.test(q[n]);++n);r="L"==(p?q[p-1]:l);for(r=r==("L"==(n<m?q[n]:l))?r?"L":"R":l;p<n;++p)q[p]=r;p=n-1}l=[];var u;for(n=
0;n<m;)if(f.test(q[n])){p=n;for(++n;n<m&&f.test(q[n]);++n);l.push(new b(0,p,n))}else{var A=n;p=l.length;r="rtl"==k?1:0;for(++n;n<m&&"L"!=q[n];++n);for(var H=A;H<n;)if(g.test(q[H])){A<H&&(l.splice(p,0,new b(1,A,H)),p+=r);A=H;for(++H;H<n&&g.test(q[H]);++H);l.splice(p,0,new b(2,A,H));p+=r;A=H}else++H;A<n&&l.splice(p,0,new b(1,A,n))}"ltr"==k&&(1==l[0].level&&(u=h.match(/^\s+/))&&(l[0].from=u[0].length,l.unshift(new b(0,0,u[0].length))),1==L(l).level&&(u=h.match(/\s+$/))&&(L(l).to-=u[0].length,l.push(new b(0,
m-u[0].length,m))));return"rtl"==k?l.reverse():l}}(),xc=[],z=function(a,b,d){a.addEventListener?a.addEventListener(b,d,!1):a.attachEvent?a.attachEvent("on"+b,d):(a=a._handlers||(a._handlers={}),a[b]=(a[b]||xc).concat(d))},th=function(){if(G&&9>U)return!1;var a=v("div");return"draggable"in a||"dragDrop"in a}(),jd,yd,ke=3!="\n\nb".split(/\n/).length?function(a){for(var b=0,d=[],c=a.length;b<=c;){var e=a.indexOf("\n",b);-1==e&&(e=a.length);var f=a.slice(b,"\r"==a.charAt(e-1)?e-1:e),g=f.indexOf("\r");
-1!=g?(d.push(f.slice(0,g)),b+=g+1):(d.push(f),b=e+1)}return d}:function(a){return a.split(/\r\n?|\n/)},Gh=window.getSelection?function(a){try{return a.selectionStart!=a.selectionEnd}catch(b){return!1}}:function(a){try{var b=a.ownerDocument.selection.createRange()}catch(d){}return b&&b.parentElement()==a?0!=b.compareEndPoints("StartToEnd",b):!1},nh=function(){var a=v("div");if("oncopy"in a)return!0;a.setAttribute("oncopy","return;");return"function"==typeof a.oncopy}(),Ed=null,kd={},ob={},pb={},Y=
function(a,b,d){this.pos=this.start=0;this.string=a;this.tabSize=b||8;this.lineStart=this.lastColumnPos=this.lastColumnValue=0;this.lineOracle=d};Y.prototype.eol=function(){return this.pos>=this.string.length};Y.prototype.sol=function(){return this.pos==this.lineStart};Y.prototype.peek=function(){return this.string.charAt(this.pos)||void 0};Y.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)};Y.prototype.eat=function(a){var b=this.string.charAt(this.pos);
if("string"==typeof a?b==a:b&&(a.test?a.test(b):a(b)))return++this.pos,b};Y.prototype.eatWhile=function(a){for(var b=this.pos;this.eat(a););return this.pos>b};Y.prototype.eatSpace=function(){for(var a=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>a};Y.prototype.skipToEnd=function(){this.pos=this.string.length};Y.prototype.skipTo=function(a){a=this.string.indexOf(a,this.pos);if(-1<a)return this.pos=a,!0};Y.prototype.backUp=function(a){this.pos-=a};Y.prototype.column=
function(){this.lastColumnPos<this.start&&(this.lastColumnValue=wa(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start);return this.lastColumnValue-(this.lineStart?wa(this.string,this.lineStart,this.tabSize):0)};Y.prototype.indentation=function(){return wa(this.string,null,this.tabSize)-(this.lineStart?wa(this.string,this.lineStart,this.tabSize):0)};Y.prototype.match=function(a,b,d){if("string"==typeof a){var c=function(f){return d?f.toLowerCase():
f},e=this.string.substr(this.pos,a.length);if(c(e)==c(a))return!1!==b&&(this.pos+=a.length),!0}else{if((a=this.string.slice(this.pos).match(a))&&0<a.index)return null;a&&!1!==b&&(this.pos+=a[0].length);return a}};Y.prototype.current=function(){return this.string.slice(this.start,this.pos)};Y.prototype.hideFirstChars=function(a,b){this.lineStart+=a;try{return b()}finally{this.lineStart-=a}};Y.prototype.lookAhead=function(a){var b=this.lineOracle;return b&&b.lookAhead(a)};Y.prototype.baseToken=function(){var a=
this.lineOracle;return a&&a.baseToken(this.pos)};var Bc=function(a,b){this.state=a;this.lookAhead=b},Ea=function(a,b,d,c){this.state=b;this.doc=a;this.line=d;this.maxLookAhead=c||0;this.baseTokens=null;this.baseTokenPos=1};Ea.prototype.lookAhead=function(a){var b=this.doc.getLine(this.line+a);null!=b&&a>this.maxLookAhead&&(this.maxLookAhead=a);return b};Ea.prototype.baseToken=function(a){if(!this.baseTokens)return null;for(;this.baseTokens[this.baseTokenPos]<=a;)this.baseTokenPos+=2;var b=this.baseTokens[this.baseTokenPos+
1];return{type:b&&b.replace(/( |^)overlay .*/,""),size:this.baseTokens[this.baseTokenPos]-a}};Ea.prototype.nextLine=function(){this.line++;0<this.maxLookAhead&&this.maxLookAhead--};Ea.fromSaved=function(a,b,d){return b instanceof Bc?new Ea(a,Ya(a.mode,b.state),d,b.lookAhead):new Ea(a,Ya(a.mode,b),d)};Ea.prototype.save=function(a){a=!1!==a?Ya(this.doc.mode,this.state):this.state;return 0<this.maxLookAhead?new Bc(a,this.maxLookAhead):a};var Ae=function(a,b,d){this.start=a.start;this.end=a.pos;this.string=
a.current();this.type=b||null;this.state=d},Lf=!1,Ka=!1,xb=function(a,b,d){this.text=a;Ee(this,b);this.height=d?d(this):1};xb.prototype.lineNo=function(){return O(this)};nb(xb);var Ig={},Hg={},rb=null,Pb=null,Te={left:0,right:0,top:0,bottom:0},db,mb=function(a,b,d){this.cm=d;var c=this.vert=v("div",[v("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),e=this.horiz=v("div",[v("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");c.tabIndex=e.tabIndex=-1;a(c);a(e);z(c,
"scroll",function(){c.clientHeight&&b(c.scrollTop,"vertical")});z(e,"scroll",function(){e.clientWidth&&b(e.scrollLeft,"horizontal")});this.checkedZeroWidth=!1;G&&8>U&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};mb.prototype.update=function(a){var b=a.scrollWidth>a.clientWidth+1,d=a.scrollHeight>a.clientHeight+1,c=a.nativeBarWidth;d?(this.vert.style.display="block",this.vert.style.bottom=b?c+"px":"0",this.vert.firstChild.style.height=Math.max(0,a.scrollHeight-a.clientHeight+(a.viewHeight-
(b?c:0)))+"px"):(this.vert.style.display="",this.vert.firstChild.style.height="0");b?(this.horiz.style.display="block",this.horiz.style.right=d?c+"px":"0",this.horiz.style.left=a.barLeft+"px",this.horiz.firstChild.style.width=Math.max(0,a.scrollWidth-a.clientWidth+(a.viewWidth-a.barLeft-(d?c:0)))+"px"):(this.horiz.style.display="",this.horiz.firstChild.style.width="0");!this.checkedZeroWidth&&0<a.clientHeight&&(0==c&&this.zeroWidthHack(),this.checkedZeroWidth=!0);return{right:d?c:0,bottom:b?c:0}};
mb.prototype.setScrollLeft=function(a){this.horiz.scrollLeft!=a&&(this.horiz.scrollLeft=a);this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")};mb.prototype.setScrollTop=function(a){this.vert.scrollTop!=a&&(this.vert.scrollTop=a);this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")};mb.prototype.zeroWidthHack=function(){this.horiz.style.height=this.vert.style.width=ya&&!Eh?"12px":"18px";this.horiz.style.pointerEvents=this.vert.style.pointerEvents=
"none";this.disableHoriz=new Va;this.disableVert=new Va};mb.prototype.enableZeroWidthBar=function(a,b,d){function c(){var e=a.getBoundingClientRect();("vert"==d?document.elementFromPoint(e.right-1,(e.top+e.bottom)/2):document.elementFromPoint((e.right+e.left)/2,e.bottom-1))!=a?a.style.pointerEvents="none":b.set(1E3,c)}a.style.pointerEvents="auto";b.set(1E3,c)};mb.prototype.clear=function(){var a=this.horiz.parentNode;a.removeChild(this.horiz);a.removeChild(this.vert)};var qc=function(){};qc.prototype.update=
function(){return{bottom:0,right:0}};qc.prototype.setScrollLeft=function(){};qc.prototype.setScrollTop=function(){};qc.prototype.clear=function(){};var of={"native":mb,"null":qc},Tg=0,Oc=function(a,b,d){var c=a.display;this.viewport=b;this.visible=Lc(c,a.doc,b);this.editorIsHidden=!c.wrapper.offsetWidth;this.wrapperHeight=c.wrapper.clientHeight;this.wrapperWidth=c.wrapper.clientWidth;this.oldDisplayWidth=ab(a);this.force=d;this.dims=Dd(a);this.events=[]};Oc.prototype.signal=function(a,b){xa(a,b)&&
this.events.push(arguments)};Oc.prototype.finish=function(){for(var a=0;a<this.events.length;a++)X.apply(null,this.events[a])};var Pc=0,ta=null;G?ta=-.53:Ma?ta=15:Fc?ta=-.7:ge&&(ta=-1/3);var ua=function(a,b){this.ranges=a;this.primIndex=b};ua.prototype.primary=function(){return this.ranges[this.primIndex]};ua.prototype.equals=function(a){if(a==this)return!0;if(a.primIndex!=this.primIndex||a.ranges.length!=this.ranges.length)return!1;for(var b=0;b<this.ranges.length;b++){var d=this.ranges[b],c=a.ranges[b];
if(!pd(d.anchor,c.anchor)||!pd(d.head,c.head))return!1}return!0};ua.prototype.deepCopy=function(){for(var a=[],b=0;b<this.ranges.length;b++)a[b]=new J(qd(this.ranges[b].anchor),qd(this.ranges[b].head));return new ua(a,this.primIndex)};ua.prototype.somethingSelected=function(){for(var a=0;a<this.ranges.length;a++)if(!this.ranges[a].empty())return!0;return!1};ua.prototype.contains=function(a,b){b||(b=a);for(var d=0;d<this.ranges.length;d++){var c=this.ranges[d];if(0<=B(b,c.from())&&0>=B(a,c.to()))return d}return-1};
var J=function(a,b){this.anchor=a;this.head=b};J.prototype.from=function(){return Ac(this.anchor,this.head)};J.prototype.to=function(){return zc(this.anchor,this.head)};J.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch};cc.prototype={chunkSize:function(){return this.lines.length},removeInner:function(a,b){for(var d=a,c=a+b;d<c;++d){var e=this.lines[d];this.height-=e.height;var f=e;f.parent=null;De(f);ca(e,"delete")}this.lines.splice(a,b)},collapse:function(a){a.push.apply(a,
this.lines)},insertInner:function(a,b,d){this.height+=d;this.lines=this.lines.slice(0,a).concat(b).concat(this.lines.slice(a));for(a=0;a<b.length;++a)b[a].parent=this},iterN:function(a,b,d){for(b=a+b;a<b;++a)if(d(this.lines[a]))return!0}};dc.prototype={chunkSize:function(){return this.size},removeInner:function(a,b){this.size-=b;for(var d=0;d<this.children.length;++d){var c=this.children[d],e=c.chunkSize();if(a<e){var f=Math.min(b,e-a),g=c.height;c.removeInner(a,f);this.height-=g-c.height;e==f&&(this.children.splice(d--,
1),c.parent=null);if(0==(b-=f))break;a=0}else a-=e}25>this.size-b&&(1<this.children.length||!(this.children[0]instanceof cc))&&(a=[],this.collapse(a),this.children=[new cc(a)],this.children[0].parent=this)},collapse:function(a){for(var b=0;b<this.children.length;++b)this.children[b].collapse(a)},insertInner:function(a,b,d){this.size+=b.length;this.height+=d;for(var c=0;c<this.children.length;++c){var e=this.children[c],f=e.chunkSize();if(a<=f){e.insertInner(a,b,d);if(e.lines&&50<e.lines.length){for(b=
a=e.lines.length%25+25;b<e.lines.length;)d=new cc(e.lines.slice(b,b+=25)),e.height-=d.height,this.children.splice(++c,0,d),d.parent=this;e.lines=e.lines.slice(0,a);this.maybeSpill()}break}a-=f}},maybeSpill:function(){if(!(10>=this.children.length)){var a=this;do{var b=a.children.splice(a.children.length-5,5);b=new dc(b);if(a.parent){a.size-=b.size;a.height-=b.height;var d=ea(a.parent.children,a);a.parent.children.splice(d+1,0,b)}else d=new dc(a.children),d.parent=a,a.children=[d,b],a=d;b.parent=a.parent}while(10<
a.children.length);a.parent.maybeSpill()}},iterN:function(a,b,d){for(var c=0;c<this.children.length;++c){var e=this.children[c],f=e.chunkSize();if(a<f){f=Math.min(b,f-a);if(e.iterN(a,f,d))return!0;if(0==(b-=f))break;a=0}else a-=f}}};var ec=function(a,b,d){if(d)for(var c in d)d.hasOwnProperty(c)&&(this[c]=d[c]);this.doc=a;this.node=b};ec.prototype.clear=function(){var a=this.doc.cm,b=this.line.widgets,d=this.line,c=O(d);if(null!=c&&b){for(var e=0;e<b.length;++e)b[e]==this&&b.splice(e--,1);b.length||
(d.widgets=null);var f=Rb(this);Da(d,Math.max(0,d.height-f));a&&(pa(a,function(){var g=-f;Ga(d)<(a.curOp&&a.curOp.scrollTop||a.doc.scrollTop)&&Mc(a,g);Qa(a,c,"widget")}),ca(a,"lineWidgetCleared",a,this,c))}};ec.prototype.changed=function(){var a=this,b=this.height,d=this.doc.cm,c=this.line;this.height=null;var e=Rb(this)-b;e&&(Oa(this.doc,c)||Da(c,c.height+e),d&&pa(d,function(){d.curOp.forceUpdate=!0;Ga(c)<(d.curOp&&d.curOp.scrollTop||d.doc.scrollTop)&&Mc(d,e);ca(d,"lineWidgetChanged",d,a,O(c))}))};
nb(ec);var Rf=0,Ta=function(a,b){this.lines=[];this.type=b;this.doc=a;this.id=++Rf};Ta.prototype.clear=function(){if(!this.explicitlyCleared){var a=this.doc.cm,b=a&&!a.curOp;b&&jb(a);if(xa(this,"clear")){var d=this.find();d&&ca(this,"clear",d.from,d.to)}for(var c=d=null,e=0;e<this.lines.length;++e){var f=this.lines[e],g=Nb(f.markedSpans,this);a&&!this.collapsed?Qa(a,O(f),"text"):a&&(null!=g.to&&(c=O(f)),null!=g.from&&(d=O(f)));for(var h=f,k=void 0,l=f.markedSpans,m=g,q=0;q<l.length;++q)l[q]!=m&&(k||
(k=[])).push(l[q]);h.markedSpans=k;null==g.from&&this.collapsed&&!Oa(this.doc,f)&&a&&Da(f,tb(a.display))}if(a&&this.collapsed&&!a.options.lineWrapping)for(e=0;e<this.lines.length;++e)f=Fa(this.lines[e]),g=Dc(f),g>a.display.maxLineLength&&(a.display.maxLine=f,a.display.maxLineLength=g,a.display.maxLineChanged=!0);null!=d&&a&&this.collapsed&&ma(a,d,c+1);this.lines.length=0;this.explicitlyCleared=!0;this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,a&&Hf(a.doc));a&&ca(a,"markerCleared",a,this,d,
c);b&&kb(a);this.parent&&this.parent.clear()}};Ta.prototype.find=function(a,b){null==a&&"bookmark"==this.type&&(a=1);for(var d,c,e=0;e<this.lines.length;++e){var f=this.lines[e],g=Nb(f.markedSpans,this);if(null!=g.from&&(d=t(b?f:O(f),g.from),-1==a))return d;if(null!=g.to&&(c=t(b?f:O(f),g.to),1==a))return c}return d&&{from:d,to:c}};Ta.prototype.changed=function(){var a=this,b=this.find(-1,!0),d=this,c=this.doc.cm;b&&c&&pa(c,function(){var e=b.line,f=O(b.line);if(f=Cd(c,f))Ue(f),c.curOp.selectionChanged=
c.curOp.forceUpdate=!0;c.curOp.updateMaxLine=!0;Oa(d.doc,e)||null==d.height||(f=d.height,d.height=null,(f=Rb(d)-f)&&Da(e,e.height+f));ca(c,"markerChanged",c,a)})};Ta.prototype.attachLine=function(a){if(!this.lines.length&&this.doc.cm){var b=this.doc.cm.curOp;b.maybeHiddenMarkers&&-1!=ea(b.maybeHiddenMarkers,this)||(b.maybeUnhiddenMarkers||(b.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(a)};Ta.prototype.detachLine=function(a){this.lines.splice(ea(this.lines,a),1);!this.lines.length&&this.doc.cm&&
(a=this.doc.cm.curOp,(a.maybeHiddenMarkers||(a.maybeHiddenMarkers=[])).push(this))};nb(Ta);var fc=function(a,b){this.markers=a;this.primary=b;for(b=0;b<a.length;++b)a[b].parent=this};fc.prototype.clear=function(){if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var a=0;a<this.markers.length;++a)this.markers[a].clear();ca(this,"clear")}};fc.prototype.find=function(a,b){return this.primary.find(a,b)};nb(fc);var Hh=0,oa=function(a,b,d,c,e){if(!(this instanceof oa))return new oa(a,b,d,c,e);null==
d&&(d=0);dc.call(this,[new cc([new xb("",null)])]);this.first=d;this.scrollTop=this.scrollLeft=0;this.cantEdit=!1;this.cleanGeneration=1;this.modeFrontier=this.highlightFrontier=d;d=t(d,0);this.sel=Na(d);this.history=new Qc(null);this.id=++Hh;this.modeOption=b;this.lineSep=c;this.direction="rtl"==e?"rtl":"ltr";this.extend=!1;"string"==typeof a&&(a=this.splitLines(a));Xd(this,{from:d,to:d,text:a});da(this,Na(d),Ia)};oa.prototype=ne(dc.prototype,{constructor:oa,iter:function(a,b,d){d?this.iterN(a-this.first,
b-a,d):this.iterN(this.first,this.first+this.size,a)},insert:function(a,b){for(var d=0,c=0;c<b.length;++c)d+=b[c].height;this.insertInner(a-this.first,b,d)},remove:function(a,b){this.removeInner(a-this.first,b)},getValue:function(a){var b=nd(this,this.first,this.first+this.size);return!1===a?b:b.join(a||this.lineSeparator())},setValue:ba(function(a){var b=t(this.first,0),d=this.first+this.size-1;Ab(this,{from:b,to:t(d,w(this,d).text.length),text:this.splitLines(a),origin:"setValue",full:!0},!0);this.cm&&
Ub(this.cm,0,0);da(this,Na(b),Ia)}),replaceRange:function(a,b,d,c){b=C(this,b);d=d?C(this,d):b;Bb(this,a,b,d,c)},getRange:function(a,b,d){a=Za(this,C(this,a),C(this,b));return!1===d?a:a.join(d||this.lineSeparator())},getLine:function(a){return(a=this.getLineHandle(a))&&a.text},getLineHandle:function(a){if(Lb(this,a))return w(this,a)},getLineNumber:function(a){return O(a)},getLineHandleVisualStart:function(a){"number"==typeof a&&(a=w(this,a));return Fa(a)},lineCount:function(){return this.size},firstLine:function(){return this.first},
lastLine:function(){return this.first+this.size-1},clipPos:function(a){return C(this,a)},getCursor:function(a){var b=this.sel.primary();return null==a||"head"==a?b.head:"anchor"==a?b.anchor:"end"==a||"to"==a||!1===a?b.to():b.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:ba(function(a,b,d){a=C(this,"number"==typeof a?t(a,b||0):a);da(this,Na(a,null),d)}),setSelection:ba(function(a,b,d){var c=C(this,a);a=C(this,b||
a);da(this,Na(c,a),d)}),extendSelection:ba(function(a,b,d){Sc(this,C(this,a),b&&C(this,b),d)}),extendSelections:ba(function(a,b){Df(this,ue(this,a),b)}),extendSelectionsBy:ba(function(a,b){a=vc(this.sel.ranges,a);Df(this,ue(this,a),b)}),setSelections:ba(function(a,b,d){if(a.length){for(var c=[],e=0;e<a.length;e++)c[e]=new J(C(this,a[e].anchor),C(this,a[e].head));null==b&&(b=Math.min(a.length-1,this.sel.primIndex));da(this,Ca(this.cm,c,b),d)}}),addSelection:ba(function(a,b,d){var c=this.sel.ranges.slice(0);
c.push(new J(C(this,a),C(this,b||a)));da(this,Ca(this.cm,c,c.length-1),d)}),getSelection:function(a){for(var b=this.sel.ranges,d,c=0;c<b.length;c++){var e=Za(this,b[c].from(),b[c].to());d=d?d.concat(e):e}return!1===a?d:d.join(a||this.lineSeparator())},getSelections:function(a){for(var b=[],d=this.sel.ranges,c=0;c<d.length;c++){var e=Za(this,d[c].from(),d[c].to());!1!==a&&(e=e.join(a||this.lineSeparator()));b[c]=e}return b},replaceSelection:function(a,b,d){for(var c=[],e=0;e<this.sel.ranges.length;e++)c[e]=
a;this.replaceSelections(c,b,d||"+input")},replaceSelections:ba(function(a,b,d){for(var c=[],e=this.sel,f=0;f<e.ranges.length;f++){var g=e.ranges[f];c[f]={from:g.from(),to:g.to(),text:this.splitLines(a[f]),origin:d}}if(a=b&&"end"!=b){a=[];e=d=t(this.first,0);for(f=0;f<c.length;f++){var h=c[f];g=vf(h.from,d,e);var k=vf(Ra(h),d,e);d=h.to;e=k;"around"==b?(h=this.sel.ranges[f],h=0>B(h.head,h.anchor),a[f]=new J(h?k:g,h?g:k)):a[f]=new J(g,g)}a=new ua(a,this.sel.primIndex)}b=a;for(a=c.length-1;0<=a;a--)Ab(this,
c[a]);b?Ef(this,b):this.cm&&vb(this.cm)}),undo:ba(function(){Vc(this,"undo")}),redo:ba(function(){Vc(this,"redo")}),undoSelection:ba(function(){Vc(this,"undo",!0)}),redoSelection:ba(function(){Vc(this,"redo",!0)}),setExtending:function(a){this.extend=a},getExtending:function(){return this.extend},historySize:function(){for(var a=this.history,b=0,d=0,c=0;c<a.done.length;c++)a.done[c].ranges||++b;for(c=0;c<a.undone.length;c++)a.undone[c].ranges||++d;return{undo:b,redo:d}},clearHistory:function(){var a=
this;this.history=new Qc(this.history.maxGeneration);Sa(this,function(b){return b.history=a.history},!0)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(a){a&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null);return this.history.generation},isClean:function(a){return this.history.generation==(a||this.cleanGeneration)},getHistory:function(){return{done:yb(this.history.done),undone:yb(this.history.undone)}},setHistory:function(a){var b=
this.history=new Qc(this.history.maxGeneration);b.done=yb(a.done.slice(0),null,!0);b.undone=yb(a.undone.slice(0),null,!0)},setGutterMarker:ba(function(a,b,d){return bc(this,a,"gutter",function(c){var e=c.gutterMarkers||(c.gutterMarkers={});e[b]=d;!d&&oe(e)&&(c.gutterMarkers=null);return!0})}),clearGutter:ba(function(a){var b=this;this.iter(function(d){d.gutterMarkers&&d.gutterMarkers[a]&&bc(b,d,"gutter",function(){d.gutterMarkers[a]=null;oe(d.gutterMarkers)&&(d.gutterMarkers=null);return!0})})}),
lineInfo:function(a){if("number"==typeof a){if(!Lb(this,a))return null;var b=a;a=w(this,a);if(!a)return null}else if(b=O(a),null==b)return null;return{line:b,handle:a,text:a.text,gutterMarkers:a.gutterMarkers,textClass:a.textClass,bgClass:a.bgClass,wrapClass:a.wrapClass,widgets:a.widgets}},addLineClass:ba(function(a,b,d){return bc(this,a,"gutter"==b?"gutter":"class",function(c){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass";if(c[e]){if(y(d).test(c[e]))return!1;
c[e]+=" "+d}else c[e]=d;return!0})}),removeLineClass:ba(function(a,b,d){return bc(this,a,"gutter"==b?"gutter":"class",function(c){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass",f=c[e];if(f)if(null==d)c[e]=null;else{var g=f.match(y(d));if(!g)return!1;var h=g.index+g[0].length;c[e]=f.slice(0,g.index)+(g.index&&h!=f.length?" ":"")+f.slice(h)||null}else return!1;return!0})}),addLineWidget:ba(function(a,b,d){return ch(this,a,b,d)}),removeLineWidget:function(a){a.clear()},
markText:function(a,b,d){return Cb(this,C(this,a),C(this,b),d,d&&d.type||"range")},setBookmark:function(a,b){b={replacedWith:b&&(null==b.nodeType?b.widget:b),insertLeft:b&&b.insertLeft,clearWhenEmpty:!1,shared:b&&b.shared,handleMouseEvents:b&&b.handleMouseEvents};a=C(this,a);return Cb(this,a,a,b,"bookmark")},findMarksAt:function(a){a=C(this,a);var b=[],d=w(this,a.line).markedSpans;if(d)for(var c=0;c<d.length;++c){var e=d[c];(null==e.from||e.from<=a.ch)&&(null==e.to||e.to>=a.ch)&&b.push(e.marker.parent||
e.marker)}return b},findMarks:function(a,b,d){a=C(this,a);b=C(this,b);var c=[],e=a.line;this.iter(a.line,b.line+1,function(f){if(f=f.markedSpans)for(var g=0;g<f.length;g++){var h=f[g];null!=h.to&&e==a.line&&a.ch>=h.to||null==h.from&&e!=a.line||null!=h.from&&e==b.line&&h.from>=b.ch||d&&!d(h.marker)||c.push(h.marker.parent||h.marker)}++e});return c},getAllMarks:function(){var a=[];this.iter(function(b){if(b=b.markedSpans)for(var d=0;d<b.length;++d)null!=b[d].from&&a.push(b[d].marker)});return a},posFromIndex:function(a){var b,
d=this.first,c=this.lineSeparator().length;this.iter(function(e){e=e.text.length+c;if(e>a)return b=a,!0;a-=e;++d});return C(this,t(d,b))},indexFromPos:function(a){a=C(this,a);var b=a.ch;if(a.line<this.first||0>a.ch)return 0;var d=this.lineSeparator().length;this.iter(this.first,a.line,function(c){b+=c.text.length+d});return b},copy:function(a){var b=new oa(nd(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);b.scrollTop=this.scrollTop;b.scrollLeft=this.scrollLeft;
b.sel=this.sel;b.extend=!1;a&&(b.history.undoDepth=this.history.undoDepth,b.setHistory(this.getHistory()));return b},linkedDoc:function(a){a||(a={});var b=this.first,d=this.first+this.size;null!=a.from&&a.from>b&&(b=a.from);null!=a.to&&a.to<d&&(d=a.to);b=new oa(nd(this,b,d),a.mode||this.modeOption,b,this.lineSep,this.direction);a.sharedHist&&(b.history=this.history);(this.linked||(this.linked=[])).push({doc:b,sharedHist:a.sharedHist});b.linked=[{doc:this,isParent:!0,sharedHist:a.sharedHist}];a=Sf(this);
for(d=0;d<a.length;d++){var c=a[d],e=c.find(),f=b.clipPos(e.from);e=b.clipPos(e.to);B(f,e)&&(f=Cb(b,f,e,c.primary,c.primary.type),c.markers.push(f),f.parent=c)}return b},unlinkDoc:function(a){a instanceof V&&(a=a.doc);if(this.linked)for(var b=0;b<this.linked.length;++b)if(this.linked[b].doc==a){this.linked.splice(b,1);a.unlinkDoc(this);eh(Sf(this));break}if(a.history==this.history){var d=[a.id];Sa(a,function(c){return d.push(c.id)},!0);a.history=new Qc(null);a.history.done=yb(this.history.done,d);
a.history.undone=yb(this.history.undone,d)}},iterLinkedDocs:function(a){Sa(this,a)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(a){return this.lineSep?a.split(this.lineSep):ke(a)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:ba(function(a){"rtl"!=a&&(a="ltr");a!=this.direction&&(this.direction=a,this.iter(function(b){return b.order=null}),this.cm&&Zg(this.cm))})});oa.prototype.eachLine=oa.prototype.iter;for(var Uf=0,lg=!1,Ua={3:"Pause",
8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",145:"ScrollLock",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",224:"Mod",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",
63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},rc=0;10>rc;rc++)Ua[rc+48]=Ua[rc+96]=String(rc);for(var bd=65;90>=bd;bd++)Ua[bd]=String.fromCharCode(bd);for(var sc=1;12>=sc;sc++)Ua[sc+111]=Ua[sc+63235]="F"+sc;var gc={basic:{Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",
Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},pcDefault:{"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev",
"Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},emacsy:{"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore",
"Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},macDefault:{"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext",
"Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]}};gc["default"]=ya?gc.macDefault:gc.pcDefault;var hc={selectAll:Jf,singleSelection:function(a){return a.setSelection(a.getCursor("anchor"),a.getCursor("head"),Ia)},killLine:function(a){return Eb(a,
function(b){if(b.empty()){var d=w(a.doc,b.head.line).text.length;return b.head.ch==d&&b.head.line<a.lastLine()?{from:b.head,to:t(b.head.line+1,0)}:{from:b.head,to:t(b.head.line,d)}}return{from:b.from(),to:b.to()}})},deleteLine:function(a){return Eb(a,function(b){return{from:t(b.from().line,0),to:C(a.doc,t(b.to().line+1,0))}})},delLineLeft:function(a){return Eb(a,function(b){return{from:t(b.from().line,0),to:b.from()}})},delWrappedLineLeft:function(a){return Eb(a,function(b){var d=a.charCoords(b.head,
"div").top+5;return{from:a.coordsChar({left:0,top:d},"div"),to:b.from()}})},delWrappedLineRight:function(a){return Eb(a,function(b){var d=a.charCoords(b.head,"div").top+5;d=a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:d},"div");return{from:b.from(),to:d}})},undo:function(a){return a.undo()},redo:function(a){return a.redo()},undoSelection:function(a){return a.undoSelection()},redoSelection:function(a){return a.redoSelection()},goDocStart:function(a){return a.extendSelection(t(a.firstLine(),
0))},goDocEnd:function(a){return a.extendSelection(t(a.lastLine()))},goLineStart:function(a){return a.extendSelectionsBy(function(b){return $f(a,b.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(a){return a.extendSelectionsBy(function(b){return ag(a,b.head)},{origin:"+move",bias:1})},goLineEnd:function(a){return a.extendSelectionsBy(function(b){b=b.head.line;var d=w(a.doc,b);var c=d;for(var e;e=qb(c,!1);)c=e.find(1,!0).line;c!=d&&(b=O(c));return ce(!0,a,d,b,-1)},{origin:"+move",bias:-1})},
goLineRight:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:b},"div")},pc)},goLineLeft:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:0,top:b},"div")},pc)},goLineLeftSmart:function(a){return a.extendSelectionsBy(function(b){var d=a.cursorCoords(b.head,"div").top+5;d=a.coordsChar({left:0,top:d},"div");return d.ch<a.getLine(d.line).search(/\S/)?
ag(a,b.head):d},pc)},goLineUp:function(a){return a.moveV(-1,"line")},goLineDown:function(a){return a.moveV(1,"line")},goPageUp:function(a){return a.moveV(-1,"page")},goPageDown:function(a){return a.moveV(1,"page")},goCharLeft:function(a){return a.moveH(-1,"char")},goCharRight:function(a){return a.moveH(1,"char")},goColumnLeft:function(a){return a.moveH(-1,"column")},goColumnRight:function(a){return a.moveH(1,"column")},goWordLeft:function(a){return a.moveH(-1,"word")},goGroupRight:function(a){return a.moveH(1,
"group")},goGroupLeft:function(a){return a.moveH(-1,"group")},goWordRight:function(a){return a.moveH(1,"word")},delCharBefore:function(a){return a.deleteH(-1,"codepoint")},delCharAfter:function(a){return a.deleteH(1,"char")},delWordBefore:function(a){return a.deleteH(-1,"word")},delWordAfter:function(a){return a.deleteH(1,"word")},delGroupBefore:function(a){return a.deleteH(-1,"group")},delGroupAfter:function(a){return a.deleteH(1,"group")},indentAuto:function(a){return a.indentSelection("smart")},
indentMore:function(a){return a.indentSelection("add")},indentLess:function(a){return a.indentSelection("subtract")},insertTab:function(a){return a.replaceSelection("\t")},insertSoftTab:function(a){for(var b=[],d=a.listSelections(),c=a.options.tabSize,e=0;e<d.length;e++){var f=d[e].from();f=wa(a.getLine(f.line),f.ch,c);b.push(fd(c-f%c))}a.replaceSelections(b)},defaultTab:function(a){a.somethingSelected()?a.indentSelection("add"):a.execCommand("insertTab")},transposeChars:function(a){return pa(a,function(){for(var b=
a.listSelections(),d=[],c=0;c<b.length;c++)if(b[c].empty()){var e=b[c].head,f=w(a.doc,e.line).text;if(f)if(e.ch==f.length&&(e=new t(e.line,e.ch-1)),0<e.ch)e=new t(e.line,e.ch+1),a.replaceRange(f.charAt(e.ch-1)+f.charAt(e.ch-2),t(e.line,e.ch-2),e,"+transpose");else if(e.line>a.doc.first){var g=w(a.doc,e.line-1).text;g&&(e=new t(e.line,1),a.replaceRange(f.charAt(0)+a.doc.lineSeparator()+g.charAt(g.length-1),t(e.line-1,g.length-1),e,"+transpose"))}d.push(new J(e,e))}a.setSelections(d)})},newlineAndIndent:function(a){return pa(a,
function(){for(var b=a.listSelections(),d=b.length-1;0<=d;d--)a.replaceRange(a.doc.lineSeparator(),b[d].anchor,b[d].head,"+input");b=a.listSelections();for(d=0;d<b.length;d++)a.indentLine(b[d].from().line,null,!0);vb(a)})},openLine:function(a){return a.replaceSelection("\n","start")},toggleOverwrite:function(a){return a.toggleOverwrite()}},lh=new Va,de=null,ee=function(a,b,d){this.time=a;this.pos=b;this.button=d};ee.prototype.compare=function(a,b,d){return this.time+400>a&&0==B(b,this.pos)&&d==this.button};
var kc,jc,Fb={toString:function(){return"CodeMirror.Init"}},kg={},$c={};V.defaults=kg;V.optionHandlers=$c;var ie=[];V.defineInitHook=function(a){return ie.push(a)};var qa=null,P=function(a){this.cm=a;this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null;this.polling=new Va;this.composing=null;this.gracePeriod=!1;this.readDOMTimeout=null};P.prototype.init=function(a){function b(h){for(h=h.target;h;h=h.parentNode){if(h==g)return!0;if(/\bCodeMirror-(?:line)?widget\b/.test(h.className))break}return!1}
function d(h){if(b(h)&&!Z(f,h)){if(f.somethingSelected())qa={lineWise:!1,text:f.getSelections()},"cut"==h.type&&f.replaceSelection("",null,"cut");else if(f.options.lineWiseCopyCut){var k=og(f);qa={lineWise:!0,text:k.text};"cut"==h.type&&f.operation(function(){f.setSelections(k.ranges,0,Ia);f.replaceSelection("",null,"cut")})}else return;if(h.clipboardData){h.clipboardData.clearData();var l=qa.text.join("\n");h.clipboardData.setData("Text",l);if(h.clipboardData.getData("Text")==l){h.preventDefault();
return}}var m=qg();h=m.firstChild;f.display.lineSpace.insertBefore(m,f.display.lineSpace.firstChild);h.value=qa.text.join("\n");var q=document.activeElement;oc(h);setTimeout(function(){f.display.lineSpace.removeChild(m);q.focus();q==g&&e.showPrimarySelection()},50)}}var c=this,e=this,f=e.cm,g=e.div=a.lineDiv;pg(g,f.options.spellcheck,f.options.autocorrect,f.options.autocapitalize);z(g,"paste",function(h){!b(h)||Z(f,h)||ng(h,f)||11>=U&&setTimeout(aa(f,function(){return c.updateFromDOM()}),20)});z(g,
"compositionstart",function(h){c.composing={data:h.data,done:!1}});z(g,"compositionupdate",function(h){c.composing||(c.composing={data:h.data,done:!1})});z(g,"compositionend",function(h){c.composing&&(h.data!=c.composing.data&&c.readFromDOMSoon(),c.composing.done=!0)});z(g,"touchstart",function(){return e.forceCompositionEnd()});z(g,"input",function(){c.composing||c.readFromDOMSoon()});z(g,"copy",d);z(g,"cut",d)};P.prototype.screenReaderLabelChanged=function(a){a?this.div.setAttribute("aria-label",
a):this.div.removeAttribute("aria-label")};P.prototype.prepareSelection=function(){var a=df(this.cm,!1);a.focus=document.activeElement==this.div;return a};P.prototype.showSelection=function(a,b){a&&this.cm.display.view.length&&((a.focus||b)&&this.showPrimarySelection(),this.showMultipleSelections(a))};P.prototype.getSelection=function(){return this.cm.display.wrapper.ownerDocument.getSelection()};P.prototype.showPrimarySelection=function(){var a=this.getSelection(),b=this.cm,d=b.doc.sel.primary(),
c=d.from();d=d.to();if(b.display.viewTo==b.display.viewFrom||c.line>=b.display.viewTo||d.line<b.display.viewFrom)a.removeAllRanges();else{var e=ad(b,a.anchorNode,a.anchorOffset),f=ad(b,a.focusNode,a.focusOffset);if(!e||e.bad||!f||f.bad||0!=B(Ac(e,f),c)||0!=B(zc(e,f),d))if(e=b.display.view,c=c.line>=b.display.viewFrom&&sg(b,c)||{node:e[0].measure.map[2],offset:0},d=d.line<b.display.viewTo&&sg(b,d),d||(d=e[e.length-1].measure,d=d.maps?d.maps[d.maps.length-1]:d.map,d={node:d[d.length-1],offset:d[d.length-
2]-d[d.length-3]}),c&&d){e=a.rangeCount&&a.getRangeAt(0);try{var g=Ob(c.node,c.offset,d.offset,d.node)}catch(h){}g&&(!Ma&&b.state.focused?(a.collapse(c.node,c.offset),g.collapsed||(a.removeAllRanges(),a.addRange(g))):(a.removeAllRanges(),a.addRange(g)),e&&null==a.anchorNode?a.addRange(e):Ma&&this.startGracePeriod());this.rememberSelection()}else a.removeAllRanges()}};P.prototype.startGracePeriod=function(){var a=this;clearTimeout(this.gracePeriod);this.gracePeriod=setTimeout(function(){a.gracePeriod=
!1;a.selectionChanged()&&a.cm.operation(function(){return a.cm.curOp.selectionChanged=!0})},20)};P.prototype.showMultipleSelections=function(a){D(this.cm.display.cursorDiv,a.cursors);D(this.cm.display.selectionDiv,a.selection)};P.prototype.rememberSelection=function(){var a=this.getSelection();this.lastAnchorNode=a.anchorNode;this.lastAnchorOffset=a.anchorOffset;this.lastFocusNode=a.focusNode;this.lastFocusOffset=a.focusOffset};P.prototype.selectionInEditor=function(){var a=this.getSelection();if(!a.rangeCount)return!1;
a=a.getRangeAt(0).commonAncestorContainer;return ka(this.div,a)};P.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()&&document.activeElement==this.div||this.showSelection(this.prepareSelection(),!0),this.div.focus())};P.prototype.blur=function(){this.div.blur()};P.prototype.getField=function(){return this.div};P.prototype.supportsTouch=function(){return!0};P.prototype.receivedFocus=function(){function a(){b.cm.state.focused&&(b.pollSelection(),b.polling.set(b.cm.options.pollInterval,
a))}var b=this;this.selectionInEditor()?this.pollSelection():pa(this.cm,function(){return b.cm.curOp.selectionChanged=!0});this.polling.set(this.cm.options.pollInterval,a)};P.prototype.selectionChanged=function(){var a=this.getSelection();return a.anchorNode!=this.lastAnchorNode||a.anchorOffset!=this.lastAnchorOffset||a.focusNode!=this.lastFocusNode||a.focusOffset!=this.lastFocusOffset};P.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var a=
this.getSelection(),b=this.cm;if(Gc&&Fc&&this.cm.display.gutterSpecs.length&&Ah(a.anchorNode))this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),this.focus();else if(!this.composing){this.rememberSelection();var d=ad(b,a.anchorNode,a.anchorOffset),c=ad(b,a.focusNode,a.focusOffset);d&&c&&pa(b,function(){da(b.doc,Na(d,c),Ia);if(d.bad||c.bad)b.curOp.selectionChanged=!0})}}};P.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),
this.readDOMTimeout=null);var a=this.cm,b=a.display,d=a.doc.sel.primary(),c=d.from(),e=d.to();0==c.ch&&c.line>a.firstLine()&&(c=t(c.line-1,w(a.doc,c.line-1).length));e.ch==w(a.doc,e.line).text.length&&e.line<a.lastLine()&&(e=t(e.line+1,0));if(c.line<b.viewFrom||e.line>b.viewTo-1)return!1;var f;c.line==b.viewFrom||0==(f=bb(a,c.line))?(d=O(b.view[0].line),f=b.view[0].node):(d=O(b.view[f].line),f=b.view[f-1].node.nextSibling);var g=bb(a,e.line);g==b.view.length-1?(e=b.viewTo-1,b=b.lineDiv.lastChild):
(e=O(b.view[g+1].line)-1,b=b.view[g+1].node.previousSibling);if(!f)return!1;b=a.doc.splitLines(Bh(a,f,b,d,e));for(f=Za(a.doc,t(d,0),t(e,w(a.doc,e).text.length));1<b.length&&1<f.length;)if(L(b)==L(f))b.pop(),f.pop(),e--;else if(b[0]==f[0])b.shift(),f.shift(),d++;else break;var h=0;g=0;for(var k=b[0],l=f[0],m=Math.min(k.length,l.length);h<m&&k.charCodeAt(h)==l.charCodeAt(h);)++h;k=L(b);l=L(f);for(m=Math.min(k.length-(1==b.length?h:0),l.length-(1==f.length?h:0));g<m&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-
g-1);)++g;if(1==b.length&&1==f.length&&d==c.line)for(;h&&h>c.ch&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-g-1);)h--,g++;b[b.length-1]=k.slice(0,k.length-g).replace(/^\u200b+/,"");b[0]=b[0].slice(h).replace(/\u200b+$/,"");c=t(d,h);d=t(e,f.length?L(f).length-g:0);if(1<b.length||b[0]||B(c,d))return Bb(a.doc,b,c,d,"+input"),!0};P.prototype.ensurePolled=function(){this.forceCompositionEnd()};P.prototype.reset=function(){this.forceCompositionEnd()};P.prototype.forceCompositionEnd=function(){this.composing&&
(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())};P.prototype.readFromDOMSoon=function(){var a=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){a.readDOMTimeout=null;if(a.composing)if(a.composing.done)a.composing=null;else return;a.updateFromDOM()},80))};P.prototype.updateFromDOM=function(){var a=this;!this.cm.isReadOnly()&&this.pollContent()||pa(this.cm,function(){return ma(a.cm)})};P.prototype.setUneditable=function(a){a.contentEditable=
"false"};P.prototype.onKeyPress=function(a){0==a.charCode||this.composing||(a.preventDefault(),this.cm.isReadOnly()||aa(this.cm,je)(this.cm,String.fromCharCode(null==a.charCode?a.keyCode:a.charCode),0))};P.prototype.readOnlyChanged=function(a){this.div.contentEditable=String("nocursor"!=a)};P.prototype.onContextMenu=function(){};P.prototype.resetPosition=function(){};P.prototype.needsContentAttribute=!0;var W=function(a){this.cm=a;this.prevInput="";this.pollingFast=!1;this.polling=new Va;this.hasSelection=
!1;this.composing=null};W.prototype.init=function(a){function b(g){if(!Z(e,g)){if(e.somethingSelected())qa={lineWise:!1,text:e.getSelections()};else if(e.options.lineWiseCopyCut){var h=og(e);qa={lineWise:!0,text:h.text};"cut"==g.type?e.setSelections(h.ranges,null,Ia):(c.prevInput="",f.value=h.text.join("\n"),oc(f))}else return;"cut"==g.type&&(e.state.cutIncoming=+new Date)}}var d=this,c=this,e=this.cm;this.createField(a);var f=this.textarea;a.wrapper.insertBefore(this.wrapper,a.wrapper.firstChild);
mc&&(f.style.width="0px");z(f,"input",function(){G&&9<=U&&d.hasSelection&&(d.hasSelection=null);c.poll()});z(f,"paste",function(g){Z(e,g)||ng(g,e)||(e.state.pasteIncoming=+new Date,c.fastPoll())});z(f,"cut",b);z(f,"copy",b);z(a.scroller,"paste",function(g){if(!La(a,g)&&!Z(e,g))if(f.dispatchEvent){var h=new Event("paste");h.clipboardData=g.clipboardData;f.dispatchEvent(h)}else e.state.pasteIncoming=+new Date,c.focus()});z(a.lineSpace,"selectstart",function(g){La(a,g)||la(g)});z(f,"compositionstart",
function(){var g=e.getCursor("from");c.composing&&c.composing.range.clear();c.composing={start:g,range:e.markText(g,e.getCursor("to"),{className:"CodeMirror-composing"})}});z(f,"compositionend",function(){c.composing&&(c.poll(),c.composing.range.clear(),c.composing=null)})};W.prototype.createField=function(a){this.wrapper=qg();this.textarea=this.wrapper.firstChild};W.prototype.screenReaderLabelChanged=function(a){a?this.textarea.setAttribute("aria-label",a):this.textarea.removeAttribute("aria-label")};
W.prototype.prepareSelection=function(){var a=this.cm,b=a.display,d=a.doc,c=df(a);if(a.options.moveInputWithCursor){a=Aa(a,d.sel.primary().head,"div");d=b.wrapper.getBoundingClientRect();var e=b.lineDiv.getBoundingClientRect();c.teTop=Math.max(0,Math.min(b.wrapper.clientHeight-10,a.top+e.top-d.top));c.teLeft=Math.max(0,Math.min(b.wrapper.clientWidth-10,a.left+e.left-d.left))}return c};W.prototype.showSelection=function(a){var b=this.cm.display;D(b.cursorDiv,a.cursors);D(b.selectionDiv,a.selection);
null!=a.teTop&&(this.wrapper.style.top=a.teTop+"px",this.wrapper.style.left=a.teLeft+"px")};W.prototype.reset=function(a){if(!this.contextMenuPending&&!this.composing){var b=this.cm;b.somethingSelected()?(this.prevInput="",a=b.getSelection(),this.textarea.value=a,b.state.focused&&oc(this.textarea),G&&9<=U&&(this.hasSelection=a)):a||(this.prevInput=this.textarea.value="",G&&9<=U&&(this.hasSelection=null))}};W.prototype.getField=function(){return this.textarea};W.prototype.supportsTouch=function(){return!1};
W.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Zb||va()!=this.textarea))try{this.textarea.focus()}catch(a){}};W.prototype.blur=function(){this.textarea.blur()};W.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0};W.prototype.receivedFocus=function(){this.slowPoll()};W.prototype.slowPoll=function(){var a=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){a.poll();a.cm.state.focused&&a.slowPoll()})};W.prototype.fastPoll=
function(){function a(){d.poll()||b?(d.pollingFast=!1,d.slowPoll()):(b=!0,d.polling.set(60,a))}var b=!1,d=this;d.pollingFast=!0;d.polling.set(20,a)};W.prototype.poll=function(){var a=this,b=this.cm,d=this.textarea,c=this.prevInput;if(this.contextMenuPending||!b.state.focused||Gh(d)&&!c&&!this.composing||b.isReadOnly()||b.options.disableInput||b.state.keySeq)return!1;var e=d.value;if(e==c&&!b.somethingSelected())return!1;if(G&&9<=U&&this.hasSelection===e||ya&&/[\uf700-\uf7ff]/.test(e))return b.display.input.reset(),
!1;if(b.doc.sel==b.display.selForContextMenu){var f=e.charCodeAt(0);8203!=f||c||(c="\u200b");if(8666==f)return this.reset(),this.cm.execCommand("undo")}var g=0;for(f=Math.min(c.length,e.length);g<f&&c.charCodeAt(g)==e.charCodeAt(g);)++g;pa(b,function(){je(b,e.slice(g),c.length-g,null,a.composing?"*compose":null);1E3<e.length||-1<e.indexOf("\n")?d.value=a.prevInput="":a.prevInput=e;a.composing&&(a.composing.range.clear(),a.composing.range=b.markText(a.composing.start,b.getCursor("to"),{className:"CodeMirror-composing"}))});
return!0};W.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)};W.prototype.onKeyPress=function(){G&&9<=U&&(this.hasSelection=null);this.fastPoll()};W.prototype.onContextMenu=function(a){function b(){if(null!=g.selectionStart){var p=e.somethingSelected(),r="\u200b"+(p?g.value:"");g.value="\u21da";g.value=r;c.prevInput=p?"":"\u200b";g.selectionStart=1;g.selectionEnd=r.length;f.selForContextMenu=e.doc.sel}}function d(){if(c.contextMenuPending==d&&(c.contextMenuPending=
!1,c.wrapper.style.cssText=m,g.style.cssText=l,G&&9>U&&f.scrollbars.setScrollTop(f.scroller.scrollTop=k),null!=g.selectionStart)){(!G||G&&9>U)&&b();var p=0,r=function(){f.selForContextMenu==e.doc.sel&&0==g.selectionStart&&0<g.selectionEnd&&"\u200b"==c.prevInput?aa(e,Jf)(e):10>p++?f.detectingSelectAll=setTimeout(r,500):(f.selForContextMenu=null,f.input.reset())};f.detectingSelectAll=setTimeout(r,200)}}var c=this,e=c.cm,f=e.display,g=c.textarea;c.contextMenuPending&&c.contextMenuPending();var h=eb(e,
a),k=f.scroller.scrollTop;if(h&&!Ba){e.options.resetSelectionOnContextMenu&&-1==e.doc.sel.contains(h)&&aa(e,da)(e.doc,Na(h),Ia);var l=g.style.cssText,m=c.wrapper.style.cssText;h=c.wrapper.offsetParent.getBoundingClientRect();c.wrapper.style.cssText="position: static";g.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(a.clientY-h.top-5)+"px; left: "+(a.clientX-h.left-5)+"px;\n      z-index: 1000; background: "+(G?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
if(fa)var q=window.scrollY;f.input.focus();fa&&window.scrollTo(null,q);f.input.reset();e.somethingSelected()||(g.value=c.prevInput=" ");c.contextMenuPending=d;f.selForContextMenu=e.doc.sel;clearTimeout(f.detectingSelectAll);G&&9<=U&&b();if(fe){Kb(a);var n=function(){ra(window,"mouseup",n);setTimeout(d,20)};z(window,"mouseup",n)}else setTimeout(d,50)}};W.prototype.readOnlyChanged=function(a){a||this.reset();this.textarea.disabled="nocursor"==a;this.textarea.readOnly=!!a};W.prototype.setUneditable=
function(){};W.prototype.needsContentAttribute=!1;(function(a){function b(c,e,f,g){a.defaults[c]=e;f&&(d[c]=g?function(h,k,l){l!=Fb&&f(h,k,l)}:f)}var d=a.optionHandlers;a.defineOption=b;a.Init=Fb;b("value","",function(c,e){return c.setValue(e)},!0);b("mode",null,function(c,e){c.doc.modeOption=e;Wd(c)},!0);b("indentUnit",2,Wd,!0);b("indentWithTabs",!1);b("smartIndent",!0);b("tabSize",4,function(c){$b(c);Sb(c);ma(c)},!0);b("lineSeparator",null,function(c,e){if(c.doc.lineSep=e){var f=[],g=c.doc.first;
c.doc.iter(function(k){for(var l=0;;){var m=k.text.indexOf(e,l);if(-1==m)break;l=m+e.length;f.push(t(g,m))}g++});for(var h=f.length-1;0<=h;h--)Bb(c.doc,e,f[h],t(f[h].line,f[h].ch+e.length))}});b("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g,function(c,e,f){c.state.specialChars=new RegExp(e.source+(e.test("\t")?"":"|\t"),"g");f!=Fb&&c.refresh()});b("specialCharPlaceholder",Lg,function(c){return c.refresh()},!0);b("electricChars",
!0);b("inputStyle",Zb?"contenteditable":"textarea",function(){throw Error("inputStyle can not (yet) be changed in a running editor");},!0);b("spellcheck",!1,function(c,e){return c.getInputField().spellcheck=e},!0);b("autocorrect",!1,function(c,e){return c.getInputField().autocorrect=e},!0);b("autocapitalize",!1,function(c,e){return c.getInputField().autocapitalize=e},!0);b("rtlMoveVisually",!Fh);b("wholeLineUpdateBefore",!0);b("theme","default",function(c){jg(c);Yb(c)},!0);b("keyMap","default",function(c,
e,f){e=Wc(e);(f=f!=Fb&&Wc(f))&&f.detach&&f.detach(c,e);e.attach&&e.attach(c,f||null)});b("extraKeys",null);b("configureMouse",null);b("lineWrapping",!1,yh,!0);b("gutters",[],function(c,e){c.display.gutterSpecs=Ud(e,c.options.lineNumbers);Yb(c)},!0);b("fixedGutter",!0,function(c,e){c.display.gutters.style.left=e?Kd(c.display)+"px":"0";c.refresh()},!0);b("coverGutterNextToScrollbar",!1,function(c){return wb(c)},!0);b("scrollbarStyle","native",function(c){nf(c);wb(c);c.display.scrollbars.setScrollTop(c.doc.scrollTop);
c.display.scrollbars.setScrollLeft(c.doc.scrollLeft)},!0);b("lineNumbers",!1,function(c,e){c.display.gutterSpecs=Ud(c.options.gutters,e);Yb(c)},!0);b("firstLineNumber",1,Yb,!0);b("lineNumberFormatter",function(c){return c},Yb,!0);b("showCursorWhenSelecting",!1,Tb,!0);b("resetSelectionOnContextMenu",!0);b("lineWiseCopyCut",!0);b("pasteLinesPerSelection",!0);b("selectionsMayTouch",!1);b("readOnly",!1,function(c,e){"nocursor"==e&&(ub(c),c.display.input.blur());c.display.input.readOnlyChanged(e)});b("screenReaderLabel",
null,function(c,e){c.display.input.screenReaderLabelChanged(""===e?null:e)});b("disableInput",!1,function(c,e){e||c.display.input.reset()},!0);b("dragDrop",!0,xh);b("allowDropFileTypes",null);b("cursorBlinkRate",530);b("cursorScrollMargin",0);b("cursorHeight",1,Tb,!0);b("singleCursorHeightPerLine",!0,Tb,!0);b("workTime",100);b("workDelay",100);b("flattenSpans",!0,$b,!0);b("addModeClass",!1,$b,!0);b("pollInterval",100);b("undoDepth",200,function(c,e){return c.doc.history.undoDepth=e});b("historyEventDelay",
1250);b("viewportMargin",10,function(c){return c.refresh()},!0);b("maxHighlightLength",1E4,$b,!0);b("moveInputWithCursor",!0,function(c,e){e||c.display.input.resetPosition()});b("tabindex",null,function(c,e){return c.display.input.getField().tabIndex=e||""});b("autofocus",null);b("direction","ltr",function(c,e){return c.doc.setDirection(e)},!0);b("phrases",null)})(V);(function(a){var b=a.optionHandlers,d=a.helpers={};a.prototype={constructor:a,focus:function(){window.focus();this.display.input.focus()},
setOption:function(c,e){var f=this.options,g=f[c];if(f[c]!=e||"mode"==c)f[c]=e,b.hasOwnProperty(c)&&aa(this,b[c])(this,e,g),X(this,"optionChange",this,c)},getOption:function(c){return this.options[c]},getDoc:function(){return this.doc},addKeyMap:function(c,e){this.state.keyMaps[e?"push":"unshift"](Wc(c))},removeKeyMap:function(c){for(var e=this.state.keyMaps,f=0;f<e.length;++f)if(e[f]==c||e[f].name==c)return e.splice(f,1),!0},addOverlay:ia(function(c,e){var f=c.token?c:a.getMode(this.options,c);if(f.startState)throw Error("Overlays may not be stateful.");
wg(this.state.overlays,{mode:f,modeSpec:c,opaque:e&&e.opaque,priority:e&&e.priority||0},function(g){return g.priority});this.state.modeGen++;ma(this)}),removeOverlay:ia(function(c){for(var e=this.state.overlays,f=0;f<e.length;++f){var g=e[f].modeSpec;if(g==c||"string"==typeof c&&g.name==c){e.splice(f,1);this.state.modeGen++;ma(this);break}}}),indentLine:ia(function(c,e,f){"string"!=typeof e&&"number"!=typeof e&&(e=null==e?this.options.smartIndent?"smart":"prev":e?"add":"subtract");Lb(this.doc,c)&&
lc(this,c,e,f)}),indentSelection:ia(function(c){for(var e=this.doc.sel.ranges,f=-1,g=0;g<e.length;g++){var h=e[g];if(h.empty())h.head.line>f&&(lc(this,h.head.line,c,!0),f=h.head.line,g==this.doc.sel.primIndex&&vb(this));else{var k=h.from();h=h.to();var l=Math.max(f,k.line);f=Math.min(this.lastLine(),h.line-(h.ch?0:1))+1;for(h=l;h<f;++h)lc(this,h,c);h=this.doc.sel.ranges;0==k.ch&&e.length==h.length&&0<h[g].from().ch&&$d(this.doc,g,new J(k,h[g].to()),Ia)}}}),getTokenAt:function(c,e){return ze(this,
c,e)},getLineTokens:function(c,e){return ze(this,t(c),e,!0)},getTokenTypeAt:function(c){c=C(this.doc,c);var e=xe(this,w(this.doc,c.line)),f=0,g=(e.length-1)/2;c=c.ch;if(0==c)e=e[2];else for(;;){var h=f+g>>1;if((h?e[2*h-1]:0)>=c)g=h;else if(e[2*h+1]<c)f=h+1;else{e=e[2*h+2];break}}f=e?e.indexOf("overlay "):-1;return 0>f?e:0==f?null:e.slice(0,f-1)},getModeAt:function(c){var e=this.doc.mode;return e.innerMode?a.innerMode(e,this.getTokenAt(c).state).mode:e},getHelper:function(c,e){return this.getHelpers(c,
e)[0]},getHelpers:function(c,e){var f=[];if(!d.hasOwnProperty(e))return f;var g=d[e];c=this.getModeAt(c);if("string"==typeof c[e])g[c[e]]&&f.push(g[c[e]]);else if(c[e])for(var h=0;h<c[e].length;h++){var k=g[c[e][h]];k&&f.push(k)}else c.helperType&&g[c.helperType]?f.push(g[c.helperType]):g[c.name]&&f.push(g[c.name]);for(e=0;e<g._global.length;e++)h=g._global[e],h.pred(c,this)&&-1==ea(f,h.val)&&f.push(h.val);return f},getStateAfter:function(c,e){var f=this.doc;c=Math.max(f.first,Math.min(null==c?f.first+
f.size-1:c,f.first+f.size-1));return Mb(this,c+1,e).state},cursorCoords:function(c,e){var f=this.doc.sel.primary();c=null==c?f.head:"object"==typeof c?C(this.doc,c):c?f.from():f.to();return Aa(this,c,e||"page")},charCoords:function(c,e){return Gd(this,C(this.doc,c),e||"page")},coordsChar:function(c,e){c=Ye(this,c,e||"page");return Id(this,c.left,c.top)},lineAtHeight:function(c,e){c=Ye(this,{top:c,left:0},e||"page").top;return $a(this.doc,c+this.display.viewOffset)},heightAtLine:function(c,e,f){var g=
!1;if("number"==typeof c){var h=this.doc.first+this.doc.size-1;c<this.doc.first?c=this.doc.first:c>h&&(c=h,g=!0);c=w(this.doc,c)}return Hc(this,c,{top:0,left:0},e||"page",f||g).top+(g?this.doc.height-Ga(c):0)},defaultTextHeight:function(){return tb(this.display)},defaultCharWidth:function(){return sb(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(c,e,f,g,h){var k=this.display;c=Aa(this,C(this.doc,c));var l=c.bottom,m=c.left;e.style.position=
"absolute";e.setAttribute("cm-ignore-events","true");this.display.input.setUneditable(e);k.sizer.appendChild(e);if("over"==g)l=c.top;else if("above"==g||"near"==g){var q=Math.max(k.wrapper.clientHeight,this.doc.height),n=Math.max(k.sizer.clientWidth,k.lineSpace.clientWidth);("above"==g||c.bottom+e.offsetHeight>q)&&c.top>e.offsetHeight?l=c.top-e.offsetHeight:c.bottom+e.offsetHeight<=q&&(l=c.bottom);m+e.offsetWidth>n&&(m=n-e.offsetWidth)}e.style.top=l+"px";e.style.left=e.style.right="";"right"==h?(m=
k.sizer.clientWidth-e.offsetWidth,e.style.right="0px"):("left"==h?m=0:"middle"==h&&(m=(k.sizer.clientWidth-e.offsetWidth)/2),e.style.left=m+"px");f&&(c=Pd(this,{left:m,top:l,right:m+e.offsetWidth,bottom:l+e.offsetHeight}),null!=c.scrollTop&&Vb(this,c.scrollTop),null!=c.scrollLeft&&ib(this,c.scrollLeft))},triggerOnKeyDown:ia(dg),triggerOnKeyPress:ia(fg),triggerOnKeyUp:eg,triggerOnMouseDown:ia(gg),execCommand:function(c){if(hc.hasOwnProperty(c))return hc[c].call(null,this)},triggerElectric:ia(function(c){mg(this,
c)}),findPosH:function(c,e,f,g){var h=1;0>e&&(h=-1,e=-e);c=C(this.doc,c);for(var k=0;k<e&&(c=le(this.doc,c,h,f,g),!c.hitSide);++k);return c},moveH:ia(function(c,e){var f=this;this.extendSelectionsBy(function(g){return f.display.shift||f.doc.extend||g.empty()?le(f.doc,g.head,c,e,f.options.rtlMoveVisually):0>c?g.from():g.to()},pc)}),deleteH:ia(function(c,e){var f=this.doc;this.doc.sel.somethingSelected()?f.replaceSelection("",null,"+delete"):Eb(this,function(g){var h=le(f,g.head,c,e,!1);return 0>c?
{from:h,to:g.head}:{from:g.head,to:h}})}),findPosV:function(c,e,f,g){var h=1;0>e&&(h=-1,e=-e);var k=C(this.doc,c);for(c=0;c<e&&(k=Aa(this,k,"div"),null==g?g=k.left:k.left=g,k=rg(this,k,h,f),!k.hitSide);++c);return k},moveV:ia(function(c,e){var f=this,g=this.doc,h=[],k=!this.display.shift&&!g.extend&&g.sel.somethingSelected();g.extendSelectionsBy(function(m){if(k)return 0>c?m.from():m.to();var q=Aa(f,m.head,"div");null!=m.goalColumn&&(q.left=m.goalColumn);h.push(q.left);var n=rg(f,q,c,e);"page"==e&&
m==g.sel.primary()&&Mc(f,Gd(f,n,"div").top-q.top);return n},pc);if(h.length)for(var l=0;l<g.sel.ranges.length;l++)g.sel.ranges[l].goalColumn=h[l]}),findWordAt:function(c){var e=w(this.doc,c.line).text,f=c.ch,g=c.ch;if(e){var h=this.getHelper(c,"wordChars");"before"!=c.sticky&&g!=e.length||!f?++g:--f;var k=e.charAt(f);for(k=wc(k,h)?function(l){return wc(l,h)}:/\s/.test(k)?function(l){return/\s/.test(l)}:function(l){return!/\s/.test(l)&&!wc(l)};0<f&&k(e.charAt(f-1));)--f;for(;g<e.length&&k(e.charAt(g));)++g}return new J(t(c.line,
f),t(c.line,g))},toggleOverwrite:function(c){if(null==c||c!=this.state.overwrite)(this.state.overwrite=!this.state.overwrite)?Wa(this.display.cursorDiv,"CodeMirror-overwrite"):hb(this.display.cursorDiv,"CodeMirror-overwrite"),X(this,"overwriteToggle",this,this.state.overwrite)},hasFocus:function(){return this.display.input.getField()==va()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:ia(function(c,e){Ub(this,c,e)}),getScrollInfo:function(){var c=this.display.scroller;
return{left:c.scrollLeft,top:c.scrollTop,height:c.scrollHeight-Ha(this)-this.display.barHeight,width:c.scrollWidth-Ha(this)-this.display.barWidth,clientHeight:Bd(this),clientWidth:ab(this)}},scrollIntoView:ia(function(c,e){null==c?(c={from:this.doc.sel.primary().head,to:null},null==e&&(e=this.options.cursorScrollMargin)):"number"==typeof c?c={from:t(c,0),to:null}:null==c.from&&(c={from:c,to:null});c.to||(c.to=c.from);c.margin=e||0;null!=c.from.line?(Nc(this),this.curOp.scrollToPos=c):jf(this,c.from,
c.to,c.margin)}),setSize:ia(function(c,e){var f=this,g=function(k){return"number"==typeof k||/^\d+$/.test(String(k))?k+"px":k};null!=c&&(this.display.wrapper.style.width=g(c));null!=e&&(this.display.wrapper.style.height=g(e));this.options.lineWrapping&&Ve(this);var h=this.display.viewFrom;this.doc.iter(h,this.display.viewTo,function(k){if(k.widgets)for(var l=0;l<k.widgets.length;l++)if(k.widgets[l].noHScroll){Qa(f,h,"widget");break}++h});this.curOp.forceUpdate=!0;X(this,"refresh",this)}),operation:function(c){return pa(this,
c)},startOperation:function(){return jb(this)},endOperation:function(){return kb(this)},refresh:ia(function(){var c=this.display.cachedTextHeight;ma(this);this.curOp.forceUpdate=!0;Sb(this);Ub(this,this.doc.scrollLeft,this.doc.scrollTop);Td(this.display);(null==c||.5<Math.abs(c-tb(this.display))||this.options.lineWrapping)&&Ld(this);X(this,"refresh",this)}),swapDoc:ia(function(c){var e=this.doc;e.cm=null;this.state.selectingText&&this.state.selectingText();xf(this,c);Sb(this);this.display.input.reset();
Ub(this,c.scrollLeft,c.scrollTop);this.curOp.forceScroll=!0;ca(this,"swapDoc",this,e);return e}),phrase:function(c){var e=this.options.phrases;return e&&Object.prototype.hasOwnProperty.call(e,c)?e[c]:c},getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}};nb(a);a.registerHelper=function(c,e,f){d.hasOwnProperty(c)||
(d[c]=a[c]={_global:[]});d[c][e]=f};a.registerGlobalHelper=function(c,e,f,g){a.registerHelper(c,e,g);d[c]._global.push({pred:f,val:g})}})(V);var Ih="iter insert remove copy getEditor constructor".split(" "),tc;for(tc in oa.prototype)oa.prototype.hasOwnProperty(tc)&&0>ea(Ih,tc)&&(V.prototype[tc]=function(a){return function(){return a.apply(this.doc,arguments)}}(oa.prototype[tc]));nb(oa);V.inputStyles={textarea:W,contenteditable:P};V.defineMode=function(a){V.defaults.mode||"null"==a||(V.defaults.mode=
a);Cg.apply(this,arguments)};V.defineMIME=function(a,b){ob[a]=b};V.defineMode("null",function(){return{token:function(a){return a.skipToEnd()}}});V.defineMIME("text/plain","null");V.defineExtension=function(a,b){V.prototype[a]=b};V.defineDocExtension=function(a,b){oa.prototype[a]=b};V.fromTextArea=function(a,b){function d(){a.value=h.getValue()}b=b?Xa(b):{};b.value=a.value;!b.tabindex&&a.tabIndex&&(b.tabindex=a.tabIndex);!b.placeholder&&a.placeholder&&(b.placeholder=a.placeholder);if(null==b.autofocus){var c=
va();b.autofocus=c==a||null!=a.getAttribute("autofocus")&&c==document.body}if(a.form&&(z(a.form,"submit",d),!b.leaveSubmitMethodAlone)){var e=a.form;var f=e.submit;try{var g=e.submit=function(){d();e.submit=f;e.submit();e.submit=g}}catch(k){}}b.finishInit=function(k){k.save=d;k.getTextArea=function(){return a};k.toTextArea=function(){k.toTextArea=isNaN;d();a.parentNode.removeChild(k.getWrapperElement());a.style.display="";a.form&&(ra(a.form,"submit",d),b.leaveSubmitMethodAlone||"function"!=typeof a.form.submit||
(a.form.submit=f))}};a.style.display="none";var h=V(function(k){return a.parentNode.insertBefore(k,a.nextSibling)},b);return h};(function(a){a.off=ra;a.on=z;a.wheelEventPixels=Yg;a.Doc=oa;a.splitLines=ke;a.countColumn=wa;a.findColumn=ed;a.isWordChar=gd;a.Pass=Yc;a.signal=X;a.Line=xb;a.changeEnd=Ra;a.scrollbarModel=of;a.Pos=t;a.cmpPos=B;a.modes=kd;a.mimeModes=ob;a.resolveMode=yc;a.getMode=ld;a.modeExtensions=pb;a.extendMode=Dg;a.copyState=Ya;a.startState=te;a.innerMode=md;a.commands=hc;a.keyMap=gc;
a.keyName=Zf;a.isModifierKey=Wf;a.lookupKey=Db;a.normalizeKeyMap=jh;a.StringStream=Y;a.SharedTextMarker=fc;a.TextMarker=Ta;a.LineWidget=ec;a.e_preventDefault=la;a.e_stopPropagation=re;a.e_stop=Kb;a.addClass=Wa;a.contains=ka;a.rmClass=hb;a.keyNames=Ua})(V);V.version="5.58.1";return V});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
/*!
 * collection-visit <https://github.com/jonschlinkert/collection-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var visit = require('object-visit');
var mapVisit = require('map-visit');

module.exports = function(collection, method, val) {
  var result;

  if (typeof val === 'string' && (method in collection)) {
    var args = [].slice.call(arguments, 2);
    result = collection[method].apply(collection, args);
  } else if (Array.isArray(val)) {
    result = mapVisit.apply(null, arguments);
  } else {
    result = visit.apply(null, arguments);
  }

  if (typeof result !== 'undefined') {
    return result;
  }

  return collection;
};

},{"map-visit":101,"object-visit":120}],37:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],38:[function(require,module,exports){
module.exports={
  "O_RDONLY": 0,
  "O_WRONLY": 1,
  "O_RDWR": 2,
  "S_IFMT": 61440,
  "S_IFREG": 32768,
  "S_IFDIR": 16384,
  "S_IFCHR": 8192,
  "S_IFBLK": 24576,
  "S_IFIFO": 4096,
  "S_IFLNK": 40960,
  "S_IFSOCK": 49152,
  "O_CREAT": 512,
  "O_EXCL": 2048,
  "O_NOCTTY": 131072,
  "O_TRUNC": 1024,
  "O_APPEND": 8,
  "O_DIRECTORY": 1048576,
  "O_NOFOLLOW": 256,
  "O_SYNC": 128,
  "O_SYMLINK": 2097152,
  "O_NONBLOCK": 4,
  "S_IRWXU": 448,
  "S_IRUSR": 256,
  "S_IWUSR": 128,
  "S_IXUSR": 64,
  "S_IRWXG": 56,
  "S_IRGRP": 32,
  "S_IWGRP": 16,
  "S_IXGRP": 8,
  "S_IRWXO": 7,
  "S_IROTH": 4,
  "S_IWOTH": 2,
  "S_IXOTH": 1,
  "E2BIG": 7,
  "EACCES": 13,
  "EADDRINUSE": 48,
  "EADDRNOTAVAIL": 49,
  "EAFNOSUPPORT": 47,
  "EAGAIN": 35,
  "EALREADY": 37,
  "EBADF": 9,
  "EBADMSG": 94,
  "EBUSY": 16,
  "ECANCELED": 89,
  "ECHILD": 10,
  "ECONNABORTED": 53,
  "ECONNREFUSED": 61,
  "ECONNRESET": 54,
  "EDEADLK": 11,
  "EDESTADDRREQ": 39,
  "EDOM": 33,
  "EDQUOT": 69,
  "EEXIST": 17,
  "EFAULT": 14,
  "EFBIG": 27,
  "EHOSTUNREACH": 65,
  "EIDRM": 90,
  "EILSEQ": 92,
  "EINPROGRESS": 36,
  "EINTR": 4,
  "EINVAL": 22,
  "EIO": 5,
  "EISCONN": 56,
  "EISDIR": 21,
  "ELOOP": 62,
  "EMFILE": 24,
  "EMLINK": 31,
  "EMSGSIZE": 40,
  "EMULTIHOP": 95,
  "ENAMETOOLONG": 63,
  "ENETDOWN": 50,
  "ENETRESET": 52,
  "ENETUNREACH": 51,
  "ENFILE": 23,
  "ENOBUFS": 55,
  "ENODATA": 96,
  "ENODEV": 19,
  "ENOENT": 2,
  "ENOEXEC": 8,
  "ENOLCK": 77,
  "ENOLINK": 97,
  "ENOMEM": 12,
  "ENOMSG": 91,
  "ENOPROTOOPT": 42,
  "ENOSPC": 28,
  "ENOSR": 98,
  "ENOSTR": 99,
  "ENOSYS": 78,
  "ENOTCONN": 57,
  "ENOTDIR": 20,
  "ENOTEMPTY": 66,
  "ENOTSOCK": 38,
  "ENOTSUP": 45,
  "ENOTTY": 25,
  "ENXIO": 6,
  "EOPNOTSUPP": 102,
  "EOVERFLOW": 84,
  "EPERM": 1,
  "EPIPE": 32,
  "EPROTO": 100,
  "EPROTONOSUPPORT": 43,
  "EPROTOTYPE": 41,
  "ERANGE": 34,
  "EROFS": 30,
  "ESPIPE": 29,
  "ESRCH": 3,
  "ESTALE": 70,
  "ETIME": 101,
  "ETIMEDOUT": 60,
  "ETXTBSY": 26,
  "EWOULDBLOCK": 35,
  "EXDEV": 18,
  "SIGHUP": 1,
  "SIGINT": 2,
  "SIGQUIT": 3,
  "SIGILL": 4,
  "SIGTRAP": 5,
  "SIGABRT": 6,
  "SIGIOT": 6,
  "SIGBUS": 10,
  "SIGFPE": 8,
  "SIGKILL": 9,
  "SIGUSR1": 30,
  "SIGSEGV": 11,
  "SIGUSR2": 31,
  "SIGPIPE": 13,
  "SIGALRM": 14,
  "SIGTERM": 15,
  "SIGCHLD": 20,
  "SIGCONT": 19,
  "SIGSTOP": 17,
  "SIGTSTP": 18,
  "SIGTTIN": 21,
  "SIGTTOU": 22,
  "SIGURG": 16,
  "SIGXCPU": 24,
  "SIGXFSZ": 25,
  "SIGVTALRM": 26,
  "SIGPROF": 27,
  "SIGWINCH": 28,
  "SIGIO": 23,
  "SIGSYS": 12,
  "SSL_OP_ALL": 2147486719,
  "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
  "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
  "SSL_OP_CISCO_ANYCONNECT": 32768,
  "SSL_OP_COOKIE_EXCHANGE": 8192,
  "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
  "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
  "SSL_OP_EPHEMERAL_RSA": 0,
  "SSL_OP_LEGACY_SERVER_CONNECT": 4,
  "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
  "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
  "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
  "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
  "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
  "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
  "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
  "SSL_OP_NO_COMPRESSION": 131072,
  "SSL_OP_NO_QUERY_MTU": 4096,
  "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
  "SSL_OP_NO_SSLv2": 16777216,
  "SSL_OP_NO_SSLv3": 33554432,
  "SSL_OP_NO_TICKET": 16384,
  "SSL_OP_NO_TLSv1": 67108864,
  "SSL_OP_NO_TLSv1_1": 268435456,
  "SSL_OP_NO_TLSv1_2": 134217728,
  "SSL_OP_PKCS1_CHECK_1": 0,
  "SSL_OP_PKCS1_CHECK_2": 0,
  "SSL_OP_SINGLE_DH_USE": 1048576,
  "SSL_OP_SINGLE_ECDH_USE": 524288,
  "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
  "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
  "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
  "SSL_OP_TLS_D5_BUG": 256,
  "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
  "ENGINE_METHOD_DSA": 2,
  "ENGINE_METHOD_DH": 4,
  "ENGINE_METHOD_RAND": 8,
  "ENGINE_METHOD_ECDH": 16,
  "ENGINE_METHOD_ECDSA": 32,
  "ENGINE_METHOD_CIPHERS": 64,
  "ENGINE_METHOD_DIGESTS": 128,
  "ENGINE_METHOD_STORE": 256,
  "ENGINE_METHOD_PKEY_METHS": 512,
  "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
  "ENGINE_METHOD_ALL": 65535,
  "ENGINE_METHOD_NONE": 0,
  "DH_CHECK_P_NOT_SAFE_PRIME": 2,
  "DH_CHECK_P_NOT_PRIME": 1,
  "DH_UNABLE_TO_CHECK_GENERATOR": 4,
  "DH_NOT_SUITABLE_GENERATOR": 8,
  "NPN_ENABLED": 1,
  "RSA_PKCS1_PADDING": 1,
  "RSA_SSLV23_PADDING": 2,
  "RSA_NO_PADDING": 3,
  "RSA_PKCS1_OAEP_PADDING": 4,
  "RSA_X931_PADDING": 5,
  "RSA_PKCS1_PSS_PADDING": 6,
  "POINT_CONVERSION_COMPRESSED": 2,
  "POINT_CONVERSION_UNCOMPRESSED": 4,
  "POINT_CONVERSION_HYBRID": 6,
  "F_OK": 0,
  "R_OK": 4,
  "W_OK": 2,
  "X_OK": 1,
  "UV_UDP_REUSEADDR": 4
}

},{}],39:[function(require,module,exports){
/*!
 * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {
 *   this.cache = {};
 * }
 * App.prototype.set = function(key, val) {
 *   this.cache[key] = val;
 *   return this;
 * };
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this.cache).length;
 *   }
 * });
 *
 * copy(App.prototype, 'count', 'len');
 *
 * // create an instance
 * var app = new App();
 *
 * app.set('a', true);
 * app.set('b', true);
 * app.set('c', true);
 *
 * console.log(app.count);
 * //=> 3
 * console.log(app.len);
 * //=> 3
 * ```
 * @name copy
 * @param {Object} `receiver` The target object
 * @param {Object} `provider` The provider object
 * @param {String} `from` The key to copy on provider.
 * @param {String} `to` Optionally specify a new key name to use.
 * @return {Object}
 * @api public
 */

module.exports = function copyDescriptor(receiver, provider, from, to) {
  if (!isObject(provider) && typeof provider !== 'function') {
    to = from;
    from = provider;
    provider = receiver;
  }
  if (!isObject(receiver) && typeof receiver !== 'function') {
    throw new TypeError('expected the first argument to be an object');
  }
  if (!isObject(provider) && typeof provider !== 'function') {
    throw new TypeError('expected provider to be an object');
  }

  if (typeof to !== 'string') {
    to = from;
  }
  if (typeof from !== 'string') {
    throw new TypeError('expected key to be a string');
  }

  if (!(from in provider)) {
    throw new Error('property "' + from + '" does not exist');
  }

  var val = Object.getOwnPropertyDescriptor(provider, from);
  if (val) Object.defineProperty(receiver, to, val);
};

function isObject(val) {
  return {}.toString.call(val) === '[object Object]';
}


},{}],40:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":84}],41:[function(require,module,exports){
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

},{"./debug":42,"_process":128}],42:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":109}],43:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isobject = require('isobject');
var isDescriptor = require('is-descriptor');
var define = (typeof Reflect !== 'undefined' && Reflect.defineProperty)
  ? Reflect.defineProperty
  : Object.defineProperty;

module.exports = function defineProperty(obj, key, val) {
  if (!isobject(obj) && typeof obj !== 'function' && !Array.isArray(obj)) {
    throw new TypeError('expected an object, function, or array');
  }

  if (typeof key !== 'string') {
    throw new TypeError('expected "key" to be a string');
  }

  if (isDescriptor(val)) {
    define(obj, key, val);
    return obj;
  }

  define(obj, key, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });

  return obj;
};

},{"is-descriptor":46,"isobject":97}],44:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":99}],45:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"kind-of":99}],46:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"is-accessor-descriptor":44,"is-data-descriptor":45,"kind-of":99}],47:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');

/**
 * Module dependencies
 */

var debug = require('debug')('expand-brackets');
var extend = require('extend-shallow');
var Snapdragon = require('snapdragon');
var toRegex = require('to-regex');

/**
 * Parses the given POSIX character class `pattern` and returns a
 * string that can be used for creating regular expressions for matching.
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

function brackets(pattern, options) {
  debug('initializing from <%s>', __filename);
  var res = brackets.create(pattern, options);
  return res.output;
}

/**
 * Takes an array of strings and a POSIX character class pattern, and returns a new
 * array with only the strings that matched the pattern.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]'));
 * //=> ['a']
 *
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]+'));
 * //=> ['a', 'ab']
 * ```
 * @param {Array} `arr` Array of strings to match
 * @param {String} `pattern` POSIX character class pattern(s)
 * @param {Object} `options`
 * @return {Array}
 * @api public
 */

brackets.match = function(arr, pattern, options) {
  arr = [].concat(arr);
  var opts = extend({}, options);
  var isMatch = brackets.matcher(pattern, opts);
  var len = arr.length;
  var idx = -1;
  var res = [];

  while (++idx < len) {
    var ele = arr[idx];
    if (isMatch(ele)) {
      res.push(ele);
    }
  }

  if (res.length === 0) {
    if (opts.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }

    if (opts.nonull === true || opts.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }
  return res;
};

/**
 * Returns true if the specified `string` matches the given
 * brackets `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 *
 * console.log(brackets.isMatch('a.a', '[[:alpha:]].[[:alpha:]]'));
 * //=> true
 * console.log(brackets.isMatch('1.2', '[[:alpha:]].[[:alpha:]]'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

brackets.isMatch = function(str, pattern, options) {
  return brackets.matcher(pattern, options)(str);
};

/**
 * Takes a POSIX character class pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var isMatch = brackets.matcher('[[:lower:]].[[:upper:]]');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.A'));
 * //=> true
 * ```
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

brackets.matcher = function(pattern, options) {
  var re = brackets.makeRe(pattern, options);
  return function(str) {
    return re.test(str);
  };
};

/**
 * Create a regular expression from the given `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var re = brackets.makeRe('[[:alpha:]]');
 * console.log(re);
 * //=> /^(?:[a-zA-Z])$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

brackets.makeRe = function(pattern, options) {
  var res = brackets.create(pattern, options);
  var opts = extend({strictErrors: false}, options);
  return toRegex(res.output, opts);
};

/**
 * Parses the given POSIX character class `pattern` and returns an object
 * with the compiled `output` and optional source `map`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets('[[:alpha:]]'));
 * // { options: { source: 'string' },
 * //   input: '[[:alpha:]]',
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      not: [Function],
 * //      escape: [Function],
 * //      text: [Function],
 * //      posix: [Function],
 * //      bracket: [Function],
 * //      'bracket.open': [Function],
 * //      'bracket.inner': [Function],
 * //      'bracket.literal': [Function],
 * //      'bracket.close': [Function] },
 * //   output: '[a-zA-Z]',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes: [ [Object], [Object], [Object] ] },
 * //   parsingErrors: [] }
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

brackets.create = function(pattern, options) {
  var snapdragon = (options && options.snapdragon) || new Snapdragon(options);
  compilers(snapdragon);
  parsers(snapdragon);

  var ast = snapdragon.parse(pattern, options);
  ast.input = pattern;
  var res = snapdragon.compile(ast, options);
  res.input = pattern;
  return res;
};

/**
 * Expose `brackets` constructor, parsers and compilers
 */

brackets.compilers = compilers;
brackets.parsers = parsers;

/**
 * Expose `brackets`
 * @type {Function}
 */

module.exports = brackets;

}).call(this)}).call(this,"/node_modules/expand-brackets/index.js")

},{"./lib/compilers":48,"./lib/parsers":49,"debug":41,"extend-shallow":52,"snapdragon":166,"to-regex":195}],48:[function(require,module,exports){
'use strict';

var posix = require('posix-character-classes');

module.exports = function(brackets) {
  brackets.compiler

    /**
     * Escaped characters
     */

    .set('escape', function(node) {
      return this.emit('\\' + node.val.replace(/^\\/, ''), node);
    })

    /**
     * Text
     */

    .set('text', function(node) {
      return this.emit(node.val.replace(/([{}])/g, '\\$1'), node);
    })

    /**
     * POSIX character classes
     */

    .set('posix', function(node) {
      if (node.val === '[::]') {
        return this.emit('\\[::\\]', node);
      }

      var val = posix[node.inner];
      if (typeof val === 'undefined') {
        val = '[' + node.inner + ']';
      }
      return this.emit(val, node);
    })

    /**
     * Non-posix brackets
     */

    .set('bracket', function(node) {
      return this.mapVisit(node.nodes);
    })
    .set('bracket.open', function(node) {
      return this.emit(node.val, node);
    })
    .set('bracket.inner', function(node) {
      var inner = node.val;

      if (inner === '[' || inner === ']') {
        return this.emit('\\' + node.val, node);
      }
      if (inner === '^]') {
        return this.emit('^\\]', node);
      }
      if (inner === '^') {
        return this.emit('^', node);
      }

      if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
        inner = inner.split('-').join('\\-');
      }

      var isNegated = inner.charAt(0) === '^';
      // add slashes to negated brackets, per spec
      if (isNegated && inner.indexOf('/') === -1) {
        inner += '/';
      }
      if (isNegated && inner.indexOf('.') === -1) {
        inner += '.';
      }

      // don't unescape `0` (octal literal)
      inner = inner.replace(/\\([1-9])/g, '$1');
      return this.emit(inner, node);
    })
    .set('bracket.close', function(node) {
      var val = node.val.replace(/^\\/, '');
      if (node.parent.escaped === true) {
        return this.emit('\\' + val, node);
      }
      return this.emit(val, node);
    });
};

},{"posix-character-classes":126}],49:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var define = require('define-property');

/**
 * Text regex
 */

var TEXT_REGEX = '(\\[(?=.*\\])|\\])+';
var not = utils.createRegex(TEXT_REGEX);

/**
 * Brackets parsers
 */

function parsers(brackets) {
  brackets.state = brackets.state || {};
  brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
  brackets.parser

    .capture('escape', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[0]
      });
    })

    /**
     * Text parser
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos({
        type: 'text',
        val: m[0]
      });
    })

    /**
     * POSIX character classes: "[[:alpha:][:digits:]]"
     */

    .capture('posix', function() {
      var pos = this.position();
      var m = this.match(/^\[:(.*?):\](?=.*\])/);
      if (!m) return;

      var inside = this.isInside('bracket');
      if (inside) {
        brackets.posix++;
      }

      return pos({
        type: 'posix',
        insideBracket: inside,
        inner: m[1],
        val: m[0]
      });
    })

    /**
     * Bracket (noop)
     */

    .capture('bracket', function() {})

    /**
     * Open: '['
     */

    .capture('bracket.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\[(?=.*\])/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
        last.val = last.val.slice(0, last.val.length - 1);
        return pos({
          type: 'escape',
          val: m[0]
        });
      }

      var open = pos({
        type: 'bracket.open',
        val: m[0]
      });

      if (last.type === 'bracket.open' || this.isInside('bracket')) {
        open.val = '\\' + open.val;
        open.type = 'bracket.inner';
        open.escaped = true;
        return open;
      }

      var node = pos({
        type: 'bracket',
        nodes: [open]
      });

      define(node, 'parent', prev);
      define(open, 'parent', node);
      this.push('bracket', node);
      prev.nodes.push(node);
    })

    /**
     * Bracket text
     */

    .capture('bracket.inner', function() {
      if (!this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      var next = this.input.charAt(0);
      var val = m[0];

      var node = pos({
        type: 'bracket.inner',
        val: val
      });

      if (val === '\\\\') {
        return node;
      }

      var first = val.charAt(0);
      var last = val.slice(-1);

      if (first === '!') {
        val = '^' + val.slice(1);
      }

      if (last === '\\' || (val === '^' && next === ']')) {
        val += this.input[0];
        this.consume(1);
      }

      node.val = val;
      return node;
    })

    /**
     * Close: ']'
     */

    .capture('bracket.close', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\]/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
        last.val = last.val.slice(0, last.val.length - 1);

        return pos({
          type: 'escape',
          val: m[0]
        });
      }

      var node = pos({
        type: 'bracket.close',
        rest: this.input,
        val: m[0]
      });

      if (last.type === 'bracket.open') {
        node.type = 'bracket.inner';
        node.escaped = true;
        return node;
      }

      var bracket = this.pop('bracket');
      if (!this.isType(bracket, 'bracket')) {
        if (this.options.strict) {
          throw new Error('missing opening "["');
        }
        node.type = 'bracket.inner';
        node.escaped = true;
        return node;
      }

      bracket.nodes.push(node);
      define(node, 'parent', bracket);
    });
}

/**
 * Brackets parsers
 */

module.exports = parsers;

/**
 * Expose text regex
 */

module.exports.TEXT_REGEX = TEXT_REGEX;

},{"./utils":50,"define-property":51}],50:[function(require,module,exports){
'use strict';

var toRegex = require('to-regex');
var regexNot = require('regex-not');
var cached;

/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */

exports.last = function(arr) {
  return arr[arr.length - 1];
};

/**
 * Create and cache regex to use for text nodes
 */

exports.createRegex = function(pattern, include) {
  if (cached) return cached;
  var opts = {contains: true, strictClose: false};
  var not = regexNot.create(pattern, opts);
  var re;

  if (typeof include === 'string') {
    re = toRegex('^(?:' + include + '|' + not + ')', opts);
  } else {
    re = toRegex(not, opts);
  }

  return (cached = re);
};

},{"regex-not":146,"to-regex":195}],51:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],52:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],53:[function(require,module,exports){
'use strict';

var isExtendable = require('is-extendable');
var assignSymbols = require('assign-symbols');

module.exports = Object.assign || function(obj/*, objects*/) {
  if (obj === null || typeof obj === 'undefined') {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  if (!isObject(obj)) {
    obj = {};
  }
  for (var i = 1; i < arguments.length; i++) {
    var val = arguments[i];
    if (isString(val)) {
      val = toObject(val);
    }
    if (isObject(val)) {
      assign(obj, val);
      assignSymbols(obj, val);
    }
  }
  return obj;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

function isString(val) {
  return (val && typeof val === 'string');
}

function toObject(str) {
  var obj = {};
  for (var i in str) {
    obj[i] = str[i];
  }
  return obj;
}

function isObject(val) {
  return (val && typeof val === 'object') || isExtendable(val);
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function isEnum(obj, key) {
  return Object.prototype.propertyIsEnumerable.call(obj, key);
}

},{"assign-symbols":10,"is-extendable":54}],54:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isPlainObject = require('is-plain-object');

module.exports = function isExtendable(val) {
  return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};

},{"is-plain-object":94}],55:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var extend = require('extend-shallow');
var unique = require('array-unique');
var toRegex = require('to-regex');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Extglob = require('./lib/extglob');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob('*.!(*a)'));
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

function extglob(pattern, options) {
  return extglob.create(pattern, options).output;
}

/**
 * Takes an array of strings and an extglob pattern and returns a new
 * array that contains only the strings that match the pattern.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));
 * //=> ['a.b', 'a.c']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Extglob pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of matches
 * @api public
 */

extglob.match = function(list, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  list = utils.arrayify(list);
  var isMatch = extglob.matcher(pattern, options);
  var len = list.length;
  var idx = -1;
  var matches = [];

  while (++idx < len) {
    var ele = list[idx];

    if (isMatch(ele)) {
      matches.push(ele);
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }

  return options.nodupes !== false ? unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given
 * extglob `pattern`.
 *
 * ```js
 * var extglob = require('extglob');
 *
 * console.log(extglob.isMatch('a.a', '*.!(*a)'));
 * //=> false
 * console.log(extglob.isMatch('a.b', '*.!(*a)'));
 * //=> true
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

extglob.isMatch = function(str, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern === str) {
    return true;
  }

  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }

  var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);
  return isMatch(str);
};

/**
 * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but
 * the pattern can match any part of the string.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(extglob.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options`
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

extglob.contains = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }

  var opts = extend({}, options, {contains: true});
  opts.strictClose = false;
  opts.strictOpen = false;
  return extglob.isMatch(str, pattern, opts);
};

/**
 * Takes an extglob pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var extglob = require('extglob');
 * var isMatch = extglob.matcher('*.!(*a)');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

extglob.matcher = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  function matcher() {
    var re = extglob.makeRe(pattern, options);
    return function(str) {
      return re.test(str);
    };
  }

  return utils.memoize('matcher', pattern, options, matcher);
};

/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.create('*.!(*a)').output);
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

extglob.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  function create() {
    var ext = new Extglob(options);
    var ast = ext.parse(pattern, options);
    return ext.compile(ast, options);
  }

  return utils.memoize('create', pattern, options, create);
};

/**
 * Returns an array of matches captured by `pattern` in `string`, or `null`
 * if the pattern did not match.
 *
 * ```js
 * var extglob = require('extglob');
 * extglob.capture(pattern, string[, options]);
 *
 * console.log(extglob.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(extglob.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

extglob.capture = function(pattern, str, options) {
  var re = extglob.makeRe(pattern, extend({capture: true}, options));

  function match() {
    return function(string) {
      var match = re.exec(string);
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = utils.memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given `pattern` and `options`.
 *
 * ```js
 * var extglob = require('extglob');
 * var re = extglob.makeRe('*.!(*a)');
 * console.log(re);
 * //=> /^[^\/]*?\.(?![^\/]*?a)[^\/]*?$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

extglob.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var opts = extend({strictErrors: false}, options);
    if (opts.strictErrors === true) opts.strict = true;
    var res = extglob.create(pattern, opts);
    return toRegex(res.output, opts);
  }

  var regex = utils.memoize('makeRe', pattern, options, makeRe);
  if (regex.source.length > MAX_LENGTH) {
    throw new SyntaxError('potentially malicious regex detected');
  }

  return regex;
};

/**
 * Cache
 */

extglob.cache = utils.cache;
extglob.clearCache = function() {
  extglob.cache.__data__ = {};
};

/**
 * Expose `Extglob` constructor, parsers and compilers
 */

extglob.Extglob = Extglob;
extglob.compilers = compilers;
extglob.parsers = parsers;

/**
 * Expose `extglob`
 * @type {Function}
 */

module.exports = extglob;

},{"./lib/compilers":56,"./lib/extglob":57,"./lib/parsers":58,"./lib/utils":59,"array-unique":5,"extend-shallow":61,"to-regex":195}],56:[function(require,module,exports){
'use strict';

var brackets = require('expand-brackets');

/**
 * Extglob compilers
 */

module.exports = function(extglob) {
  function star() {
    if (typeof extglob.options.star === 'function') {
      return extglob.options.star.apply(this, arguments);
    }
    if (typeof extglob.options.star === 'string') {
      return extglob.options.star;
    }
    return '.*?';
  }

  /**
   * Use `expand-brackets` compilers
   */

  extglob.use(brackets.compilers);
  extglob.compiler

    /**
     * Escaped: "\\*"
     */

    .set('escape', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * Dot: "."
     */

    .set('dot', function(node) {
      return this.emit('\\' + node.val, node);
    })

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) {
      var val = '[^\\\\/.]';
      var prev = this.prev();

      if (node.parsed.slice(-1) === '(') {
        var ch = node.rest.charAt(0);
        if (ch !== '!' && ch !== '=' && ch !== ':') {
          return this.emit(val, node);
        }
        return this.emit(node.val, node);
      }

      if (prev.type === 'text' && prev.val) {
        return this.emit(val, node);
      }

      if (node.val.length > 1) {
        val += '{' + node.val.length + '}';
      }
      return this.emit(val, node);
    })

    /**
     * Plus: "+"
     */

    .set('plus', function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') {
        return this.emit(node.val, node);
      }
      var ch = this.output.slice(-1);
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
        return this.emit('\\+', node);
      }
      if (/\w/.test(ch) && !node.inside) {
        return this.emit('+\\+?', node);
      }
      return this.emit('+', node);
    })

    /**
     * Star: "*"
     */

    .set('star', function(node) {
      var prev = this.prev();
      var prefix = prev.type !== 'text' && prev.type !== 'escape'
        ? '(?!\\.)'
        : '';

      return this.emit(prefix + star.call(this, node), node);
    })

    /**
     * Parens
     */

    .set('paren', function(node) {
      return this.mapVisit(node.nodes);
    })
    .set('paren.open', function(node) {
      var capture = this.options.capture ? '(' : '';

      switch (node.parent.prefix) {
        case '!':
        case '^':
          return this.emit(capture + '(?:(?!(?:', node);
        case '*':
        case '+':
        case '?':
        case '@':
          return this.emit(capture + '(?:', node);
        default: {
          var val = node.val;
          if (this.options.bash === true) {
            val = '\\' + val;
          } else if (!this.options.capture && val === '(' && node.parent.rest[0] !== '?') {
            val += '?:';
          }

          return this.emit(val, node);
        }
      }
    })
    .set('paren.close', function(node) {
      var capture = this.options.capture ? ')' : '';

      switch (node.prefix) {
        case '!':
        case '^':
          var prefix = /^(\)|$)/.test(node.rest) ? '$' : '';
          var str = star.call(this, node);

          // if the extglob has a slash explicitly defined, we know the user wants
          // to match slashes, so we need to ensure the "star" regex allows for it
          if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
            str = '.*?';
          }

          return this.emit(prefix + ('))' + str + ')') + capture, node);
        case '*':
        case '+':
        case '?':
          return this.emit(')' + node.prefix + capture, node);
        case '@':
          return this.emit(')' + capture, node);
        default: {
          var val = (this.options.bash === true ? '\\' : '') + ')';
          return this.emit(val, node);
        }
      }
    })

    /**
     * Text
     */

    .set('text', function(node) {
      var val = node.val.replace(/[\[\]]/g, '\\$&');
      return this.emit(val, node);
    });
};

},{"expand-brackets":47}],57:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
var define = require('define-property');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./compilers');
var parsers = require('./parsers');

/**
 * Customize Snapdragon parser and renderer
 */

function Extglob(options) {
  this.options = extend({source: 'extglob'}, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
  this.snapdragon.patterns = this.snapdragon.patterns || {};
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon);
  parsers(this.snapdragon);

  /**
   * Override Snapdragon `.parse` method
   */

  define(this.snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strict !== true) {
      var node = last.nodes[0];
      node.val = '\\' + node.val;
      var sibling = node.parent.nodes[1];
      if (sibling.type === 'star') {
        sibling.loose = true;
      }
    }

    // add non-enumerable parser reference
    define(parsed, 'parser', this.parser);
    return parsed;
  });

  /**
   * Decorate `.parse` method
   */

  define(this, 'parse', function(ast, options) {
    return this.snapdragon.parse.apply(this.snapdragon, arguments);
  });

  /**
   * Decorate `.compile` method
   */

  define(this, 'compile', function(ast, options) {
    return this.snapdragon.compile.apply(this.snapdragon, arguments);
  });

}

/**
 * Expose `Extglob`
 */

module.exports = Extglob;

},{"./compilers":56,"./parsers":58,"define-property":60,"extend-shallow":61,"snapdragon":166}],58:[function(require,module,exports){
'use strict';

var brackets = require('expand-brackets');
var define = require('define-property');
var utils = require('./utils');

/**
 * Characters to use in text regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var TEXT_REGEX = '([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+';
var not = utils.createRegex(TEXT_REGEX);

/**
 * Extglob parsers
 */

function parsers(extglob) {
  extglob.state = extglob.state || {};

  /**
   * Use `expand-brackets` parsers
   */

  extglob.use(brackets.parsers);
  extglob.parser.sets.paren = extglob.parser.sets.paren || [];
  extglob.parser

    /**
     * Extglob open: "*("
     */

    .capture('paren.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^([!@*?+])?\(/);
      if (!m) return;

      var prev = this.prev();
      var prefix = m[1];
      var val = m[0];

      var open = pos({
        type: 'paren.open',
        parsed: parsed,
        val: val
      });

      var node = pos({
        type: 'paren',
        prefix: prefix,
        nodes: [open]
      });

      // if nested negation extglobs, just cancel them out to simplify
      if (prefix === '!' && prev.type === 'paren' && prev.prefix === '!') {
        prev.prefix = '@';
        node.prefix = '@';
      }

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      this.push('paren', node);
      prev.nodes.push(node);
    })

    /**
     * Extglob close: ")"
     */

    .capture('paren.close', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\)/);
      if (!m) return;

      var parent = this.pop('paren');
      var node = pos({
        type: 'paren.close',
        rest: this.input,
        parsed: parsed,
        val: m[0]
      });

      if (!this.isType(parent, 'paren')) {
        if (this.options.strict) {
          throw new Error('missing opening paren: "("');
        }
        node.escaped = true;
        return node;
      }

      node.prefix = parent.prefix;
      parent.nodes.push(node);
      define(node, 'parent', parent);
    })

    /**
     * Escape: "\\."
     */

    .capture('escape', function() {
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[0],
        ch: m[1]
      });
    })

    /**
     * Question marks: "?"
     */

    .capture('qmark', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;
      extglob.state.metachar = true;
      return pos({
        type: 'qmark',
        rest: this.input,
        parsed: parsed,
        val: m[0]
      });
    })

    /**
     * Character parsers
     */

    .capture('star', /^\*(?!\()/)
    .capture('plus', /^\+(?!\()/)
    .capture('dot', /^\./)
    .capture('text', not);
};

/**
 * Expose text regex string
 */

module.exports.TEXT_REGEX = TEXT_REGEX;

/**
 * Extglob parsers
 */

module.exports = parsers;

},{"./utils":59,"define-property":60,"expand-brackets":47}],59:[function(require,module,exports){
'use strict';

var regex = require('regex-not');
var Cache = require('fragment-cache');

/**
 * Utils
 */

var utils = module.exports;
var cache = utils.cache = new Cache();

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (!Array.isArray(val)) {
    return [val];
  }
  return val;
};

/**
 * Memoize a generated regex or function
 */

utils.memoize = function(type, pattern, options, fn) {
  var key = utils.createKey(type + pattern, options);

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  if (options && options.cache === false) {
    return val;
  }

  cache.set(type, key, val);
  return val;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  var key = pattern;
  if (typeof options === 'undefined') {
    return key;
  }
  for (var prop in options) {
    key += ';' + prop + '=' + String(options[prop]);
  }
  return key;
};

/**
 * Create the regex to use for matching text
 */

utils.createRegex = function(str) {
  var opts = {contains: true, strictClose: false};
  return regex(str, opts);
};

},{"fragment-cache":68,"regex-not":146}],60:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"is-descriptor":64}],61:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],62:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":99}],63:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"kind-of":99}],64:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"is-accessor-descriptor":62,"is-data-descriptor":63,"kind-of":99}],65:[function(require,module,exports){
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var util = require('util');
var isNumber = require('is-number');
var extend = require('extend-shallow');
var repeat = require('repeat-string');
var toRegex = require('to-regex-range');

/**
 * Return a range of numbers or letters.
 *
 * @param  {String} `start` Start of the range
 * @param  {String} `stop` End of the range
 * @param  {String} `step` Increment or decrement to use.
 * @param  {Function} `fn` Custom function to modify each element in the range.
 * @return {Array}
 */

function fillRange(start, stop, step, options) {
  if (typeof start === 'undefined') {
    return [];
  }

  if (typeof stop === 'undefined' || start === stop) {
    // special case, for handling negative zero
    var isString = typeof start === 'string';
    if (isNumber(start) && !toNumber(start)) {
      return [isString ? '0' : 0];
    }
    return [start];
  }

  if (typeof step !== 'number' && typeof step !== 'string') {
    options = step;
    step = undefined;
  }

  if (typeof options === 'function') {
    options = { transform: options };
  }

  var opts = extend({step: step}, options);
  if (opts.step && !isValidNumber(opts.step)) {
    if (opts.strictRanges === true) {
      throw new TypeError('expected options.step to be a number');
    }
    return [];
  }

  opts.isNumber = isValidNumber(start) && isValidNumber(stop);
  if (!opts.isNumber && !isValid(start, stop)) {
    if (opts.strictRanges === true) {
      throw new RangeError('invalid range arguments: ' + util.inspect([start, stop]));
    }
    return [];
  }

  opts.isPadded = isPadded(start) || isPadded(stop);
  opts.toString = opts.stringify
    || typeof opts.step === 'string'
    || typeof start === 'string'
    || typeof stop === 'string'
    || !opts.isNumber;

  if (opts.isPadded) {
    opts.maxLength = Math.max(String(start).length, String(stop).length);
  }

  // support legacy minimatch/fill-range options
  if (typeof opts.optimize === 'boolean') opts.toRegex = opts.optimize;
  if (typeof opts.makeRe === 'boolean') opts.toRegex = opts.makeRe;
  return expand(start, stop, opts);
}

function expand(start, stop, options) {
  var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
  var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);

  var step = Math.abs(toNumber(options.step)) || 1;
  if (options.toRegex && step === 1) {
    return toRange(a, b, start, stop, options);
  }

  var zero = {greater: [], lesser: []};
  var asc = a < b;
  var arr = new Array(Math.round((asc ? b - a : a - b) / step));
  var idx = 0;

  while (asc ? a <= b : a >= b) {
    var val = options.isNumber ? a : String.fromCharCode(a);
    if (options.toRegex && (val >= 0 || !options.isNumber)) {
      zero.greater.push(val);
    } else {
      zero.lesser.push(Math.abs(val));
    }

    if (options.isPadded) {
      val = zeros(val, options);
    }

    if (options.toString) {
      val = String(val);
    }

    if (typeof options.transform === 'function') {
      arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
    } else {
      arr[idx++] = val;
    }

    if (asc) {
      a += step;
    } else {
      a -= step;
    }
  }

  if (options.toRegex === true) {
    return toSequence(arr, zero, options);
  }
  return arr;
}

function toRange(a, b, start, stop, options) {
  if (options.isPadded) {
    return toRegex(start, stop, options);
  }

  if (options.isNumber) {
    return toRegex(Math.min(a, b), Math.max(a, b), options);
  }

  var start = String.fromCharCode(Math.min(a, b));
  var stop = String.fromCharCode(Math.max(a, b));
  return '[' + start + '-' + stop + ']';
}

function toSequence(arr, zeros, options) {
  var greater = '', lesser = '';
  if (zeros.greater.length) {
    greater = zeros.greater.join('|');
  }
  if (zeros.lesser.length) {
    lesser = '-(' + zeros.lesser.join('|') + ')';
  }
  var res = greater && lesser
    ? greater + '|' + lesser
    : greater || lesser;

  if (options.capture) {
    return '(' + res + ')';
  }
  return res;
}

function zeros(val, options) {
  if (options.isPadded) {
    var str = String(val);
    var len = str.length;
    var dash = '';
    if (str.charAt(0) === '-') {
      dash = '-';
      str = str.slice(1);
    }
    var diff = options.maxLength - len;
    var pad = repeat('0', diff);
    val = (dash + pad + str);
  }
  if (options.stringify) {
    return String(val);
  }
  return val;
}

function toNumber(val) {
  return Number(val) || 0;
}

function isPadded(str) {
  return /^-?0\d/.test(str);
}

function isValid(min, max) {
  return (isValidNumber(min) || isValidLetter(min))
      && (isValidNumber(max) || isValidLetter(max));
}

function isValidLetter(ch) {
  return typeof ch === 'string' && ch.length === 1 && /^\w+$/.test(ch);
}

function isValidNumber(n) {
  return isNumber(n) && !/\./.test(n);
}

/**
 * Expose `fillRange`
 * @type {Function}
 */

module.exports = fillRange;

},{"extend-shallow":66,"is-number":92,"repeat-string":149,"to-regex-range":194,"util":211}],66:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],67:[function(require,module,exports){
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function forIn(obj, fn, thisArg) {
  for (var key in obj) {
    if (fn.call(thisArg, obj[key], key, obj) === false) {
      break;
    }
  }
};

},{}],68:[function(require,module,exports){
/*!
 * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
 *
 * Copyright (c) 2016-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var MapCache = require('map-cache');

/**
 * Create a new `FragmentCache` with an optional object to use for `caches`.
 *
 * ```js
 * var fragment = new FragmentCache();
 * ```
 * @name FragmentCache
 * @param {String} `cacheName`
 * @return {Object} Returns the [map-cache][] instance.
 * @api public
 */

function FragmentCache(caches) {
  this.caches = caches || {};
}

/**
 * Prototype
 */

FragmentCache.prototype = {

  /**
   * Get cache `name` from the `fragment.caches` object. Creates a new
   * `MapCache` if it doesn't already exist.
   *
   * ```js
   * var cache = fragment.cache('files');
   * console.log(fragment.caches.hasOwnProperty('files'));
   * //=> true
   * ```
   * @name .cache
   * @param {String} `cacheName`
   * @return {Object} Returns the [map-cache][] instance.
   * @api public
   */

  cache: function(cacheName) {
    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
  },

  /**
   * Set a value for property `key` on cache `name`
   *
   * ```js
   * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));
   * ```
   * @name .set
   * @param {String} `name`
   * @param {String} `key` Property name to set
   * @param {any} `val` The value of `key`
   * @return {Object} The cache instance for chaining
   * @api public
   */

  set: function(cacheName, key, val) {
    var cache = this.cache(cacheName);
    cache.set(key, val);
    return cache;
  },

  /**
   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
   *
   * ```js
   * var cache = fragment.cache('files');
   * cache.set('somefile.js');
   *
   * console.log(cache.has('somefile.js'));
   * //=> true
   *
   * console.log(cache.has('some-other-file.js'));
   * //=> false
   * ```
   * @name .has
   * @param {String} `name` Cache name
   * @param {String} `key` Optionally specify a property to check for on cache `name`
   * @return {Boolean}
   * @api public
   */

  has: function(cacheName, key) {
    return typeof this.get(cacheName, key) !== 'undefined';
  },

  /**
   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
   * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
   * the entire cache (`name`) is returned.
   *
   * ```js
   * var Vinyl = require('vinyl');
   * var cache = fragment.cache('files');
   * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));
   * console.log(cache.get('somefile.js'));
   * //=> <File "somefile.js">
   * ```
   * @name .get
   * @param {String} `name`
   * @return {Object} Returns cache `name`, or the value of `key` if specified
   * @api public
   */

  get: function(name, key) {
    var cache = this.cache(name);
    if (typeof key === 'string') {
      return cache.get(key);
    }
    return cache;
  }
};

/**
 * Expose `FragmentCache`
 */

exports = module.exports = FragmentCache;

},{"map-cache":100}],69:[function(require,module,exports){
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function(obj, prop, a, b, c) {
  if (!isObject(obj) || !prop) {
    return obj;
  }

  prop = toString(prop);

  // allowing for multiple properties to be passed as
  // a string or array, but much faster (3-4x) than doing
  // `[].slice.call(arguments)`
  if (a) prop += '.' + toString(a);
  if (b) prop += '.' + toString(b);
  if (c) prop += '.' + toString(c);

  if (prop in obj) {
    return obj[prop];
  }

  var segs = prop.split('.');
  var len = segs.length;
  var i = -1;

  while (obj && (++i < len)) {
    var key = segs[i];
    while (key[key.length - 1] === '\\') {
      key = key.slice(0, -1) + '.' + segs[++i];
    }
    obj = obj[key];
  }
  return obj;
};

function isObject(val) {
  return val !== null && (typeof val === 'object' || typeof val === 'function');
}

function toString(val) {
  if (!val) return '';
  if (Array.isArray(val)) {
    return val.join('.');
  }
  return val;
}

},{}],70:[function(require,module,exports){
'use strict';

var path = require('path');
var isglob = require('is-glob');
var pathDirname = require('path-dirname');
var isWin32 = require('os').platform() === 'win32';

module.exports = function globParent(str) {
	// flip windows path separators
	if (isWin32 && str.indexOf('/') < 0) str = str.split('\\').join('/');

	// special case for strings ending in enclosure containing path separator
	if (/[\{\[].*[\/]*.*[\}\]]$/.test(str)) str += '/';

	// preserves full path in case of trailing path separator
	str += 'a';

	// remove path parts that are globby
	do {str = pathDirname.posix(str)}
	while (isglob(str) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(str));

	// remove escape chars and return result
	return str.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, '$1');
};

},{"is-glob":71,"os":122,"path":207,"path-dirname":124}],71:[function(require,module,exports){
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob = require('is-extglob');

module.exports = function isGlob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) return true;

  var regex = /(\\).|([*?]|\[.*\]|\{.*\}|\(.*\|.*\)|^!)/;
  var match;

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }
  return false;
};

},{"is-extglob":90}],72:[function(require,module,exports){
'use strict'

module.exports = clone

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}

},{}],73:[function(require,module,exports){
(function (process,global){(function (){
var fs = require('fs')
var polyfills = require('./polyfills.js')
var legacy = require('./legacy-streams.js')
var clone = require('./clone.js')

var util = require('util')

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      retry()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      require('assert').equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== 'function') {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort()

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]])

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
}

function retry () {
  var elem = fs[gracefulQueue].shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./clone.js":72,"./legacy-streams.js":74,"./polyfills.js":75,"_process":128,"assert":6,"fs":205,"util":211}],74:[function(require,module,exports){
(function (process){(function (){
var Stream = require('stream').Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

}).call(this)}).call(this,require('_process'))

},{"_process":128,"stream":208}],75:[function(require,module,exports){
(function (process){(function (){
var constants = require('constants')

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

var chdir = process.chdir
process.chdir = function(d) {
  cwd = null
  chdir.call(process, d)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    read.__proto__ = fs$read
    return read
  })(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

}).call(this)}).call(this,require('_process'))

},{"_process":128,"constants":38}],76:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var hasValues = require('has-values');
var get = require('get-value');

module.exports = function(val, prop) {
  return hasValues(isObject(val) && prop ? get(val, prop) : val);
};

},{"get-value":69,"has-values":77,"isobject":97}],77:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');
var isNumber = require('is-number');

module.exports = function hasValue(val) {
  // is-number checks for NaN and other edge cases
  if (isNumber(val)) {
    return true;
  }

  switch (typeOf(val)) {
    case 'null':
    case 'boolean':
    case 'function':
      return true;
    case 'string':
    case 'arguments':
      return val.length !== 0;
    case 'error':
      return val.message !== '';
    case 'array':
      var len = val.length;
      if (len === 0) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (hasValue(val[i])) {
          return true;
        }
      }
      return false;
    case 'file':
    case 'map':
    case 'set':
      return val.size !== 0;
    case 'object':
      var keys = Object.keys(val);
      if (keys.length === 0) {
        return false;
      }
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (hasValue(val[key])) {
          return true;
        }
      }
      return false;
    default: {
      return false;
    }
  }
};

},{"is-number":92,"kind-of":78}],78:[function(require,module,exports){
var isBuffer = require('is-buffer');
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  // primitivies
  if (typeof val === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (typeof val === 'string' || val instanceof String) {
    return 'string';
  }
  if (typeof val === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (typeof val === 'function' || val instanceof Function) {
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  var type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }
  if (type === '[object Promise]') {
    return 'promise';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }

  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

},{"is-buffer":84}],79:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],80:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],81:[function(require,module,exports){
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// accessor descriptor properties
var accessor = {
  get: 'function',
  set: 'function',
  configurable: 'boolean',
  enumerable: 'boolean'
};

function isAccessorDescriptor(obj, prop) {
  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (has(obj, 'value') || has(obj, 'writable')) {
    return false;
  }

  if (!has(obj, 'get') || typeof obj.get !== 'function') {
    return false;
  }

  // tldr: it's valid to have "set" be undefined
  // "set" might be undefined if `Object.getOwnPropertyDescriptor`
  // was used to get the value, and only `get` was defined by the user
  if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
    return false;
  }

  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === accessor[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

function has(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}

/**
 * Expose `isAccessorDescriptor`
 */

module.exports = isAccessorDescriptor;

},{"kind-of":82}],82:[function(require,module,exports){
var isBuffer = require('is-buffer');
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  // primitivies
  if (typeof val === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (typeof val === 'string' || val instanceof String) {
    return 'string';
  }
  if (typeof val === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (typeof val === 'function' || val instanceof Function) {
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  var type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }

  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

},{"is-buffer":84}],83:[function(require,module,exports){
'use strict';
var path = require('path');
var binaryExtensions = require('binary-extensions');
var exts = Object.create(null);

binaryExtensions.forEach(function (el) {
	exts[el] = true;
});

module.exports = function (filepath) {
	return path.extname(filepath).slice(1).toLowerCase() in exts;
};

},{"binary-extensions":18,"path":207}],84:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],85:[function(require,module,exports){
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// data descriptor properties
var data = {
  configurable: 'boolean',
  enumerable: 'boolean',
  writable: 'boolean'
};

function isDataDescriptor(obj, prop) {
  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (!('value' in obj) && !('writable' in obj)) {
    return false;
  }

  for (var key in obj) {
    if (key === 'value') continue;

    if (!data.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === data[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

/**
 * Expose `isDataDescriptor`
 */

module.exports = isDataDescriptor;

},{"kind-of":86}],86:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],87:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"is-accessor-descriptor":81,"is-data-descriptor":85,"kind-of":88}],88:[function(require,module,exports){
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  var type = typeof val;

  // primitivies
  if (type === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (type === 'string' || val instanceof String) {
    return 'string';
  }
  if (type === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (type === 'function' || val instanceof Function) {
    if (typeof val.constructor.name !== 'undefined' && val.constructor.name.slice(0, 9) === 'Generator') {
      return 'generatorfunction';
    }
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }
  if (type === '[object Promise]') {
    return 'promise';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }
  
  if (type === '[object Map Iterator]') {
    return 'mapiterator';
  }
  if (type === '[object Set Iterator]') {
    return 'setiterator';
  }
  if (type === '[object String Iterator]') {
    return 'stringiterator';
  }
  if (type === '[object Array Iterator]') {
    return 'arrayiterator';
  }
  
  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  return val.constructor
    && typeof val.constructor.isBuffer === 'function'
    && val.constructor.isBuffer(val);
}

},{}],89:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function isExtendable(val) {
  return typeof val !== 'undefined' && val !== null
    && (typeof val === 'object' || typeof val === 'function');
};

},{}],90:[function(require,module,exports){
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

},{}],91:[function(require,module,exports){
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = require('is-extglob');
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};

},{"is-extglob":90}],92:[function(require,module,exports){
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function isNumber(num) {
  var type = typeOf(num);

  if (type === 'string') {
    if (!num.trim()) return false;
  } else if (type !== 'number') {
    return false;
  }

  return (num - num + 1) >= 0;
};

},{"kind-of":93}],93:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],94:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

},{"isobject":97}],95:[function(require,module,exports){
(function (process,global){(function (){
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright  2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

(function(factory) {
  if (exports && typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof window !== 'undefined') {
    window.isWindows = factory();
  } else if (typeof global !== 'undefined') {
    global.isWindows = factory();
  } else if (typeof self !== 'undefined') {
    self.isWindows = factory();
  } else {
    this.isWindows = factory();
  }
})(function() {
  'use strict';
  return function isWindows() {
    return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
  };
});

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":128}],96:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],97:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],98:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.JSON5 = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.5' };
	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document) && _isObject(document.createElement);
	var _domCreate = function (it) {
	  return is ? document.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) { return it; }
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) { try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: _library ? 'pure' : 'global',
	  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _functionToString = _shared('native-function-to-string', Function.toString);

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var TPL = ('' + _functionToString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return _functionToString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }
	  if (O[key] === val) { return; }
	  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) { source = name; }
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) { _redefine(target, key, out, type & $export.U); }
	    // export
	    if (exports[key] != out) { _hide(exports, key, exp); }
	    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) { throw TypeError("Can't call method on  " + it); }
	  return it;
	};

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var $at = _stringAt(false);
	_export(_export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});

	var codePointAt = _core.String.codePointAt;

	var max = Math.max;
	var min = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments$1[i++];
	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

	var fromCodePoint = _core.String.fromCodePoint;

	// This is a generated file. Do not edit.
	var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
	var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
	var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

	var unicode = {
		Space_Separator: Space_Separator,
		ID_Start: ID_Start,
		ID_Continue: ID_Continue
	};

	var util = {
	    isSpaceSeparator: function isSpaceSeparator (c) {
	        return typeof c === 'string' && unicode.Space_Separator.test(c)
	    },

	    isIdStartChar: function isIdStartChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c === '$') || (c === '_') ||
	        unicode.ID_Start.test(c)
	        )
	    },

	    isIdContinueChar: function isIdContinueChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c >= '0' && c <= '9') ||
	        (c === '$') || (c === '_') ||
	        (c === '\u200C') || (c === '\u200D') ||
	        unicode.ID_Continue.test(c)
	        )
	    },

	    isDigit: function isDigit (c) {
	        return typeof c === 'string' && /[0-9]/.test(c)
	    },

	    isHexDigit: function isHexDigit (c) {
	        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
	    },
	};

	var source;
	var parseState;
	var stack;
	var pos;
	var line;
	var column;
	var token;
	var key;
	var root;

	var parse = function parse (text, reviver) {
	    source = String(text);
	    parseState = 'start';
	    stack = [];
	    pos = 0;
	    line = 1;
	    column = 0;
	    token = undefined;
	    key = undefined;
	    root = undefined;

	    do {
	        token = lex();

	        // This code is unreachable.
	        // if (!parseStates[parseState]) {
	        //     throw invalidParseState()
	        // }

	        parseStates[parseState]();
	    } while (token.type !== 'eof')

	    if (typeof reviver === 'function') {
	        return internalize({'': root}, '', reviver)
	    }

	    return root
	};

	function internalize (holder, name, reviver) {
	    var value = holder[name];
	    if (value != null && typeof value === 'object') {
	        for (var key in value) {
	            var replacement = internalize(value, key, reviver);
	            if (replacement === undefined) {
	                delete value[key];
	            } else {
	                value[key] = replacement;
	            }
	        }
	    }

	    return reviver.call(holder, name, value)
	}

	var lexState;
	var buffer;
	var doubleQuote;
	var sign;
	var c;

	function lex () {
	    lexState = 'default';
	    buffer = '';
	    doubleQuote = false;
	    sign = 1;

	    for (;;) {
	        c = peek();

	        // This code is unreachable.
	        // if (!lexStates[lexState]) {
	        //     throw invalidLexState(lexState)
	        // }

	        var token = lexStates[lexState]();
	        if (token) {
	            return token
	        }
	    }
	}

	function peek () {
	    if (source[pos]) {
	        return String.fromCodePoint(source.codePointAt(pos))
	    }
	}

	function read () {
	    var c = peek();

	    if (c === '\n') {
	        line++;
	        column = 0;
	    } else if (c) {
	        column += c.length;
	    } else {
	        column++;
	    }

	    if (c) {
	        pos += c.length;
	    }

	    return c
	}

	var lexStates = {
	    default: function default$1 () {
	        switch (c) {
	        case '\t':
	        case '\v':
	        case '\f':
	        case ' ':
	        case '\u00A0':
	        case '\uFEFF':
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'comment';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        if (util.isSpaceSeparator(c)) {
	            read();
	            return
	        }

	        // This code is unreachable.
	        // if (!lexStates[parseState]) {
	        //     throw invalidLexState(parseState)
	        // }

	        return lexStates[parseState]()
	    },

	    comment: function comment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineComment';
	            return

	        case '/':
	            read();
	            lexState = 'singleLineComment';
	            return
	        }

	        throw invalidChar(read())
	    },

	    multiLineComment: function multiLineComment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineCommentAsterisk';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	    },

	    multiLineCommentAsterisk: function multiLineCommentAsterisk () {
	        switch (c) {
	        case '*':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	        lexState = 'multiLineComment';
	    },

	    singleLineComment: function singleLineComment () {
	        switch (c) {
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        read();
	    },

	    value: function value () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        case 'n':
	            read();
	            literal('ull');
	            return newToken('null', null)

	        case 't':
	            read();
	            literal('rue');
	            return newToken('boolean', true)

	        case 'f':
	            read();
	            literal('alse');
	            return newToken('boolean', false)

	        case '-':
	        case '+':
	            if (read() === '-') {
	                sign = -1;
	            }

	            lexState = 'sign';
	            return

	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            buffer = '';
	            lexState = 'string';
	            return
	        }

	        throw invalidChar(read())
	    },

	    identifierNameStartEscape: function identifierNameStartEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	            break

	        default:
	            if (!util.isIdStartChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    identifierName: function identifierName () {
	        switch (c) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            buffer += read();
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameEscape';
	            return
	        }

	        if (util.isIdContinueChar(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('identifier', buffer)
	    },

	    identifierNameEscape: function identifierNameEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            break

	        default:
	            if (!util.isIdContinueChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    sign: function sign$1 () {
	        switch (c) {
	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', sign * Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)
	        }

	        throw invalidChar(read())
	    },

	    zero: function zero () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return

	        case 'x':
	        case 'X':
	            buffer += read();
	            lexState = 'hexadecimal';
	            return
	        }

	        return newToken('numeric', sign * 0)
	    },

	    decimalInteger: function decimalInteger () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalPointLeading: function decimalPointLeading () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalPoint: function decimalPoint () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalFraction: function decimalFraction () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalExponent: function decimalExponent () {
	        switch (c) {
	        case '+':
	        case '-':
	            buffer += read();
	            lexState = 'decimalExponentSign';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentSign: function decimalExponentSign () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentInteger: function decimalExponentInteger () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    hexadecimal: function hexadecimal () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            lexState = 'hexadecimalInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    hexadecimalInteger: function hexadecimalInteger () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    string: function string () {
	        switch (c) {
	        case '\\':
	            read();
	            buffer += escape();
	            return

	        case '"':
	            if (doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case "'":
	            if (!doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case '\n':
	        case '\r':
	            throw invalidChar(read())

	        case '\u2028':
	        case '\u2029':
	            separatorChar(c);
	            break

	        case undefined:
	            throw invalidChar(read())
	        }

	        buffer += read();
	    },

	    start: function start () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        // This code is unreachable since the default lexState handles eof.
	        // case undefined:
	        //     return newToken('eof')
	        }

	        lexState = 'value';
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (c) {
	        case '$':
	        case '_':
	            buffer = read();
	            lexState = 'identifierName';
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameStartEscape';
	            return

	        case '}':
	            return newToken('punctuator', read())

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            lexState = 'string';
	            return
	        }

	        if (util.isIdStartChar(c)) {
	            buffer += read();
	            lexState = 'identifierName';
	            return
	        }

	        throw invalidChar(read())
	    },

	    afterPropertyName: function afterPropertyName () {
	        if (c === ':') {
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        lexState = 'value';
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        switch (c) {
	        case ',':
	        case '}':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (c === ']') {
	            return newToken('punctuator', read())
	        }

	        lexState = 'value';
	    },

	    afterArrayValue: function afterArrayValue () {
	        switch (c) {
	        case ',':
	        case ']':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the default lexState.
	        // if (c === undefined) {
	        //     read()
	        //     return newToken('eof')
	        // }

	        throw invalidChar(read())
	    },
	};

	function newToken (type, value) {
	    return {
	        type: type,
	        value: value,
	        line: line,
	        column: column,
	    }
	}

	function literal (s) {
	    for (var i = 0, list = s; i < list.length; i += 1) {
	        var c = list[i];

	        var p = peek();

	        if (p !== c) {
	            throw invalidChar(read())
	        }

	        read();
	    }
	}

	function escape () {
	    var c = peek();
	    switch (c) {
	    case 'b':
	        read();
	        return '\b'

	    case 'f':
	        read();
	        return '\f'

	    case 'n':
	        read();
	        return '\n'

	    case 'r':
	        read();
	        return '\r'

	    case 't':
	        read();
	        return '\t'

	    case 'v':
	        read();
	        return '\v'

	    case '0':
	        read();
	        if (util.isDigit(peek())) {
	            throw invalidChar(read())
	        }

	        return '\0'

	    case 'x':
	        read();
	        return hexEscape()

	    case 'u':
	        read();
	        return unicodeEscape()

	    case '\n':
	    case '\u2028':
	    case '\u2029':
	        read();
	        return ''

	    case '\r':
	        read();
	        if (peek() === '\n') {
	            read();
	        }

	        return ''

	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	        throw invalidChar(read())

	    case undefined:
	        throw invalidChar(read())
	    }

	    return read()
	}

	function hexEscape () {
	    var buffer = '';
	    var c = peek();

	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    c = peek();
	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	function unicodeEscape () {
	    var buffer = '';
	    var count = 4;

	    while (count-- > 0) {
	        var c = peek();
	        if (!util.isHexDigit(c)) {
	            throw invalidChar(read())
	        }

	        buffer += read();
	    }

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	var parseStates = {
	    start: function start () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (token.type) {
	        case 'identifier':
	        case 'string':
	            key = token.value;
	            parseState = 'afterPropertyName';
	            return

	        case 'punctuator':
	            // This code is unreachable since it's handled by the lexState.
	            // if (token.value !== '}') {
	            //     throw invalidToken()
	            // }

	            pop();
	            return

	        case 'eof':
	            throw invalidEOF()
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterPropertyName: function afterPropertyName () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator' || token.value !== ':') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        parseState = 'beforePropertyValue';
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        if (token.type === 'punctuator' && token.value === ']') {
	            pop();
	            return
	        }

	        push();
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforePropertyName';
	            return

	        case '}':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterArrayValue: function afterArrayValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforeArrayValue';
	            return

	        case ']':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'eof') {
	        //     throw invalidToken()
	        // }
	    },
	};

	function push () {
	    var value;

	    switch (token.type) {
	    case 'punctuator':
	        switch (token.value) {
	        case '{':
	            value = {};
	            break

	        case '[':
	            value = [];
	            break
	        }

	        break

	    case 'null':
	    case 'boolean':
	    case 'numeric':
	    case 'string':
	        value = token.value;
	        break

	    // This code is unreachable.
	    // default:
	    //     throw invalidToken()
	    }

	    if (root === undefined) {
	        root = value;
	    } else {
	        var parent = stack[stack.length - 1];
	        if (Array.isArray(parent)) {
	            parent.push(value);
	        } else {
	            parent[key] = value;
	        }
	    }

	    if (value !== null && typeof value === 'object') {
	        stack.push(value);

	        if (Array.isArray(value)) {
	            parseState = 'beforeArrayValue';
	        } else {
	            parseState = 'beforePropertyName';
	        }
	    } else {
	        var current = stack[stack.length - 1];
	        if (current == null) {
	            parseState = 'end';
	        } else if (Array.isArray(current)) {
	            parseState = 'afterArrayValue';
	        } else {
	            parseState = 'afterPropertyValue';
	        }
	    }
	}

	function pop () {
	    stack.pop();

	    var current = stack[stack.length - 1];
	    if (current == null) {
	        parseState = 'end';
	    } else if (Array.isArray(current)) {
	        parseState = 'afterArrayValue';
	    } else {
	        parseState = 'afterPropertyValue';
	    }
	}

	// This code is unreachable.
	// function invalidParseState () {
	//     return new Error(`JSON5: invalid parse state '${parseState}'`)
	// }

	// This code is unreachable.
	// function invalidLexState (state) {
	//     return new Error(`JSON5: invalid lex state '${state}'`)
	// }

	function invalidChar (c) {
	    if (c === undefined) {
	        return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	    }

	    return syntaxError(("JSON5: invalid character '" + (formatChar(c)) + "' at " + line + ":" + column))
	}

	function invalidEOF () {
	    return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	}

	// This code is unreachable.
	// function invalidToken () {
	//     if (token.type === 'eof') {
	//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
	//     }

	//     const c = String.fromCodePoint(token.value.codePointAt(0))
	//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
	// }

	function invalidIdentifier () {
	    column -= 5;
	    return syntaxError(("JSON5: invalid identifier character at " + line + ":" + column))
	}

	function separatorChar (c) {
	    console.warn(("JSON5: '" + (formatChar(c)) + "' in strings is not valid ECMAScript; consider escaping"));
	}

	function formatChar (c) {
	    var replacements = {
	        "'": "\\'",
	        '"': '\\"',
	        '\\': '\\\\',
	        '\b': '\\b',
	        '\f': '\\f',
	        '\n': '\\n',
	        '\r': '\\r',
	        '\t': '\\t',
	        '\v': '\\v',
	        '\0': '\\0',
	        '\u2028': '\\u2028',
	        '\u2029': '\\u2029',
	    };

	    if (replacements[c]) {
	        return replacements[c]
	    }

	    if (c < ' ') {
	        var hexString = c.charCodeAt(0).toString(16);
	        return '\\x' + ('00' + hexString).substring(hexString.length)
	    }

	    return c
	}

	function syntaxError (message) {
	    var err = new SyntaxError(message);
	    err.lineNumber = line;
	    err.columnNumber = column;
	    return err
	}

	var stringify = function stringify (value, replacer, space) {
	    var stack = [];
	    var indent = '';
	    var propertyList;
	    var replacerFunc;
	    var gap = '';
	    var quote;

	    if (
	        replacer != null &&
	        typeof replacer === 'object' &&
	        !Array.isArray(replacer)
	    ) {
	        space = replacer.space;
	        quote = replacer.quote;
	        replacer = replacer.replacer;
	    }

	    if (typeof replacer === 'function') {
	        replacerFunc = replacer;
	    } else if (Array.isArray(replacer)) {
	        propertyList = [];
	        for (var i = 0, list = replacer; i < list.length; i += 1) {
	            var v = list[i];

	            var item = (void 0);

	            if (typeof v === 'string') {
	                item = v;
	            } else if (
	                typeof v === 'number' ||
	                v instanceof String ||
	                v instanceof Number
	            ) {
	                item = String(v);
	            }

	            if (item !== undefined && propertyList.indexOf(item) < 0) {
	                propertyList.push(item);
	            }
	        }
	    }

	    if (space instanceof Number) {
	        space = Number(space);
	    } else if (space instanceof String) {
	        space = String(space);
	    }

	    if (typeof space === 'number') {
	        if (space > 0) {
	            space = Math.min(10, Math.floor(space));
	            gap = '          '.substr(0, space);
	        }
	    } else if (typeof space === 'string') {
	        gap = space.substr(0, 10);
	    }

	    return serializeProperty('', {'': value})

	    function serializeProperty (key, holder) {
	        var value = holder[key];
	        if (value != null) {
	            if (typeof value.toJSON5 === 'function') {
	                value = value.toJSON5(key);
	            } else if (typeof value.toJSON === 'function') {
	                value = value.toJSON(key);
	            }
	        }

	        if (replacerFunc) {
	            value = replacerFunc.call(holder, key, value);
	        }

	        if (value instanceof Number) {
	            value = Number(value);
	        } else if (value instanceof String) {
	            value = String(value);
	        } else if (value instanceof Boolean) {
	            value = value.valueOf();
	        }

	        switch (value) {
	        case null: return 'null'
	        case true: return 'true'
	        case false: return 'false'
	        }

	        if (typeof value === 'string') {
	            return quoteString(value, false)
	        }

	        if (typeof value === 'number') {
	            return String(value)
	        }

	        if (typeof value === 'object') {
	            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
	        }

	        return undefined
	    }

	    function quoteString (value) {
	        var quotes = {
	            "'": 0.1,
	            '"': 0.2,
	        };

	        var replacements = {
	            "'": "\\'",
	            '"': '\\"',
	            '\\': '\\\\',
	            '\b': '\\b',
	            '\f': '\\f',
	            '\n': '\\n',
	            '\r': '\\r',
	            '\t': '\\t',
	            '\v': '\\v',
	            '\0': '\\0',
	            '\u2028': '\\u2028',
	            '\u2029': '\\u2029',
	        };

	        var product = '';

	        for (var i = 0; i < value.length; i++) {
	            var c = value[i];
	            switch (c) {
	            case "'":
	            case '"':
	                quotes[c]++;
	                product += c;
	                continue

	            case '\0':
	                if (util.isDigit(value[i + 1])) {
	                    product += '\\x00';
	                    continue
	                }
	            }

	            if (replacements[c]) {
	                product += replacements[c];
	                continue
	            }

	            if (c < ' ') {
	                var hexString = c.charCodeAt(0).toString(16);
	                product += '\\x' + ('00' + hexString).substring(hexString.length);
	                continue
	            }

	            product += c;
	        }

	        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });

	        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

	        return quoteChar + product + quoteChar
	    }

	    function serializeObject (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var keys = propertyList || Object.keys(value);
	        var partial = [];
	        for (var i = 0, list = keys; i < list.length; i += 1) {
	            var key = list[i];

	            var propertyString = serializeProperty(key, value);
	            if (propertyString !== undefined) {
	                var member = serializeKey(key) + ':';
	                if (gap !== '') {
	                    member += ' ';
	                }
	                member += propertyString;
	                partial.push(member);
	            }
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '{}';
	        } else {
	            var properties;
	            if (gap === '') {
	                properties = partial.join(',');
	                final = '{' + properties + '}';
	            } else {
	                var separator = ',\n' + indent;
	                properties = partial.join(separator);
	                final = '{\n' + indent + properties + ',\n' + stepback + '}';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }

	    function serializeKey (key) {
	        if (key.length === 0) {
	            return quoteString(key, true)
	        }

	        var firstChar = String.fromCodePoint(key.codePointAt(0));
	        if (!util.isIdStartChar(firstChar)) {
	            return quoteString(key, true)
	        }

	        for (var i = firstChar.length; i < key.length; i++) {
	            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
	                return quoteString(key, true)
	            }
	        }

	        return key
	    }

	    function serializeArray (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var partial = [];
	        for (var i = 0; i < value.length; i++) {
	            var propertyString = serializeProperty(String(i), value);
	            partial.push((propertyString !== undefined) ? propertyString : 'null');
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '[]';
	        } else {
	            if (gap === '') {
	                var properties = partial.join(',');
	                final = '[' + properties + ']';
	            } else {
	                var separator = ',\n' + indent;
	                var properties$1 = partial.join(separator);
	                final = '[\n' + indent + properties$1 + ',\n' + stepback + ']';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }
	};

	var JSON5 = {
	    parse: parse,
	    stringify: stringify,
	};

	var lib = JSON5;

	var es5 = lib;

	return es5;

})));

},{}],99:[function(require,module,exports){
var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

},{}],100:[function(require,module,exports){
/*!
 * map-cache <https://github.com/jonschlinkert/map-cache>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var hasOwn = Object.prototype.hasOwnProperty;

/**
 * Expose `MapCache`
 */

module.exports = MapCache;

/**
 * Creates a cache object to store key/value pairs.
 *
 * ```js
 * var cache = new MapCache();
 * ```
 *
 * @api public
 */

function MapCache(data) {
  this.__data__ = data || {};
}

/**
 * Adds `value` to `key` on the cache.
 *
 * ```js
 * cache.set('foo', 'bar');
 * ```
 *
 * @param {String} `key` The key of the value to cache.
 * @param {*} `value` The value to cache.
 * @returns {Object} Returns the `Cache` object for chaining.
 * @api public
 */

MapCache.prototype.set = function mapSet(key, value) {
  if (key !== '__proto__') {
    this.__data__[key] = value;
  }
  return this;
};

/**
 * Gets the cached value for `key`.
 *
 * ```js
 * cache.get('foo');
 * //=> 'bar'
 * ```
 *
 * @param {String} `key` The key of the value to get.
 * @returns {*} Returns the cached value.
 * @api public
 */

MapCache.prototype.get = function mapGet(key) {
  return key === '__proto__' ? undefined : this.__data__[key];
};

/**
 * Checks if a cached value for `key` exists.
 *
 * ```js
 * cache.has('foo');
 * //=> true
 * ```
 *
 * @param {String} `key` The key of the entry to check.
 * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.
 * @api public
 */

MapCache.prototype.has = function mapHas(key) {
  return key !== '__proto__' && hasOwn.call(this.__data__, key);
};

/**
 * Removes `key` and its value from the cache.
 *
 * ```js
 * cache.del('foo');
 * ```
 * @title .del
 * @param {String} `key` The key of the value to remove.
 * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.
 * @api public
 */

MapCache.prototype.del = function mapDelete(key) {
  return this.has(key) && delete this.__data__[key];
};

},{}],101:[function(require,module,exports){
'use strict';

var util = require('util');
var visit = require('object-visit');

/**
 * Map `visit` over an array of objects.
 *
 * @param  {Object} `collection` The context in which to invoke `method`
 * @param  {String} `method` Name of the method to call on `collection`
 * @param  {Object} `arr` Array of objects.
 */

module.exports = function mapVisit(collection, method, val) {
  if (isObject(val)) {
    return visit.apply(null, arguments);
  }

  if (!Array.isArray(val)) {
    throw new TypeError('expected an array: ' + util.inspect(val));
  }

  var args = [].slice.call(arguments, 3);

  for (var i = 0; i < val.length; i++) {
    var ele = val[i];
    if (isObject(ele)) {
      visit.apply(null, [collection, method, ele].concat(args));
    } else {
      collection[method].apply(collection, [ele].concat(args));
    }
  }
};

function isObject(val) {
  return val && (typeof val === 'function' || (!Array.isArray(val) && typeof val === 'object'));
}

},{"object-visit":120,"util":211}],102:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var braces = require('braces');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var mm = require('micromatch');
 * mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

function micromatch(list, patterns, options) {
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) {
    return [];
  }

  if (len === 1) {
    return micromatch.match(list, patterns[0], options);
  }

  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) {
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
    } else {
      keep.push.apply(keep, micromatch.match(list, pattern, options));
    }
  }

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) {
    return utils.unique(matches);
  }

  return matches;
}

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.match(list, pattern[, options]);
 *
 * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */

micromatch.match = function(list, pattern, options) {
  if (Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be a string');
  }

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, micromatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) {
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) {
      matches.push(utils.value(ele, unixify, options));
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return utils.unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [options.unescape ? utils.unescape(pattern) : pattern];
    }
  }

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) {
    matches = micromatch.not(matches, options.ignore, options);
  }

  return options.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.isMatch(string, pattern[, options]);
 *
 * console.log(mm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(mm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */

micromatch.isMatch = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (isEmptyString(str) || isEmptyString(pattern)) {
    return false;
  }

  var equals = utils.equalsPattern(options);
  if (equals(str)) {
    return true;
  }

  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);
  return isMatch(str);
};

/**
 * Returns true if some of the strings in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }
  for (var i = 0; i < list.length; i++) {
    if (micromatch(list[i], patterns, options).length === 1) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }
  for (var i = 0; i < list.length; i++) {
    if (micromatch(list[i], patterns, options).length !== 1) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.any(string, patterns[, options]);
 *
 * console.log(mm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(mm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.any = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (isEmptyString(str) || isEmptyString(patterns)) {
    return false;
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (micromatch.isMatch(str, patterns[i], options)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }
  if (typeof patterns === 'string') {
    patterns = [patterns];
  }
  for (var i = 0; i < patterns.length; i++) {
    if (!micromatch.isMatch(str, patterns[i], options)) {
      return false;
    }
  }
  return true;
};

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = function(list, patterns, options) {
  var opts = extend({}, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  var unixify = utils.unixify(opts);
  list = utils.arrayify(list).map(unixify);

  var matches = utils.diff(list, micromatch(list, patterns, opts));
  if (ignore) {
    matches = utils.diff(matches, micromatch(list, ignore));
  }

  return opts.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    if (isEmptyString(str) || isEmptyString(patterns)) {
      return false;
    }

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) {
      return true;
    }
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) {
      return true;
    }
  }

  var opts = extend({}, options, {contains: true});
  return micromatch.any(str, patterns, opts);
};

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */

micromatch.matchBase = function(pattern, options) {
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = function(obj, patterns, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('expected the first argument to be an object');
  }
  var keys = micromatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
};

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matcher(pattern[, options]);
 *
 * var isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = function matcher(pattern, options) {
  if (Array.isArray(pattern)) {
    return compose(pattern, options, matcher);
  }

  // if pattern is a regex
  if (pattern instanceof RegExp) {
    return test(pattern);
  }

  // if pattern is invalid
  if (!utils.isString(pattern)) {
    throw new TypeError('expected pattern to be an array, string or regex');
  }

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) {
    if (options && options.nocase === true) {
      pattern = pattern.toLowerCase();
    }
    return utils.matchPath(pattern, options);
  }

  // if pattern is a glob string
  var re = micromatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (micromatch.matchBase(pattern, options)) {
    return utils.matchBasename(re, options);
  }

  function test(regex) {
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) {
      if (equals(str)) {
        return true;
      }

      if (regex.test(unixify(str))) {
        return true;
      }
      return false;
    };
  }

  var fn = test(re);
  Object.defineProperty(fn, 'result', {
    configurable: true,
    enumerable: false,
    value: re.result
  });
  return fn;
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = function(pattern, str, options) {
  var re = micromatch.makeRe(pattern, extend({capture: true}, options));
  var unixify = utils.unixify(options);

  function match() {
    return function(string) {
      var match = re.exec(unixify(string));
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var result = micromatch.create(pattern, options);
    var ast_array = [];
    var output = result.map(function(obj) {
      obj.ast.state = obj.state;
      ast_array.push(obj.ast);
      return obj.output;
    });

    var regex = toRegex(output.join('|'), options);
    Object.defineProperty(regex, 'result', {
      configurable: true,
      enumerable: false,
      value: ast_array
    });
    return regex;
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Expand the given brace `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * console.log(mm.braces('foo/{a,b}/bar'));
 * //=> ['foo/(a|b)/bar']
 *
 * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));
 * //=> ['foo/(a|b)/bar']
 * ```
 * @param {String} `pattern` String with brace pattern to expand.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = function(pattern, options) {
  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be an array or string');
  }

  function expand() {
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return utils.arrayify(pattern);
    }
    return braces(pattern, options);
  }

  return memoize('braces', pattern, options, expand);
};

/**
 * Proxy to the [micromatch.braces](#method), for parity with
 * minimatch.
 */

micromatch.braceExpand = function(pattern, options) {
  var opts = extend({}, options, {expand: true});
  return micromatch.braces(pattern, opts);
};

/**
 * Parses the given glob `pattern` and returns an array of abstract syntax
 * trees (ASTs), with the compiled `output` and optional source `map` on
 * each AST.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.create(pattern[, options]);
 *
 * console.log(mm.create('abc/*.js'));
 * // [{ options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }]
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

micromatch.create = function(pattern, options) {
  return memoize('create', pattern, options, function() {
    function create(str, opts) {
      return micromatch.compile(micromatch.parse(str, opts), opts);
    }

    pattern = micromatch.braces(pattern, options);
    var len = pattern.length;
    var idx = -1;
    var res = [];

    while (++idx < len) {
      res.push(create(pattern[idx], options));
    }
    return res;
  });
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.parse(pattern[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

micromatch.parse = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  function parse() {
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  }

  return memoize('parse', pattern, options, parse);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.compile(ast[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(mm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

micromatch.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = micromatch.parse(ast, options);
  }

  return memoize('compile', ast.input, options, function() {
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  });
};

/**
 * Clear the regex cache.
 *
 * ```js
 * mm.clearCache();
 * ```
 * @api public
 */

micromatch.clearCache = function() {
  micromatch.cache.caches = {};
};

/**
 * Returns true if the given value is effectively an empty string
 */

function isEmptyString(val) {
  return String(val) === '' || String(val) === './';
}

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) {
  var matchers;

  return memoize('compose', String(patterns), options, function() {
    return function(file) {
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) {
        matchers = [];
        for (var i = 0; i < patterns.length; i++) {
          matchers.push(matcher(patterns[i], options));
        }
      }

      var len = matchers.length;
      while (len--) {
        if (matchers[len](file) === true) {
          return true;
        }
      }
      return false;
    };
  });
}

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) {
    return fn(pattern, options);
  }

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
}

/**
 * Expose compiler, parser and cache on `micromatch`
 */

micromatch.compilers = compilers;
micromatch.parsers = parsers;
micromatch.caches = cache.caches;

/**
 * Expose `micromatch`
 * @type {Function}
 */

module.exports = micromatch;

},{"./lib/cache":103,"./lib/compilers":104,"./lib/parsers":105,"./lib/utils":106,"braces":19,"extend-shallow":53,"to-regex":195,"util":211}],103:[function(require,module,exports){
module.exports = new (require('fragment-cache'))();

},{"fragment-cache":68}],104:[function(require,module,exports){
'use strict';

var nanomatch = require('nanomatch');
var extglob = require('extglob');

module.exports = function(snapdragon) {
  var compilers = snapdragon.compiler.compilers;
  var opts = snapdragon.options;

  // register nanomatch compilers
  snapdragon.use(nanomatch.compilers);

  // get references to some specific nanomatch compilers before they
  // are overridden by the extglob and/or custom compilers
  var escape = compilers.escape;
  var qmark = compilers.qmark;
  var slash = compilers.slash;
  var star = compilers.star;
  var text = compilers.text;
  var plus = compilers.plus;
  var dot = compilers.dot;

  // register extglob compilers or escape exglobs if disabled
  if (opts.extglob === false || opts.noext === true) {
    snapdragon.compiler.use(escapeExtglobs);
  } else {
    snapdragon.use(extglob.compilers);
  }

  snapdragon.use(function() {
    this.options.star = this.options.star || function(/*node*/) {
      return '[^\\\\/]*?';
    };
  });

  // custom micromatch compilers
  snapdragon.compiler

    // reset referenced compiler
    .set('dot', dot)
    .set('escape', escape)
    .set('plus', plus)
    .set('slash', slash)
    .set('qmark', qmark)
    .set('star', star)
    .set('text', text);
};

function escapeExtglobs(compiler) {
  compiler.set('paren', function(node) {
    var val = '';
    visit(node, function(tok) {
      if (tok.val) val += (/^\W/.test(tok.val) ? '\\' : '') + tok.val;
    });
    return this.emit(val, node);
  });

  /**
   * Visit `node` with the given `fn`
   */

  function visit(node, fn) {
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  }

  /**
   * Map visit over array of `nodes`.
   */

  function mapVisit(nodes, fn) {
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      visit(nodes[idx], fn);
    }
  }
}

},{"extglob":55,"nanomatch":110}],105:[function(require,module,exports){
'use strict';

var extglob = require('extglob');
var nanomatch = require('nanomatch');
var regexNot = require('regex-not');
var toRegex = require('to-regex');
var not;

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var TEXT = '([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+';
var createNotRegex = function(opts) {
  return not || (not = textRegex(TEXT));
};

/**
 * Parsers
 */

module.exports = function(snapdragon) {
  var parsers = snapdragon.parser.parsers;

  // register nanomatch parsers
  snapdragon.use(nanomatch.parsers);

  // get references to some specific nanomatch parsers before they
  // are overridden by the extglob and/or parsers
  var escape = parsers.escape;
  var slash = parsers.slash;
  var qmark = parsers.qmark;
  var plus = parsers.plus;
  var star = parsers.star;
  var dot = parsers.dot;

  // register extglob parsers
  snapdragon.use(extglob.parsers);

  // custom micromatch parsers
  snapdragon.parser
    .use(function() {
      // override "notRegex" created in nanomatch parser
      this.notRegex = /^\!+(?!\()/;
    })
    // reset the referenced parsers
    .capture('escape', escape)
    .capture('slash', slash)
    .capture('qmark', qmark)
    .capture('star', star)
    .capture('plus', plus)
    .capture('dot', dot)

    /**
     * Override `text` parser
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(createNotRegex(this.options));
      if (!m || !m[0]) return;

      // escape regex boundary characters and simple brackets
      var val = m[0].replace(/([[\]^$])/g, '\\$1');

      return pos({
        type: 'text',
        val: val
      });
    });
};

/**
 * Create text regex
 */

function textRegex(pattern) {
  var notStr = regexNot.create(pattern, {contains: true, strictClose: false});
  var prefix = '(?:[\\^]|\\\\|';
  return toRegex(prefix + notStr + ')', {strictClose: false});
}

},{"extglob":55,"nanomatch":110,"regex-not":146,"to-regex":195}],106:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return {Boolean}
 */

utils.isWindows = function() {
  return path.sep === '\\' || process.platform === 'win32';
};

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) {
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
    snapdragon = options.snapdragon;
  // create a new instance
  } else {
    snapdragon = new Snapdragon(options);
  }

  utils.define(snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) {
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') {
        if (inner.val.charAt(0) === '[') {
          inner.val = '\\' + inner.val;
        }

      } else {
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });

  return snapdragon;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  if (utils.typeOf(options) !== 'object') {
    return pattern;
  }
  var val = pattern;
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    val += ';' + key + '=' + String(options[key]);
  }
  return val;
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) {
  return typeof val === 'string';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) {
  return utils.typeOf(val) === 'object';
};

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) {
  return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
};

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) {
  return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, '\\$&');
};

/**
 * Normalize slashes in the given filepath.
 *
 * @param {String} `filepath`
 * @return {String}
 */

utils.toPosixPath = function(str) {
  return str.replace(/\\+/g, '/');
};

/**
 * Strip backslashes before special characters in a string.
 *
 * @param {String} `str`
 * @return {String}
 */

utils.unescape = function(str) {
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
};

/**
 * Strip the prefix from a filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripPrefix = function(str) {
  if (str.charAt(0) !== '.') {
    return str;
  }
  var ch = str.charAt(1);
  if (utils.isSlash(ch)) {
    return str.slice(2);
  }
  return str;
};

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) {
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
};

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.matchPath = function(pattern, options) {
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
};

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) {
  return pattern === filepath || pattern === unixPath;
};

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) {
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
};

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.equalsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function fn(filepath) {
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) {
      return equal;
    }
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.containsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function(filepath) {
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) {
      return contains;
    }
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param {RegExp} `re` Matching regex
 * @return {Function}
 */

utils.matchBasename = function(re) {
  return function(filepath) {
    return re.test(path.basename(filepath));
  };
};

/**
 * Determines the filepath to return based on the provided options.
 * @return {any}
 */

utils.value = function(str, unixify, options) {
  if (options && options.unixify === false) {
    return str;
  }
  return unixify(str);
};

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return {Function}
 */

utils.unixify = function(options) {
  options = options || {};
  return function(filepath) {
    if (utils.isWindows() || options.unixify === true) {
      filepath = utils.toPosixPath(filepath);
    }
    if (options.stripPrefix !== false) {
      filepath = utils.stripPrefix(filepath);
    }
    if (options.unescape === true) {
      filepath = utils.unescape(filepath);
    }
    return filepath;
  };
};

}).call(this)}).call(this,require('_process'))

},{"_process":128,"arr-diff":2,"array-unique":5,"define-property":43,"extend-shallow":53,"kind-of":99,"object.pick":121,"path":207,"snapdragon":166}],107:[function(require,module,exports){
'use strict';

var isExtendable = require('is-extendable');
var forIn = require('for-in');

function mixinDeep(target, objects) {
  var len = arguments.length, i = 0;
  while (++i < len) {
    var obj = arguments[i];
    if (isObject(obj)) {
      forIn(obj, copy, target);
    }
  }
  return target;
}

/**
 * Copy properties from the source object to the
 * target object.
 *
 * @param  {*} `val`
 * @param  {String} `key`
 */

function copy(val, key) {
  if (!isValidKey(key)) {
    return;
  }

  var obj = this[key];
  if (isObject(val) && isObject(obj)) {
    mixinDeep(obj, val);
  } else {
    this[key] = val;
  }
}

/**
 * Returns true if `val` is an object or function.
 *
 * @param  {any} val
 * @return {Boolean}
 */

function isObject(val) {
  return isExtendable(val) && !Array.isArray(val);
}

/**
 * Returns true if `key` is a valid key to use when extending objects.
 *
 * @param  {String} `key`
 * @return {Boolean}
 */

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
};

/**
 * Expose `mixinDeep`
 */

module.exports = mixinDeep;

},{"for-in":67,"is-extendable":108}],108:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54,"is-plain-object":94}],109:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],110:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm(list, patterns[, options]);
 *
 * console.log(nm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

function nanomatch(list, patterns, options) {
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) {
    return [];
  }

  if (len === 1) {
    return nanomatch.match(list, patterns[0], options);
  }

  var negated = false;
  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) {
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
      negated = true;
    } else {
      keep.push.apply(keep, nanomatch.match(list, pattern, options));
    }
  }

  // minimatch.match parity
  if (negated && keep.length === 0) {
    if (options && options.unixify === false) {
      keep = list.slice();
    } else {
      var unixify = utils.unixify(options);
      for (var i = 0; i < list.length; i++) {
        keep.push(unixify(list[i]));
      }
    }
  }

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) {
    return utils.unique(matches);
  }

  return matches;
}

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.match(list, pattern[, options]);
 *
 * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */

nanomatch.match = function(list, pattern, options) {
  if (Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be a string');
  }

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, nanomatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) {
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) {
      matches.push(utils.value(ele, unixify, options));
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return utils.unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [options.unescape ? utils.unescape(pattern) : pattern];
    }
  }

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) {
    matches = nanomatch.not(matches, options.ignore, options);
  }

  return options.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.isMatch(string, pattern[, options]);
 *
 * console.log(nm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(nm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */

nanomatch.isMatch = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
    return false;
  }

  var equals = utils.equalsPattern(options);
  if (equals(str)) {
    return true;
  }

  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);
  return isMatch(str);
};

/**
 * Returns true if some of the elements in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.some(list, patterns[, options]);
 *
 * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.some = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }

  for (var i = 0; i < list.length; i++) {
    if (nanomatch(list[i], patterns, options).length === 1) {
      return true;
    }
  }

  return false;
};

/**
 * Returns true if every element in the given `list` matches
 * at least one of the given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.every(list, patterns[, options]);
 *
 * console.log(nm.every('foo.js', ['foo.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.every = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }

  for (var i = 0; i < list.length; i++) {
    if (nanomatch(list[i], patterns, options).length !== 1) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.any(string, patterns[, options]);
 *
 * console.log(nm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(nm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.any = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
    return false;
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (nanomatch.isMatch(str, patterns[i], options)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if **all** of the given `patterns`
 * match the specified string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.all(string, patterns[, options]);
 *
 * console.log(nm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(nm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.all = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (!nanomatch.isMatch(str, patterns[i], options)) {
      return false;
    }
  }
  return true;
};

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.not(list, patterns[, options]);
 *
 * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

nanomatch.not = function(list, patterns, options) {
  var opts = extend({}, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  list = utils.arrayify(list);

  var matches = utils.diff(list, nanomatch(list, patterns, opts));
  if (ignore) {
    matches = utils.diff(matches, nanomatch(list, ignore));
  }

  return opts.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.contains(string, pattern[, options]);
 *
 * console.log(nm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(nm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

nanomatch.contains = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
      return false;
    }

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) {
      return true;
    }
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) {
      return true;
    }
  }

  var opts = extend({}, options, {contains: true});
  return nanomatch.any(str, patterns, opts);
};

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */

nanomatch.matchBase = function(pattern, options) {
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(nm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

nanomatch.matchKeys = function(obj, patterns, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('expected the first argument to be an object');
  }
  var keys = nanomatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
};

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matcher(pattern[, options]);
 *
 * var isMatch = nm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */

nanomatch.matcher = function matcher(pattern, options) {
  if (utils.isEmptyString(pattern)) {
    return function() {
      return false;
    };
  }

  if (Array.isArray(pattern)) {
    return compose(pattern, options, matcher);
  }

  // if pattern is a regex
  if (pattern instanceof RegExp) {
    return test(pattern);
  }

  // if pattern is invalid
  if (!utils.isString(pattern)) {
    throw new TypeError('expected pattern to be an array, string or regex');
  }

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) {
    if (options && options.nocase === true) {
      pattern = pattern.toLowerCase();
    }
    return utils.matchPath(pattern, options);
  }

  // if pattern is a glob string
  var re = nanomatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (nanomatch.matchBase(pattern, options)) {
    return utils.matchBasename(re, options);
  }

  function test(regex) {
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) {
      if (equals(str)) {
        return true;
      }

      if (regex.test(unixify(str))) {
        return true;
      }
      return false;
    };
  }

  // create matcher function
  var matcherFn = test(re);
  // set result object from compiler on matcher function,
  // as a non-enumerable property. useful for debugging
  utils.define(matcherFn, 'result', re.result);
  return matcherFn;
};

/**
 * Returns an array of matches captured by `pattern` in `string, or
 * `null` if the pattern did not match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.capture(pattern, string[, options]);
 *
 * console.log(nm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(nm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

nanomatch.capture = function(pattern, str, options) {
  var re = nanomatch.makeRe(pattern, extend({capture: true}, options));
  var unixify = utils.unixify(options);

  function match() {
    return function(string) {
      var match = re.exec(unixify(string));
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.makeRe(pattern[, options]);
 *
 * console.log(nm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

nanomatch.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var opts = utils.extend({wrap: false}, options);
    var result = nanomatch.create(pattern, opts);
    var regex = toRegex(result.output, opts);
    utils.define(regex, 'result', result);
    return regex;
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Parses the given glob `pattern` and returns an object with the compiled `output`
 * and optional source `map`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.create(pattern[, options]);
 *
 * console.log(nm.create('abc/*.js'));
 * // { options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

nanomatch.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }
  function create() {
    return nanomatch.compile(nanomatch.parse(pattern, options), options);
  }
  return memoize('create', pattern, options, create);
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.parse(pattern[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

nanomatch.parse = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  function parse() {
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  }

  return memoize('parse', pattern, options, parse);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.compile(ast[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(nm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

nanomatch.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = nanomatch.parse(ast, options);
  }

  function compile() {
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  }

  return memoize('compile', ast.input, options, compile);
};

/**
 * Clear the regex cache.
 *
 * ```js
 * nm.clearCache();
 * ```
 * @api public
 */

nanomatch.clearCache = function() {
  nanomatch.cache.__data__ = {};
};

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) {
  var matchers;

  return memoize('compose', String(patterns), options, function() {
    return function(file) {
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) {
        matchers = [];
        for (var i = 0; i < patterns.length; i++) {
          matchers.push(matcher(patterns[i], options));
        }
      }

      var len = matchers.length;
      while (len--) {
        if (matchers[len](file) === true) {
          return true;
        }
      }
      return false;
    };
  });
}

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) {
    return fn(pattern, options);
  }

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
}

/**
 * Expose compiler, parser and cache on `nanomatch`
 */

nanomatch.compilers = compilers;
nanomatch.parsers = parsers;
nanomatch.cache = cache;

/**
 * Expose `nanomatch`
 * @type {Function}
 */

module.exports = nanomatch;

},{"./lib/cache":111,"./lib/compilers":112,"./lib/parsers":113,"./lib/utils":114,"extend-shallow":53,"to-regex":195,"util":211}],111:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"dup":103,"fragment-cache":68}],112:[function(require,module,exports){
'use strict';

/**
* Nanomatch compilers
*/

module.exports = function(nanomatch, options) {
  function slash() {
    if (options && typeof options.slash === 'string') {
      return options.slash;
    }
    if (options && typeof options.slash === 'function') {
      return options.slash.call(nanomatch);
    }
    return '\\\\/';
  }

  function star() {
    if (options && typeof options.star === 'string') {
      return options.star;
    }
    if (options && typeof options.star === 'function') {
      return options.star.call(nanomatch);
    }
    return '[^' + slash() + ']*?';
  }

  var ast = nanomatch.ast = nanomatch.parser.ast;
  ast.state = nanomatch.parser.state;
  nanomatch.compiler.state = ast.state;
  nanomatch.compiler

    /**
     * Negation / escaping
     */

    .set('not', function(node) {
      var prev = this.prev();
      if (this.options.nonegate === true || prev.type !== 'bos') {
        return this.emit('\\' + node.val, node);
      }
      return this.emit(node.val, node);
    })
    .set('escape', function(node) {
      if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
        return this.emit(node.val, node);
      }
      return this.emit('\\' + node.val, node);
    })
    .set('quoted', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * Regex
     */

    .set('dollar', function(node) {
      if (node.parent.type === 'bracket') {
        return this.emit(node.val, node);
      }
      return this.emit('\\' + node.val, node);
    })

    /**
     * Dot: "."
     */

    .set('dot', function(node) {
      if (node.dotfiles === true) this.dotfiles = true;
      return this.emit('\\' + node.val, node);
    })

    /**
     * Slashes: "/" and "\"
     */

    .set('backslash', function(node) {
      return this.emit(node.val, node);
    })
    .set('slash', function(node, nodes, i) {
      var val = '[' + slash() + ']';
      var parent = node.parent;
      var prev = this.prev();

      // set "node.hasSlash" to true on all ancestor parens nodes
      while (parent.type === 'paren' && !parent.hasSlash) {
        parent.hasSlash = true;
        parent = parent.parent;
      }

      if (prev.addQmark) {
        val += '?';
      }

      // word boundary
      if (node.rest.slice(0, 2) === '\\b') {
        return this.emit(val, node);
      }

      // globstars
      if (node.parsed === '**' || node.parsed === './**') {
        this.output = '(?:' + this.output;
        return this.emit(val + ')?', node);
      }

      // negation
      if (node.parsed === '!**' && this.options.nonegate !== true) {
        return this.emit(val + '?\\b', node);
      }
      return this.emit(val, node);
    })

    /**
     * Square brackets
     */

    .set('bracket', function(node) {
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;
      var val = node.val;

      if (node.escaped === true) {
        inner = inner.replace(/\\?(\W)/g, '\\$1');
        negated = '';
      }

      if (inner === ']-') {
        inner = '\\]\\-';
      }

      if (negated && inner.indexOf('.') === -1) {
        inner += '.';
      }
      if (negated && inner.indexOf('/') === -1) {
        inner += '/';
      }

      val = open + negated + inner + close;
      return this.emit(val, node);
    })

    /**
     * Square: "[.]" (only matches a single character in brackets)
     */

    .set('square', function(node) {
      var val = (/^\W/.test(node.val) ? '\\' : '') + node.val;
      return this.emit(val, node);
    })

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) {
      var prev = this.prev();
      // don't use "slash" variable so that we always avoid
      // matching backslashes and slashes with a qmark
      var val = '[^.\\\\/]';
      if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) {
        val = '[^\\\\/]';
      }

      if (node.parsed.slice(-1) === '(') {
        var ch = node.rest.charAt(0);
        if (ch === '!' || ch === '=' || ch === ':') {
          return this.emit(node.val, node);
        }
      }

      if (node.val.length > 1) {
        val += '{' + node.val.length + '}';
      }
      return this.emit(val, node);
    })

    /**
     * Plus
     */

    .set('plus', function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') {
        return this.emit(node.val, node);
      }
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
        return this.emit('\\+', node);
      }
      var ch = this.output.slice(-1);
      if (/\w/.test(ch) && !node.inside) {
        return this.emit('+\\+?', node);
      }
      return this.emit('+', node);
    })

    /**
     * globstar: '**'
     */

    .set('globstar', function(node, nodes, i) {
      if (!this.output) {
        this.state.leadingGlobstar = true;
      }

      var prev = this.prev();
      var before = this.prev(2);
      var next = this.next();
      var after = this.next(2);
      var type = prev.type;
      var val = node.val;

      if (prev.type === 'slash' && next.type === 'slash') {
        if (before.type === 'text') {
          this.output += '?';

          if (after.type !== 'text') {
            this.output += '\\b';
          }
        }
      }

      var parsed = node.parsed;
      if (parsed.charAt(0) === '!') {
        parsed = parsed.slice(1);
      }

      var isInside = node.isInside.paren || node.isInside.brace;
      if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {
        val = star();
      } else {
        val = this.options.dot !== true
          ? '(?:(?!(?:[' + slash() + ']|^)\\.).)*?'
          : '(?:(?!(?:[' + slash() + ']|^)(?:\\.{1,2})($|[' + slash() + ']))(?!\\.{2}).)*?';
      }

      if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {
        val = '(?!\\.)' + val;
      }

      if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {
        if (after.type === 'text' || after.type === 'star') {
          node.addQmark = true;
        }
      }

      if (this.options.capture) {
        val = '(' + val + ')';
      }

      return this.emit(val, node);
    })

    /**
     * Star: "*"
     */

    .set('star', function(node, nodes, i) {
      var prior = nodes[i - 2] || {};
      var prev = this.prev();
      var next = this.next();
      var type = prev.type;

      function isStart(n) {
        return n.type === 'bos' || n.type === 'slash';
      }

      if (this.output === '' && this.options.contains !== true) {
        this.output = '(?![' + slash() + '])';
      }

      if (type === 'bracket' && this.options.bash === false) {
        var str = next && next.type === 'bracket' ? star() : '*?';
        if (!prev.nodes || prev.nodes[1].type !== 'posix') {
          return this.emit(str, node);
        }
      }

      var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'
        ? (this.options.dot ? '(?!(?:^|[' + slash() + '])\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\.)')
        : '';

      if (isStart(prev) || (isStart(prior) && type === 'not')) {
        if (prefix !== '(?!\\.)') {
          prefix += '(?!(\\.{2}|\\.[' + slash() + ']))(?=.)';
        } else {
          prefix += '(?=.)';
        }
      } else if (prefix === '(?!\\.)') {
        prefix = '';
      }

      if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {
        this.output = '(?!\\.)' + this.output;
      }

      var output = prefix + star();
      if (this.options.capture) {
        output = '(' + output + ')';
      }

      return this.emit(output, node);
    })

    /**
     * Text
     */

    .set('text', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * End-of-string
     */

    .set('eos', function(node) {
      var prev = this.prev();
      var val = node.val;

      this.output = '(?:\\.[' + slash() + '](?=.))?' + this.output;
      if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {
        val += (this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)');
      }

      return this.emit(val, node);
    });

  /**
   * Allow custom compilers to be passed on options
   */

  if (options && typeof options.compilers === 'function') {
    options.compilers(nanomatch.compiler);
  }
};


},{}],113:[function(require,module,exports){
'use strict';

var regexNot = require('regex-not');
var toRegex = require('to-regex');

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var cached;
var NOT_REGEX = '[\\[!*+?$^"\'.\\\\/]+';
var not = createTextRegex(NOT_REGEX);

/**
 * Nanomatch parsers
 */

module.exports = function(nanomatch, options) {
  var parser = nanomatch.parser;
  var opts = parser.options;

  parser.state = {
    slashes: 0,
    paths: []
  };

  parser.ast.state = parser.state;
  parser

    /**
     * Beginning-of-string
     */

    .capture('prefix', function() {
      if (this.parsed) return;
      var m = this.match(/^\.[\\/]/);
      if (!m) return;
      this.state.strictOpen = !!this.options.strictOpen;
      this.state.addPrefix = true;
    })

    /**
     * Escape: "\\."
     */

    .capture('escape', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|([$^]))/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[2] || m[1]
      });
    })

    /**
     * Quoted strings
     */

    .capture('quoted', function() {
      var pos = this.position();
      var m = this.match(/^["']/);
      if (!m) return;

      var quote = m[0];
      if (this.input.indexOf(quote) === -1) {
        return pos({
          type: 'escape',
          val: quote
        });
      }

      var tok = advanceTo(this.input, quote);
      this.consume(tok.len);

      return pos({
        type: 'quoted',
        val: tok.esc
      });
    })

    /**
     * Negations: "!"
     */

    .capture('not', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(this.notRegex || /^!+/);
      if (!m) return;
      var val = m[0];

      var isNegated = (val.length % 2) === 1;
      if (parsed === '' && !isNegated) {
        val = '';
      }

      // if nothing has been parsed, we know `!` is at the start,
      // so we need to wrap the result in a negation regex
      if (parsed === '' && isNegated && this.options.nonegate !== true) {
        this.bos.val = '(?!^(?:';
        this.append = ')$).*';
        val = '';
      }
      return pos({
        type: 'not',
        val: val
      });
    })

    /**
     * Dot: "."
     */

    .capture('dot', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\.+/);
      if (!m) return;

      var val = m[0];
      this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');

      return pos({
        type: 'dot',
        dotfiles: this.state.dot,
        val: val
      });
    })

    /**
     * Plus: "+"
     */

    .capture('plus', /^\+(?!\()/)

    /**
     * Question mark: "?"
     */

    .capture('qmark', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;

      this.state.metachar = true;
      this.state.qmark = true;

      return pos({
        type: 'qmark',
        parsed: parsed,
        val: m[0]
      });
    })

    /**
     * Globstar: "**"
     */

    .capture('globstar', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
      if (!m) return;

      var type = opts.noglobstar !== true ? 'globstar' : 'star';
      var node = pos({type: type, parsed: parsed});
      this.state.metachar = true;

      while (this.input.slice(0, 4) === '/**/') {
        this.input = this.input.slice(3);
      }

      node.isInside = {
        brace: this.isInside('brace'),
        paren: this.isInside('paren')
      };

      if (type === 'globstar') {
        this.state.globstar = true;
        node.val = '**';

      } else {
        this.state.star = true;
        node.val = '*';
      }

      return node;
    })

    /**
     * Star: "*"
     */

    .capture('star', function() {
      var pos = this.position();
      var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
      var m = this.match(starRe);
      if (!m) return;

      this.state.metachar = true;
      this.state.star = true;
      return pos({
        type: 'star',
        val: m[0]
      });
    })

    /**
     * Slash: "/"
     */

    .capture('slash', function() {
      var pos = this.position();
      var m = this.match(/^\//);
      if (!m) return;

      this.state.slashes++;
      return pos({
        type: 'slash',
        val: m[0]
      });
    })

    /**
     * Backslash: "\\"
     */

    .capture('backslash', function() {
      var pos = this.position();
      var m = this.match(/^\\(?![*+?(){}[\]'"])/);
      if (!m) return;

      var val = m[0];

      if (this.isInside('bracket')) {
        val = '\\';
      } else if (val.length > 1) {
        val = '\\\\';
      }

      return pos({
        type: 'backslash',
        val: val
      });
    })

    /**
     * Square: "[.]"
     */

    .capture('square', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\[([^!^\\])\]/);
      if (!m) return;

      return pos({
        type: 'square',
        val: m[1]
      });
    })

    /**
     * Brackets: "[...]" (basic, this can be overridden by other parsers)
     */

    .capture('bracket', function() {
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = (m[2] || '').replace(/\\\\+/, '\\\\');
      var close = m[3] || '';

      if (m[2] && inner.length < m[2].length) {
        val = val.replace(/\\\\+/, '\\\\');
      }

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') {
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          if (ch === ']') {
            close = ch;
            break;
          }
          inner += ch;
        }
      }

      return pos({
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      });
    })

    /**
     * Text
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos({
        type: 'text',
        val: m[0]
      });
    });

  /**
   * Allow custom parsers to be passed on options
   */

  if (options && typeof options.parsers === 'function') {
    options.parsers(nanomatch.parser);
  }
};

/**
 * Advance to the next non-escaped character
 */

function advanceTo(input, endChar) {
  var ch = input.charAt(0);
  var tok = { len: 1, val: '', esc: '' };
  var idx = 0;

  function advance() {
    if (ch !== '\\') {
      tok.esc += '\\' + ch;
      tok.val += ch;
    }

    ch = input.charAt(++idx);
    tok.len++;

    if (ch === '\\') {
      advance();
      advance();
    }
  }

  while (ch && ch !== endChar) {
    advance();
  }
  return tok;
}

/**
 * Create text regex
 */

function createTextRegex(pattern) {
  if (cached) return cached;
  var opts = {contains: true, strictClose: false};
  var not = regexNot.create(pattern, opts);
  var re = toRegex('^(?:[*]\\((?=.)|' + not + ')', opts);
  return (cached = re);
}

/**
 * Expose negation string
 */

module.exports.not = NOT_REGEX;

},{"regex-not":146,"to-regex":195}],114:[function(require,module,exports){
'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var isWindows = require('is-windows')();
var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the given value is effectively an empty string
 */

utils.isEmptyString = function(val) {
  return String(val) === '' || String(val) === './';
};

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return {Boolean}
 */

utils.isWindows = function() {
  return path.sep === '\\' || isWindows === true;
};

/**
 * Return the last element from an array
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) {
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
    snapdragon = options.snapdragon;
  // create a new instance
  } else {
    snapdragon = new Snapdragon(options);
  }

  utils.define(snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.call(this, str, options);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) {
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') {
        if (inner.val.charAt(0) === '[') {
          inner.val = '\\' + inner.val;
        }

      } else {
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });

  return snapdragon;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  if (typeof options === 'undefined') {
    return pattern;
  }
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) {
  return typeof val === 'string';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isRegex = function(val) {
  return utils.typeOf(val) === 'regexp';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) {
  return utils.typeOf(val) === 'object';
};

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) {
  return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, '\\$&');
};

/**
 * Combines duplicate characters in the provided `input` string.
 * @param {String} `input`
 * @returns {String}
 */

utils.combineDupes = function(input, patterns) {
  patterns = utils.arrayify(patterns).join('|').split('|');
  patterns = patterns.map(function(s) {
    return s.replace(/\\?([+*\\/])/g, '\\$1');
  });
  var substr = patterns.join('|');
  var regex = new RegExp('(' + substr + ')(?=\\1)', 'g');
  return input.replace(regex, '');
};

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) {
  return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
};

/**
 * Normalize slashes in the given filepath.
 *
 * @param {String} `filepath`
 * @return {String}
 */

utils.toPosixPath = function(str) {
  return str.replace(/\\+/g, '/');
};

/**
 * Strip backslashes before special characters in a string.
 *
 * @param {String} `str`
 * @return {String}
 */

utils.unescape = function(str) {
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
};

/**
 * Strip the drive letter from a windows filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripDrive = function(fp) {
  return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, '/') : fp;
};

/**
 * Strip the prefix from a filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripPrefix = function(str) {
  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\')) {
    return str.slice(2);
  }
  return str;
};

/**
 * Returns true if `str` is a common character that doesn't need
 * to be processed to be used for matching.
 * @param {String} `str`
 * @return {Boolean}
 */

utils.isSimpleChar = function(str) {
  return str.trim() === '' || str === '.';
};

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) {
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
};

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.matchPath = function(pattern, options) {
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
};

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) {
  return pattern === filepath || pattern === unixPath;
};

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) {
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
};

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.equalsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function fn(filepath) {
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) {
      return equal;
    }
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.containsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function(filepath) {
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) {
      return contains;
    }
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param {RegExp} `re` Matching regex
 * @return {Function}
 */

utils.matchBasename = function(re) {
  return function(filepath) {
    return re.test(filepath) || re.test(path.basename(filepath));
  };
};

/**
 * Returns the given value unchanced.
 * @return {any}
 */

utils.identity = function(val) {
  return val;
};

/**
 * Determines the filepath to return based on the provided options.
 * @return {any}
 */

utils.value = function(str, unixify, options) {
  if (options && options.unixify === false) {
    return str;
  }
  if (options && typeof options.unixify === 'function') {
    return options.unixify(str);
  }
  return unixify(str);
};

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return {Function}
 */

utils.unixify = function(options) {
  var opts = options || {};
  return function(filepath) {
    if (opts.stripPrefix !== false) {
      filepath = utils.stripPrefix(filepath);
    }
    if (opts.unescape === true) {
      filepath = utils.unescape(filepath);
    }
    if (opts.unixify === true || utils.isWindows()) {
      filepath = utils.toPosixPath(filepath);
    }
    return filepath;
  };
};

},{"arr-diff":2,"array-unique":5,"define-property":43,"extend-shallow":53,"is-windows":95,"kind-of":99,"object.pick":121,"path":207,"snapdragon":166}],115:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var removeTrailingSeparator = require('remove-trailing-separator');

module.exports = function normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  str = str.replace(/[\\\/]+/g, '/');
  if (stripTrailing !== false) {
    str = removeTrailingSeparator(str);
  }
  return str;
};

},{"remove-trailing-separator":147}],116:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],117:[function(require,module,exports){
'use strict';

var typeOf = require('kind-of');
var copyDescriptor = require('copy-descriptor');
var define = require('define-property');

/**
 * Copy static properties, prototype properties, and descriptors from one object to another.
 *
 * ```js
 * function App() {}
 * var proto = App.prototype;
 * App.prototype.set = function() {};
 * App.prototype.get = function() {};
 *
 * var obj = {};
 * copy(obj, proto);
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

function copy(receiver, provider, omit) {
  if (!isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }

  var props = nativeKeys(provider);
  var keys = Object.keys(provider);
  var len = props.length;
  omit = arrayify(omit);

  while (len--) {
    var key = props[len];

    if (has(keys, key)) {
      define(receiver, key, provider[key]);
    } else if (!(key in receiver) && !has(omit, key)) {
      copyDescriptor(receiver, provider, key);
    }
  }
};

/**
 * Return true if the given value is an object or function
 */

function isObject(val) {
  return typeOf(val) === 'object' || typeof val === 'function';
}

/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 */

function has(obj, val) {
  val = arrayify(val);
  var len = val.length;

  if (isObject(obj)) {
    for (var key in obj) {
      if (val.indexOf(key) > -1) {
        return true;
      }
    }

    var keys = nativeKeys(obj);
    return has(keys, val);
  }

  if (Array.isArray(obj)) {
    var arr = obj;
    while (len--) {
      if (arr.indexOf(val[len]) > -1) {
        return true;
      }
    }
    return false;
  }

  throw new TypeError('expected an array or object.');
}

/**
 * Cast the given value to an array.
 *
 * ```js
 * arrayify('foo');
 * //=> ['foo']
 *
 * arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 */

function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
}

/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * hasConstructor({});
 * //=> true
 *
 * hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 */

function hasConstructor(val) {
  return isObject(val) && typeof val.constructor !== 'undefined';
}

/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 */

function nativeKeys(val) {
  if (!hasConstructor(val)) return [];
  return Object.getOwnPropertyNames(val);
}

/**
 * Expose `copy`
 */

module.exports = copy;

/**
 * Expose `copy.has` for tests
 */

module.exports.has = has;

},{"copy-descriptor":39,"define-property":118,"kind-of":119}],118:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],119:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],120:[function(require,module,exports){
/*!
 * object-visit <https://github.com/jonschlinkert/object-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

module.exports = function visit(thisArg, method, target, val) {
  if (!isObject(thisArg) && typeof thisArg !== 'function') {
    throw new Error('object-visit expects `thisArg` to be an object.');
  }

  if (typeof method !== 'string') {
    throw new Error('object-visit expects `method` name to be a string');
  }

  if (typeof thisArg[method] !== 'function') {
    return thisArg;
  }

  var args = [].slice.call(arguments, 3);
  target = target || {};

  for (var key in target) {
    var arr = [key, target[key]].concat(args);
    thisArg[method].apply(thisArg, arr);
  }
  return thisArg;
};

},{"isobject":97}],121:[function(require,module,exports){
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

var isObject = require('isobject');

module.exports = function pick(obj, keys) {
  if (!isObject(obj) && typeof obj !== 'function') {
    return {};
  }

  var res = {};
  if (typeof keys === 'string') {
    if (keys in obj) {
      res[keys] = obj[keys];
    }
    return res;
  }

  var len = keys.length;
  var idx = -1;

  while (++idx < len) {
    var key = keys[idx];
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
};

},{"isobject":97}],122:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],123:[function(require,module,exports){
/*!
 * pascalcase <https://github.com/jonschlinkert/pascalcase>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

function pascalcase(str) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string.');
  }
  str = str.replace(/([A-Z])/g, ' $1');
  if (str.length === 1) { return str.toUpperCase(); }
  str = str.replace(/^[\W_]+|[\W_]+$/g, '').toLowerCase();
  str = str.charAt(0).toUpperCase() + str.slice(1);
  return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
    return ch.toUpperCase();
  });
}

module.exports = pascalcase;

},{}],124:[function(require,module,exports){
(function (process){(function (){
'use strict';

var path = require('path');
var inspect = require('util').inspect;

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + inspect(path));
  }
}

function posix(path) {
  assertPath(path);
  if (path.length === 0)
    return '.';
  var code = path.charCodeAt(0);
  var hasRoot = (code === 47/*/*/);
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47/*/*/) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1)
    return hasRoot ? '/' : '.';
  if (hasRoot && end === 1)
    return '//';
  return path.slice(0, end);
}

function win32(path) {
  assertPath(path);
  var len = path.length;
  if (len === 0)
    return '.';
  var rootEnd = -1;
  var end = -1;
  var matchedSlash = true;
  var offset = 0;
  var code = path.charCodeAt(0);

  // Try to match a root
  if (len > 1) {
    if (code === 47/*/*/ || code === 92/*\*/) {
      // Possible UNC root

      rootEnd = offset = 1;

      code = path.charCodeAt(1);
      if (code === 47/*/*/ || code === 92/*\*/) {
        // Matched double path separator at beginning
        var j = 2;
        var last = j;
        // Match 1 or more non-path separators
        for (; j < len; ++j) {
          code = path.charCodeAt(j);
          if (code === 47/*/*/ || code === 92/*\*/)
            break;
        }
        if (j < len && j !== last) {
          // Matched!
          last = j;
          // Match 1 or more path separators
          for (; j < len; ++j) {
            code = path.charCodeAt(j);
            if (code !== 47/*/*/ && code !== 92/*\*/)
              break;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more non-path separators
            for (; j < len; ++j) {
              code = path.charCodeAt(j);
              if (code === 47/*/*/ || code === 92/*\*/)
                break;
            }
            if (j === len) {
              // We matched a UNC root only
              return path;
            }
            if (j !== last) {
              // We matched a UNC root with leftovers

              // Offset by 1 to include the separator after the UNC root to
              // treat it as a "normal root" on top of a (UNC) root
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||
               (code >= 97/*a*/ && code <= 122/*z*/)) {
      // Possible device root

      code = path.charCodeAt(1);
      if (path.charCodeAt(1) === 58/*:*/) {
        rootEnd = offset = 2;
        if (len > 2) {
          code = path.charCodeAt(2);
          if (code === 47/*/*/ || code === 92/*\*/)
            rootEnd = offset = 3;
        }
      }
    }
  } else if (code === 47/*/*/ || code === 92/*\*/) {
    return path[0];
  }

  for (var i = len - 1; i >= offset; --i) {
    code = path.charCodeAt(i);
    if (code === 47/*/*/ || code === 92/*\*/) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) {
    if (rootEnd === -1)
      return '.';
    else
      end = rootEnd;
  }
  return path.slice(0, end);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":128,"path":207,"util":211}],125:[function(require,module,exports){
(function (process){(function (){
'use strict';

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":128}],126:[function(require,module,exports){
'use strict';

/**
 * POSIX character classes
 */

module.exports = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

},{}],127:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))

},{"_process":128}],128:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],129:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":130}],130:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":132,"./_stream_writable":134,"core-util-is":40,"inherits":80,"process-nextick-args":127}],131:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":133,"core-util-is":40,"inherits":80}],132:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":130,"./internal/streams/BufferList":135,"./internal/streams/destroy":136,"./internal/streams/stream":137,"_process":128,"core-util-is":40,"events":206,"inherits":80,"isarray":96,"process-nextick-args":127,"safe-buffer":138,"string_decoder/":139,"util":25}],133:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":130,"core-util-is":40,"inherits":80}],134:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":130,"./internal/streams/destroy":136,"./internal/streams/stream":137,"_process":128,"core-util-is":40,"inherits":80,"process-nextick-args":127,"safe-buffer":138,"timers":191,"util-deprecate":203}],135:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":138,"util":25}],136:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":127}],137:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":206}],138:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":26}],139:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":138}],140:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":141}],141:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":130,"./lib/_stream_passthrough.js":131,"./lib/_stream_readable.js":132,"./lib/_stream_transform.js":133,"./lib/_stream_writable.js":134}],142:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":141}],143:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":134}],144:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var fs        =  require('graceful-fs')
  , path      =  require('path')
  , micromatch =  require('micromatch').isMatch
  , toString  =  Object.prototype.toString
  ;


// Standard helpers
function isFunction (obj) {
  return toString.call(obj) === '[object Function]';
}

function isString (obj) {
  return toString.call(obj) === '[object String]';
}

function isUndefined (obj) {
  return obj === void 0;
}

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
 * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
 *                                when callback2 is not given, it behaves like explained in callback2
 * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
 *                                function (err, fileInfos) { ... }
 */
function readdir(opts, callback1, callback2) {
  var stream
    , handleError
    , handleFatalError
    , errors = []
    , readdirResult = {
        directories: []
      , files: []
    }
    , fileProcessed
    , allProcessed
    , realRoot
    , aborted = false
    , paused = false
    ;

  // If no callbacks were given we will use a streaming interface
  if (isUndefined(callback1)) {
    var api          =  require('./stream-api')();
    stream           =  api.stream;
    callback1        =  api.processEntry;
    callback2        =  api.done;
    handleError      =  api.handleError;
    handleFatalError =  api.handleFatalError;

    stream.on('close', function () { aborted = true; });
    stream.on('pause', function () { paused = true; });
    stream.on('resume', function () { paused = false; });
  } else {
    handleError      =  function (err) { errors.push(err); };
    handleFatalError =  function (err) {
      handleError(err);
      allProcessed(errors, null);
    };
  }

  if (isUndefined(opts)){
    handleFatalError(new Error (
      'Need to pass at least one argument: opts! \n' +
      'https://github.com/paulmillr/readdirp#options'
      )
    );
    return stream;
  }

  opts.root            =  opts.root            || '.';
  opts.fileFilter      =  opts.fileFilter      || function() { return true; };
  opts.directoryFilter =  opts.directoryFilter || function() { return true; };
  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
  opts.entryType       =  opts.entryType       || 'files';

  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);

  if (isUndefined(callback2)) {
    fileProcessed = function() { };
    allProcessed = callback1;
  } else {
    fileProcessed = callback1;
    allProcessed = callback2;
  }

  function normalizeFilter (filter) {

    if (isUndefined(filter)) return undefined;

    function isNegated (filters) {

      function negated(f) {
        return f.indexOf('!') === 0;
      }

      var some = filters.some(negated);
      if (!some) {
        return false;
      } else {
        if (filters.every(negated)) {
          return true;
        } else {
          // if we detect illegal filters, bail out immediately
          throw new Error(
            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
            'https://github.com/paulmillr/readdirp#filters'
          );
        }
      }
    }

    // Turn all filters into a function
    if (isFunction(filter)) {

      return filter;

    } else if (isString(filter)) {

      return function (entryInfo) {
        return micromatch(entryInfo.name, filter.trim());
      };

    } else if (filter && Array.isArray(filter)) {

      if (filter) filter = filter.map(function (f) {
        return f.trim();
      });

      return isNegated(filter) ?
        // use AND to concat multiple negated filters
        function (entryInfo) {
          return filter.every(function (f) {
            return micromatch(entryInfo.name, f);
          });
        }
        :
        // use OR to concat multiple inclusive filters
        function (entryInfo) {
          return filter.some(function (f) {
            return micromatch(entryInfo.name, f);
          });
        };
    }
  }

  function processDir(currentDir, entries, callProcessed) {
    if (aborted) return;
    var total = entries.length
      , processed = 0
      , entryInfos = []
      ;

    fs.realpath(currentDir, function(err, realCurrentDir) {
      if (aborted) return;
      if (err) {
        handleError(err);
        callProcessed(entryInfos);
        return;
      }

      var relDir = path.relative(realRoot, realCurrentDir);

      if (entries.length === 0) {
        callProcessed([]);
      } else {
        entries.forEach(function (entry) {

          var fullPath = path.join(realCurrentDir, entry)
            , relPath  = path.join(relDir, entry);

          statfn(fullPath, function (err, stat) {
            if (err) {
              handleError(err);
            } else {
              entryInfos.push({
                  name          :  entry
                , path          :  relPath   // relative to root
                , fullPath      :  fullPath

                , parentDir     :  relDir    // relative to root
                , fullParentDir :  realCurrentDir

                , stat          :  stat
              });
            }
            processed++;
            if (processed === total) callProcessed(entryInfos);
          });
        });
      }
    });
  }

  function readdirRec(currentDir, depth, callCurrentDirProcessed) {
    var args = arguments;
    if (aborted) return;
    if (paused) {
      setImmediate(function () {
        readdirRec.apply(null, args);
      })
      return;
    }

    fs.readdir(currentDir, function (err, entries) {
      if (err) {
        handleError(err);
        callCurrentDirProcessed();
        return;
      }

      processDir(currentDir, entries, function(entryInfos) {

        var subdirs = entryInfos
          .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });

        subdirs.forEach(function (di) {
          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
            fileProcessed(di);
          }
          readdirResult.directories.push(di);
        });

        entryInfos
          .filter(function(ei) {
            var isCorrectType = opts.entryType === 'all' ?
              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
            return isCorrectType && opts.fileFilter(ei);
          })
          .forEach(function (fi) {
            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
              fileProcessed(fi);
            }
            readdirResult.files.push(fi);
          });

        var pendingSubdirs = subdirs.length;

        // Be done if no more subfolders exist or we reached the maximum desired depth
        if(pendingSubdirs === 0 || depth === opts.depth) {
          callCurrentDirProcessed();
        } else {
          // recurse into subdirs, keeping track of which ones are done
          // and call back once all are processed
          subdirs.forEach(function (subdir) {
            readdirRec(subdir.fullPath, depth + 1, function () {
              pendingSubdirs = pendingSubdirs - 1;
              if(pendingSubdirs === 0) {
                callCurrentDirProcessed();
              }
            });
          });
        }
      });
    });
  }

  // Validate and normalize filters
  try {
    opts.fileFilter = normalizeFilter(opts.fileFilter);
    opts.directoryFilter = normalizeFilter(opts.directoryFilter);
  } catch (err) {
    // if we detect illegal filters, bail out immediately
    handleFatalError(err);
    return stream;
  }

  // If filters were valid get on with the show
  fs.realpath(opts.root, function(err, res) {
    if (err) {
      handleFatalError(err);
      return stream;
    }

    realRoot = res;
    readdirRec(opts.root, 0, function () {
      // All errors are collected into the errors array
      if (errors.length > 0) {
        allProcessed(errors, readdirResult);
      } else {
        allProcessed(null, readdirResult);
      }
    });
  });

  return stream;
}

module.exports = readdir;

}).call(this)}).call(this,require("timers").setImmediate)

},{"./stream-api":145,"graceful-fs":73,"micromatch":102,"path":207,"timers":191}],145:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var stream = require('readable-stream');
var util = require('util');

var Readable = stream.Readable;

module.exports = ReaddirpReadable;

util.inherits(ReaddirpReadable, Readable);

function ReaddirpReadable (opts) {
  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);

  opts = opts || {};

  opts.objectMode = true;
  Readable.call(this, opts);

  // backpressure not implemented at this point
  this.highWaterMark = Infinity;

  this._destroyed = false;
  this._paused = false;
  this._warnings = [];
  this._errors = [];

  this._pauseResumeErrors();
}

var proto = ReaddirpReadable.prototype;

proto._pauseResumeErrors = function () {
  var self = this;
  self.on('pause', function () { self._paused = true });
  self.on('resume', function () {
    if (self._destroyed) return;
    self._paused = false;

    self._warnings.forEach(function (err) { self.emit('warn', err) });
    self._warnings.length = 0;

    self._errors.forEach(function (err) { self.emit('error', err) });
    self._errors.length = 0;
  })
}

// called for each entry
proto._processEntry = function (entry) {
  if (this._destroyed) return;
  this.push(entry);
}

proto._read = function () { }

proto.destroy = function () {
  // when stream is destroyed it will emit nothing further, not even errors or warnings
  this.push(null);
  this.readable = false;
  this._destroyed = true;
  this.emit('close');
}

proto._done = function () {
  this.push(null);
}

// we emit errors and warnings async since we may handle errors like invalid args
// within the initial event loop before any event listeners subscribed
proto._handleError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._warnings.push(err);
    if (!self._destroyed) self.emit('warn', err);
  });
}

proto._handleFatalError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._errors.push(err);
    if (!self._destroyed) self.emit('error', err);
  });
}

function createStreamAPI () {
  var stream = new ReaddirpReadable();

  return {
      stream           :  stream
    , processEntry     :  stream._processEntry.bind(stream)
    , done             :  stream._done.bind(stream)
    , handleError      :  stream._handleError.bind(stream)
    , handleFatalError :  stream._handleFatalError.bind(stream)
  };
}

module.exports = createStreamAPI;

}).call(this)}).call(this,require("timers").setImmediate)

},{"readable-stream":141,"timers":191,"util":211}],146:[function(require,module,exports){
'use strict';

var extend = require('extend-shallow');
var safe = require('safe-regex');

/**
 * The main export is a function that takes a `pattern` string and an `options` object.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not('foo'));
 & //=> /^(?:(?!^(?:foo)$).)*$/
 * ```
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.
 * @api public
 */

function toRegex(pattern, options) {
  return new RegExp(toRegex.create(pattern, options));
}

/**
 * Create a regex-compatible string from the given `pattern` and `options`.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not.create('foo'));
 & //=> '^(?:(?!^(?:foo)$).)*$'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

toRegex.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var opts = extend({}, options);
  if (opts.contains === true) {
    opts.strictNegate = false;
  }

  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var endChar = opts.endChar ? opts.endChar : '+';
  var str = pattern;

  if (opts.strictNegate === false) {
    str = '(?:(?!(?:' + pattern + ')).)' + endChar;
  } else {
    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;
  }

  var res = open + str + close;
  if (opts.safe === true && safe(res) === false) {
    throw new Error('potentially unsafe regular expression: ' + res);
  }

  return res;
};

/**
 * Expose `toRegex`
 */

module.exports = toRegex;

},{"extend-shallow":53,"safe-regex":156}],147:[function(require,module,exports){
(function (process){(function (){
var isWin = process.platform === 'win32';

module.exports = function (str) {
	var i = str.length - 1;
	if (i < 2) {
		return str;
	}
	while (isSeparator(str, i)) {
		i--;
	}
	return str.substr(0, i + 1);
};

function isSeparator(str, i) {
	var char = str[i];
	return i > 0 && (char === '/' || (isWin && char === '\\'));
}

}).call(this)}).call(this,require('_process'))

},{"_process":128}],148:[function(require,module,exports){
/*!
 * repeat-element <https://github.com/jonschlinkert/repeat-element>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function repeat(ele, num) {
  var arr = new Array(num);

  for (var i = 0; i < num; i++) {
    arr[i] = ele;
  }

  return arr;
};

},{}],149:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

},{}],150:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (MIT) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],151:[function(require,module,exports){
var util      = require('./util');
var types     = require('./types');
var sets      = require('./sets');
var positions = require('./positions');


module.exports = function(regexpStr) {
  var i = 0, l, c,
      start = { type: types.ROOT, stack: []},

      // Keep track of last clause/group and stack.
      lastGroup = start,
      last = start.stack,
      groupStack = [];


  var repeatErr = function(i) {
    util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));
  };

  // Decode a few escaped characters.
  var str = util.strToChars(regexpStr);
  l = str.length;

  // Iterate through each character in string.
  while (i < l) {
    c = str[i++];

    switch (c) {
      // Handle escaped characters, inclues a few sets.
      case '\\':
        c = str[i++];

        switch (c) {
          case 'b':
            last.push(positions.wordBoundary());
            break;

          case 'B':
            last.push(positions.nonWordBoundary());
            break;

          case 'w':
            last.push(sets.words());
            break;

          case 'W':
            last.push(sets.notWords());
            break;

          case 'd':
            last.push(sets.ints());
            break;

          case 'D':
            last.push(sets.notInts());
            break;

          case 's':
            last.push(sets.whitespace());
            break;

          case 'S':
            last.push(sets.notWhitespace());
            break;

          default:
            // Check if c is integer.
            // In which case it's a reference.
            if (/\d/.test(c)) {
              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });

            // Escaped character.
            } else {
              last.push({ type: types.CHAR, value: c.charCodeAt(0) });
            }
        }

        break;


      // Positionals.
      case '^':
          last.push(positions.begin());
        break;

      case '$':
          last.push(positions.end());
        break;


      // Handle custom sets.
      case '[':
        // Check if this class is 'anti' i.e. [^abc].
        var not;
        if (str[i] === '^') {
          not = true;
          i++;
        } else {
          not = false;
        }

        // Get all the characters in class.
        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);

        // Increase index by length of class.
        i += classTokens[1];
        last.push({
          type: types.SET,
          set: classTokens[0],
          not: not,
        });

        break;


      // Class of any character except \n.
      case '.':
        last.push(sets.anyChar());
        break;


      // Push group onto stack.
      case '(':
        // Create group.
        var group = {
          type: types.GROUP,
          stack: [],
          remember: true,
        };

        c = str[i];

        // If if this is a special kind of group.
        if (c === '?') {
          c = str[i + 1];
          i += 2;

          // Match if followed by.
          if (c === '=') {
            group.followedBy = true;

          // Match if not followed by.
          } else if (c === '!') {
            group.notFollowedBy = true;

          } else if (c !== ':') {
            util.error(regexpStr,
              'Invalid group, character \'' + c +
              '\' after \'?\' at column ' + (i - 1));
          }

          group.remember = false;
        }

        // Insert subgroup into current group stack.
        last.push(group);

        // Remember the current group for when the group closes.
        groupStack.push(lastGroup);

        // Make this new group the current group.
        lastGroup = group;
        last = group.stack;
        break;


      // Pop group out of stack.
      case ')':
        if (groupStack.length === 0) {
          util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));
        }
        lastGroup = groupStack.pop();

        // Check if this group has a PIPE.
        // To get back the correct last stack.
        last = lastGroup.options ?
          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;


      // Use pipe character to give more choices.
      case '|':
        // Create array where options are if this is the first PIPE
        // in this clause.
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        }

        // Create a new stack and add to options for rest of clause.
        var stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;


      // Repetition.
      // For every repetition, remove last element from last stack
      // then insert back a RANGE object.
      // This design is chosen because there could be more than
      // one repetition symbols in a regex i.e. `a?+{2,3}`.
      case '{':
        var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
        if (rs !== null) {
          if (last.length === 0) {
            repeatErr(i);
          }
          min = parseInt(rs[1], 10);
          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
          i += rs[0].length;

          last.push({
            type: types.REPETITION,
            min: min,
            max: max,
            value: last.pop(),
          });
        } else {
          last.push({
            type: types.CHAR,
            value: 123,
          });
        }
        break;

      case '?':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 0,
          max: 1,
          value: last.pop(),
        });
        break;

      case '+':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop(),
        });
        break;

      case '*':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop(),
        });
        break;


      // Default is a character that is not `\[](){}?+*^$`.
      default:
        last.push({
          type: types.CHAR,
          value: c.charCodeAt(0),
        });
    }

  }

  // Check if any groups have not been closed.
  if (groupStack.length !== 0) {
    util.error(regexpStr, 'Unterminated group');
  }

  return start;
};

module.exports.types = types;

},{"./positions":152,"./sets":153,"./types":154,"./util":155}],152:[function(require,module,exports){
var types = require('./types');

exports.wordBoundary = function() {
  return { type: types.POSITION, value: 'b' };
};

exports.nonWordBoundary = function() {
  return { type: types.POSITION, value: 'B' };
};

exports.begin = function() {
  return { type: types.POSITION, value: '^' };
};

exports.end = function() {
  return { type: types.POSITION, value: '$' };
};

},{"./types":154}],153:[function(require,module,exports){
var types = require('./types');

var INTS = function() {
 return [{ type: types.RANGE , from: 48, to: 57 }];
};

var WORDS = function() {
 return [
    { type: types.CHAR, value: 95 },
    { type: types.RANGE, from: 97, to: 122 },
    { type: types.RANGE, from: 65, to: 90 }
  ].concat(INTS());
};

var WHITESPACE = function() {
 return [
    { type: types.CHAR, value: 9 },
    { type: types.CHAR, value: 10 },
    { type: types.CHAR, value: 11 },
    { type: types.CHAR, value: 12 },
    { type: types.CHAR, value: 13 },
    { type: types.CHAR, value: 32 },
    { type: types.CHAR, value: 160 },
    { type: types.CHAR, value: 5760 },
    { type: types.CHAR, value: 6158 },
    { type: types.CHAR, value: 8192 },
    { type: types.CHAR, value: 8193 },
    { type: types.CHAR, value: 8194 },
    { type: types.CHAR, value: 8195 },
    { type: types.CHAR, value: 8196 },
    { type: types.CHAR, value: 8197 },
    { type: types.CHAR, value: 8198 },
    { type: types.CHAR, value: 8199 },
    { type: types.CHAR, value: 8200 },
    { type: types.CHAR, value: 8201 },
    { type: types.CHAR, value: 8202 },
    { type: types.CHAR, value: 8232 },
    { type: types.CHAR, value: 8233 },
    { type: types.CHAR, value: 8239 },
    { type: types.CHAR, value: 8287 },
    { type: types.CHAR, value: 12288 },
    { type: types.CHAR, value: 65279 }
  ];
};

var NOTANYCHAR = function() {
  return [
    { type: types.CHAR, value: 10 },
    { type: types.CHAR, value: 13 },
    { type: types.CHAR, value: 8232 },
    { type: types.CHAR, value: 8233 },
  ];
};

// Predefined class objects.
exports.words = function() {
  return { type: types.SET, set: WORDS(), not: false };
};

exports.notWords = function() {
  return { type: types.SET, set: WORDS(), not: true };
};

exports.ints = function() {
  return { type: types.SET, set: INTS(), not: false };
};

exports.notInts = function() {
  return { type: types.SET, set: INTS(), not: true };
};

exports.whitespace = function() {
  return { type: types.SET, set: WHITESPACE(), not: false };
};

exports.notWhitespace = function() {
  return { type: types.SET, set: WHITESPACE(), not: true };
};

exports.anyChar = function() {
  return { type: types.SET, set: NOTANYCHAR(), not: true };
};

},{"./types":154}],154:[function(require,module,exports){
module.exports = {
  ROOT       : 0,
  GROUP      : 1,
  POSITION   : 2,
  SET        : 3,
  RANGE      : 4,
  REPETITION : 5,
  REFERENCE  : 6,
  CHAR       : 7,
};

},{}],155:[function(require,module,exports){
var types = require('./types');
var sets  = require('./sets');


// All of these are private and only used by randexp.
// It's assumed that they will always be called with the correct input.

var CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
var SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };

/**
 * Finds character representations in str and convert all to
 * their respective characters
 *
 * @param {String} str
 * @return {String}
 */
exports.strToChars = function(str) {
  /* jshint maxlen: false */
  var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
    if (lbs) {
      return s;
    }

    var code = b     ? 8 :
               a16   ? parseInt(a16, 16) :
               b16   ? parseInt(b16, 16) :
               c8    ? parseInt(c8,   8) :
               dctrl ? CTRL.indexOf(dctrl) :
               SLSH[eslsh];

    var c = String.fromCharCode(code);

    // Escape special regex characters.
    if (/[\[\]{}\^$.|?*+()]/.test(c)) {
      c = '\\' + c;
    }

    return c;
  });

  return str;
};


/**
 * turns class into tokens
 * reads str until it encounters a ] not preceeded by a \
 *
 * @param {String} str
 * @param {String} regexpStr
 * @return {Array.<Array.<Object>, Number>}
 */
exports.tokenizeClass = function(str, regexpStr) {
  /* jshint maxlen: false */
  var tokens = [];
  var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
  var rs, c;


  while ((rs = regexp.exec(str)) != null) {
    if (rs[1]) {
      tokens.push(sets.words());

    } else if (rs[2]) {
      tokens.push(sets.ints());

    } else if (rs[3]) {
      tokens.push(sets.whitespace());

    } else if (rs[4]) {
      tokens.push(sets.notWords());

    } else if (rs[5]) {
      tokens.push(sets.notInts());

    } else if (rs[6]) {
      tokens.push(sets.notWhitespace());

    } else if (rs[7]) {
      tokens.push({
        type: types.RANGE,
        from: (rs[8] || rs[9]).charCodeAt(0),
          to: rs[10].charCodeAt(0),
      });

    } else if (c = rs[12]) {
      tokens.push({
        type: types.CHAR,
        value: c.charCodeAt(0),
      });

    } else {
      return [tokens, regexp.lastIndex];
    }
  }

  exports.error(regexpStr, 'Unterminated character class');
};


/**
 * Shortcut to throw errors.
 *
 * @param {String} regexp
 * @param {String} msg
 */
exports.error = function(regexp, msg) {
  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
};

},{"./sets":153,"./types":154}],156:[function(require,module,exports){
var parse = require('ret');
var types = parse.types;

module.exports = function (re, opts) {
    if (!opts) opts = {};
    var replimit = opts.limit === undefined ? 25 : opts.limit;
    
    if (isRegExp(re)) re = re.source;
    else if (typeof re !== 'string') re = String(re);
    
    try { re = parse(re) }
    catch (err) { return false }
    
    var reps = 0;
    return (function walk (node, starHeight) {
        if (node.type === types.REPETITION) {
            starHeight ++;
            reps ++;
            if (starHeight > 1) return false;
            if (reps > replimit) return false;
        }
        
        if (node.options) {
            for (var i = 0, len = node.options.length; i < len; i++) {
                var ok = walk({ stack: node.options[i] }, starHeight);
                if (!ok) return false;
            }
        }
        var stack = node.stack || (node.value && node.value.stack);
        if (!stack) return true;
        
        for (var i = 0; i < stack.length; i++) {
            var ok = walk(stack[i], starHeight);
            if (!ok) return false;
        }
        
        return true;
    })(re, 0);
};

function isRegExp (x) {
    return {}.toString.call(x) === '[object RegExp]';
}

},{"ret":151}],157:[function(require,module,exports){
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var split = require('split-string');
var extend = require('extend-shallow');
var isPlainObject = require('is-plain-object');
var isObject = require('is-extendable');

module.exports = function(obj, prop, val) {
  if (!isObject(obj)) {
    return obj;
  }

  if (Array.isArray(prop)) {
    prop = [].concat.apply([], prop).join('.');
  }

  if (typeof prop !== 'string') {
    return obj;
  }

  var keys = split(prop, {sep: '.', brackets: true}).filter(isValidKey);
  var len = keys.length;
  var idx = -1;
  var current = obj;

  while (++idx < len) {
    var key = keys[idx];
    if (idx !== len - 1) {
      if (!isObject(current[key])) {
        current[key] = {};
      }
      current = current[key];
      continue;
    }

    if (isPlainObject(current[key]) && isPlainObject(val)) {
      current[key] = extend({}, current[key], val);
    } else {
      current[key] = val;
    }
  }

  return obj;
};

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
}

},{"extend-shallow":158,"is-extendable":89,"is-plain-object":94,"split-string":187}],158:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],159:[function(require,module,exports){
'use strict';

var isObject = require('isobject');
var define = require('define-property');
var utils = require('snapdragon-util');
var ownNames;

/**
 * Create a new AST `Node` with the given `val` and `type`.
 *
 * ```js
 * var node = new Node('*', 'Star');
 * var node = new Node({type: 'star', val: '*'});
 * ```
 * @name Node
 * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.
 * @param {String} `type` The node type to use when `val` is a string.
 * @return {Object} node instance
 * @api public
 */

function Node(val, type, parent) {
  if (typeof type !== 'string') {
    parent = type;
    type = null;
  }

  define(this, 'parent', parent);
  define(this, 'isNode', true);
  define(this, 'expect', null);

  if (typeof type !== 'string' && isObject(val)) {
    lazyKeys();
    var keys = Object.keys(val);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (ownNames.indexOf(key) === -1) {
        this[key] = val[key];
      }
    }
  } else {
    this.type = type;
    this.val = val;
  }
}

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(Node.isNode(node)); //=> true
 * console.log(Node.isNode({})); //=> false
 * ```
 * @param {Object} `node`
 * @returns {Boolean}
 * @api public
 */

Node.isNode = function(node) {
  return utils.isNode(node);
};

/**
 * Define a non-enumberable property on the node instance.
 * Useful for adding properties that shouldn't be extended
 * or visible during debugging.
 *
 * ```js
 * var node = new Node();
 * node.define('foo', 'something non-enumerable');
 * ```
 * @param {String} `name`
 * @param {any} `val`
 * @return {Object} returns the node instance
 * @api public
 */

Node.prototype.define = function(name, val) {
  define(this, name, val);
  return this;
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * node.isEmpty(); //=> true
 * node.val = 'foo';
 * node.isEmpty(); //=> false
 * ```
 * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
 * @return {Boolean}
 * @api public
 */

Node.prototype.isEmpty = function(fn) {
  return utils.isEmpty(this, fn);
};

/**
 * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.push(bar);
 * ```
 * @param {Object} `node`
 * @return {Number} Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.push = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.push(node);
};

/**
 * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.unshift(bar);
 * ```
 * @param {Object} `node`
 * @return {Number} Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.unshift = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.unshift(node);
};

/**
 * Pop a node from `node.nodes`.
 *
 * ```js
 * var node = new Node({type: 'foo'});
 * node.push(new Node({type: 'a'}));
 * node.push(new Node({type: 'b'}));
 * node.push(new Node({type: 'c'}));
 * node.push(new Node({type: 'd'}));
 * console.log(node.nodes.length);
 * //=> 4
 * node.pop();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return {Number} Returns the popped `node`
 * @api public
 */

Node.prototype.pop = function() {
  return this.nodes && this.nodes.pop();
};

/**
 * Shift a node from `node.nodes`.
 *
 * ```js
 * var node = new Node({type: 'foo'});
 * node.push(new Node({type: 'a'}));
 * node.push(new Node({type: 'b'}));
 * node.push(new Node({type: 'c'}));
 * node.push(new Node({type: 'd'}));
 * console.log(node.nodes.length);
 * //=> 4
 * node.shift();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return {Object} Returns the shifted `node`
 * @api public
 */

Node.prototype.shift = function() {
  return this.nodes && this.nodes.shift();
};

/**
 * Remove `node` from `node.nodes`.
 *
 * ```js
 * node.remove(childNode);
 * ```
 * @param {Object} `node`
 * @return {Object} Returns the removed node.
 * @api public
 */

Node.prototype.remove = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  this.nodes = this.nodes || [];
  var idx = node.index;
  if (idx !== -1) {
    node.index = -1;
    return this.nodes.splice(idx, 1);
  }
  return null;
};

/**
 * Get the first child node from `node.nodes` that matches the given `type`.
 * If `type` is a number, the child node at that index is returned.
 *
 * ```js
 * var child = node.find(1); //<= index of the node to get
 * var child = node.find('foo'); //<= node.type of a child node
 * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
 * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
 * ```
 * @param {String} `type`
 * @return {Object} Returns a child node or undefined.
 * @api public
 */

Node.prototype.find = function(type) {
  return utils.findNode(this.nodes, type);
};

/**
 * Return true if the node is the given `type`.
 *
 * ```js
 * var node = new Node({type: 'bar'});
 * cosole.log(node.isType('foo'));          // false
 * cosole.log(node.isType(/^(foo|bar)$/));  // true
 * cosole.log(node.isType(['foo', 'bar'])); // true
 * ```
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

Node.prototype.isType = function(type) {
  return utils.isType(this, type);
};

/**
 * Return true if the `node.nodes` has the given `type`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.push(bar);
 *
 * cosole.log(foo.hasType('qux'));          // false
 * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
 * cosole.log(foo.hasType(['qux', 'bar'])); // true
 * ```
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

Node.prototype.hasType = function(type) {
  return utils.hasType(this, type);
};

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return {Array}
 * @api public
 */

Object.defineProperty(Node.prototype, 'siblings', {
  set: function() {
    throw new Error('node.siblings is a getter and cannot be defined');
  },
  get: function() {
    return this.parent ? this.parent.nodes : null;
  }
});

/**
 * Get the node's current index from `node.parent.nodes`.
 * This should always be correct, even when the parent adds nodes.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.unshift(qux);
 *
 * console.log(bar.index) // 1
 * console.log(baz.index) // 2
 * console.log(qux.index) // 0
 * ```
 * @return {Number}
 * @api public
 */

Object.defineProperty(Node.prototype, 'index', {
  set: function(index) {
    define(this, 'idx', index);
  },
  get: function() {
    if (!Array.isArray(this.siblings)) {
      return -1;
    }
    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
    if (tok !== this) {
      this.idx = this.siblings.indexOf(this);
    }
    return this.idx;
  }
});

/**
 * Get the previous node from the siblings array or `null`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(baz.prev.type) // 'bar'
 * ```
 * @return {Object}
 * @api public
 */

Object.defineProperty(Node.prototype, 'prev', {
  set: function() {
    throw new Error('node.prev is a getter and cannot be defined');
  },
  get: function() {
    if (Array.isArray(this.siblings)) {
      return this.siblings[this.index - 1] || this.parent.prev;
    }
    return null;
  }
});

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return {Object}
 * @api public
 */

Object.defineProperty(Node.prototype, 'next', {
  set: function() {
    throw new Error('node.next is a getter and cannot be defined');
  },
  get: function() {
    if (Array.isArray(this.siblings)) {
      return this.siblings[this.index + 1] || this.parent.next;
    }
    return null;
  }
});

/**
 * Get the first node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.first.type) // 'bar'
 * ```
 * @return {Object} The first node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'first', {
  get: function() {
    return this.nodes ? this.nodes[0] : null;
  }
});

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return {Object} The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'last', {
  get: function() {
    return this.nodes ? utils.last(this.nodes) : null;
  }
});

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return {Object} The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'scope', {
  get: function() {
    if (this.isScope !== true) {
      return this.parent ? this.parent.scope : this;
    }
    return this;
  }
});

/**
 * Get own property names from Node prototype, but only the
 * first time `Node` is instantiated
 */

function lazyKeys() {
  if (!ownNames) {
    ownNames = Object.getOwnPropertyNames(Node.prototype);
  }
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}

/**
 * Expose `Node`
 */

exports = module.exports = Node;

},{"define-property":160,"isobject":97,"snapdragon-util":164}],160:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"is-descriptor":163}],161:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":99}],162:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"kind-of":99}],163:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"is-accessor-descriptor":161,"is-data-descriptor":162,"kind-of":99}],164:[function(require,module,exports){
'use strict';

var typeOf = require('kind-of');
var utils = module.exports;

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isNode(node)); //=> true
 * console.log(utils.isNode({})); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Boolean}
 * @api public
 */

utils.isNode = function(node) {
  return typeOf(node) === 'object' && node.isNode === true;
};

/**
 * Emit an empty string for the given `node`.
 *
 * ```js
 * // do nothing for beginning-of-string
 * snapdragon.compiler.set('bos', utils.noop);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.noop = function(node) {
  append(this, '', node);
};

/**
 * Appdend `node.val` to `compiler.output`, exactly as it was created
 * by the parser.
 *
 * ```js
 * snapdragon.compiler.set('text', utils.identity);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.identity = function(node) {
  append(this, node.val, node);
};

/**
 * Previously named `.emit`, this method appends the given `val`
 * to `compiler.output` for the given node. Useful when you know
 * what value should be appended advance, regardless of the actual
 * value of `node.val`.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     this.mapVisit(node);
 *   })
 *   .set('i.open', utils.append('<i>'))
 *   .set('i.close', utils.append('</i>'))
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Function} Returns a compiler middleware function.
 * @api public
 */

utils.append = function(val) {
  return function(node) {
    append(this, val, node);
  };
};

/**
 * Used in compiler middleware, this onverts an AST node into
 * an empty `text` node and deletes `node.nodes` if it exists.
 * The advantage of this method is that, as opposed to completely
 * removing the node, indices will not need to be re-calculated
 * in sibling nodes, and nothing is appended to the output.
 *
 * ```js
 * utils.toNoop(node);
 * // convert `node.nodes` to the given value instead of deleting it
 * utils.toNoop(node, []);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
 * @api public
 */

utils.toNoop = function(node, nodes) {
  if (nodes) {
    node.nodes = nodes;
  } else {
    delete node.nodes;
    node.type = 'text';
    node.val = '';
  }
};

/**
 * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
 * automatically calls registered compilers, this allows you to pass a visitor
 * function.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.visit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Object} returns the node after recursively visiting all child nodes.
 * @api public
 */

utils.visit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(fn), 'expected a visitor function');
  fn(node);
  return node.nodes ? utils.mapVisit(node, fn) : node;
};

/**
 * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
 * [visit](#visit), use this method if you do not want `fn` to be called on
 * the first node.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.mapVisit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Object} `options`
 * @param {Function} `fn`
 * @return {Object} returns the node
 * @api public
 */

utils.mapVisit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isArray(node.nodes), 'expected node.nodes to be an array');
  assert(isFunction(fn), 'expected a visitor function');

  for (var i = 0; i < node.nodes.length; i++) {
    utils.visit(node.nodes[i], fn);
  }
  return node;
};

/**
 * Unshift an `*.open` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^{/);
 *   if (match) {
 *     var parent = new Node({type: 'brace'});
 *     utils.addOpen(parent, Node);
 *     console.log(parent.nodes[0]):
 *     // { type: 'brace.open', val: '' };
 *
 *     // push the parent "brace" node onto the stack
 *     this.push(parent);
 *
 *     // return the parent node, so it's also added to the AST
 *     return brace;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created opening node.
 * @api public
 */

utils.addOpen = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var open = new Node({ type: node.type + '.open', val: val});
  var unshift = node.unshift || node.unshiftNode;
  if (typeof unshift === 'function') {
    unshift.call(node, open);
  } else {
    utils.unshiftNode(node, open);
  }
  return open;
};

/**
 * Push a `*.close` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^}/);
 *   if (match) {
 *     var parent = this.parent();
 *     if (parent.type !== 'brace') {
 *       throw new Error('missing opening: ' + '}');
 *     }
 *
 *     utils.addClose(parent, Node);
 *     console.log(parent.nodes[parent.nodes.length - 1]):
 *     // { type: 'brace.close', val: '' };
 *
 *     // no need to return a node, since the parent
 *     // was already added to the AST
 *     return;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created closing node.
 * @api public
 */

utils.addClose = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var close = new Node({ type: node.type + '.close', val: val});
  var push = node.push || node.pushNode;
  if (typeof push === 'function') {
    push.call(node, close);
  } else {
    utils.pushNode(node, close);
  }
  return close;
};

/**
 * Wraps the given `node` with `*.open` and `*.close` nodes.
 *
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the node
 * @api public
 */

utils.wrapNodes = function(node, Node, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  utils.addOpen(node, Node, filter);
  utils.addClose(node, Node, filter);
  return node;
};

/**
 * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.pushNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object} Returns the child node
 * @api public
 */

utils.pushNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.push(node);
  return node;
};

/**
 * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.unshiftNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {undefined}
 * @api public
 */

utils.unshiftNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.unshift(node);
};

/**
 * Pop the last `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.popNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.popNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.pop === 'function') {
    return node.pop();
  }
  return node.nodes && node.nodes.pop();
};

/**
 * Shift the first `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.shiftNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.shiftNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.shift === 'function') {
    return node.shift();
  }
  return node.nodes && node.nodes.shift();
};

/**
 * Remove the specified `node` from `parent.nodes`.
 *
 * ```js
 * var parent = new Node({type: 'abc'});
 * var foo = new Node({type: 'foo'});
 * utils.pushNode(parent, foo);
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.removeNode(parent, foo);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
 * @api public
 */

utils.removeNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!parent.nodes) {
    return null;
  }

  if (typeof parent.remove === 'function') {
    return parent.remove(node);
  }

  var idx = parent.nodes.indexOf(node);
  if (idx !== -1) {
    return parent.nodes.splice(idx, 1);
  }
};

/**
 * Returns true if `node.type` matches the given `type`. Throws a
 * `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isType(node, 'foo')); // false
 * console.log(utils.isType(node, 'bar')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  switch (typeOf(type)) {
    case 'array':
      var types = type.slice();
      for (var i = 0; i < types.length; i++) {
        if (utils.isType(node, types[i])) {
          return true;
        }
      }
      return false;
    case 'string':
      return node.type === type;
    case 'regexp':
      return type.test(node.type);
    default: {
      throw new TypeError('expected "type" to be an array, string or regexp');
    }
  }
};

/**
 * Returns true if the given `node` has the given `type` in `node.nodes`.
 * Throws a `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'bar'}),
 *     new Node({type: 'baz'})
 *   ]
 * });
 * console.log(utils.hasType(node, 'xyz')); // false
 * console.log(utils.hasType(node, 'baz')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.hasType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (!Array.isArray(node.nodes)) return false;
  for (var i = 0; i < node.nodes.length; i++) {
    if (utils.isType(node.nodes[i], type)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns the first node from `node.nodes` of the given `type`
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var textNode = utils.firstOfType(node.nodes, 'text');
 * console.log(textNode.val);
 * //=> 'abc'
 * ```
 * @param {Array} `nodes`
 * @param {String} `type`
 * @return {Object|undefined} Returns the first matching node or undefined.
 * @api public
 */

utils.firstOfType = function(nodes, type) {
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (utils.isType(node, type)) {
      return node;
    }
  }
};

/**
 * Returns the node at the specified index, or the first node of the
 * given `type` from `node.nodes`.
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var nodeOne = utils.findNode(node.nodes, 'text');
 * console.log(nodeOne.val);
 * //=> 'abc'
 *
 * var nodeTwo = utils.findNode(node.nodes, 1);
 * console.log(nodeTwo.val);
 * //=> 'xyz'
 * ```
 *
 * @param {Array} `nodes`
 * @param {String|Number} `type` Node type or index.
 * @return {Object} Returns a node or undefined.
 * @api public
 */

utils.findNode = function(nodes, type) {
  if (!Array.isArray(nodes)) {
    return null;
  }
  if (typeof type === 'number') {
    return nodes[type];
  }
  return utils.firstOfType(nodes, type);
};

/**
 * Returns true if the given node is an "*.open" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isOpen(brace)); // false
 * console.log(utils.isOpen(open)); // true
 * console.log(utils.isOpen(close)); // false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-5) === '.open';
};

/**
 * Returns true if the given node is a "*.close" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isClose(brace)); // false
 * console.log(utils.isClose(open)); // false
 * console.log(utils.isClose(close)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-6) === '.close';
};

/**
 * Returns true if `node.nodes` **has** an `.open` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.hasOpen(brace)); // false
 *
 * brace.pushNode(open);
 * console.log(utils.hasOpen(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var first = node.first || node.nodes ? node.nodes[0] : null;
  if (utils.isNode(first)) {
    return first.type === node.type + '.open';
  }
  return false;
};

/**
 * Returns true if `node.nodes` **has** a `.close` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(close);
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
  if (utils.isNode(last)) {
    return last.type === node.type + '.close';
  }
  return false;
};

/**
 * Returns true if `node.nodes` has both `.open` and `.close` nodes
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasOpen(brace)); // false
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(open);
 * brace.pushNode(close);
 * console.log(utils.hasOpen(brace)); // true
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpenAndClose = function(node) {
  return utils.hasOpen(node) && utils.hasClose(node);
};

/**
 * Push the given `node` onto the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.addType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.open$/, '');

  if (!state.hasOwnProperty('inside')) {
    state.inside = {};
  }
  if (!state.inside.hasOwnProperty(type)) {
    state.inside[type] = [];
  }

  var arr = state.inside[type];
  arr.push(node);
  return arr;
};

/**
 * Remove the given `node` from the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * utils.removeType(state, node);
 * //=> { brace: [] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.removeType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.close$/, '');

  if (state.inside.hasOwnProperty(type)) {
    return state.inside[type].pop();
  }
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * utils.isEmpty(node); //=> true
 * node.val = 'foo';
 * utils.isEmpty(node); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Boolean}
 * @api public
 */

utils.isEmpty = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!Array.isArray(node.nodes)) {
    if (node.type !== 'text') {
      return true;
    }
    if (typeof fn === 'function') {
      return fn(node, node.parent);
    }
    return !utils.trim(node.val);
  }

  for (var i = 0; i < node.nodes.length; i++) {
    var child = node.nodes[i];
    if (utils.isOpen(child) || utils.isClose(child)) {
      continue;
    }
    if (!utils.isEmpty(child, fn)) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if the `state.inside` stack for the given type exists
 * and has one or more nodes on it.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * utils.addType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> true
 * utils.removeType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * ```
 * @param {Object} `state`
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isInsideType = function(state, type) {
  assert(isObject(state), 'expected state to be an object');
  assert(isString(type), 'expected type to be a string');

  if (!state.hasOwnProperty('inside')) {
    return false;
  }

  if (!state.inside.hasOwnProperty(type)) {
    return false;
  }

  return state.inside[type].length > 0;
};

/**
 * Returns true if `node` is either a child or grand-child of the given `type`,
 * or `state.inside[type]` is a non-empty array.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.isInside(state, open, 'brace')); //=> false
 * utils.pushNode(node, open);
 * console.log(utils.isInside(state, open, 'brace')); //=> true
 * ```
 * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type` The `node.type` to check for.
 * @return {Boolean}
 * @api public
 */

utils.isInside = function(state, node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      if (utils.isInside(state, node, type[i])) {
        return true;
      }
    }
    return false;
  }

  var parent = node.parent;
  if (typeof type === 'string') {
    return (parent && parent.type === type) || utils.isInsideType(state, type);
  }

  if (typeOf(type) === 'regexp') {
    if (parent && parent.type && type.test(parent.type)) {
      return true;
    }

    var keys = Object.keys(state.inside);
    var len = keys.length;
    var idx = -1;
    while (++idx < len) {
      var key = keys[idx];
      var val = state.inside[key];

      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Get the last `n` element from the given `array`. Used for getting
 * a node from `node.nodes.`
 *
 * @param {Array} `array`
 * @param {Number} `n`
 * @return {undefined}
 * @api public
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Cast the given `val` to an array.
 *
 * ```js
 * console.log(utils.arrayify(''));
 * //=> []
 * console.log(utils.arrayify('foo'));
 * //=> ['foo']
 * console.log(utils.arrayify(['foo']));
 * //=> ['foo']
 * ```
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.arrayify = function(val) {
  if (typeof val === 'string' && val !== '') {
    return [val];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  return val;
};

/**
 * Convert the given `val` to a string by joining with `,`. Useful
 * for creating a cheerio/CSS/DOM-style selector from a list of strings.
 *
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.stringify = function(val) {
  return utils.arrayify(val).join(',');
};

/**
 * Ensure that the given value is a string and call `.trim()` on it,
 * or return an empty string.
 *
 * @param {String} `str`
 * @return {String}
 * @api public
 */

utils.trim = function(str) {
  return typeof str === 'string' ? str.trim() : '';
};

/**
 * Return true if val is an object
 */

function isObject(val) {
  return typeOf(val) === 'object';
}

/**
 * Return true if val is a string
 */

function isString(val) {
  return typeof val === 'string';
}

/**
 * Return true if val is a function
 */

function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Return true if val is an array
 */

function isArray(val) {
  return Array.isArray(val);
}

/**
 * Shim to ensure the `.append` methods work with any version of snapdragon
 */

function append(compiler, val, node) {
  if (typeof compiler.append !== 'function') {
    return compiler.emit(val, node);
  }
  return compiler.append(val, node);
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}

},{"kind-of":165}],165:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],166:[function(require,module,exports){
'use strict';

var Base = require('base');
var define = require('define-property');
var Compiler = require('./lib/compiler');
var Parser = require('./lib/parser');
var utils = require('./lib/utils');
var regexCache = {};
var cache = {};

/**
 * Create a new instance of `Snapdragon` with the given `options`.
 *
 * ```js
 * var snapdragon = new Snapdragon();
 * ```
 *
 * @param {Object} `options`
 * @api public
 */

function Snapdragon(options) {
  Base.call(this, null, options);
  this.options = utils.extend({source: 'string'}, this.options);
  this.compiler = new Compiler(this.options);
  this.parser = new Parser(this.options);

  Object.defineProperty(this, 'compilers', {
    get: function() {
      return this.compiler.compilers;
    }
  });

  Object.defineProperty(this, 'parsers', {
    get: function() {
      return this.parser.parsers;
    }
  });

  Object.defineProperty(this, 'regex', {
    get: function() {
      return this.parser.regex;
    }
  });
}

/**
 * Inherit Base
 */

Base.extend(Snapdragon);

/**
 * Add a parser to `snapdragon.parsers` for capturing the given `type` using
 * the specified regex or parser function. A function is useful if you need
 * to customize how the token is created and/or have access to the parser
 * instance to check options, etc.
 *
 * ```js
 * snapdragon
 *   .capture('slash', /^\//)
 *   .capture('dot', function() {
 *     var pos = this.position();
 *     var m = this.match(/^\./);
 *     if (!m) return;
 *     return pos({
 *       type: 'dot',
 *       val: m[0]
 *     });
 *   });
 * ```
 * @param {String} `type`
 * @param {RegExp|Function} `regex`
 * @return {Object} Returns the parser instance for chaining
 * @api public
 */

Snapdragon.prototype.capture = function() {
  return this.parser.capture.apply(this.parser, arguments);
};

/**
 * Register a plugin `fn`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * snapdragon.use(function() {
 *   console.log(this);          //<= snapdragon instance
 *   console.log(this.parser);   //<= parser instance
 *   console.log(this.compiler); //<= compiler instance
 * });
 * ```
 * @param {Object} `fn`
 * @api public
 */

Snapdragon.prototype.use = function(fn) {
  fn.call(this, this);
  return this;
};

/**
 * Parse the given `str`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register parsers
 * snapdragon.parser.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 * console.log(ast);
 * ```
 * @param {String} `str`
 * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.
 * @return {Object} Returns an AST.
 * @api public
 */

Snapdragon.prototype.parse = function(str, options) {
  this.options = utils.extend({}, this.options, options);
  var parsed = this.parser.parse(str, this.options);

  // add non-enumerable parser reference
  define(parsed, 'parser', this.parser);
  return parsed;
};

/**
 * Compile the given `AST`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register plugins
 * snapdragon.use(function() {});
 * // register parser plugins
 * snapdragon.parser.use(function() {});
 * // register compiler plugins
 * snapdragon.compiler.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 *
 * // compile
 * var res = snapdragon.compile(ast);
 * console.log(res.output);
 * ```
 * @param {Object} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object with an `output` property with the rendered string.
 * @api public
 */

Snapdragon.prototype.compile = function(ast, options) {
  this.options = utils.extend({}, this.options, options);
  var compiled = this.compiler.compile(ast, this.options);

  // add non-enumerable compiler reference
  define(compiled, 'compiler', this.compiler);
  return compiled;
};

/**
 * Expose `Snapdragon`
 */

module.exports = Snapdragon;

/**
 * Expose `Parser` and `Compiler`
 */

module.exports.Compiler = Compiler;
module.exports.Parser = Parser;

},{"./lib/compiler":167,"./lib/parser":168,"./lib/utils":171,"base":13,"define-property":172}],167:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

var use = require('use');
var define = require('define-property');
var debug = require('debug')('snapdragon:compiler');
var utils = require('./utils');

/**
 * Create a new `Compiler` with the given `options`.
 * @param {Object} `options`
 */

function Compiler(options, state) {
  debug('initializing', __filename);
  this.options = utils.extend({source: 'string'}, options);
  this.state = state || {};
  this.compilers = {};
  this.output = '';
  this.set('eos', function(node) {
    return this.emit(node.val, node);
  });
  this.set('noop', function(node) {
    return this.emit(node.val, node);
  });
  this.set('bos', function(node) {
    return this.emit(node.val, node);
  });
  use(this);
}

/**
 * Prototype methods
 */

Compiler.prototype = {

  /**
   * Throw an error message with details including the cursor position.
   * @param {String} `msg` Message to use in the Error.
   */

  error: function(msg, node) {
    var pos = node.position || {start: {column: 0}};
    var message = this.options.source + ' column:' + pos.start.column + ': ' + msg;

    var err = new Error(message);
    err.reason = msg;
    err.column = pos.start.column;
    err.source = this.pattern;

    if (this.options.silent) {
      this.errors.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Define a non-enumberable property on the `Compiler` instance.
   *
   * ```js
   * compiler.define('foo', 'bar');
   * ```
   * @name .define
   * @param {String} `key` propery name
   * @param {any} `val` property value
   * @return {Object} Returns the Compiler instance for chaining.
   * @api public
   */

  define: function(key, val) {
    define(this, key, val);
    return this;
  },

  /**
   * Emit `node.val`
   */

  emit: function(str, node) {
    this.output += str;
    return str;
  },

  /**
   * Add a compiler `fn` with the given `name`
   */

  set: function(name, fn) {
    this.compilers[name] = fn;
    return this;
  },

  /**
   * Get compiler `name`.
   */

  get: function(name) {
    return this.compilers[name];
  },

  /**
   * Get the previous AST node.
   */

  prev: function(n) {
    return this.ast.nodes[this.idx - (n || 1)] || { type: 'bos', val: '' };
  },

  /**
   * Get the next AST node.
   */

  next: function(n) {
    return this.ast.nodes[this.idx + (n || 1)] || { type: 'eos', val: '' };
  },

  /**
   * Visit `node`.
   */

  visit: function(node, nodes, i) {
    var fn = this.compilers[node.type];
    this.idx = i;

    if (typeof fn !== 'function') {
      throw this.error('compiler "' + node.type + '" is not registered', node);
    }
    return fn.call(this, node, nodes, i);
  },

  /**
   * Map visit over array of `nodes`.
   */

  mapVisit: function(nodes) {
    if (!Array.isArray(nodes)) {
      throw new TypeError('expected an array');
    }
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      this.visit(nodes[idx], nodes, idx);
    }
    return this;
  },

  /**
   * Compile `ast`.
   */

  compile: function(ast, options) {
    var opts = utils.extend({}, this.options, options);
    this.ast = ast;
    this.parsingErrors = this.ast.errors;
    this.output = '';

    // source map support
    if (opts.sourcemap) {
      var sourcemaps = require('./source-maps');
      sourcemaps(this);
      this.mapVisit(this.ast.nodes);
      this.applySourceMaps();
      this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();
      return this;
    }

    this.mapVisit(this.ast.nodes);
    return this;
  }
};

/**
 * Expose `Compiler`
 */

module.exports = Compiler;

}).call(this)}).call(this,"/node_modules/snapdragon/lib/compiler.js")

},{"./source-maps":170,"./utils":171,"debug":41,"define-property":172,"use":202}],168:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

var use = require('use');
var util = require('util');
var Cache = require('map-cache');
var define = require('define-property');
var debug = require('debug')('snapdragon:parser');
var Position = require('./position');
var utils = require('./utils');

/**
 * Create a new `Parser` with the given `input` and `options`.
 * @param {String} `input`
 * @param {Object} `options`
 * @api public
 */

function Parser(options) {
  debug('initializing', __filename);
  this.options = utils.extend({source: 'string'}, options);
  this.init(this.options);
  use(this);
}

/**
 * Prototype methods
 */

Parser.prototype = {
  constructor: Parser,

  init: function(options) {
    this.orig = '';
    this.input = '';
    this.parsed = '';

    this.column = 1;
    this.line = 1;

    this.regex = new Cache();
    this.errors = this.errors || [];
    this.parsers = this.parsers || {};
    this.types = this.types || [];
    this.sets = this.sets || {};
    this.fns = this.fns || [];
    this.currentType = 'root';

    var pos = this.position();
    this.bos = pos({type: 'bos', val: ''});

    this.ast = {
      type: 'root',
      errors: this.errors,
      nodes: [this.bos]
    };

    define(this.bos, 'parent', this.ast);
    this.nodes = [this.ast];

    this.count = 0;
    this.setCount = 0;
    this.stack = [];
  },

  /**
   * Throw a formatted error with the cursor column and `msg`.
   * @param {String} `msg` Message to use in the Error.
   */

  error: function(msg, node) {
    var pos = node.position || {start: {column: 0, line: 0}};
    var line = pos.start.line;
    var column = pos.start.column;
    var source = this.options.source;

    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;
    var err = new Error(message);
    err.source = source;
    err.reason = msg;
    err.pos = pos;

    if (this.options.silent) {
      this.errors.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Define a non-enumberable property on the `Parser` instance.
   *
   * ```js
   * parser.define('foo', 'bar');
   * ```
   * @name .define
   * @param {String} `key` propery name
   * @param {any} `val` property value
   * @return {Object} Returns the Parser instance for chaining.
   * @api public
   */

  define: function(key, val) {
    define(this, key, val);
    return this;
  },

  /**
   * Mark position and patch `node.position`.
   */

  position: function() {
    var start = { line: this.line, column: this.column };
    var self = this;

    return function(node) {
      define(node, 'position', new Position(start, self));
      return node;
    };
  },

  /**
   * Set parser `name` with the given `fn`
   * @param {String} `name`
   * @param {Function} `fn`
   * @api public
   */

  set: function(type, fn) {
    if (this.types.indexOf(type) === -1) {
      this.types.push(type);
    }
    this.parsers[type] = fn.bind(this);
    return this;
  },

  /**
   * Get parser `name`
   * @param {String} `name`
   * @api public
   */

  get: function(name) {
    return this.parsers[name];
  },

  /**
   * Push a `token` onto the `type` stack.
   *
   * @param {String} `type`
   * @return {Object} `token`
   * @api public
   */

  push: function(type, token) {
    this.sets[type] = this.sets[type] || [];
    this.count++;
    this.stack.push(token);
    return this.sets[type].push(token);
  },

  /**
   * Pop a token off of the `type` stack
   * @param {String} `type`
   * @returns {Object} Returns a token
   * @api public
   */

  pop: function(type) {
    this.sets[type] = this.sets[type] || [];
    this.count--;
    this.stack.pop();
    return this.sets[type].pop();
  },

  /**
   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
   *
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  isInside: function(type) {
    this.sets[type] = this.sets[type] || [];
    return this.sets[type].length > 0;
  },

  /**
   * Return true if `node` is the given `type`.
   *
   * ```js
   * parser.isType(node, 'brace');
   * ```
   * @param {Object} `node`
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  isType: function(node, type) {
    return node && node.type === type;
  },

  /**
   * Get the previous AST node
   * @return {Object}
   */

  prev: function(n) {
    return this.stack.length > 0
      ? utils.last(this.stack, n)
      : utils.last(this.nodes, n);
  },

  /**
   * Update line and column based on `str`.
   */

  consume: function(len) {
    this.input = this.input.substr(len);
  },

  /**
   * Update column based on `str`.
   */

  updatePosition: function(str, len) {
    var lines = str.match(/\n/g);
    if (lines) this.line += lines.length;
    var i = str.lastIndexOf('\n');
    this.column = ~i ? len - i : this.column + len;
    this.parsed += str;
    this.consume(len);
  },

  /**
   * Match `regex`, return captures, and update the cursor position by `match[0]` length.
   * @param {RegExp} `regex`
   * @return {Object}
   */

  match: function(regex) {
    var m = regex.exec(this.input);
    if (m) {
      this.updatePosition(m[0], m[0].length);
      return m;
    }
  },

  /**
   * Capture `type` with the given regex.
   * @param {String} `type`
   * @param {RegExp} `regex`
   * @return {Function}
   */

  capture: function(type, regex) {
    if (typeof regex === 'function') {
      return this.set.apply(this, arguments);
    }

    this.regex.set(type, regex);
    this.set(type, function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(regex);
      if (!m || !m[0]) return;

      var prev = this.prev();
      var node = pos({
        type: type,
        val: m[0],
        parsed: parsed,
        rest: this.input
      });

      if (m[1]) {
        node.inner = m[1];
      }

      define(node, 'inside', this.stack.length > 0);
      define(node, 'parent', prev);
      prev.nodes.push(node);
    }.bind(this));
    return this;
  },

  /**
   * Create a parser with open and close for parens,
   * brackets or braces
   */

  capturePair: function(type, openRegex, closeRegex, fn) {
    this.sets[type] = this.sets[type] || [];

    /**
     * Open
     */

    this.set(type + '.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(openRegex);
      if (!m || !m[0]) return;

      var val = m[0];
      this.setCount++;
      this.specialChars = true;
      var open = pos({
        type: type + '.open',
        val: val,
        rest: this.input
      });

      if (typeof m[1] !== 'undefined') {
        open.inner = m[1];
      }

      var prev = this.prev();
      var node = pos({
        type: type,
        nodes: [open]
      });

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'prefix', m[1]);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      if (typeof fn === 'function') {
        fn.call(this, open, node);
      }

      this.push(type, node);
      prev.nodes.push(node);
    });

    /**
     * Close
     */

    this.set(type + '.close', function() {
      var pos = this.position();
      var m = this.match(closeRegex);
      if (!m || !m[0]) return;

      var parent = this.pop(type);
      var node = pos({
        type: type + '.close',
        rest: this.input,
        suffix: m[1],
        val: m[0]
      });

      if (!this.isType(parent, type)) {
        if (this.options.strict) {
          throw new Error('missing opening "' + type + '"');
        }

        this.setCount--;
        node.escaped = true;
        return node;
      }

      if (node.suffix === '\\') {
        parent.escaped = true;
        node.escaped = true;
      }

      parent.nodes.push(node);
      define(node, 'parent', parent);
    });

    return this;
  },

  /**
   * Capture end-of-string
   */

  eos: function() {
    var pos = this.position();
    if (this.input) return;
    var prev = this.prev();

    while (prev.type !== 'root' && !prev.visited) {
      if (this.options.strict === true) {
        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));
      }

      if (!hasDelims(prev)) {
        prev.parent.escaped = true;
        prev.escaped = true;
      }

      visit(prev, function(node) {
        if (!hasDelims(node.parent)) {
          node.parent.escaped = true;
          node.escaped = true;
        }
      });

      prev = prev.parent;
    }

    var tok = pos({
      type: 'eos',
      val: this.append || ''
    });

    define(tok, 'parent', this.ast);
    return tok;
  },

  /**
   * Run parsers to advance the cursor position
   */

  next: function() {
    var parsed = this.parsed;
    var len = this.types.length;
    var idx = -1;
    var tok;

    while (++idx < len) {
      if ((tok = this.parsers[this.types[idx]].call(this))) {
        define(tok, 'rest', this.input);
        define(tok, 'parsed', parsed);
        this.last = tok;
        return tok;
      }
    }
  },

  /**
   * Parse the given string.
   * @return {Array}
   */

  parse: function(input) {
    if (typeof input !== 'string') {
      throw new TypeError('expected a string');
    }

    this.init(this.options);
    this.orig = input;
    this.input = input;
    var self = this;

    function parse() {
      // check input before calling `.next()`
      input = self.input;

      // get the next AST ndoe
      var node = self.next();
      if (node) {
        var prev = self.prev();
        if (prev) {
          define(node, 'parent', prev);
          if (prev.nodes) {
            prev.nodes.push(node);
          }
        }

        if (self.sets.hasOwnProperty(prev.type)) {
          self.currentType = prev.type;
        }
      }

      // if we got here but input is not changed, throw an error
      if (self.input && input === self.input) {
        throw new Error('no parsers registered for: "' + self.input.slice(0, 5) + '"');
      }
    }

    while (this.input) parse();
    if (this.stack.length && this.options.strict) {
      var node = this.stack.pop();
      throw this.error('missing opening ' + node.type + ': "' + this.orig + '"');
    }

    var eos = this.eos();
    var tok = this.prev();
    if (tok.type !== 'eos') {
      this.ast.nodes.push(eos);
    }

    return this.ast;
  }
};

/**
 * Visit `node` with the given `fn`
 */

function visit(node, fn) {
  if (!node.visited) {
    define(node, 'visited', true);
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  }
  return node;
}

/**
 * Map visit over array of `nodes`.
 */

function mapVisit(nodes, fn) {
  var len = nodes.length;
  var idx = -1;
  while (++idx < len) {
    visit(nodes[idx], fn);
  }
}

function hasOpen(node) {
  return node.nodes && node.nodes[0].type === (node.type + '.open');
}

function hasClose(node) {
  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');
}

function hasDelims(node) {
  return hasOpen(node) && hasClose(node);
}

/**
 * Expose `Parser`
 */

module.exports = Parser;

}).call(this)}).call(this,"/node_modules/snapdragon/lib/parser.js")

},{"./position":169,"./utils":171,"debug":41,"define-property":172,"map-cache":100,"use":202,"util":211}],169:[function(require,module,exports){
'use strict';

var define = require('define-property');

/**
 * Store position for a node
 */

module.exports = function Position(start, parser) {
  this.start = start;
  this.end = { line: parser.line, column: parser.column };
  define(this, 'content', parser.orig);
  define(this, 'source', parser.options.source);
};

},{"define-property":172}],170:[function(require,module,exports){
'use strict';

var fs = require('fs');
var path = require('path');
var define = require('define-property');
var utils = require('./utils');

/**
 * Expose `mixin()`.
 * This code is based on `source-maps-support.js` in reworkcss/css
 * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js
 * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 */

module.exports = mixin;

/**
 * Mixin source map support into `compiler`.
 *
 * @param {Object} `compiler`
 * @api public
 */

function mixin(compiler) {
  define(compiler, '_comment', compiler.comment);
  compiler.map = new utils.SourceMap.SourceMapGenerator();
  compiler.position = { line: 1, column: 1 };
  compiler.content = {};
  compiler.files = {};

  for (var key in exports) {
    define(compiler, key, exports[key]);
  }
}

/**
 * Update position.
 *
 * @param {String} str
 */

exports.updatePosition = function(str) {
  var lines = str.match(/\n/g);
  if (lines) this.position.line += lines.length;
  var i = str.lastIndexOf('\n');
  this.position.column = ~i ? str.length - i : this.position.column + str.length;
};

/**
 * Emit `str` with `position`.
 *
 * @param {String} str
 * @param {Object} [pos]
 * @return {String}
 */

exports.emit = function(str, node) {
  var position = node.position || {};
  var source = position.source;
  if (source) {
    if (position.filepath) {
      source = utils.unixify(position.filepath);
    }

    this.map.addMapping({
      source: source,
      generated: {
        line: this.position.line,
        column: Math.max(this.position.column - 1, 0)
      },
      original: {
        line: position.start.line,
        column: position.start.column - 1
      }
    });

    if (position.content) {
      this.addContent(source, position);
    }
    if (position.filepath) {
      this.addFile(source, position);
    }

    this.updatePosition(str);
    this.output += str;
  }
  return str;
};

/**
 * Adds a file to the source map output if it has not already been added
 * @param {String} `file`
 * @param {Object} `pos`
 */

exports.addFile = function(file, position) {
  if (typeof position.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
  this.files[file] = position.content;
};

/**
 * Adds a content source to the source map output if it has not already been added
 * @param {String} `source`
 * @param {Object} `position`
 */

exports.addContent = function(source, position) {
  if (typeof position.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.content, source)) return;
  this.map.setSourceContent(source, position.content);
};

/**
 * Applies any original source maps to the output and embeds the source file
 * contents in the source map.
 */

exports.applySourceMaps = function() {
  Object.keys(this.files).forEach(function(file) {
    var content = this.files[file];
    this.map.setSourceContent(file, content);

    if (this.options.inputSourcemaps === true) {
      var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
      if (originalMap) {
        var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);
        var relativeTo = originalMap.sourcesRelativeTo;
        this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));
      }
    }
  }, this);
};

/**
 * Process comments, drops sourceMap comments.
 * @param {Object} node
 */

exports.comment = function(node) {
  if (/^# sourceMappingURL=/.test(node.comment)) {
    return this.emit('', node.position);
  }
  return this._comment(node);
};

},{"./utils":171,"define-property":172,"fs":205,"path":207}],171:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

exports.extend = require('extend-shallow');
exports.SourceMap = require('source-map');
exports.sourceMapResolve = require('source-map-resolve');

/**
 * Convert backslash in the given string to forward slashes
 */

exports.unixify = function(fp) {
  return fp.split(/\\+/).join('/');
};

/**
 * Return true if `val` is a non-empty string
 *
 * @param {String} `str`
 * @return {Boolean}
 */

exports.isString = function(str) {
  return str && typeof str === 'string';
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

exports.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Get the last `n` element from the given `array`
 * @param {Array} `array`
 * @return {*}
 */

exports.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

},{"extend-shallow":173,"source-map":186,"source-map-resolve":174}],172:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],173:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],174:[function(require,module,exports){
(function (setImmediate){(function (){
// Note: source-map-resolve.js is generated from source-map-resolve-node.js and
// source-map-resolve-template.js. Only edit the two latter files, _not_
// source-map-resolve.js!

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(["source-map-url", "resolve-url"], factory)
  } else if (typeof exports === "object") {
    var sourceMappingURL = require("source-map-url")
    var resolveUrl = require("resolve-url")
    module.exports = factory(sourceMappingURL, resolveUrl)
  } else {
    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl)
  }
}(this, function(sourceMappingURL, resolveUrl) {

  function callbackAsync(callback, error, result) {
    setImmediate(function() { callback(error, result) })
  }

  function parseMapToJSON(string, data) {
    try {
      return JSON.parse(string.replace(/^\)\]\}'/, ""))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }

  function readSync(read, url, data) {
    var readUrl = url
    try {
      return String(read(readUrl))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }



  function resolveSourceMap(code, codeUrl, read, callback) {
    var mapData
    try {
      mapData = resolveSourceMapHelper(code, codeUrl)
    } catch (error) {
      return callbackAsync(callback, error)
    }
    if (!mapData || mapData.map) {
      return callbackAsync(callback, null, mapData)
    }
    var readUrl = mapData.url
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = mapData
        return callback(error)
      }
      mapData.map = String(result)
      try {
        mapData.map = parseMapToJSON(mapData.map, mapData)
      } catch (error) {
        return callback(error)
      }
      callback(null, mapData)
    })
  }

  function resolveSourceMapSync(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl)
    if (!mapData || mapData.map) {
      return mapData
    }
    mapData.map = readSync(read, mapData.url, mapData)
    mapData.map = parseMapToJSON(mapData.map, mapData)
    return mapData
  }

  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/

  /**
   * The media type for JSON text is application/json.
   *
   * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }
   *
   * `text/json` is non-standard media type
   */
  var jsonMimeTypeRegex = /^(?:application|text)\/json$/

  /**
   * JSON text exchanged between systems that are not part of a closed ecosystem
   * MUST be encoded using UTF-8.
   *
   * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}
   */
  var jsonCharacterEncoding = "utf-8"

  function base64ToBuf(b64) {
    var binStr = atob(b64)
    var len = binStr.length
    var arr = new Uint8Array(len)
    for (var i = 0; i < len; i++) {
      arr[i] = binStr.charCodeAt(i)
    }
    return arr
  }

  function decodeBase64String(b64) {
    if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
      return atob(b64)
    }
    var buf = base64ToBuf(b64);
    // Note: `decoder.decode` method will throw a `DOMException` with the
    // `"EncodingError"` value when an coding error is found.
    var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})
    return decoder.decode(buf);
  }

  function resolveSourceMapHelper(code, codeUrl) {
    var url = sourceMappingURL.getFrom(code)
    if (!url) {
      return null
    }

    var dataUri = url.match(dataUriRegex)
    if (dataUri) {
      var mimeType = dataUri[1] || "text/plain"
      var lastParameter = dataUri[2] || ""
      var encoded = dataUri[3] || ""
      var data = {
        sourceMappingURL: url,
        url: null,
        sourcesRelativeTo: codeUrl,
        map: encoded
      }
      if (!jsonMimeTypeRegex.test(mimeType)) {
        var error = new Error("Unuseful data uri mime type: " + mimeType)
        error.sourceMapData = data
        throw error
      }
      try {
        data.map = parseMapToJSON(
          lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded),
          data
        )
      } catch (error) {
        error.sourceMapData = data
        throw error
      }
      return data
    }

    var mapUrl = resolveUrl(codeUrl, url)
    return {
      sourceMappingURL: url,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    }
  }



  function resolveSources(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    var pending = map.sources ? map.sources.length : 0
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (pending === 0) {
      callbackAsync(callback, null, result)
      return
    }

    var done = function() {
      pending--
      if (pending === 0) {
        callback(null, result)
      }
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent
        callbackAsync(done, null)
      } else {
        var readUrl = fullUrl
        read(readUrl, function(error, source) {
          result.sourcesContent[index] = error ? error : String(source)
          done()
        })
      }
    })
  }

  function resolveSourcesSync(map, mapUrl, read, options) {
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (!map.sources || map.sources.length === 0) {
      return result
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (read !== null) {
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
        } else {
          var readUrl = fullUrl
          try {
            result.sourcesContent[index] = String(read(readUrl))
          } catch (error) {
            result.sourcesContent[index] = error
          }
        }
      }
    })

    return result
  }

  var endingSlash = /\/?$/

  function resolveSourcesHelper(map, mapUrl, options, fn) {
    options = options || {}
    var fullUrl
    var sourceContent
    var sourceRoot
    for (var index = 0, len = map.sources.length; index < len; index++) {
      sourceRoot = null
      if (typeof options.sourceRoot === "string") {
        sourceRoot = options.sourceRoot
      } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
        sourceRoot = map.sourceRoot
      }
      // If the sourceRoot is the empty string, it is equivalent to not setting
      // the property at all.
      if (sourceRoot === null || sourceRoot === '') {
        fullUrl = resolveUrl(mapUrl, map.sources[index])
      } else {
        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
        // does not make sense.
        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index])
      }
      sourceContent = (map.sourcesContent || [])[index]
      fn(fullUrl, sourceContent, index)
    }
  }



  function resolve(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    if (code === null) {
      var mapUrl = codeUrl
      var data = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      var readUrl = mapUrl
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = data
          return callback(error)
        }
        data.map = String(result)
        try {
          data.map = parseMapToJSON(data.map, data)
        } catch (error) {
          return callback(error)
        }
        _resolveSources(data)
      })
    } else {
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error)
        }
        if (!mapData) {
          return callback(null, null)
        }
        _resolveSources(mapData)
      })
    }

    function _resolveSources(mapData) {
      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
        if (error) {
          return callback(error)
        }
        mapData.sourcesResolved = result.sourcesResolved
        mapData.sourcesContent  = result.sourcesContent
        callback(null, mapData)
      })
    }
  }

  function resolveSync(code, codeUrl, read, options) {
    var mapData
    if (code === null) {
      var mapUrl = codeUrl
      mapData = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      mapData.map = readSync(read, mapUrl, mapData)
      mapData.map = parseMapToJSON(mapData.map, mapData)
    } else {
      mapData = resolveSourceMapSync(code, codeUrl, read)
      if (!mapData) {
        return null
      }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
    mapData.sourcesResolved = result.sourcesResolved
    mapData.sourcesContent  = result.sourcesContent
    return mapData
  }



  return {
    resolveSourceMap:     resolveSourceMap,
    resolveSourceMapSync: resolveSourceMapSync,
    resolveSources:       resolveSources,
    resolveSourcesSync:   resolveSourcesSync,
    resolve:              resolve,
    resolveSync:          resolveSync,
    parseMapToJSON:       parseMapToJSON
  }

}));

}).call(this)}).call(this,require("timers").setImmediate)

},{"resolve-url":150,"source-map-url":175,"timers":191}],175:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (MIT) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.sourceMappingURL = factory()
  }
}(this, function() {

  var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/

  var regex = RegExp(
    "(?:" +
      "/\\*" +
      "(?:\\s*\r?\n(?://)?)?" +
      "(?:" + innerRegex.source + ")" +
      "\\s*" +
      "\\*/" +
      "|" +
      "//(?:" + innerRegex.source + ")" +
    ")" +
    "\\s*"
  )

  return {

    regex: regex,
    _innerRegex: innerRegex,

    getFrom: function(code) {
      var match = code.match(regex)
      return (match ? match[1] || match[2] || "" : null)
    },

    existsIn: function(code) {
      return regex.test(code)
    },

    removeFrom: function(code) {
      return code.replace(regex, "")
    },

    insertBefore: function(code, string) {
      var match = code.match(regex)
      if (match) {
        return code.slice(0, match.index) + string + code.slice(match.index)
      } else {
        return code + string
      }
    }
  }

}));

},{}],176:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":185}],177:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":178}],178:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],179:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],180:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":185}],181:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],182:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":176,"./base64-vlq":177,"./binary-search":179,"./quick-sort":181,"./util":185}],183:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":176,"./base64-vlq":177,"./mapping-list":180,"./util":185}],184:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":183,"./util":185}],185:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

},{}],186:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":182,"./lib/source-map-generator":183,"./lib/source-node":184}],187:[function(require,module,exports){
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var extend = require('extend-shallow');

module.exports = function(str, options, fn) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (typeof options === 'function') {
    fn = options;
    options = null;
  }

  // allow separator to be defined as a string
  if (typeof options === 'string') {
    options = { sep: options };
  }

  var opts = extend({sep: '.'}, options);
  var quotes = opts.quotes || ['"', "'", '`'];
  var brackets;

  if (opts.brackets === true) {
    brackets = {
      '<': '>',
      '(': ')',
      '[': ']',
      '{': '}'
    };
  } else if (opts.brackets) {
    brackets = opts.brackets;
  }

  var tokens = [];
  var stack = [];
  var arr = [''];
  var sep = opts.sep;
  var len = str.length;
  var idx = -1;
  var closeIdx;

  function expected() {
    if (brackets && stack.length) {
      return brackets[stack[stack.length - 1]];
    }
  }

  while (++idx < len) {
    var ch = str[idx];
    var next = str[idx + 1];
    var tok = { val: ch, idx: idx, arr: arr, str: str };
    tokens.push(tok);

    if (ch === '\\') {
      tok.val = keepEscaping(opts, str, idx) === true ? (ch + next) : next;
      tok.escaped = true;
      if (typeof fn === 'function') {
        fn(tok);
      }
      arr[arr.length - 1] += tok.val;
      idx++;
      continue;
    }

    if (brackets && brackets[ch]) {
      stack.push(ch);
      var e = expected();
      var i = idx + 1;

      if (str.indexOf(e, i + 1) !== -1) {
        while (stack.length && i < len) {
          var s = str[++i];
          if (s === '\\') {
            s++;
            continue;
          }

          if (quotes.indexOf(s) !== -1) {
            i = getClosingQuote(str, s, i + 1);
            continue;
          }

          e = expected();
          if (stack.length && str.indexOf(e, i + 1) === -1) {
            break;
          }

          if (brackets[s]) {
            stack.push(s);
            continue;
          }

          if (e === s) {
            stack.pop();
          }
        }
      }

      closeIdx = i;
      if (closeIdx === -1) {
        arr[arr.length - 1] += ch;
        continue;
      }

      ch = str.slice(idx, closeIdx + 1);
      tok.val = ch;
      tok.idx = idx = closeIdx;
    }

    if (quotes.indexOf(ch) !== -1) {
      closeIdx = getClosingQuote(str, ch, idx + 1);
      if (closeIdx === -1) {
        arr[arr.length - 1] += ch;
        continue;
      }

      if (keepQuotes(ch, opts) === true) {
        ch = str.slice(idx, closeIdx + 1);
      } else {
        ch = str.slice(idx + 1, closeIdx);
      }

      tok.val = ch;
      tok.idx = idx = closeIdx;
    }

    if (typeof fn === 'function') {
      fn(tok, tokens);
      ch = tok.val;
      idx = tok.idx;
    }

    if (tok.val === sep && tok.split !== false) {
      arr.push('');
      continue;
    }

    arr[arr.length - 1] += tok.val;
  }

  return arr;
};

function getClosingQuote(str, ch, i, brackets) {
  var idx = str.indexOf(ch, i);
  if (str.charAt(idx - 1) === '\\') {
    return getClosingQuote(str, ch, idx + 1);
  }
  return idx;
}

function keepQuotes(ch, opts) {
  if (opts.keepDoubleQuotes === true && ch === '"') return true;
  if (opts.keepSingleQuotes === true && ch === "'") return true;
  return opts.keepQuotes;
}

function keepEscaping(opts, str, idx) {
  if (typeof opts.keepEscaping === 'function') {
    return opts.keepEscaping(str, idx);
  }
  return opts.keepEscaping === true || str[idx + 1] === '\\';
}

},{"extend-shallow":53}],188:[function(require,module,exports){
/*!
 * static-extend <https://github.com/jonschlinkert/static-extend>
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var copy = require('object-copy');
var define = require('define-property');
var util = require('util');

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = require('static-extend');
 * Parent.extend = extend(Parent);
 *
 * // optionally pass a custom merge function as the second arg
 * Parent.extend = extend(Parent, function(Child) {
 *   Child.prototype.mixin = function(key, val) {
 *     Child.prototype[key] = val;
 *   };
 * });
 *
 * // extend "child" constructors
 * Parent.extend(Child);
 *
 * // optionally define prototype methods as the second arg
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */

function extend(Parent, extendFn) {
  if (typeof Parent !== 'function') {
    throw new TypeError('expected Parent to be a function.');
  }

  return function(Ctor, proto) {
    if (typeof Ctor !== 'function') {
      throw new TypeError('expected Ctor to be a function.');
    }

    util.inherits(Ctor, Parent);
    copy(Ctor, Parent);

    // proto can be null or a plain object
    if (typeof proto === 'object') {
      var obj = Object.create(proto);

      for (var k in obj) {
        Ctor.prototype[k] = obj[k];
      }
    }

    // keep a reference to the parent prototype
    define(Ctor.prototype, '_parent_', {
      configurable: true,
      set: function() {},
      get: function() {
        return Parent.prototype;
      }
    });

    if (typeof extendFn === 'function') {
      extendFn(Ctor, Parent);
    }

    Ctor.extend = extend(Ctor, extendFn);
  };
};

/**
 * Expose `extend`
 */

module.exports = extend;

},{"define-property":189,"object-copy":117,"util":211}],189:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],190:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":128,"readable-stream":141,"util":211,"xtend":212}],191:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":128,"timers":191}],192:[function(require,module,exports){
/*!
 * to-object-path <https://github.com/jonschlinkert/to-object-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function toPath(args) {
  if (typeOf(args) !== 'arguments') {
    args = arguments;
  }
  return filter(args).join('.');
};

function filter(arr) {
  var len = arr.length;
  var idx = -1;
  var res = [];

  while (++idx < len) {
    var ele = arr[idx];
    if (typeOf(ele) === 'arguments' || Array.isArray(ele)) {
      res.push.apply(res, filter(ele));
    } else if (typeof ele === 'string') {
      res.push(ele);
    }
  }
  return res;
}

},{"kind-of":193}],193:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],194:[function(require,module,exports){
/*!
 * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var repeat = require('repeat-string');
var isNumber = require('is-number');
var cache = {};

function toRegexRange(min, max, options) {
  if (isNumber(min) === false) {
    throw new RangeError('toRegexRange: first argument is invalid.');
  }

  if (typeof max === 'undefined' || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new RangeError('toRegexRange: second argument is invalid.');
  }

  options = options || {};
  var relax = String(options.relaxZeros);
  var shorthand = String(options.shorthand);
  var capture = String(options.capture);
  var key = min + ':' + max + '=' + relax + shorthand + capture;
  if (cache.hasOwnProperty(key)) {
    return cache[key].result;
  }

  var a = Math.min(min, max);
  var b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    var result = min + '|' + max;
    if (options.capture) {
      return '(' + result + ')';
    }
    return result;
  }

  var isPadded = padding(min) || padding(max);
  var positives = [];
  var negatives = [];

  var tok = {min: min, max: max, a: a, b: b};
  if (isPadded) {
    tok.isPadded = isPadded;
    tok.maxLen = String(tok.max).length;
  }

  if (a < 0) {
    var newMin = b < 0 ? Math.abs(b) : 1;
    var newMax = Math.abs(a);
    negatives = splitToPatterns(newMin, newMax, tok, options);
    a = tok.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, tok, options);
  }

  tok.negatives = negatives;
  tok.positives = positives;
  tok.result = siftPatterns(negatives, positives, options);

  if (options.capture && (positives.length + negatives.length) > 1) {
    tok.result = '(' + tok.result + ')';
  }

  cache[key] = tok;
  return tok.result;
}

function siftPatterns(neg, pos, options) {
  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  min = Number(min);
  max = Number(max);

  var nines = 1;
  var stops = [max];
  var stop = +countNines(min, nines);

  while (min <= stop && stop <= max) {
    stops = push(stops, stop);
    nines += 1;
    stop = +countNines(min, nines);
  }

  var zeros = 1;
  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops = push(stops, stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return {pattern: String(start), digits: []};
  }

  var zipped = zip(String(start), String(stop));
  var len = zipped.length, i = -1;

  var pattern = '';
  var digits = 0;

  while (++i < len) {
    var numbers = zipped[i];
    var startDigit = numbers[0];
    var stopDigit = numbers[1];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);

    } else {
      digits += 1;
    }
  }

  if (digits) {
    pattern += options.shorthand ? '\\d' : '[0-9]';
  }

  return { pattern: pattern, digits: [digits] };
}

function splitToPatterns(min, max, tok, options) {
  var ranges = splitToRanges(min, max);
  var len = ranges.length;
  var idx = -1;

  var tokens = [];
  var start = min;
  var prev;

  while (++idx < len) {
    var range = ranges[idx];
    var obj = rangeToPattern(start, range, options);
    var zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.digits.length > 1) {
        prev.digits.pop();
      }
      prev.digits.push(obj.digits[0]);
      prev.string = prev.pattern + toQuantifier(prev.digits);
      start = range + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(range, tok);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
    tokens.push(obj);
    start = range + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  var res = [];

  for (var i = 0; i < arr.length; i++) {
    var tok = arr[i];
    var ele = tok.string;

    if (options.relaxZeros !== false) {
      if (prefix === '-' && ele.charAt(0) === '0') {
        if (ele.charAt(1) === '{') {
          ele = '0*' + ele.replace(/^0\{\d+\}/, '');
        } else {
          ele = '0*' + ele.slice(1);
        }
      }
    }

    if (!intersection && !contains(comparison, 'string', ele)) {
      res.push(prefix + ele);
    }

    if (intersection && contains(comparison, 'string', ele)) {
      res.push(prefix + ele);
    }
  }
  return res;
}

/**
 * Zip strings (`for in` can be used on string characters)
 */

function zip(a, b) {
  var arr = [];
  for (var ch in a) arr.push([a[ch], b[ch]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function push(arr, ele) {
  if (arr.indexOf(ele) === -1) arr.push(ele);
  return arr;
}

function contains(arr, key, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i][key] === val) {
      return true;
    }
  }
  return false;
}

function countNines(min, len) {
  return String(min).slice(0, -len) + repeat('9', len);
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  var start = digits[0];
  var stop = digits[1] ? (',' + digits[1]) : '';
  if (!stop && (!start || start === 1)) {
    return '';
  }
  return '{' + start + stop + '}';
}

function toCharacterClass(a, b) {
  return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';
}

function padding(str) {
  return /^-?(0+)\d/.exec(str);
}

function padZeros(val, tok) {
  if (tok.isPadded) {
    var diff = Math.abs(tok.maxLen - String(val).length);
    switch (diff) {
      case 0:
        return '';
      case 1:
        return '0';
      default: {
        return '0{' + diff + '}';
      }
    }
  }
  return val;
}

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;

},{"is-number":92,"repeat-string":149}],195:[function(require,module,exports){
'use strict';

var safe = require('safe-regex');
var define = require('define-property');
var extend = require('extend-shallow');
var not = require('regex-not');
var MAX_LENGTH = 1024 * 64;

/**
 * Session cache
 */

var cache = {};

/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

module.exports = function(patterns, options) {
  if (!Array.isArray(patterns)) {
    return makeRe(patterns, options);
  }
  return makeRe(patterns.join('|'), options);
};

/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

function makeRe(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  var key = pattern;
  // do this before shallow cloning options, it's a lot faster
  if (!options || (options && options.cache !== false)) {
    key = createKey(pattern, options);

    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
  }

  var opts = extend({}, options);
  if (opts.contains === true) {
    if (opts.negate === true) {
      opts.strictNegate = false;
    } else {
      opts.strict = false;
    }
  }

  if (opts.strict === false) {
    opts.strictOpen = false;
    opts.strictClose = false;
  }

  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var flags = opts.flags || '';
  var regex;

  if (opts.nocase === true && !/i/.test(flags)) {
    flags += 'i';
  }

  try {
    if (opts.negate || typeof opts.strictNegate === 'boolean') {
      pattern = not.create(pattern, opts);
    }

    var str = open + '(?:' + pattern + ')' + close;
    regex = new RegExp(str, flags);

    if (opts.safe === true && safe(regex) === false) {
      throw new Error('potentially unsafe regular expression: ' + regex.source);
    }

  } catch (err) {
    if (opts.strictErrors === true || opts.safe === true) {
      err.key = key;
      err.pattern = pattern;
      err.originalOptions = options;
      err.createdOptions = opts;
      throw err;
    }

    try {
      regex = new RegExp('^' + pattern.replace(/(\W)/g, '\\$1') + '$');
    } catch (err) {
      regex = /.^/; //<= match nothing
    }
  }

  if (opts.cache !== false) {
    memoize(regex, key, pattern, opts);
  }
  return regex;
}

/**
 * Memoize generated regex. This can result in dramatic speed improvements
 * and simplify debugging by adding options and pattern to the regex. It can be
 * disabled by passing setting `options.cache` to false.
 */

function memoize(regex, key, pattern, options) {
  define(regex, 'cached', true);
  define(regex, 'pattern', pattern);
  define(regex, 'options', options);
  define(regex, 'key', key);
  cache[key] = regex;
}

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

function createKey(pattern, options) {
  if (!options) return pattern;
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
}

/**
 * Expose `makeRe`
 */

module.exports.makeRe = makeRe;

},{"define-property":43,"extend-shallow":53,"regex-not":146,"safe-regex":156}],196:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');
var union = require('arr-union');
var get = require('get-value');
var set = require('set-value');

module.exports = function unionValue(obj, prop, value) {
  if (!isObject(obj)) {
    throw new TypeError('union-value expects the first argument to be an object.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('union-value expects `prop` to be a string.');
  }

  var arr = arrayify(get(obj, prop));
  set(obj, prop, union(arr, arrayify(value)));
  return obj;
};

function arrayify(val) {
  if (val === null || typeof val === 'undefined') {
    return [];
  }
  if (Array.isArray(val)) {
    return val;
  }
  return [val];
}

},{"arr-union":4,"get-value":69,"is-extendable":89,"set-value":157}],197:[function(require,module,exports){
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var has = require('has-value');

module.exports = function unset(obj, prop) {
  if (!isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (obj.hasOwnProperty(prop)) {
    delete obj[prop];
    return true;
  }

  if (has(obj, prop)) {
    var segs = prop.split('.');
    var last = segs.pop();
    while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
      last = segs.pop().slice(0, -1) + '.' + last;
    }
    while (segs.length) obj = obj[prop = segs.shift()];
    return (delete obj[last]);
  }
  return true;
};

},{"has-value":198,"isobject":97}],198:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var hasValues = require('has-values');
var get = require('get-value');

module.exports = function(obj, prop, noZero) {
  if (isObject(obj)) {
    return hasValues(get(obj, prop), noZero);
  }
  return hasValues(obj, prop);
};

},{"get-value":69,"has-values":200,"isobject":199}],199:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isArray = require('isarray');

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && isArray(val) === false;
};

},{"isarray":96}],200:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function hasValue(o, noZero) {
  if (o === null || o === undefined) {
    return false;
  }

  if (typeof o === 'boolean') {
    return true;
  }

  if (typeof o === 'number') {
    if (o === 0 && noZero === true) {
      return false;
    }
    return true;
  }

  if (o.length !== undefined) {
    return o.length !== 0;
  }

  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      return true;
    }
  }
  return false;
};

},{}],201:[function(require,module,exports){
/**
* upath http://github.com/anodynos/upath/
*
* A proxy to `path`, replacing `\` with `/` for all results & new methods to normalize & join keeping leading `./` and add, change, default, trim file extensions.
* Version 1.2.0 - Compiled on 2019-09-02 23:33:57
* Repository git://github.com/anodynos/upath
* Copyright(c) 2019 Angelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT
*/

// Generated by uRequire v0.7.0-beta.33 target: 'lib' template: 'nodejs'


var VERSION = '1.2.0'; // injected by urequire-rc-inject-version

var extraFn, extraFunctions, isFunction, isString, isValidExt, name, path, propName, propValue, toUnix, upath, slice = [].slice, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  }, hasProp = {}.hasOwnProperty;
path = require("path");
isFunction = function (val) {
  return val instanceof Function;
};
isString = function (val) {
  return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
};
upath = exports;
upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
toUnix = function (p) {
  var double;
  p = p.replace(/\\/g, "/");
  double = /\/\//;
  while (p.match(double)) {
    p = p.replace(double, "/");
  }
  return p;
};
for (propName in path) {
  propValue = path[propName];
  if (isFunction(propValue)) {
    upath[propName] = function (propName) {
      return function () {
        var args, result;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        args = args.map(function (p) {
          if (isString(p)) {
            return toUnix(p);
          } else {
            return p;
          }
        });
        result = path[propName].apply(path, args);
        if (isString(result)) {
          return toUnix(result);
        } else {
          return result;
        }
      };
    }(propName);
  } else {
    upath[propName] = propValue;
  }
}
upath.sep = "/";
extraFunctions = {
  toUnix: toUnix,
  normalizeSafe: function (p) {
    p = toUnix(p);
    if (p.startsWith("./")) {
      if (p.startsWith("./..") || p === "./") {
        return upath.normalize(p);
      } else {
        return "./" + upath.normalize(p);
      }
    } else {
      return upath.normalize(p);
    }
  },
  normalizeTrim: function (p) {
    p = upath.normalizeSafe(p);
    if (p.endsWith("/")) {
      return p.slice(0, +(p.length - 2) + 1 || 9000000000);
    } else {
      return p;
    }
  },
  joinSafe: function () {
    var p, result;
    p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    result = upath.join.apply(null, p);
    if (p[0].startsWith("./") && !result.startsWith("./")) {
      result = "./" + result;
    }
    return result;
  },
  addExt: function (file, ext) {
    if (!ext) {
      return file;
    } else {
      if (ext[0] !== ".") {
        ext = "." + ext;
      }
      return file + (file.endsWith(ext) ? "" : ext);
    }
  },
  trimExt: function (filename, ignoreExts, maxSize) {
    var oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9000000000);
    } else {
      return filename;
    }
  },
  removeExt: function (filename, ext) {
    if (!ext) {
      return filename;
    } else {
      ext = ext[0] === "." ? ext : "." + ext;
      if (upath.extname(filename) === ext) {
        return upath.trimExt(filename);
      } else {
        return filename;
      }
    }
  },
  changeExt: function (filename, ext, ignoreExts, maxSize) {
    if (maxSize == null) {
      maxSize = 7;
    }
    return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
  },
  defaultExt: function (filename, ext, ignoreExts, maxSize) {
    var oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename;
    } else {
      return upath.addExt(filename, ext);
    }
  }
};
isValidExt = function (ext, ignoreExts, maxSize) {
  if (ignoreExts == null) {
    ignoreExts = [];
  }
  return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function (e) {
    return (e && e[0] !== "." ? "." : "") + e;
  }), ext) < 0;
};
for (name in extraFunctions) {
  if (!hasProp.call(extraFunctions, name))
    continue;
  extraFn = extraFunctions[name];
  if (upath[name] !== void 0) {
    throw new Error("path." + name + " already exists.");
  } else {
    upath[name] = extraFn;
  }
}

;
},{"path":207}],202:[function(require,module,exports){
/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function base(app, options) {
  if (!isObject(app) && typeof app !== 'function') {
    throw new TypeError('expected an object or function');
  }

  var opts = isObject(options) ? options : {};
  var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';
  if (!Array.isArray(app[prop])) {
    define(app, prop, []);
  }

  /**
   * Define a plugin function to be passed to use. The only
   * parameter exposed to the plugin is `app`, the object or function.
   * passed to `use(app)`. `app` is also exposed as `this` in plugins.
   *
   * Additionally, **if a plugin returns a function, the function will
   * be pushed onto the `fns` array**, allowing the plugin to be
   * called at a later point by the `run` method.
   *
   * ```js
   * var use = require('use');
   *
   * // define a plugin
   * function foo(app) {
   *   // do stuff
   * }
   *
   * var app = function(){};
   * use(app);
   *
   * // register plugins
   * app.use(foo);
   * app.use(bar);
   * app.use(baz);
   * ```
   * @name .use
   * @param {Function} `fn` plugin function to call
   * @api public
   */

  define(app, 'use', use);

  /**
   * Run all plugins on `fns`. Any plugin that returns a function
   * when called by `use` is pushed onto the `fns` array.
   *
   * ```js
   * var config = {};
   * app.run(config);
   * ```
   * @name .run
   * @param {Object} `value` Object to be modified by plugins.
   * @return {Object} Returns the object passed to `run`
   * @api public
   */

  define(app, 'run', function(val) {
    if (!isObject(val)) return;

    if (!val.use || !val.run) {
      define(val, prop, val[prop] || []);
      define(val, 'use', use);
    }

    if (!val[prop] || val[prop].indexOf(base) === -1) {
      val.use(base);
    }

    var self = this || app;
    var fns = self[prop];
    var len = fns.length;
    var idx = -1;

    while (++idx < len) {
      val.use(fns[idx]);
    }
    return val;
  });

  /**
   * Call plugin `fn`. If a function is returned push it into the
   * `fns` array to be called by the `run` method.
   */

  function use(type, fn, options) {
    var offset = 1;

    if (typeof type === 'string' || Array.isArray(type)) {
      fn = wrap(type, fn);
      offset++;
    } else {
      options = fn;
      fn = type;
    }

    if (typeof fn !== 'function') {
      throw new TypeError('expected a function');
    }

    var self = this || app;
    var fns = self[prop];

    var args = [].slice.call(arguments, offset);
    args.unshift(self);

    if (typeof opts.hook === 'function') {
      opts.hook.apply(self, args);
    }

    var val = fn.apply(self, args);
    if (typeof val === 'function' && fns.indexOf(val) === -1) {
      fns.push(val);
    }
    return self;
  }

  /**
   * Wrap a named plugin function so that it's only called on objects of the
   * given `type`
   *
   * @param {String} `type`
   * @param {Function} `fn` Plugin function
   * @return {Function}
   */

  function wrap(type, fn) {
    return function plugin() {
      return this.type === type ? fn.apply(this, arguments) : plugin;
    };
  }

  return app;
};

function isObject(val) {
  return val && typeof val === 'object' && !Array.isArray(val);
}

function define(obj, key, val) {
  Object.defineProperty(obj, key, {
    configurable: true,
    writable: true,
    value: val
  });
}

},{}],203:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],204:[function(require,module,exports){
var through = require('through2');
var path = require('path');
var chokidar = require('chokidar');
var xtend = require('xtend');
var anymatch = require('anymatch');

module.exports = watchify;
module.exports.args = {
    cache: {}, packageCache: {}
};

function watchify (b, opts) {
    if (!opts) opts = {};
    var cache = b._options.cache;
    var pkgcache = b._options.packageCache;
    var delay = typeof opts.delay === 'number' ? opts.delay : 100;
    var changingDeps = {};
    var pending = false;
    var updating = false;
    
    var wopts = {persistent: true};
    if (opts.ignoreWatch) {
        var ignored = opts.ignoreWatch !== true
            ? opts.ignoreWatch
            : '**/node_modules/**';
    }
    if (opts.poll || typeof opts.poll === 'number') {
        wopts.usePolling = true;
        wopts.interval = opts.poll !== true
            ? opts.poll
            : undefined;
    }

    if (cache) {
        b.on('reset', collect);
        collect();
    }
    
    function collect () {
        b.pipeline.get('deps').push(through.obj(function(row, enc, next) {
            var file = row.expose ? b._expose[row.id] : row.file;
            cache[file] = {
                source: row.source,
                deps: xtend(row.deps)
            };
            this.push(row);
            next();
        }));
    }
    
    b.on('file', function (file) {
        watchFile(file);
    });
    
    b.on('package', function (pkg) {
        var file = path.join(pkg.__dirname, 'package.json');
        watchFile(file);
        if (pkgcache) pkgcache[file] = pkg;
    });
    
    b.on('reset', reset);
    reset();
    
    function reset () {
        var time = null;
        var bytes = 0;
        b.pipeline.get('record').on('end', function () {
            time = Date.now();
        });
        
        b.pipeline.get('wrap').push(through(write, end));
        function write (buf, enc, next) {
            bytes += buf.length;
            this.push(buf);
            next();
        }
        function end () {
            var delta = Date.now() - time;
            b.emit('time', delta);
            b.emit('bytes', bytes);
            b.emit('log', bytes + ' bytes written ('
                + (delta / 1000).toFixed(2) + ' seconds)'
            );
            this.push(null);
        }
    }
    
    var fwatchers = {};
    var fwatcherFiles = {};
    var ignoredFiles = {};
    
    b.on('transform', function (tr, mfile) {
        tr.on('file', function (dep) {
            watchFile(mfile, dep);
        });
    });
    b.on('bundle', function (bundle) {
        updating = true;
        bundle.on('error', onend);
        bundle.on('end', onend);
        function onend () { updating = false }
    });

    function watchFile (file, dep) {
        dep = dep || file;
        if (ignored) {
            if (!ignoredFiles.hasOwnProperty(file)) {
                ignoredFiles[file] = anymatch(ignored, file);
            }
            if (ignoredFiles[file]) return;
        }
        if (!fwatchers[file]) fwatchers[file] = [];
        if (!fwatcherFiles[file]) fwatcherFiles[file] = [];
        if (fwatcherFiles[file].indexOf(dep) >= 0) return;

        var w = b._watcher(dep, wopts);
        w.setMaxListeners(0);
        w.on('error', b.emit.bind(b, 'error'));
        w.on('change', function () {
            invalidate(file);
        });
        fwatchers[file].push(w);
        fwatcherFiles[file].push(dep);
    }
    
    function invalidate (id) {
        if (cache) delete cache[id];
        if (pkgcache) delete pkgcache[id];
        changingDeps[id] = true;
        
        if (!updating && fwatchers[id]) {
            fwatchers[id].forEach(function (w) {
                w.close();
            });
            delete fwatchers[id];
            delete fwatcherFiles[id];
        }
        
        // wait for the disk/editor to quiet down first:
        if (pending) clearTimeout(pending);
        pending = setTimeout(notify, delay);
    }
    
    function notify () {
        if (updating) {
            pending = setTimeout(notify, delay);
        } else {
            pending = false;
            b.emit('update', Object.keys(changingDeps));
            changingDeps = {};
        }
    }
    
    b.close = function () {
        Object.keys(fwatchers).forEach(function (id) {
            fwatchers[id].forEach(function (w) { w.close() });
        });
    };
    
    b._watcher = function (file, opts) {
        return chokidar.watch(file, opts);
    };

    return b;
}

},{"anymatch":1,"chokidar":28,"path":207,"through2":190,"xtend":212}],205:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],206:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],207:[function(require,module,exports){
(function (process){(function (){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this)}).call(this,require('_process'))

},{"_process":128}],208:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":206,"inherits":80,"readable-stream/duplex.js":129,"readable-stream/passthrough.js":140,"readable-stream/readable.js":141,"readable-stream/transform.js":142,"readable-stream/writable.js":143}],209:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],210:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],211:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":210,"_process":128,"inherits":209}],212:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],213:[function(require,module,exports){

let displayedExercises = require("./exercisesToShowOnIndex.js");
let quizExercises = require("./data/quiz.js");

let exercises = [...displayedExercises, ...quizExercises];

module.exports = exercises;
},{"./data/quiz.js":223,"./exercisesToShowOnIndex.js":230}],214:[function(require,module,exports){
module.exports = [
  {
    //title is the category it appears in on the homepage
    title: '2D Arrays',
    // Pseudocode problems should start with a capital letter
    name: '2dArrayPrintAll',

    inputs: [
      `([[1, 2, 3],[4, 5, 6],[7, 8, 9]])`,
      '([[2, 3], [6, 4]])',
      '([["a", "b", "c"],["A", "B", "C"], ["","", ""]])',
      '([[13, 6], [1, 2], [4, 6]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a two - dimensional array ARR, output each element of the array on its own line. 
    At the end of each row, output the phrase END ROW. `,

    solution: `method PrintAll(ARR)
  loop R from 0 to ARR.Length() - 1
    loop C from 0 to ARR[R].Length() - 1
      output ARR[R][C]
    end loop
    output "END ROW"
  end loop
end method`,
  },
  {
    //title is the category it appears in on the homepage
    title: '2D Arrays',
    // Pseudocode problems should start with a capital letter
    name: 'DiagArray',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6],[7, 8, 9]])`,
      '([[2, 3], [6, 4]])',
      '([["a", "b", "c"],["A", "B", "C"], ["","", ""]])',
      '([[13, 6], [1, 2], [4, 6]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Give a two - dimensional square array ARR, output a one - dimensional array that contains the elements 
    of its <i>primary diagonal</i > - that is, the elements whose row index and 
    column index are the same. 
    You can assume ARR has the same number of rows and columns.
    You can make a new array of length L with the command <code>NEW = new Array(L)</code> `,
    solution: `method FindDiagonal(ARR)
  // ARR.Length() will give the number of rows
  // ARR[0].Length() would give the # of columns
  NEW = new Array(ARR.Length())
  loop I from 0 to ARR.Length() - 1
    NEW[I] = ARR[I][I]
  end loop
  output NEW
end method`,
  }, {
    //title is the category it appears in on the homepage
    title: '2D Arrays',
    // Pseudocode problems should start with a capital letter
    name: 'FindValue',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6]], 0)`,
      '([[2, 3], [6, 4], [2, 3]], 4)',
      '([["a", "b", "c"],["A", "B", "C"], ["","", ""]], "A")',
      '([[13, 6], [1, 2], [4, 6]], 6)',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]], 4)',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a two-dimensional array ARR and a search value VAL,
    search the array in reading order - rows then columns - to find the first
    occurence of VAL. Once you find it, output "VAL found at index [R][C]"
    replacing VAL, R, and C with the appropriate values. If it isn't found, output
    "VAL not found". `,
    solution: `method FindValue(ARR, VAL)
  // ARR.Length() will give the number of rows
  // ARR[0].Length() would give the # of columns
  FOUND = FALSE
  loop ROW from 0 to ARR.Length() - 1
    loop COL from 0 to ARR[ROW].Length() - 1
      if ARR[ROW][COL] = VAL then
        output "" + VAL + " found at index [" + ROW + "][" + COL + "]"
        return
      end if
    end loop
  end loop
  output "" + VAL + " not found"
end method`,
  }, {
    //title is the category it appears in on the homepage
    title: '2D Arrays',
    // Pseudocode problems should start with a capital letter
    name: 'SwapRows',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6]], 0, 1)`,
      '([[2, 3], [6, 4], [2, 3]], 0, 2)',
      '([["a", "b", "c"],["A", "B", "C"], ["","", ""]], 1, 2)',
      '([[13, 6], [1, 2], [4, 6]], 0, 2)',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]], 2, 3)',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a 2d array MAT and two indices K and L, construct code to swap
    the elements in row K with the elements in row L (you can assume all rows are the
      same length). OUTPUT the new MAT on completion. (IB November 2018, 12b)`,
    solution: `method SwapRows(MAT, K, L)
      loop I from 0 to MAT[K].Length()-1
        TEMP = MAT[K][I]
        MAT[K][I]=MAT[L][I]
        MAT[L][I]=TEMP
      end loop
      output MAT
    end method`,
  }, {
    //title is the category it appears in on the homepage
    title: '2D Arrays',
    // Pseudocode problems should start with a capital letter
    name: 'Sort2D',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 21, 5],[4, 15, 6]])`,
      '([[2, 3], [1, 6], [2, 2]])',
      '([[13, 6, 11], [1, 2, 3], [4, 6, 5], [7, 0, -3]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a 2D array MAT of numbers, construct a method that will sort the matrix 
    so that the sum of each row is in ascending order, and return the sorted array.
    
    Hint: It may be helpful to make submethods such as SumRow(MAT, ROW) and SwapRows(MAT, R1, R2).
    If you make methods inside the main method, you can use them just fine.`,
    solution: `method Sort2D(MAT)
    // Using selection sort
    loop FRNT from 0 to MAT.Length() - 2
      loop CHK from (FRNT + 1) to (MAT.Length() - 1)
        MIN = FRNT
        if SumRow(MAT, CHK) < SumRow(MAT, MIN) then
          MIN = CHK
        end if
        if MIN != FRNT then
          SwapRows(MAT, FRNT, MIN)
        end if
      end loop
    end loop
    
    output MAT


    method SumRow(MAT, R)
      S = 0
      loop I from 0 to MAT[R].Length() - 1
        S = S + MAT[R][I]
      end loop
      return S
    end method

    method SwapRows(MAT, K, L)
      loop I from 0 to MAT[K].Length() - 1
        TEMP = MAT[K][I]
        MAT[K][I]=MAT[L][I]
        MAT[L][I]=TEMP
      end loop
      return MAT
    end method
    
  end method`,

  }, {
    //title is the category it appears in on the homepage
    title: '2D Arrays',
    // Pseudocode problems should start with a capital letter
    name: 'DiagonalCollection',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6],[7, 8, 9]])`,
      '([[2, 3], [6, 4]])',
      '([[13, 6], [1, 2]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a 2d array square MAT, build a collection COL that contains the diagonal elements of MAT. Output the new collection. You can make a new collection with the command COL = new Collection()`,
    solution: `method Diagonal(MAT)
    COL = new Collection() 
    loop I from 0 to MAT.Length() - 1
      COL.addItem(MAT[I][I])
    end loop
    output COL
end method`,
  }, {
    //title is the category it appears in on the homepage
    title: 'Stacks and Queues',
    name: 'CollectionToStack',
    inputType: "collection",
    inputs: [
      '({1, 2, 3})',
      '({7, -3, 14})',
      '({"first", "second", "third"})',
      '({"Bob", "Mary", "Margaret", "Josiah", "Alistair"})'
    ],
    question: `Given a collection, COL, create a stack STK that contains 
    the elements so that the first element in the collection is the bottom 
    element in the stack. Output the stack. You can create a new stack with the command
    STK = new Stack()`,
    solution: `method CollectionToStack(COL)
        STK = new Stack()
        loop while COL.hasNext() 
          STK.push(COL.getNext())
        end loop
        output STK
    end method`,
  }, {
    //title is the category it appears in on the homepage
    title: 'Stacks and Queues',
    name: 'CollectionToQueue',
    inputType: "collection",
    inputs: [
      '({1, 2, 3})',
      '({7, -3, 14})',
      '({"first", "second", "third"})',
      '({"Bob", "Mary", "Margaret", "Josiah", "Alistair"})'
    ],
    question: `Given a collection, COL, create a queue that contains 
    the elements so that the first element in the collection is the front of the queue. 
    Output the queue. You can create a new queue with the command
    QUE = new Queue()`,
    solution: `method CollectinToQueue(COL)
        QUE = new Queue()
        loop while COL.hasNext() 
          QUE.enqueue(COL.getNext())
        end loop
        output QUE
    end method`,
  }, {
    //title is the category it appears in on the homepage
    title: 'Stacks and Queues',
    name: 'ReverseCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3})',
      '({7, -3, 14})',
      '({"first", "second", "third"})',
      '({"Bob", "Mary", "Margaret", "Josiah", "Alistair"})'
    ],
    question: `Given a collection, COL, create a new collection that contains the reverse  create a queue
      that contains the same elements in reverse order. (Hint: use a stack in the middle!).
      Output the new collection.`,
    solution: `method ReverseCollection(COL)
        STK = new Stack()
        BCK = new Collection()
        COL.resetNext()

        loop while COL.hasNext() 
          STK.push(COL.getNext())
        end loop

        loop while NOT STK.isEmpty()
          BCK.addItem(STK.pop())
        end loop
        
        output BCK
    end method`,
  }, { //title is the category it appears in on the homepage
    title: 'Stacks and Queues',
    name: 'SplitStack',
    inputType: "stack",
    inputs: [
      '(B[1, 2, 3]T)',
      '(B[7, -3, 3, 14]T)',
      '(B[9, -2, 5, 11, 2]T)',
      '(B[2, 3, 4, 5, 6]T)',
      '(B[3, -3, 3, -3, 3]T)'
    ],
    question: `Given a stack if integers, STK, take items from the top of the stack
    and move them into a second stack, until you find a 3. The 3 should not be put in
    EITHER stack. 
    
    Output FIRST the new stack THEN the old stack (outputting empty stacks is fine)`,
    solution: `method SplitStack(STK)
    STK2 = new Stack()
    FOUND = false
    loop while NOT STK.isEmpty() AND NOT FOUND
      E = STK.pop()
      if E = 3 then
        FOUND = true
      else
        STK2.push(E)
      end if
    end loop

    output STK2
    output STK
end method`,
  }
]
},{}],215:[function(require,module,exports){
module.exports = [{
  question: 'Given an array SCORES, output "TRUE" if each score is equal or greater than the one before. The array will be length 2 or more. You can use the property ARR.length to find the length of the array.',
  title: 'AP-1',
  name: 'ScoresIncreasing',
  inputs: [
    "([1, 3, 4])",
    "([1, 3, 2])",
    "([1, 1, 4])",
    "([1, 1, 2, 4, 4, 7])",
    "([1, 1, 2, 4, 3, 7])"
  ]
},
{
  question: 'Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2.',
  title: 'AP-1',
  name: 'scores100',
  inputs: [
    "([1, 100, 100])",
    "([1, 100, 99, 100])",
    "([100, 1, 100, 100])",
    "([100, 1, 100, 1])",
    "([1, 2, 3, 4, 5])",
    "([1, 2, 100, 4, 5])"
  ]
},
{
  question: 'Given an array of scores sorted in increasing order, return true if the array contains 3 adjacent scores that differ from each other by at most 2, such as with {3, 4, 5} or {3, 5, 5}.',
  title: 'AP-1',
  name: 'scoresClump',
  inputs: [
    "([3, 4, 5])",
    "([3, 4, 6])",
    "([1, 3, 5, 5])",
    "([2, 4, 5, 6])",
    "([2, 4, 5, 7])",
    "([2, 4, 4, 7])",
    "([3, 3, 6, 7, 9])",
    "([3, 3, 7, 7, 9])",
    "([4, 5, 8])"
  ]
},
{
  question: 'Given an array of scores, compute the int average of the first half and the second half, and return whichever is larger. We\'ll say that the second half begins at index length/2. The array length will be at least 2. To practice decomposition, write a separate helper method int average(int[] scores, int start, int end) {  which computes the average of the elements between indexes start..end. Call your helper method twice to implement scoresAverage(). Write your helper method after your scoresAverage() method in the JavaBat text area. Normally you would compute averages with doubles, but here we use ints so the expected results are exact.',
  title: 'AP-1',
  name: 'scoresAverage',
  inputs: [
    "([2, 2, 4, 4])",
    "([4, 4, 4, 2, 2, 2])",
    "([3, 4, 5, 1, 2, 3])",
    "([5, 6])",
    "([5, 4])",
    "([5, 4, 5, 6, 2, 1, 2, 3])"
  ]
},
{
  question: 'Given an array of strings, return the count of the number of strings with the given length.',
  title: 'AP-1',
  name: 'wordsCount',
  inputs: [
    "(['a', 'bb', 'b', 'ccc'], 1)",
    "(['a', 'bb', 'b', 'ccc'], 3)",
    "(['a', 'bb', 'b', 'ccc'], 4)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 1)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 2)"
  ]
},
{
  question: 'Given an array of strings, return a new array containing the first N strings. N will be in the range 1..length.',
  title: 'AP-1',
  name: 'wordsFront',
  inputs: [
    "(['a', 'b', 'c', 'd'], 1)",
    "(['a', 'b', 'c', 'd'], 2)",
    "(['a', 'b', 'c', 'd'], 3)",
    "(['a', 'b', 'c', 'd'], 4)",
    "(['Hi', 'There'], 1)"
  ]
},
{
  question: 'Given an array of strings, return a new List (e.g. an ArrayList) where all the strings of the given length are omitted. See wordsWithout() below which is more difficult because it uses arrays.',
  title: 'AP-1',
  name: 'wordsWithoutList',
  inputs: [
    "(['a', 'bb', 'b', 'ccc'], 1)",
    "(['a', 'bb', 'b', 'ccc'], 3)",
    "(['a', 'bb', 'b', 'ccc'], 4)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 1)"
  ]
},
{
  question: 'Given a positive int n, return true if it contains a 1 digit. Note: use % to get the rightmost digit, and / to discard the rightmost digit.',
  title: 'AP-1',
  name: 'hasOne',
  inputs: [
    "(10)",
    "(22)",
    "(220)",
    "(212)",
    "(1)",
    "(9)",
    "(211112)",
    "(121121)",
    "(222222)",
    "(56156)",
    "(56556)"
  ]
},
{
  question: 'We\'ll say that a positive int divides itself if every digit in the number divides into the number evenly. So for example 128 divides itself since 1, 2, and 8 all divide into 128 evenly. We\'ll say that 0 does not divide into anything evenly, so no number with a 0 digit divides itself. Note: use % to get the rightmost digit, and / to discard the rightmost digit.',
  title: 'AP-1',
  name: 'dividesSelf',
  inputs: [
    "(128)",
    "(12)",
    "(120)",
    "(122)",
    "(13)",
    "(32)",
    "(22)",
    "(42)",
    "(212)",
    "(213)",
    "(162)"
  ]
},
{
  question: 'Given an array of positive ints, return a new array of length "count" containing the first even numbers from the original array. The original array will contain at least "count" even numbers.',
  title: 'AP-1',
  name: 'copyEvens',
  inputs: [
    "([3, 2, 4, 5, 8], 2)",
    "([3, 2, 4, 5, 8], 3)",
    "([6, 1, 2, 4, 5, 8], 3)",
    "([6, 1, 2, 4, 5, 8], 4)",
    "([3, 1, 4, 1, 5], 1)",
    "([2], 1)",
    "([6, 2, 4, 8], 2)",
    "([6, 2, 4, 8], 3)",
    "([6, 2, 4, 8], 4)",
    "([1, 8, 4], 1)",
    "([1, 8, 4], 2)",
    "([2, 8, 4], 2)"
  ]
},
{
  question: 'We\'ll say that a positive int n is "endy" if it is in the range 0..10 or 90..100 (inclusive). Given an array of positive ints, return a new array of length "count" containing the first endy numbers from the original array. Decompose out a separate isEndy(int n) method to test if a number is endy. The original array will contain at least "count" endy numbers.',
  title: 'AP-1',
  name: 'copyEndy',
  inputs: [
    "([9, 11, 90, 22, 6], 2)",
    "([9, 11, 90, 22, 6], 3)",
    "([12, 1, 1, 13, 0, 20], 2)",
    "([12, 1, 1, 13, 0, 20], 3)",
    "([0], 1)",
    "([10, 11, 90], 2)",
    "([90, 22, 100], 2)",
    "([12, 11, 10, 89, 101, 4], 1)",
    "([13, 2, 2, 0], 2)",
    "([13, 2, 2, 0], 3)",
    "([13, 2, 13, 2, 0, 30], 2)",
    "([13, 2, 13, 2, 0, 30], 3)"
  ]
},
{
  question: 'Given 2 arrays that are the same length containing strings, compare the 1st string in one array to the 1st string in the other array, the 2nd to the 2nd and so on. Count the number of times that the 2 strings are non-empty and start with the same char. The strings may be any length, including 0.',
  title: 'AP-1',
  name: 'matchUp',
  inputs: [
    "(['aa', 'bb', 'cc'], ['aaa', 'xx', 'bb'])",
    "(['aa', 'bb', 'cc'], ['aaa', 'b', 'bb'])",
    "(['aa', 'bb', 'cc'], ['', '', 'ccc'])",
    "(['', '', 'ccc'], ['aa', 'bb', 'cc'])",
    "(['', '', ''], ['', 'bb', 'cc'])",
    "(['aa', 'bb', 'cc'], ['', '', ''])",
    "(['aa', '', 'ccc'], ['', 'bb', 'cc'])",
    "(['x', 'y', 'z'], ['y', 'z', 'x'])",
    "(['', 'y', 'z'], ['', 'y', 'x'])",
    "(['x', 'y', 'z'], ['xx', 'yyy', 'zzz'])",
    "(['x', 'y', 'z'], ['xx', 'yyy', ''])",
    "(['b', 'x', 'y', 'z'], ['a', 'xx', 'yyy', 'zzz'])",
    "(['aaa', 'bb', 'c'], ['aaa', 'xx', 'bb'])"
  ]
},
{
  question: 'The "key" array is an array containing the correct answers to an exam, like {"a", "a", "b", "b"}. the "answers" array contains a student\'s answers, with "?" representing a question left blank. The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer.',
  title: 'AP-1',
  name: 'scoreUp',
  inputs: [
    "(['a', 'a', 'b', 'b'], ['a', 'c', 'b', 'c'])",
    "(['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'b'])",
    "(['a', 'a', 'b', 'b'], ['?', 'c', 'b', '?'])",
    "(['a', 'a', 'b', 'b'], ['?', 'c', '?', '?'])",
    "(['a', 'a', 'b', 'b'], ['c', '?', 'b', 'b'])",
    "(['a', 'a', 'b', 'b'], ['c', '?', 'b', '?'])",
    "(['a', 'b', 'c'], ['a', 'c', 'b'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', 'a', 'c', 'a', 'c'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', '?', '?', 'a', 'c'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', '?', '?', 'c', 'c'])",
    "(['a', 'b', 'c'], ['a', 'b', 'c'])"
  ]
},
{
  question: 'Given an array of strings, return a new array without the strings that are equal to the target string. One approach is to count the occurrences of the target string, make a new array of the correct length, and then copy over the correct strings.',
  title: 'AP-1',
  name: 'wordsWithout',
  inputs: [
    "(['a', 'b', 'c', 'a'], 'a')",
    "(['a', 'b', 'c', 'a'], 'b')",
    "(['a', 'b', 'c', 'a'], 'c')",
    "(['b', 'c', 'a', 'a'], 'b')",
    "(['xx', 'yyy', 'x', 'yy', 'x'], 'x')",
    "(['xx', 'yyy', 'x', 'yy', 'x'], 'yy')",
    "(['aa', 'ab', 'ac', 'aa'], 'aa')"
  ]
},
{
  question: 'Given two arrays, A and B, of non-negative int scores. A "special" score is one which is a multiple of 10, such as 40 or 90. Return the sum of largest special score in A and the largest special score in B. To practice decomposition, write a separate helper method which finds the largest special score in an array. Write your helper method after your scoresSpecial() method in the JavaBat text area.',
  title: 'AP-1',
  name: 'scoresSpecial',
  inputs: [
    "([12, 10, 4], [2, 20, 30])",
    "([20, 10, 4], [2, 20, 10])",
    "([12, 11, 4], [2, 20, 31])",
    "([1, 20, 2, 50], [3, 4, 5])",
    "([3, 4, 5], [1, 50, 2, 20])",
    "([10, 4, 20, 30], [20])",
    "([10, 4, 20, 30], [20])",
    "([10, 4, 20, 30], [3, 20, 99])",
    "([10, 4, 20, 30], [30, 20, 99])",
    "([], [2])",
    "([], [20])",
    "([14, 10, 4], [4, 20, 30])"
  ]
},
{
  question: 'We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1 + 5 = 6. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'sumHeights',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 8, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 2, 2)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 3, 6)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 4)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 5)"
  ]
},
{
  question: '(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index, however increases in height count double. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1*2 + 5 = 7. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'sumHeights2',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 8, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 2, 2)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 3, 6)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 4)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 5)"
  ]
},
{
  question: '(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the number of "big" steps for a walk starting at the start index and ending at the end index. We\'ll say that  step is big if it is 5 or more up or down. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'bigHeights',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 3], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([5, 13, 6, 7, 2], 1, 2)",
    "([5, 13, 6, 7, 2], 0, 2)",
    "([5, 13, 6, 7, 2], 1, 4)",
    "([5, 13, 6, 7, 2], 0, 4)",
    "([5, 13, 6, 7, 2], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 3, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 2, 8)"
  ]
},
{
  question: 'We have data for two users, A and B, each with a String name and an int id. The goal is to order the users such as for sorting. Return -1 if A comes before B, 1 if A comes after B, and 0 if they are the same. Order first by the string names, and then by the id numbers if the names are the same. Note: with Strings str1.compareTo(str2) returns an int value which is negative/0/positive to indicate how str1 is ordered to str2 (the value is not limited to -1/0/1). (On the AP, there would be two User objects, but here the code simply takes the two strings and two ints directly. The code logic is the same.)',
  title: 'AP-1',
  name: 'userCompare',
  inputs: [
    "('bb', 1, 'zz', 2)",
    "('bb', 1, 'aa', 2)",
    "('bb', 1, 'bb', 1)",
    "('bb', 5, 'bb', 1)",
    "('bb', 5, 'bb', 10)",
    "('adam', 1, 'bob', 2)",
    "('bob', 1, 'bob', 2)",
    "('bzb', 1, 'bob', 2)"
  ]
},
{
  question: 'Start with two arrays of strings, A and B, each with its elements in alphabetical order and without duplicates. Return a new array containing the first N elements from the two arrays. The result array should be in alphabetical order and without duplicates. A and B will both have a length which is N or more. The best "linear" solution makes a single pass over A and B, taking advantage of the fact that they are in alphabetical order, copying elements directly to the new array.',
  title: 'AP-1',
  name: 'mergeTwo',
  inputs: [
    "(['a', 'c', 'z'], ['b', 'f', 'z'], 3)",
    "(['a', 'c', 'z'], ['c', 'f', 'z'], 3)",
    "(['f', 'g', 'z'], ['c', 'f', 'g'], 3)",
    "(['a', 'c', 'z'], ['a', 'c', 'z'], 3)",
    "(['a', 'b', 'c', 'z'], ['a', 'c', 'z'], 3)",
    "(['a', 'c', 'z'], ['a', 'b', 'c', 'z'], 3)",
    "(['a', 'c', 'z'], ['a', 'c', 'z'], 2)",
    "(['a', 'c', 'z'], ['a', 'c', 'y', 'z'], 3)",
    "(['x', 'y', 'z'], ['a', 'b', 'z'], 3)"
  ]
},
{
  question: 'Start with two arrays of strings, a and b, each in alphabetical order, possibly with duplicates. Return the count of the number of strings which appear in both arrays. The best "linear" solution makes a single pass over both arrays, taking advantage of the fact that they are in alphabetical order.',
  title: 'AP-1',
  name: 'commonTwo',
  inputs: [
    "(['a', 'c', 'x'], ['b', 'c', 'd', 'x'])",
    "(['a', 'c', 'x'], ['a', 'b', 'c', 'x', 'z'])",
    "(['a', 'b', 'c'], ['a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'b', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'b', 'c', 'c'])",
    "(['b', 'b', 'b', 'b', 'c'], ['a', 'b', 'b', 'b', 'c'])",
    "(['a', 'b', 'c', 'c', 'd'], ['a', 'b', 'b', 'c', 'd', 'd'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b', 'b'])",
    "(['a', 'a', 'b', 'b', 'c'], ['c', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b', 'b', 'x'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b'])",
    "(['a'], ['a', 'b'])",
    "(['a'], ['b'])",
    "(['a', 'a'], ['b', 'b'])",
    "(['a', 'b'], ['a', 'b'])"
  ]
}
];


},{}],216:[function(require,module,exports){
/**--- Solutions --- **/

let solutions = {};

solutions.ScoresIncreasing = `method ScoresIncreasing(SCORES)
  WORKS = "TRUE"
  loop I from 0 to SCORES.length - 1
    if SCORES[I] != SCORES[I-1] AND SCORES[I] < SCORES[I-1] then
      WORKS = "FALSE"
    end if
  end loop
  output WORKS
end method`;

solutions.scores100 = function scores100(scores) {
  let count = 0;

  for (let i = 0; i < scores.length; i++) {
    if (scores[i] == 100 && scores[i + 1] == 100) {
      count += 1;
    }
  }
  return count > 0;
}

solutions.scoresClump = function scoresClump(scores) {

  for (let i = 0; i < scores.length - 1; i++) {
    if (scores[i + 2] - scores[i] <= 2) {
      return true;
    }
  }
  return false;
}

solutions.scoresAverage = function scoresAverage(scores) {

  function average(nums) {
    let sum = 0;
    for (let i = 0; i < nums.length; i++) {
      sum += nums[i]
    }
    return sum / nums.length;
  }

  let half = scores.length / 2
  let first = [];
  let second = [];

  for (let i = 0; i < half; i++) {
    first.push(scores[i])
  };

  for (let i = half; i < scores.length; i++) {
    second.push(scores[i])
  };

  let av1 = average(first);
  let av2 = average(second);

  if (av1 > av2) {
    return av1;
  }
  return av2
}

solutions.wordsCount = function wordsCount(words, len) {

  let count = 0;
  for (let i = 0; i < words.length; i++) {
    if (words[i].length == len) {
      count += 1;
    }
  }
  return count;
}

solutions.wordsFront = function wordsFront(words, n) {

  let arr = [];
  for (let i = 0; i < n; i++) {
    arr.push(words[i]);
  }
  return arr;
}

solutions.wordsWithoutList = function wordsWithoutList(words, len) {
  let arr = [];

  for (let i = 0; i < words.length; i++) {
    if (words[i].length != len) {
      arr.push(words[i]);
    }
  }
  return arr;
}

solutions.hasOne = function hasOne(n) {

  let str = n.toString()

  let j = str.length - 1;
  while (j >= 0) {
    if (parseInt(str[j]) % 10 == 1) {
      return true;
    }
    j--;
  }
  return false;
}

solutions.dividesSelf = function dividesSelf(n) {
  let num = n.toString();

  let j = num.length - 1;

  while (j >= 0) {
    if (n % parseInt(num[j]) != 0) {
      return false;
    }
    j--;
  }
  return true;
}

solutions.copyEvens = function copyEvens(nums, count) {

  let erray = [];
  let j = count;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      erray.push(nums[i]);
      j--;
      if (j < 1) break
    }
  }
  return erray;
}

solutions.copyEndy = function copyEndy(nums, count) {
  let newArray = [];
  for (let i = 0; i < nums.length; i++) {
    let n = nums[i];
    if (n >= 0 && n <= 10 || n >= 90 && n <= 100) {
      newArray.push(n);
    }
    if (newArray.length === count) {
      break;
    }
  }
  return newArray;
}

solutions.matchUp = function matchUp(a, b) {
  let count = 0;

  for (let i = 0; i < a.length; i++) {
    if (a[i].length > 0 && b[i].length > 0 &&
      a[i].charAt(0) == b[i].charAt(0)) {
      count++;
    }
  }

  return count;
}

solutions.scoreUp = function scoreUp(key, answers) {
  let score = 0;

  for (let i = 0; i < key.length; i++) {
    if (answers[i] == "?") {
      score += 0;
    }
    else if (key[i] != answers[i]) {
      score -= 1;
    } else {
      score += 4;
    }
  }
  return score;
}

solutions.wordsWithout = function wordsWithout(words, target) {
  let nuarr = [];

  for (let i = 0; i < words.length; i++) {
    if (words[i] != target) {
      nuarr.push(words[i]);
    }
  }
  return nuarr;
}

solutions.scoresSpecial = function scoresSpecial(a, b) {
  function largest(x) {

    let big = 0;
    for (let i = 0; i < x.length; i++) {
      if (x[i] > big && x[i] % 10 == 0) {
        big = x[i]
      }
    }

    return big;
  }
  let ares = largest(a);
  let bres = largest(b);

  return ares + bres;
}

solutions.sumHeights = function sumHeights(heights, start, end) {
  let res = 0;
  for (let i = start; i < end; i++) {
    res += Math.abs(heights[i] - heights[i + 1])
  }
  return res;
}

solutions.sumHeights2 = function sumHeights2(heights, start, end) {

  let sum = 0;
  for (let i = start; i < end; i++) {
    if (heights[i + 1] > heights[i]) {
      sum += Math.abs(heights[i] - heights[i + 1]) * 2
    } else {
      sum += Math.abs(heights[i] - heights[i + 1]);
    }
  }
  return sum;
}

solutions.bigHeights = function bigHeights(heights, start, end) {
  let count = 0;
  for (let i = start; i < end; i++) {
    if (Math.abs(heights[i] - heights[i + 1]) >= 5) {
      count += 1;
    }
  }
  return count;
}

solutions.userCompare = function userCompare(aName, aId, bName, bId) {

  if (aName < bName) {
    return -1;
  } else if (aName > bName) {
    return 1;
  } else if (aId < bId) {
    return -1;
  } else if (aId > bId) {
    return 1;
  }
  return 0;
}

solutions.mergeTwo = function mergeTwo(a, b, n) {
  let abinit = a.concat(b);
  let ab = abinit.sort();

  let arr = ""

  let count = n;

  for (let i = 0; i < ab.length - 1; i++) {
    if (count <= 0) { break; }

    if (ab[i] == ab[i + 1] && arr.charAt(arr.length - 1) != ab[i]) {
      arr += ab[i];
      count--;
      i++;
    } else {
      arr += ab[i];
      count--;
    }
  }
  return arr.split("");
}

solutions.commonTwo = function commonTwo(a, b) {
  let str = "";
  let count = 0;

  for (let i = 0; i < b.length; i++) {
    for (let j = 0; j < a.length; j++) {
      if (a[j] == b[i] && !str.includes(a[j])) {
        str += a[j];
        count++;
      }
    }
  }
  return count;
}

module.exports = solutions;
},{}],217:[function(require,module,exports){
module.exports = [
  {
    //title is the category it appears in on the homepage
    title: 'Array',
    // Pseudocode problems should start with a capital letter
    name: 'FirstLast6',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      '([1, 2, 6])',
      '([6, 1, 2, 3])',
      '([13, 6, 1, 2, 3])',
      '([13, 6, 1, 2, 6])',
      '([3, 2, 1])',
      '([3, 6, 1])',
      '([3, 6])',
      '([6])',
      '([3])',
      '([5, 6])',
      '([5, 5])',
      '([1, 2, 3, 4, 6])',
      '([1, 2, 3, 4])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given an array of numbers, output TRUE if 6 appears as either the first or last element in the array. The array will be length 1 or more. Use ARR.Length() to access the number of elements in the array.`,
    solution: `method FirstLast6(NUMS)
    END = NUMS.Length() - 1
    if NUMS[0] = 6 OR NUMS[END] = 6 then
      output TRUE
    else
      output FALSE
    end if
  end method`,
  },
  {
    title: 'Array',
    name: 'SameFirstLast',
    inputs: [
      '([1, 2, 3])',
      '([1, 2, 3, 1])',
      '([1, 2, 1])',
      '([7])',
      '([])',
      '([1, 2, 3, 4, 5, 1])',
      '([1, 2, 3, 4, 5, 13])',
      '([13, 2, 3, 4, 5, 13])',
      '([7, 7])',
    ],
    question: `Given an array of numbers, output TRUE if the array is length 1 or more, and the first element and the last element are equal. Otherwise output FALSE`,
    solution: `method SameFirstLast(NUMS)
    END = NUMS.Length() - 1
    if END >= 0 AND NUMS[END] = NUMS[0] then
      output TRUE
    else
      output FALSE
    end if
  end method`,
  },
  {
    title: 'Array',
    name: 'CommonEnd',
    inputs: [
      '([1, 2, 3], [7, 3])',
      '([1, 2, 3], [7, 3, 2])',
      '([1, 2, 3], [1, 3])',
      '([1, 2, 3], [1])',
      '([1, 2, 3], [2])',
    ],
    question: `Given 2 arrays, ARR1 and ARR2, output TRUE if they have the same first element or they have the same last element, and FALSE otherwise.`,
    solution: `method CommonEnd(ARR1, ARR2)
    if ARR1[0] = ARR2[0] OR ARR1[ARR1.Length() - 1] = ARR2[ARR2.Length() - 1] then
      output TRUE
    else
      output FALSE
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MaxEnd',
    inputs: [
      '([1, 2, 3])',
      '([11, 5, 9, 2, 1])',
      '([2, 11, 3, 7, 1])',
      '([11, 3, 3])',
      '([3, 11])',
      '([2, 2, 2, 2])',
      '([2, 11, 2])',
      '([0, 0, 1])',
    ],
    question: `Given an array of numbers, figure out which is larger, the first
    or last element in the array, and set all the other elements to be that value. Then output the new array.
    You can use ARR.Length() to find the length of the array.`,
    solution: `method MaxEnd(NUMS)
    if NUMS[0] > NUMS[NUMS.Length()-1] then
      MAX = NUMS[0]
    else
      MAX = NUMS[NUMS.Length()-1]
    end if
    loop I from 0 to NUMS.Length()-1
      NUMS[I] = MAX
    end loop
    output NUMS
  end method`

  },
  {
    title: 'Array',
    name: 'Sum2',
    inputs: [
      '([1, 2, 3])',
      '([1, 1])',
      '([1, 1, 1, 1])',
      '([1, 2])',
      '([1])',
      '([])',
      '([4, 5, 6])',
      '([4])',
    ],
    question: `Given an array of numbers, output the sum of the first 2 elements in the array.
    If the array length is less than 2, just sum up the elements that exist, returning 0 if
    the array is length 0. You can use ARR.Length() to access the length of the array.`,
    solution: `method Sum2(NUMS)
    if NUMS.Length() = 0 then
      output 0
    else if NUMS.Length() = 1 then
      output NUMS[0]
    else
      output NUMS[0]+NUMS[1]
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MiddleWay',
    inputs: [
      '([1, 2, 3], [4, 5, 6])',
      '([7, 7, 7], [3, 8, 0])',
      '([5, 2, 9], [1, 4, 5])',
      '([1, 9, 7], [4, 8, 8])',
      '([1, 2, 3], [3, 1, 4])',
      '([1, 2, 3], [4, 1, 1])',
    ],
    question: `Given 2 arrays that are both known to have length 3, output a new array of length 2
    containing their middle elements. You can make a new array with the format <code>NEW = [e1, e2, e3]</code>`,
    solution: `method MiddleWay(ARR1, ARR2)
    NEW = [ARR1[1], ARR2[1]];
    output NEW
  end method`
  },
  {
    title: 'Array',
    name: 'MakeEnds',
    inputs: [
      '([1, 2, 3])',
      '(["a", "b", "c", "d"])',
      '([TRUE, FALSE, FALSE, TRUE])',
      '([1.2, 2.0, 2e8, 2.892, 2, 2, 2, 3])',
      '([7, 4])',
      '([7])',
      '([5, 2, 9])',
      '([2, 3, 4, 1])',
    ],
    question: `Given an array, return a new array length 2 containing the
    first and last elements from the original array. The original array will be
    length 1 or more. You can make a new array with the format <code>NEW = [e1, e2, e3]</code>`,
    solution: `method MakeEnds(ARR)
    NEW = [ARR[0], ARR[ARR.Length() - 1]]
    output NEW
  end method`
  },
  {
    title: 'Array',
    name: 'Has23',
    inputs: [
      '([2, 5])',
      '([4, 3])',
      '([4, 5])',
      '([2, 2])',
      '([3, 2])',
      '([3, 3])',
      '([7, 7])',
      '([3, 9])',
      '([9, 5])',
    ],
    question: 'Given an array that contains exactly two numbers, output TRUE if it contains a 2 or a 3,. FALSE otherwise',
    solution: `method Has23(NUMS)
    if NUMS[0] = 2 OR NUMS[0] = 3 OR NUMS[1] = 2 OR NUMS[1] = 3 then
      output TRUE
    else
      output FALSE
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'No23',
    inputs: [
      '([4, 5])',
      '([4, 2])',
      '([3, 5])',
      '([1, 9])',
      '([2, 9])',
      '([1, 3])',
      '([1, 1])',
      '([2, 2])',
      '([3, 3])',
      '([7, 8])',
      '([8, 7])',
    ],
    question: 'Given an array of numbers of length 2, output TRUE if it does not contain a 2 or 3, FALSE otherwise',
    solution: `method No23(NUMS)
  if NUMS[0] = 2 OR NUMS[1] = 2 OR NUMS[0] = 3 OR NUMS[1] = 3 then
    output FALSE
  else
    output TRUE
  end if
end method`
  },
  {
    title: 'Array',
    name: 'Double23',
    inputs: [
      '([2, 2])',
      '([3, 3])',
      '([2, 3])',
      '([3, 2, 3])',
      '([4, 5, 2, 3])',
      '([2])',
      '([3])',
      '([])',
      '([3, 4])',
    ],
    question: `Given an array of numbers, output TRUE if the array contains at least two 2s or at least two 3s. Use ARR.Length() to get its length.`,
    solution: `method Double23(ARR)
  NUM2 = 0
  NUM3 = 0

  loop I from 0 to ARR.Length()-1
    if ARR[I] = 2 then
      NUM2 = NUM2 + 1
    else if ARR[I] = 3 then
      NUM3 = NUM3 + 1
    end if
  end loop

  if NUM3 >= 2 OR NUM2 >= 2 then
    output TRUE
  else
    output FALSE
  end if

end method`,
  },
  {
    title: 'Array',
    name: 'Sum',
    inputs: [
      '([1, 2, 3, 4])',
      '([2, 3, 5, 7, 2, 3])',
      '([1, 2, 1])',
      '([3, 2, 1])',
      '([2, 2, 3])',
      '([2, 3, 3])',
    ],
    question: `Given an array of integers, output the sum of all numbers in the array.`,
    solution: `method Sum(ARR)
    SUM = 0
    loop I from 0 to ARR.Length()-1
      SUM = SUM + ARR[I]
    end loop
    output SUM
end method`
  },
  {
    title: 'Array',
    name: 'Average',
    inputs: [
      '([1, 2, 3, 4])',
      '([2, 3, 5, 7, 2, 3])',
      '([1, 2, 1])',
      '([3, 2, 1])',
      '([2, 2, 3])',
      '([2, 3, 3])',
    ],
    question: `Given an array of integers, output the average (mean) of all numbers in the array.`,
    solution: `method Average(ARR)
    SUM = 0
    loop I from 0 to ARR.Length()-1
      SUM = SUM + ARR[I]
    end loop
    output SUM / ARR.Length()
end method`
  },
  {
    title: 'Array',
    name: 'PositiveAverage',
    inputs: [
      '([1, 2, 3, 4])',
      '([2, 3, 5, 7, 2, 3])',
      '([1, 2, 1])',
      '([3, 2, 1])',
      '([2, 2, 3])',
      '([2, 3, 3])',
    ],
    question: `Given an array of integers, output the average of all postive numbers in the array.`,
    solution: `method PositiveAverage(ARR)
    SUM = 0
    COUNT = 0
    loop I from 0 to ARR.Length()-1
      if ARR[I] > 0
        SUM = SUM + ARR[I]
        COUNT = COUNT + 1
      end if
    end loop
    output SUM / COUNT
end method`
  },
  {
    title: 'Array',
    name: 'Fix23',
    inputs: [
      '([1, 2, 3, 4])',
      '([2, 3, 5, 7, 2, 3])',
      '([1, 2, 1])',
      '([3, 2, 1])',
      '([2, 2, 3])',
      '([2, 3, 3])',
    ],
    question: `Given an array of integers, any time there is a 2 followed by a 3, change the 3 to a 0. 
    Output the changed array.`,
    solution: `method Fix23(ARR) 
    loop I from 0 to ARR.Length()-2
      if ARR[I] = 2 AND ARR[I+1] = 3 then
        ARR[I+1] = 0
      end if
    end loop
    output ARR
end method`
  },
  {
    title: 'Array',
    name: 'Start1',
    inputs: [
      '([1, 2, 3], [1, 3])',
      '([7, 2, 3], [1])',
      '([1, 2], [])',
      '([], [1, 2])',
      '([7], [])',
      '([7], [1])',
      '([1], [1])',
      '([7], [8])',
      '([], [])',
      '([1, 3], [1])',
    ],
    question: `Start with 2 int arrays, A and B, of any length. Output how many of the arrays
    have 1 as their first element.`,
    solution: `method Start1(A,B)
    COUNT = 0
    if A.Length() > 0 AND A[0] = 1 then
      COUNT = COUNT + 1
    end if
    if B.Length() > 0 AND B[0] = 1 then
      COUNT = COUNT + 1
    end if
    output COUNT
  end method`

  },
  {
    title: 'Array',
    name: 'BiggerSum',
    inputs: [
      '([1, 2, 3], [3, 4, 4])',
      '([3, 4, 11], [1, 2, 8])',
      '([1, 1, -1], [1, 0, 0])',
      '([2, 1, 1], [1, 1, 2, 3])',
      '([2, 2, 1, 1], [1, 3, 3, -1])',
      '([1, 3], [2, 2])',
      '([6, 7], [3, 1])',
    ],
    question: `Start with integer arrays, A and B. 
      Find the sum of each array and output the winner 
      in the form "<code>A: 23</code>" (where 23 is the sum). 
      If there is a tie, output in the form "<code>TIE: 23</code>"`,
    solution: `method BiggerSum(A,B)
    SUMA = 0
    SUMB = 0
    loop I from 0 to A.Length()-1
      SUMA = SUMA + A[I]
    end loop
    loop I from 0 to B.Length() - 1
      SUMB = SUMB + B[I]
    end loop
    if SUMA > SUMB then
      output "A: " + SUMA
    else if SUMB > SUMA then
      output "B: " + SUMB
    else
      output "TIE: " + SUMA
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MakeMiddle',
    inputs: [
      '([1, 2, 3, 4, 5])',
      '([7, 1, 2, 3, 4, 9])',
      '([1, 2, 7])',
      '([5, 2, 4, 7])',
      '([9, 0, 4, 3, 9, 1, 2])',
    ],
    question: `Given an array of integers, output a new array of length 2. 
    The new array should contain the two middle elements if the original array had
    an even number of elements, or it should contain the exact middle element twice
    if the original array had an odd number of elements.`,
    solution: `method MakeMiddle(ARR)
    if ARR.Length() mod 2 = 0 then
      MID = ARR.Length() / 2 
      //if length = 4, this will be 2, and we want 1 and 2
      output [ ARR[MID-1], ARR[MID] ]
    else
      MID = ARR.Length() div 2
      // if length = 5, this will be 2, just what we want!
      output [ ARR[MID], ARR[MID] ]
    end if
  end method`,

  },
  {
    title: 'Array',
    name: 'SelectionSort',
    inputs: [
      '([1, 3, 6, 2, 5])',
      '([7, 1, 2, 3, 4, 9])',
      '([1, 3, 2])',
      '([5, 2, 4, 7])',
      '([9, 0, 4, 3, 9, 1, 2])',
    ],
    question: `Sort the given array using selection sort, then output the sorted array.
    (the tool won't know what sort you use, so check the solution to make sure it is right!)`,
    solution: `method SelectionSort(ARR)
    loop FRNT from 0 to ARR.Length() - 2
      min = ARR[FRNT]
      loop CHK from FRNT + 1 to ARR.Length() - 1
        if ARR[CHK] < ARR[FRNT] then
          TEMP = ARR[CHK]
          ARR[CHK] = ARR[FRNT]
          ARR[FRNT] = TEMP
        end if
      end loop
    end loop
    output ARR
  end method`,

  },
  {
    title: 'Array',
    name: 'BubbleSort',
    inputs: [
      '([1, 3, 6, 2, 5])',
      '([7, 1, 2, 3, 4, 9])',
      '([1, 3, 2])',
      '([5, 2, 4, 7])',
      '([9, 0, 4, 3, 9, 1, 2])',
    ],
    question: `Sort the given array using bubble sort, then output the sorted array.
    (the tool won't know what sort you use, so check the solution to make sure it is right!)`,
    solution: `method BubbleSort(ARR)
    loop NUMBUBBLED from 0 to ARR.Length() - 2
      END = ARR.Length() - NUMBUBBLED - 1
      loop BUB from 0 to END
        if ARR[BUB] > ARR[BUB + 1] then
          TEMP = ARR[BUB]
          ARR[BUB] = ARR[BUB + 1]
          ARR[BUB + 1] = TEMP
        end if
      end loop
    end loop
    output ARR
  end method`,

  },
  {
    title: 'Array',
    name: 'BinarySearch',
    inputs: [
      '([1, 2, 3, 5, 7, 11], 7)',
      '([1, 2, 2, 2, 2, 3, 4, 9], 5)',
      '([1, 7, 12, 17, 20, 23, 23], 20)',
      '([2, 4, 5, 7, 7, 11, 11, 17], 17)',
      '([0, 1, 2, 8, 9, 9], 0)',
    ],
    question: `Search the sorted array ARR for the value VAL, outputting the INDEX of its location. If VAL is not in the array, output "NOT FOUND".`,
    solution: `method BinarySearch(ARR, VAL)
    BEGIN = 0
    FOUND = FALSE
    END = ARR.Length() - 1

    loop while BEGIN <= END AND NOT FOUND 
      MID = (BEGIN + END) div 2
      if ARR[MID] = VAL then
        output MID
        FOUND = TRUE
      else if ARR[MID] < VAL then
        BEGIN = MID + 1
      else
        END = MID - 1
      end if
    end loop

    if NOT FOUND then
      output "NOT FOUND"
    end if
    
  end method`,

  },
  {
    title: 'Array',
    name: 'FindTallest',
    inputs: [
      '(["LeBron", "Michael", "Magic", "Shaquille"], [206, 196, 202, 216])',
      '(["Pel", "Maradona", "Messi", "Ronaldo"], [173, 165, 170, 185])',
      '(["Dave","Mary","Bob"], [180, 172, 191])',

    ],
    preamble: `function Compare(str1, str2) { return str1.localeCompare(str2) }`,
    question: `In this problem, you are given two arrays called NAMES and HEIGHTS. NAMES is an array of strings, representing names. HEIGHTS is an array of heights, in cm. The name in a certain position corresponds to the height in the same position. Your method should find, and output, the tallest person in the list.`,
    solution: `method FindTallest(NAMES, HEIGHTS)
    TallestIndex = 0
    
    loop I from 1 to HEIGHTS.Length() - 1 
      if HEIGHTS[I] > HEIGHTS[TallestIndex] then
         TallestIndex = I
      end if
    end loop
    output NAMES[TallestIndex]
    
  end method`,

  },
  {
    title: 'Array',
    name: 'FindBiggestBMI',
    inputs: [
      '(["LeBron", "Michael", "Magic", "Shaquille"], [206, 196, 202, 216], [113, 98, 100, 147])',
      '(["Pel", "Maradona", "Messi", "Ronaldo"], [173, 165, 170, 185], [65, 73, 68, 80])',
      '(["Dave","Mary","Bob"], [180, 172, 191], [81, 74, 83])',

    ],
    preamble: `function CalcBMI(h, w) { return w / ((h/100) * (h/100)) }`,
    question: `In this problem, you are given three arrays called NAMES (strings), HEIGHTS (numbers, cm), and WEIGHTS (numbers, kg). You also have access to a method called CalcBMI(H, W) that accepts the height (cm) and weight (kg) and returns the Body Mass Index of the person. Your job is to identify the person with the highest BMI in each group and output something like "Biggest BMI of ____ from ____"`,
    solution: `method FindBiggestBMI(NAMES, HEIGHTS, WEIGHTS)
    BiggestBMIIndex = 0
    BiggestBMI = CalcBMI(HEIGHTS[0], WEIGHTS[0])
    
    loop I from 1 to HEIGHTS.Length() - 1 
      BMI = CalcBMI(HEIGHTS[I], WEIGHTS[I])
      if BMI > BiggestBMI then
         BiggestBMIIndex = I
      end if
    end loop
    output "Biggest BMI of " + BiggestBMI + " from " + NAMES[BiggestBMIIndex]
    
  end method`,

  },

];

var notUsed = [
  {
    title: 'Array',
    name: 'plusTwo',
    inputs: [
      '([1, 2], [3, 4])',
      '([4, 4], [2, 2])',
      '([9, 2], [3, 4])',
    ],
    question: `Given 2 int arrays, each length 2, return a new array length 4
    containing all their elements.`,
  },
  {
    title: 'Array',
    name: 'swapEnds',
    inputs: [
      '([1, 2, 3, 4])',
      '([1, 2, 3])',
      '([8, 6, 7, 9, 5])',
      '([3, 1, 4, 1, 5, 9])',
      '([1, 2])',
      '([1])',
    ],
    question: `Given an array of ints, swap the first and last elements in the array.
    Return the modified array.The array length will be at least 1.`,
  },
  {
    title: 'Array',
    name: 'midThree',
    inputs: [
      '([1, 2, 3, 4, 5])',
      '([8, 6, 7, 5, 3, 0, 9])',
      '([1, 2, 3])',
    ],
    question: `Given an array of ints of odd length, return a new array length 3
    containing the elements from the middle of the array.The array length will be
    at least 3.`,
  },
  {
    title: 'Array',
    name: 'maxTriple',
    inputs: [
      '([1, 2, 3])',
      '([1, 5, 3])',
      '([5, 2, 3])',
      '([1, 2, 3, 1, 1])',
      '([1, 7, 3, 1, 5])',
      '([5, 1, 3, 7, 1])',
      '([5, 1, 7, 3, 7, 8, 1])',
      '([5, 1, 7, 9, 7, 8, 1])',
      '([5, 1, 7, 3, 7, 8, 9])',
      '([2, 2, 5, 1, 1])',
    ],
    question: `Given an array of ints of odd length, look at the first, last,
    and middle values in the array and return the largest.The array length will
    be a least 1.`,
  },
  {
    title: 'Array',
    name: 'frontPiece',
    inputs: [
      '([1, 2, 3])',
      '([1, 2])',
      '([1])',
      '([])',
      '([6, 5, 0])',
      '([6, 5])',
      '([3, 1, 4, 1, 5])',
      '([6])',
    ],
    question: `Given an int array of any length, return a new array of its first
    2 elements.If the array is smaller than length 2, use whatever
    elements are present.`,
  },
  {
    title: 'Array',
    name: 'unlucky1',
    inputs: [
      '([1, 3, 4, 5])',
      '([2, 1, 3, 4, 5])',
      '([1, 1, 1])',
      '([1, 3, 1])',
      '([1, 1, 3])',
      '([1, 2, 3])',
      '([3, 3, 3])',
      '([1, 3])',
      '([1, 4])',
      '([1])',
      '([])',
      '([1, 1, 1, 3, 1])',
      '([1, 1, 3, 1, 1])',
      '([1, 1, 1, 1, 3])',
      '([1, 4, 1, 5])',
      '([1, 1, 2, 3])',
      '([2, 3, 2, 1])',
      '([2, 3, 1, 3])',
      '([1, 2, 3, 4, 1, 3])',
    ],
    question: `We'll say that a 1 immediately followed by a 3 in an array is
    an "unlucky" 1. Return true if the given array contains an unlucky 1 in the
    first 2 or last 2 positions in the array.`,
  },
  {
    title: 'Array',
    name: 'make2',
    inputs: [
      '([4, 5], [1, 2, 3])',
      '([4], [1, 2, 3])',
      '([], [1, 2])',
      '([1, 2], [])',
      '([3], [1, 2, 3])',
      '([3], [1])',
      '([3, 1, 4], [])',
      '([1], [1])',
      '([1, 2, 3], [7, 8])',
      '([7, 8], [1, 2, 3])',
      '([7], [1, 2, 3])',
      '([5, 4], [2, 3, 7])',
    ],
    question: `Given 2 int arrays, a and b, return a new array length 2 containing,
    as much as will fit, the elements from a followed by the elements from b.The
    arrays may be any length, including 0, but there will be 2 or more elements
    available between the 2 arrays.`,
  },
  {
    title: 'Array',
    name: 'front11',
    inputs: [
      '([1, 2, 3], [7, 9, 8])',
      '([1], [2])',
      '([1, 7], [])',
      '([], [2, 8])',
      '([], [])',
      '([3], [1, 4, 1, 9])',
      '([1, 4, 1, 9], [])',
    ],
    question: `Given 2 int arrays, a and b, of any length, return a new array with the
    first element of each array.If either array is length 0, ignore that array.`,
  },
  {
    title: 'Array',
    name: 'findLowestIndex',
    inputs: [
      "([99, 98, 97, 96, 95])",
      "([2, 2, 0])",
      "([1, 3, 5])",
      "([5])",
      "([11, 9, 0, 1])",
      "([2, 11, 9, 0])",
      "([2])",
      "([2, 5, -12])",
    ],

    question: `Return the index of the minimum value in an array.The input array will have at
     least one element in it.`
  },
  {
    title: 'Array',
    name: 'countEvens',
    inputs: [
      "([2, 1, 2, 3, 4])",
      "([2, 2, 0])",
      "([1, 3, 5])",
      "([])",
      "([11, 9, 0, 1])",
      "([2, 11, 9, 0])",
      "([2])",
      "([2, 5, 12])",
    ],

    question: `Return the number of even ints in the given array.Note: the % "mod"
    operator computes the remainder, e.g. 5 % 2 is 1.`
  },
  {
    title: 'Array',
    name: 'bigDiff',
    inputs: [
      "([10, 3, 5, 6])",
      "([7, 2, 10, 9])",
      "([2, 10, 7, 2])",
      "([2, 10])",
      "([10, 2])",
      "([10, 0])",
      "([2, 3])",
      "([2, 2])",
      "([2])",
      "([5, 1, 6, 1, 9, 9])",
      "([7, 6, 8, 5])",
      "([7, 7, 6, 8, 5, 5, 6])",
    ],
    question: `Given an array length 1 or more of ints, return the difference between
the largest and smallest values in the array.Note: the built -in Math.min(v1, v2)
and Math.max(v1, v2) methods return the smaller or larger of two values.`
  },
  {
    title: 'Array',
    name: 'centeredAverage',
    inputs: [
      "([1, 2, 3, 4, 100])",
      "([1, 1, 5, 5, 10, 8, 7])",
      "([-10, -4, -2, -4, -2, 0])",
      "([5, 3, 4, 6, 2])",
      "([5, 3, 4, 0, 100])",
      "([100, 0, 5, 3, 4])",
      "([4, 0, 100])",
      "([0, 2, 3, 4, 100])",
      "([1, 1, 100])",
      "([7, 7, 7])",
      "([1, 7, 8])",
      "([1, 1, 99, 99])",
      "([1000, 0, 1, 99])",
      "([4, 4, 4, 4, 5])",
      "([4, 4, 4, 1, 5])",
      "([6, 4, 8, 12, 3])",
    ],
    question: `Return the "centered" average of an array of ints, which we'll say
is the mean average of the values, except ignoring the largest and smallest
values in the array.If there are multiple copies of the smallest value, ignore
just one copy, and likewise for the largest value.Use int division to produce
the final average.You may assume that the array is length 3 or more.`
  },
  {
    title: 'Array',
    name: 'sum13',
    inputs: [
      "([1, 2, 2, 1])",
      "([1, 1])",
      "([1, 2, 2, 1, 13])",
      "([1, 2, 13, 2, 1, 13])",
      "([13, 1, 2, 13, 2, 1, 13])",
      "([])",
      "([13])",
      "([13, 13])",
      "([13, 0, 13])",
      "([13, 1, 13])",
      "([5, 7, 2])",
      "([5, 13, 2])",
      "([0])",
      "([13, 0])",
    ],
    question: `Return the sum of the numbers in the array, returning 0 for an empty array.
    Except the number 13 is very unlucky, so it does not count and numbers that come
immediately after a 13 also do not count.`
  },
  {
    title: 'Array',
    name: 'sum67',
    inputs: [
      "([1, 2, 2])",
      "([1, 2, 2, 6, 99, 99, 7])",
      "([1, 1, 6, 7, 2])",
      "([1, 6, 2, 2, 7, 1, 6, 99, 99, 7])",
      "([1, 6, 2, 6, 2, 7, 1, 6, 99, 99, 7])",
      "([2, 7, 6, 2, 6, 7, 2, 7])",
      "([2, 7, 6, 2, 6, 2, 7])",
      "([1, 6, 7, 7])",
      "([6, 7, 1, 6, 7, 7])",
      "([6, 8, 1, 6, 7])",
      "([])",
      "([6, 7, 11])",
      "([11, 6, 7, 11])",
      "([2, 2, 6, 7, 7])",
    ],
    question: `Return the sum of the numbers in the array, except ignore sections of
numbers starting with a 6 and extending to the next 7(every 6 will be followed
       by at least one 7).Return 0 for no numbers.`
  },
  {
    title: 'Array',
    name: 'has22',
    inputs: [
      "([1, 2, 2])",
      "([1, 2, 1, 2])",
      "([2, 1, 2])",
      "([2, 2, 1, 2])",
      "([1, 3, 2])",
      "([1, 3, 2, 2])",
      "([2, 3, 2, 2])",
      "([4, 2, 4, 2, 2, 5])",
      "([1, 2])",
      "([2, 2])",
      "([2])",
      "([])",
      "([3, 3, 2, 2])",
      "([5, 2, 5, 2])",
    ],
    question: `Given an array of ints, return true if the array contains
a 2 next to a 2 somewhere.`
  },
  {
    title: 'Array',
    name: 'lucky13',
    inputs: [
      "([0, 2, 4])",
      "([1, 2, 3])",
      "([1, 2, 4])",
      "([2, 7, 2, 8])",
      "([2, 7, 1, 8])",
      "([3, 7, 2, 8])",
      "([2, 7, 2, 1])",
      "([1, 2])",
      "([2, 2])",
      "([2])",
      "([3])",
      "([])",
    ],
    question: `Given an array of ints, return true if the array contains no 1's and no 3's.`
  },
  {
    title: 'Array',
    name: 'sum28',
    inputs: [
      "([2, 3, 2, 2, 4, 2])",
      "([2, 3, 2, 2, 4, 2, 2])",
      "([1, 2, 3, 4])",
      "([2, 2, 2, 2])",
      "([1, 2, 2, 2, 2, 4])",
      "([])",
      "([2])",
      "([8])",
      "([2, 2, 2])",
      "([2, 2, 2, 2, 2])",
      "([1, 2, 2, 1, 2, 2])",
      "([5, 2, 2, 2, 4, 2])",
    ],
    question: `Given an array of ints, return true if the sum of all the 2's in
the array is exactly 8.`
  },
  {
    title: 'Array',
    name: 'more14',
    inputs: [
      "([1, 4, 1])",
      "([1, 4, 1, 4])",
      "([1, 1])",
      "([1, 6, 6])",
      "([1])",
      "([1, 4])",
      "([6, 1, 1])",
      "([1, 6, 4])",
      "([1, 1, 4, 4, 1])",
      "([1, 1, 6, 4, 4, 1])",
      "([])",
      "([4, 1, 4, 6])",
      "([4, 1, 4, 6, 1])",
      "([1, 4, 1, 4, 1, 6])",
    ],
    question: `Given an array of ints, return true if the number of 1's is greater
than the number of 4's`
  },
  {
    title: 'Array',
    name: 'prependSum',
    inputs: [
      "([1, 2, 4, 4])",
      "([3, 3, 0])",
      "([1, 1, 1, 1, 1])",
      "([5, 7])",
      "([0, 0, 0, 0])",
      "([12, 13, 19, 20])",
      "([-2, 2, -2, 2])",
      "([5, 4, 3, 2, 1, 0])",
    ],

    question: `Return a modified version of the input array (nums), where the first two items have been removed
    and one item  the sum of those two items - is added to the start of the array.`
  },
  {
    title: 'Array',
    name: 'fizzArray',
    inputs: [
      "(4)",
      "(1)",
      "(10)",
      "(0)",
      "(2)",
      "(7)",
    ],
    question: `Given a number n, create and return a new array of length n,
    containing the numbers 0, 1, 2, ... n-1. The given n may be 0, in which case
    just return a length 0 array. You do not need a separate if-statement for the
    length-0 case; the for-loop should naturally execute 0 times in that case,
    so it just works. The syntax to make a new array is let myArray = [];`
  },
  {
    title: 'Array',
    name: 'only14',
    inputs: [
      "([1, 4, 1, 4])",
      "([1, 4, 2, 4])",
      "([1, 1])",
      "([4, 1])",
      "([2])",
      "([])",
      "([1, 4, 1, 3])",
      "([3, 1, 3])",
      "([1])",
      "([4])",
      "([3, 4])",
      "([1, 3, 4])",
      "([1, 1, 1])",
      "([1, 1, 1, 5])",
      "([4, 1, 4, 1])",
    ],
    question: `Given an array of ints, return true if every element is a 1 or a 4.`
  },
  {
    title: 'Array',
    name: 'fizzArray2',
    inputs: [
      "(4)",
      "(10)",
      "(2)",
      "(1)",
      "(0)",
      "(7)",
      "(9)",
      "(11)",
    ],
    question: `Given a number n, create and return a new string array of length n,
    containing the strings "0", "1" "2" .. through n-1. N may be 0, in which case
    just return a length 0 array. Note: String(xxx) will make the String
    form of most types.`
  },
  {
    title: 'Array',
    name: 'no14',
    inputs: [
      "([1, 2, 3])",
      "([1, 2, 3, 4])",
      "([2, 3, 4])",
      "([1, 1, 4, 4])",
      "([2, 2, 4, 4])",
      "([2, 3, 4, 1])",
      "([2, 1, 1])",
      "([1, 4])",
      "([2])",
      "([2, 1])",
      "([1])",
      "([4])",
      "([])",
      "([1, 1, 1, 1])",
      "([9, 4, 4, 1])",
      "([4, 2, 3, 1])",
      "([4, 2, 3, 5])",
      "([4, 4, 2])",
      "([1, 4, 4])",
    ],
    question: `Given an array of ints, return true if it contains no 1's or it contains no 4's.`
  },
  {
    title: 'Array',
    name: 'isEverywhere',
    inputs: [
      "([1, 2, 1, 3], 1)",
      "([1, 2, 1, 3], 2)",
      "([1, 2, 1, 3, 4], 1)",
      "([2, 1, 2, 1], 1)",
      "([2, 1, 2, 1], 2)",
      "([2, 1, 2, 3, 1], 2)",
      "([3, 1], 3)",
      "([3, 1], 2)",
      "([3], 1)",
      "([], 1)",
      "([1, 2, 1, 2, 3, 2, 5], 2)",
      "([1, 2, 1, 1, 1, 2], 2)",
      "([2, 1, 2, 1, 1, 2], 2)",
      "([2, 1, 2, 2, 2, 1, 1, 2], 2)",
      "([2, 1, 2, 2, 2, 1, 2, 1], 2)",
      "([2, 1, 2, 1, 2], 2)",
    ],
    question: `We'll say that a value is "everywhere" in an array if for every
    pair of adjacent elements in the array, at least one of the pair is that value.
    Return true if the given value is everywhere in the array.`
  },
  {
    title: 'Array',
    name: 'either24',
    inputs: [
      "([1, 2, 2])",
      "([4, 4, 1])",
      "([4, 4, 1, 2, 2])",
      "([1, 2, 3, 4])",
      "([3, 5, 9])",
      "([1, 2, 3, 4, 4])",
      "([2, 2, 3, 4])",
      "([1, 2, 3, 2, 2, 4])",
      "([1, 2, 3, 2, 2, 4, 4])",
      "([1, 2])",
      "([2, 2])",
      "([4, 4])",
      "([2])",
      "([])",
    ],
    question: `Given an array of ints, return true if the array contains a 2
    next to a 2 or a 4 next to a 4, but not both.`
  },
  {
    title: 'Array',
    name: 'matchUp',
    inputs: [
      "([1, 2, 3], [2, 3, 10])",
      "([1, 2, 3], [2, 3, 5])",
      "([1, 2, 3], [2, 3, 3])",
      "([5, 3], [5, 5])",
      "([5, 3], [4, 4])",
      "([5, 3], [3, 3])",
      "([5, 3], [2, 2])",
      "([5, 3], [1, 1])",
      "([5, 3], [0, 0])",
      "([4], [4])",
      "([4], [5])",
    ],
    question: `Given arrays nums1 and nums2 of the same length, for every element
    in nums1, consider the corresponding element in nums2 (at the same index).
    Return the count of the number of times that the two elements differ by 2 or
    less, but are not equal.`
  },
  {
    title: 'Array',
    name: 'has77',
    inputs: [
      "([1, 7, 7])",
      "([1, 7, 1, 7])",
      "([1, 7, 1, 1, 7])",
      "([7, 7, 1, 1, 7])",
      "([2, 7, 2, 2, 7, 2])",
      "([2, 7, 2, 2, 7, 7])",
      "([7, 2, 7, 2, 2, 7])",
      "([7, 2, 6, 2, 2, 7])",
      "([7, 7, 7])",
      "([7, 1, 7])",
      "([7, 1, 1])",
      "([1, 2])",
      "([1, 7])",
      "([7])",
    ],
    question: `Given an array of ints, return true if the array contains two 7's
    next to each other, or there are two 7's separated by one element,
    such as with {7, 1, 7}.`
  },
  {
    title: 'Array',
    name: 'has12',
    inputs: [
      "([1, 3, 2])",
      "([3, 1, 2])",
      "([3, 1, 4, 5, 2])",
      "([3, 1, 4, 5, 6])",
      "([3, 1, 4, 1, 6, 2])",
      "([2, 1, 4, 1, 6, 2])",
      "([2, 1, 4, 1, 6])",
      "([1])",
      "([2, 1, 3])",
      "([2, 1, 3, 2])",
      "([2])",
      "([3, 2])",
      "([3, 1, 3, 2])",
      "([3, 5, 9])",
      "([3, 5, 1])",
      "([3, 2, 1])",
      "([1, 2])",
    ],
    question: `Given an array of ints, return true if there is a 1 in the array
    with a 2 somewhere later in the array.`
  },
  {
    title: 'Array',
    name: 'modThree',
    inputs: [
      "([2, 1, 3, 5])",
      "([2, 1, 2, 5])",
      "([2, 4, 2, 5])",
      "([1, 2, 1, 2, 1])",
      "([9, 9, 9])",
      "([1, 2, 1])",
      "([1, 2])",
      "([1])",
      "([])",
      "([9, 7, 2, 9])",
      "([9, 7, 2, 9, 2, 2])",
      "([9, 7, 2, 9, 2, 2, 6])",
    ],
    question: `Given an array of ints, return true if the array contains either
    3 even or 3 odd values all next to each other.`
  },
  {
    title: 'Array',
    name: 'findTheMedian',
    inputs: [
      "([4,9,9,2,1,5])",
      "([1, 5, 3, 1 , 5])",
      "([10, 12, 15])",
      "([5])",
      "([11, 9, 0, 1])",
      "([-1, 11, -2, 10, -3, 15])",
      "([2, 10, 15, 13])",
      "([2, 5, -12])",
    ],

    question: `Write a method that returns the median value of an array. The input array will never be empty.
    \nIf the array is odd in length, the median is the value in the centre of the array.\
    \nIf the array is even, the median should be the average of the two middle values. \n 
    Hint: You will need to ensure the input array is sorted - there is a sort() array method you can use for this step.`
  },
  {
    title: 'Array',
    name: 'haveThree',
    inputs: [
      "([3, 1, 3, 1, 3])",
      "([3, 1, 3, 3])",
      "([3, 4, 3, 3, 4])",
      "([1, 3, 1, 3, 1, 2])",
      "([1, 3, 1, 3, 1, 3])",
      "([1, 3, 3, 1, 3])",
      "([1, 3, 1, 3, 1, 3, 4, 3])",
      "([3, 4, 3, 4, 3, 4, 4])",
      "([3, 3, 3])",
      "([1, 3])",
      "([3])",
      "([1])",
    ],
    question: `Given an array of ints, return true if the value 3 appears in the array exactly
     3 times, and no 3's are next to each other.`
  },
  {
    title: 'Array',
    name: 'twoTwo',
    inputs: [
      "([4, 2, 2, 3])",
      "([2, 2, 4])",
      "([2, 2, 4, 2])",
      "([1, 3, 4])",
      "([1, 2, 2, 3, 4])",
      "([1, 2, 3, 4])",
      "([2, 2])",
      "([2, 2, 7])",
      "([2, 2, 7, 2, 1])",
      "([4, 2, 2, 2])",
      "([2, 2, 2])",
      "([1, 2])",
      "([2])",
      "([1])",
      "([])",
      "([5, 2, 2, 3])",
      "([2, 2, 5, 2])",
    ],
    question: `Given an array of ints, return true if every 2 that appears in
    the array is next to another 2.`
  },
  {
    title: 'Array',
    name: 'sameEnds',
    inputs: [
      "([5, 6, 45, 99, 13, 5, 6], 1)",
      "([5, 6, 45, 99, 13, 5, 6], 2)",
      "([5, 6, 45, 99, 13, 5, 6], 3)",
      "([1, 2, 5, 2, 1], 1)",
      "([1, 2, 5, 2, 1], 2)",
      "([1, 2, 5, 2, 1], 0)",
      "([1, 2, 5, 2, 1], 5)",
      "([1, 1, 1], 0)",
      "([1, 1, 1], 1)",
      "([1, 1, 1], 2)",
      "([1, 1, 1], 3)",
      "([1], 1)",
      "([], 0)",
      "([4, 2, 4, 5], 1)",
    ],
    question: `Return true if the group of N numbers at the start and end of the
    array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are
    the same for n=0 and n=2, and false for n=1 and n=3. You may assume that n
    is in the range 0..nums.Length() inclusive.`
  },
  {
    title: 'Array',
    name: 'tripleUp',
    inputs: [
      "([1, 4, 5, 6, 2])",
      "([1, 2, 3])",
      "([1, 2, 4])",
      "([1, 2, 4, 5, 7, 6, 5, 6, 7, 6])",
      "([1, 2, 4, 5, 7, 6, 5, 7, 7, 6])",
      "([1, 2])",
      "([1])",
      "([])",
      "([10, 9, 8, -100, -99, -98, 100])",
      "([10, 9, 8, -100, -99, 99, 100])",
      "([-100, -99, -99, 100, 101, 102])",
      "([2, 3, 5, 6, 8, 9, 2, 3])",
    ],
    question: `Return true if the array contains, somewhere, three increasing
    adjacent numbers like .... 4, 5, 6, ... or 23, 24, 25.`
  },
  {
    title: 'Array',
    name: 'fizzArray3',
    inputs: [
      "(5, 10)",
      "(11, 18)",
      "(1, 3)",
      "(1, 2)",
      "(1, 1)",
      "(1000, 1005)",
    ],
    question: `Given start and end numbers, return a new array containing the
    sequence of integers from start up to but not including end, so start=5 and
    end=10 yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the
    start number. Note that a length-0 array is valid.`
  },
  {
    title: 'Array',
    name: 'shiftLeft',
    inputs: [
      "([6, 2, 5, 3])",
      "([1, 2])",
      "([1])",
      "([])",
      "([1, 1, 2, 2, 4])",
      "([1, 1, 1])",
      "([1, 2, 3])",
    ],
    question: `Return an array that is "left shifted" by one -- so {6, 2, 5, 3}
    returns {2, 5, 3, 6}. You may modify and return the given array, or return
    a new array.`
  },
  {
    title: 'Array',
    name: 'tenRun',
    inputs: [
      "([2, 10, 3, 4, 20, 5])",
      "([10, 1, 20, 2])",
      "([10, 1, 9, 20])",
      "([1, 2, 50, 1])",
      "([1, 20, 50, 1])",
      "([10, 10])",
      "([10, 2])",
      "([0, 2])",
      "([1, 2])",
      "([1])",
      "([])",
    ],
    question: `For each multiple of 10 in the given array, change all the values
    following it to be that multiple of 10, until encountering another multiple
    of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}.`
  },
  {
    title: 'Array',
    name: 'pre4',
    inputs: [
      "([1, 2, 4, 1])",
      "([3, 1, 4])",
      "([1, 4, 4])",
      "([1, 4, 4, 2])",
      "([1, 3, 4, 2, 4])",
      "([4, 4])",
      "([3, 3, 4])",
      "([1, 2, 1, 4])",
      "([2, 1, 4, 2])",
      "([2, 1, 2, 1, 4, 2])",
    ],
    question: `Given a non-empty array of ints, return a new array containing the
    elements from the original array that come before the first 4 in the original
     array. The original array will contain at least one 4. Note that it is valid
     in java to create an array of length 0.`
  },
  {
    title: 'Array',
    name: 'post4',
    inputs: [
      "([2, 4, 1, 2])",
      "([4, 1, 4, 2])",
      "([4, 4, 1, 2, 3])",
      "([4, 2])",
      "([4, 4, 3])",
      "([4, 4])",
      "([4])",
      "([2, 4, 1, 4, 3, 2])",
      "([4, 1, 4, 2, 2, 2])",
      "([3, 4, 3, 2])",
    ],
    question: `Given a non-empty array of ints, return a new array containing the
    elements from the original array that come after the last 4 in the original
    array. The original array will contain at least one 4. Note that it is valid
    in java to create an array of length 0.`
  },
  {
    title: 'Array',
    name: 'notAlone',
    inputs: [
      "([1, 2, 3], 2)",
      "([1, 2, 3, 2, 5, 2], 2)",
      "([3, 4], 3)",
      "([3, 3], 3)",
      "([1, 3, 1, 2], 1)",
      "([3], 3)",
      "([], 3)",
      "([7, 1, 6], 1)",
      "([1, 1, 1], 1)",
      "([1, 1, 1, 2], 1)",
    ],
    question: `We'll say that an element in an array is "alone" if there are values
    before and after it, and those values are different from it. Return a version
    of the given array where every instance of the given value which is alone is
    replaced by whichever value to its left or right is larger.`
  },
  {
    title: 'Array',
    name: 'zeroFront',
    inputs: [
      "([1, 0, 0, 1])",
      "([0, 1, 1, 0, 1])",
      "([1, 0])",
      "([0, 1])",
      "([1, 1, 1, 0])",
      "([2, 2, 2, 2])",
      "([0, 0, 1, 0])",
      "([-1, 0, 0, -1, 0])",
      "([0, -3, 0, -3])",
      "([])",
      "([9, 9, 0, 9, 0, 9])",
    ],
    question: `Return an array that contains the exact same numbers as the given
    array, but rearranged so that all the zeros are grouped at the start of the
    array. The order of the non-zero numbers does not matter. So {1, 0, 0, 1}
    becomes {0 ,0, 1, 1}. You may modify and return the given array or make a
    new array.`
  },
  {
    title: 'Array',
    name: 'withoutTen',
    inputs: [
      "([1, 10, 10, 2])",
      "([10, 2, 10])",
      "([1, 99, 10])",
      "([10, 13, 10, 14])",
      "([10, 13, 10, 14, 10])",
      "([10, 10, 3])",
      "([1])",
      "([13, 1])",
      "([10])",
      "([])",
    ],
    question: `Return a version of the given array where all the 10's have been
    removed. The remaining elements should shift left towards the start of the
    array as needed, and the empty spaces a the end of the array should be 0.
    So {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given
    array or make a new array.`
  },
  {
    title: 'Array',
    name: 'zeroMax',
    inputs: [
      "([0, 5, 0, 3])",
      "([0, 4, 0, 3])",
      "([0, 1, 0])",
      "([0, 1, 5])",
      "([0, 2, 0])",
      "([1])",
      "([0])",
      "([])",
      "([7, 0, 4, 3, 0, 2])",
      "([7, 0, 4, 3, 0, 1])",
      "([7, 0, 4, 3, 0, 0])",
      "([7, 0, 1, 0, 0, 7])",
    ],
    question: `Return a version of the given array where each zero value in the
    array is replaced by the largest odd value to the right of the zero in the
    array. If there is no odd value to the right of the zero, leave the zero
    as a zero.`
  },
  {
    title: 'Array',
    name: 'evenOdd',
    inputs: [
      "([1, 0, 1, 0, 0, 1, 1])",
      "([3, 3, 2])",
      "([2, 2, 2])",
      "([3, 2, 2])",
      "([1, 1, 0, 1, 0])",
      "([1])",
      "([1, 2])",
      "([2, 1])",
      "([])",
    ],
    question: `Return an array that contains the exact same numbers as the given
    array, but rearranged so that all the even numbers come before all the odd
    numbers. Other than that, the numbers can be in any order. You may modify
    and return the given array, or make a new array.`
  },
  {
    title: 'Array',
    name: 'fizzBuzz',
    inputs: [
      "(1, 6)",
      "(1, 8)",
      "(1, 11)",
      "(1, 16)",
      "(1, 4)",
      "(1, 2)",
      "(50, 56)",
      "(15, 17)",
      "(30, 36)",
      "(1000, 1006)",
      "(99, 102)",
      "(14, 20)",
    ],
    question: `This is slightly more difficult version of the famous FizzBuzz problem
    which is sometimes given as a first problem for job interviews.
     Consider the series of numbers beginning at start and running up to but not
     including end, so for example start=1 and end=5 gives the series 1, 2, 3, 4.
     Return a new String[] array containing the string form of these numbers, except
     for multiples of 3, use "Fizz" instead of the number, for multiples of 5 use "Buzz",
     and for multiples of both 3 and 5 use "FizzBuzz". In Java, String.valueOf(xxx) will
     make the String form of an int or other type. This version is a little more
     complicated than the usual version since you have to allocate and index into an
     array instead of just printing, and we vary the start/end instead of just always
     doing 1..100.`
  },
  {
    question: 'Consider the leftmost and righmost appearances of some value in an array. We\'ll say that the "span" is the number of elements between the two inclusive. A single value has a span of 1. Returns the largest span found in the given array. (Efficiency is not a priority.)',
    title: 'Array',
    name: 'maxSpan',
    inputs: [
      "([1, 2, 1, 1, 3])",
      "([1, 4, 2, 1, 4, 1, 4])",
      "([1, 4, 2, 1, 4, 4, 4])",
      "([3, 3, 3])",
      "([3, 9, 3])",
      "([3, 9, 9])",
      "([3, 9])",
      "([3, 3])",
      "([])",
      "([1])"
    ]
  },
  {
    question: 'Return an array that contains exactly the same numbers as the given array, but rearranged so that every 3 is immediately followed by a 4. Do not move the 3\'s, but every other number may move. The array contains the same number of 3\'s and 4\'s, every 3 has a number after it that is not a 3, and a 3 appears in the array before any 4.',
    title: 'Array',
    name: 'fix34',
    inputs: [
      "([1, 3, 1, 4])",
      "([1, 3, 1, 4, 4, 3, 1])",
      "([3, 2, 2, 4])",
      "([3, 2, 3, 2, 4, 4])",
      "([2, 3, 2, 3, 2, 4, 4])",
      "([5, 3, 5, 4, 5, 4, 5, 4, 3, 5, 3, 5])",
      "([3, 1, 4])",
      "([3, 4, 1])",
      "([1, 1, 1])",
      "([1])",
      "([])",
      "([7, 3, 7, 7, 4])",
      "([3, 1, 4, 3, 1, 4])",
      "([3, 1, 1, 3, 4, 4])"
    ]
  },
  {
    question: '(This is a slightly harder version of the fix34 problem.) Return an array that contains exactly the same numbers as the given array, but rearranged so that every 4 is immediately followed by a 5. Do not move the 4\'s, but every other number may move. The array contains the same number of 4\'s and 5\'s, and every 4 has a number after it that is not a 4. In this version, 5\'s may appear anywhere in the original array.',
    title: 'Array',
    name: 'fix45',
    inputs: [
      "([5, 4, 9, 4, 9, 5])",
      "([1, 4, 1, 5])",
      "([1, 4, 1, 5, 5, 4, 1])",
      "([4, 9, 4, 9, 5, 5, 4, 9, 5])",
      "([5, 5, 4, 1, 4, 1])",
      "([4, 2, 2, 5])",
      "([4, 2, 4, 2, 5, 5])",
      "([4, 2, 4, 5, 5])",
      "([1, 1, 1])",
      "([4, 5])",
      "([5, 4, 1])",
      "([])",
      "([5, 4, 5, 4, 1])",
      "([4, 5, 4, 1, 5])",
      "([3, 4, 5])",
      "([4, 1, 5])",
      "([5, 4, 1])",
      "([2, 4, 2, 5])"
    ]
  },
  {
    question: 'Given a non-empty array, return true if there is a place to split the array so that the sum of the numbers on one side is equal to the sum of the numbers on the other side.',
    title: 'Array',
    name: 'canBalance',
    inputs: [
      "([1, 1, 1, 2, 1])",
      "([2, 1, 1, 2, 1])",
      "([10, 10])",
      "([10, 0, 1, -1, 10])",
      "([1, 1, 1, 1, 4])",
      "([2, 1, 1, 1, 4])",
      "([2, 3, 4, 1, 2])",
      "([1, 2, 3, 1, 0, 2, 3])",
      "([1, 2, 3, 1, 0, 1, 3])",
      "([1])",
      "([1, 1, 1, 2, 1])"
    ]
  },
  {
    question: 'Given two arrays of ints sorted in increasing order, outer and inner, return true if all of the numbers in inner appear in outer. The best solution makes only a single "linear" pass of both arrays, taking advantage of the fact that both arrays are already in sorted order.',
    title: 'Array',
    name: 'linearIn',
    inputs: [
      "([1, 2, 4, 6], [2, 4])",
      "([1, 2, 4, 6], [2, 3, 4])",
      "([1, 2, 4, 4, 6], [2, 4])",
      "([2, 2, 4, 4, 6, 6], [2, 4])",
      "([2, 2, 2, 2, 2], [2, 2])",
      "([2, 2, 2, 2, 2], [2, 4])",
      "([2, 2, 2, 2, 4], [2, 4])",
      "([1, 2, 3], [2])",
      "([1, 2, 3], [-1])",
      "([1, 2, 3], [])",
      "([-1, 0, 3, 3, 3, 10, 12], [-1, 0, 3, 12])",
      "([-1, 0, 3, 3, 3, 10, 12], [0, 3, 12, 14])",
      "([-1, 0, 3, 3, 3, 10, 12], [-1, 10, 11])"
    ]
  },
  {
    question: 'Given n>=0, create an array length n*n with the following pattern, shown here for n=3 : {0, 0, 1,    0, 2, 1,    3, 2, 1} (spaces added to show the 3 groups).',
    title: 'Array',
    name: 'squareUp',
    inputs: [
      "(3)",
      "(2)",
      "(4)",
      "(1)",
      "(0)"
    ]
  },
  {
    question: 'Given n>=0, create an array with the pattern {1,    1, 2,    1, 2, 3,   ... 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length of the array will be 1 + 2 + 3 ... + n, which is known to sum to exactly n*(n + 1)/2.',
    title: 'Array',
    name: 'seriesUp',
    inputs: [
      "(3)",
      "(4)",
      "(2)",
      "(1)",
      "(0)"
    ]
  },
  {
    question: 'We\'ll say that a "mirror" section in an array is a group of contiguous elements such that somewhere in the array, the same group appears in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest mirror section found in the given array.',
    title: 'Array',
    name: 'maxMirror',
    inputs: [
      "([1, 2, 3, 8, 9, 3, 2, 1])",
      "([1, 2, 1, 4])",
      "([7, 1, 2, 9, 7, 2, 1])",
      "([21, 22, 9, 8, 7, 6, 23, 24, 6, 7, 8, 9, 25, 7, 8, 9])",
      "([1, 2, 1, 20, 21, 1, 2, 1, 2, 23, 24, 2, 1, 2, 1, 25])",
      "([1, 2, 3, 2, 1])",
      "([1, 2, 3, 3, 8])",
      "([1, 2, 7, 8, 1, 7, 2])",
      "([1, 1, 1])",
      "([1])",
      "([])",
      "([9, 1, 1, 4, 2, 1, 1, 1])",
      "([5, 9, 9, 4, 5, 4, 9, 9, 2])",
      "([5, 9, 9, 6, 5, 4, 9, 9, 2])",
      "([5, 9, 1, 6, 5, 4, 1, 9, 5])"
    ]
  },
  {
    question: 'Say that a "clump" in an array is a series of 2 or more adjacent elements of the same value. Return the number of clumps in the given array.',
    title: 'Array',
    name: 'countClumps',
    inputs: [
      "([1, 2, 2, 3, 4, 4])",
      "([1, 1, 2, 1, 1])",
      "([1, 1, 1, 1, 1])",
      "([1, 2, 3])",
      "([2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([])"
    ]
  },
]
},{}],218:[function(require,module,exports){
let solutions = {};

solutions.makeLast = function makeLast(nums) {
  let newLength = nums.length * 2;
  let newArray = [];
  for (let i = 0; i < newLength; i++) {
    newArray[i] = 0;
  }
  newArray[newLength - 1] = nums[nums.length - 1];
  return newArray;
}

solutions.double23 = function double23(nums) {
  if (nums.length < 2) {
    return false;
  }
  else if ((nums[0] == 2 && nums[1] == 2) || (nums[0] == 3 && nums[1] == 3)) {
    return true
  } else {
    return false;
  }
}

solutions.fix23 = function fix23(nums) {
  //since the length is three, the only options are the first two or last two elements
  if (nums[0] == 2 && nums[1] == 3) {
    nums[1] = 0;
  } else if (nums[1] == 2 && nums[2] == 3) {
    nums[2] = 0;
  }
  return nums;
}

solutions.findTheMedian = function findTheMedian(nums) {
  //where is the sort method? 
  let end = nums.length - 1;
  let mid = nums.length / 2
  if (nums.length % 2 === 1) {
    return nums[end / 2];
  }
  else {
    return (nums[mid - 1] + nums[mid]) / 2;
  }
}

solutions.start1 = function start1(a, b) {
  let count = 0;
  if (a[0] == 1) {
    count += 1;
  }

  if (b[0] == 1) {
    count += 1;
  }

  return count;
}

solutions.biggerTwo = function biggerTwo(a, b) {
  if (b[0] + b[1] > a[0] + a[1]) {
    return b;
  }
  else if (a[0] + a[1] > b[0] + b[1]) {
    return a;
  }
  else return a;
}

solutions.makeMiddle = function makeMiddle(nums) {
  // consider an example. If the array has length 4
  // then half will be 2, and we want the 2nd and third elements
  // which will have index 1 (half - 1) and 2 (half)
  let half = nums.length / 2;
  return [nums[half - 1], nums[half]];
}

solutions.plusTwo = function plusTwo(a, b) {
  let duoArr = [];
  duoArr[0] = a[0];
  duoArr[1] = a[1];
  duoArr[2] = b[0];
  duoArr[3] = b[1];

  return duoArr;
}

solutions.swapEnds = function swapEnds(nums) {
  // save the first value temporarily
  let first = nums[0]
  // move the last value into the first value
  nums[0] = nums[nums.length - 1];
  // move the first value into the last place
  nums[nums.length - 1] = first;
  return nums;
}

solutions.findLowestIndex = function findLowestIndex(nums) {
  let minVal = nums[0];
  let minValIndex = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < minVal) {
      minVal = nums[i]
      minValIndex = i;
    }
  }
  return minValIndex;
}




solutions.midThree = function midThree(nums) {
  //if our array is of size 3, we want our "pivot" (middle) index to be 1
  // we can do this with (size - 1)/2
  let half = (nums.length - 1) / 2;
  return [nums[half - 1], nums[half], nums[half + 1]];
}

solutions.maxTriple = function maxTriple(nums) {
  let mid = nums[(nums.length - 1) / 2];
  let start = nums[0]
  let end = nums[nums.length - 1];

  if (mid > start && mid > end) {
    return mid;
  }
  else if (start > mid && start > end) {
    return start;
  } else {
    return end;
  }
}

solutions.frontPiece = function frontPiece(nums) {
  if (nums.length < 2) {
    return nums;
  }
  return [nums[0], nums[1]];
}

solutions.unlucky1 = function unlucky1(nums) {
  if ((nums[0] == 1 && nums[1] == 3) || (nums[nums.length - 2] == 1 && nums[nums.length - 1] == 3)) {
    return true;
  }
  else return false;
}

solutions.make2 = function make2(a, b) {
  if (a.length >= 2) {
    return [a[0], a[1]]
  }
  else if (a.length == 1) {
    return [a[0], b[0]]
  }
  else return [b[0], b[1]]
}

solutions.front11 = function front11(a, b) {
  if (a.length == 0) {
    return [b[0]]
  }
  else if (b.length == 0) {
    return [a[0]]
  }
  else if (a.length == 0 && b.length == 0) {
    return []
  }
  else return [a[0], b[0]]
}



// Array-2

solutions.countEvens = function countEvens(nums) {
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      count += 1;
    }
  }
  return count;
}

solutions.bigDiff = function bigDiff(nums) {
  //changed it to a loop problem 
  //Math.abs returns the absolute value of a number 
  let max = nums[0]
  let min = nums[0]
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i]
    }
    else if (nums[i] < min) {
      min = nums[i]
    }
  }
  return Math.abs(max - min);
}

solutions.centeredAverage = function centeredAverage(nums) {
  let max = nums[0]
  let min = nums[0]
  let maxIndex = 0;
  let minIndex = 0;
  for (let i = 0; i < nums.length; i++) {//find max and min 
    if (nums[i] >= max) {
      max = nums[i]
      maxIndex = i;
    }
    else if (nums[i] < min) {
      min = nums[i]
      minIndex = i;
    }
  }
  let total = 0;
  for (let i = 0; i < nums.length; i++) {//if the index of element is neither a maxIndex or minIndex, add to total
    if (!(i == maxIndex || i == minIndex)) {
      total = total + nums[i]
    }
  }
  return total / (nums.length - 2)

}

solutions.sum13 = function sum13(nums) {
  let pre13 = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 13 || nums[i - 1] == 13) {

    } else {
      pre13.push(nums[i]);
    }
  }
  let sum = pre13.reduce((a, b) => a + b, 0)
  return sum;
}

solutions.sum67 = function sum67(nums) {
  let summ = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != 6) {
      summ += nums[i];
    } else {
      while (nums[i] != 7) {
        i++;
      }
    }
  }
  return summ;
}

solutions.has22 = function has22(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 2 && nums[i + 1] == 2) {
      return true;
    }
  }
  return false;
}

solutions.lucky13 = function lucky13(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1 || nums[i] == 3) {
      return false;
    }
  }
  return true;

}

solutions.sum28 = function sum28(nums) {
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 2) {
      count += nums[i];
    }
  }
  return count == 8;
}

solutions.more14 = function more14(nums) {

  let one = 0;
  let four = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      one += 1;
    }

    if (nums[i] == 4) {
      four += 1;
    }
  }
  if (one > four) {
    return true;
  } else {
    return false;
  }
}

solutions.Array = function fizzArray(n) {
  let newA = [];
  for (let i = 0; i < n; i++) {
    newA[i] = i;
  }
  return newA;
}

solutions.prependSum = function prependSum(nums) {
  let arr = [];
  arr[0] = nums[0] + nums[1]
  for (let i = 2; i < nums.length; i++) {
    arr[i - 1] = nums[i]; //nums start at i=2 because the first two elements were removed
  }
  return arr;
}



solutions.only14 = function only14(nums) {

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != 4 && nums[i] != 1) {
      return false;
    }
  }
  return true;
}

solutions.fizzArray2 = function fizzArray2(n) {
  let nu = [];
  for (let i = 0; i < n; i++) {
    nu[i] = i.toString();
  }
  return nu;
}

solutions.no14 = function no14(nums) {
  let has1 = false;
  let has4 = false;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      has1 = true;
    }

    if (nums[i] == 4) {
      has4 = true;
    }

  }
  if (has1 == true && has4 == true) {
    return false;
  }
  else return true;
}

solutions.isEverywhere = function isEverywhere(nums, val) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] != val && nums[i + 1] != val) {
      return false;
    }
  }
  return true;
}

solutions.either24 = function either24(nums) {
  let has22 = false;
  let has44 = false;

  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == 2 && nums[i + 1] == 2)
      has22 = true;

    if (nums[i] == 4 && nums[i + 1] == 4)
      has44 = true;
  }

  if (has22 != has44) {//both boolean values must be different (both true -> false, both false-> false)
    return true;
  }
  else return false;
}

solutions.matchUp = function matchUp(nums1, nums2) {
  //Math.abs(a-b) calculates the absolute value of the difference between a and b
  let count = 0;
  for (let i = 0; i < nums1.length; i++) {
    let diff = Math.abs(nums1[i] - nums2[i]);
    if (diff > 0 && diff < 3) {
      count += 1;
    }
  }
  return count;
}

solutions.has77 = function has77(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if ((nums[i] == 7 && nums[i + 1] == 7) || (nums[i] == 7 && nums[i + 2] == 7)) {
      return true;
    }
  }
  return false;
}

solutions.has12 = function has12(nums) {
  let has1 = false;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      has1 = true;
    }

    if (has1 == true && nums[i] == 2) {
      return true;
    }
  }
  return false;
}

solutions.modThree = function modThree(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] % 2 == nums[i + 1] % 2 && nums[i + 1] % 2 == nums[i + 2] % 2) {
      return true;
    }
  }
  return false;
}

solutions.haveThree = function haveThree(nums) {
  let three = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 3) {
      three++;
    }
    if (nums[i + 1] == 3 && nums[i] == 3) {
      return false;
    }

  }
  if (three == 3) {
    return true;
  }
  else return false;
}

solutions.twoTwo = function twoTwo(nums) {
  for (let i = 0; i < nums.length; i++) {
    if ((nums[i] == 2) && (nums[i + 1] == 2)) {
      i = i + 2//if 2 is already found, skip two indexes because the last 2 is already accounted for 
    }
    else if ((nums[i] == 2) && (nums[i + 1] != 2))
      return false;
  }
  return true;
}

solutions.sameEnds = function sameEnds(nums, len) {
  let front = nums.slice(0, len);
  let end = nums.slice(nums.length - len);

  return front.toString() == end.toString();
}

solutions.tripleUp = function tripleUp(nums) {
  for (let i = 0; i < nums.length - 2; i++) {
    if (nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2]) {
      return true;
    }
  }
  return false;
}

solutions.fizzArray3 = function fizzArray3(start, end) {
  let count = 0;
  for (let i = start; i < end; i++) {
    arr[count] = i;
    count++;
  }
  return arr
}

solutions.shiftLeft = function shiftLeft(nums) {
  let firstVal = nums[0]
  for (let i = 0; i < nums.length - 1; i++) {
    let temp = nums[i];
    nums[i] = nums[i + 1]
    nums[i + 1] = nums[i]
  }
  nums[nums.length - 1] = firstVal
  return nums
}

solutions.tenRun = function tenRun(nums) {
  let i = 0;
  while (i < nums.length - 1) {
    if (nums[i] % 10 == 0 && !(nums[i + 1] % 10 == 0)) {//if the current number is a multiple of 10 AND the next number is NOT a multiple of 10 
      nums[i + 1] = nums[i];
      i++;
    }
    else i++;
  }
  return nums;
}

solutions.pre4 = function pre4(nums) {
  //array.push(num) adds num to array 

  let b44 = [];

  let i = 0;

  while (i < nums.length && nums[i] != 4) {
    b44.push(nums[i]);
    i++;
  }
  return b44;
}

solutions.post4 = function post4(nums) {
  let arr = [];
  let index4;
  for (let i = 0; i < nums.length; i++) {//get the largest index of 4
    if (nums[i] == 4) {
      index4 = i;
    }
  }
  for (let c = 0; c < nums.length - 1 - index4; c++) {
    arr[c] = nums[c + 1 + index4]//put the values after 4 into an array
  }
  return arr;
}

solutions.notAlone = function notAlone(nums, val) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == val) {
      if (nums[i + 1] == undefined) {
        return nums;
      }

      if (nums[i - 1] == val || nums[i + 1] == val) {

      }
      else if (nums[i - 1] == undefined) {

      }
      else if (nums[i - 1] > nums[i + 1]) {
        nums[i] = nums[i - 1];
      } else {
        nums[i] = nums[i + 1];
      }
    }
  }
  return nums;
}

solutions.zeroFront = function zeroFront(nums) {
  if (nums.length == 0)
    return nums;

  let i = 0;

  while (nums[i] == 0)
    i++;

  for (let j = i + 1; j < nums.length; j++) {
    if (nums[j] == 0) {
      let temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
      i++;
    }
  }

  return nums;
}

solutions.withoutTen = function withoutTen(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 10) {
      nums[i] = 0;
      for (let c = i; c < nums.length - 1; c++) {
        let temp = nums[c]//basic swap between left and right 
        nums[c] = nums[c + 1];
        nums[c + 1] = temp;
        if (nums[c] == 10) {//if ten replaces another ten, do the step one more time 
          i = i - 1;
        }
      }
    }
  }
  return nums;
}

solutions.zeroMax = function zeroMax(nums) {
  let odd = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 0) {
      for (let c = i + 1; c < nums.length; c++) {//find largest odd value RIGHT of the 0 
        if (nums[c] > odd && nums[c] % 2 == 1) {
          odd = nums[c];
        }
      }
      nums[i] = odd;
      odd = 0;//reset odd just in case there is a larger number before the current 0. 
    }
  }
  return nums;
}

solutions.evenOdd = function evenOdd(nums) {
  //array.concat(array1) combines the two arrays. Use it wisely 
  //array.push(num) adds a variable num to the array 
  let even = [];
  let odd = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      even.push(nums[i])
    }
    else {
      odd.push(nums[i])
    }
  }
  return even.concat(odd)
}

function isEven(num) {
  return num % 2 == 0;
}

function isOdd(num) {
  return num % 2 != 0;
}

solutions.fizzBuzz = function fizzBuzz(start, end) {
  let strArray = [];
  let count = 0;
  for (let i = start; i < end; i++) {
    if (i % 3 == 0 && !(i % 5 == 0)) {
      strArray[count] = "Fizz"
      count++;
    }
    else if (i % 5 == 0 && !(i % 3 == 0)) {
      strArray[count] = "Buzz"
      count++;
    }
    else if (i % 3 == 0 && i % 5 == 0) {
      strArray[count] = "FizzBuzz"
      count++;
    }
    else {
      strArray[count] = i.toString();
      count++;
    }
  }
  return strArray;
}

// Array-3

solutions.maxSpan = function maxSpan(nums) {
  let max = 0;

  for (let i = 0; i < nums.length; i++) {
    let j = nums.length - 1;

    while (nums[i] != nums[j]) {
      j--;
    }

    let span = j - i + 1;

    if (span > max)
      max = span;
  }

  return max;
}

solutions.fix34 = function fix34(nums) {
  let i = 0;

  while (i < nums.length && nums[i] != 3)
    i++;

  let j = i + 1;

  while (j < nums.length && nums[j] != 4)
    j++;

  while (i < nums.length) {
    if (nums[i] == 3) {
      let temp = nums[i + 1];
      nums[i + 1] = nums[j];
      nums[j] = temp;

      while (j < nums.length && nums[j] != 4)
        j++;
    }
    i++;
  }

  return nums;
}

solutions.fix45 = function fix45(nums) {

  let i = 0;
  let j = 0;

  while (j < nums.length && nums[j] != 5) {
    j++;
  }

  while (i < nums.length) {
    if (nums[i] == 4) {
      let temp = nums[i + 1];
      nums[i + 1] = nums[j];
      nums[j] = temp;

      while ((j < nums.length && nums[j] != 5) || j == i + 1)
        j++;
    }
    i++;
  }
  return nums;
}

solutions.canBalance = function canBalance(nums) {
  let first = 0;
  let second = 0;

  for (let i = 0; i < nums.length; i++) {
    second += nums[i]; //adding all nums together
  }

  for (let i = 0; i <= nums.length - 2; i++) {
    first += nums[i];
    second -= nums[i];

    if (first == second) {
      return true;
    }
  }

  return false;
}

solutions.linearIn = function linearIn(outer, inner) {
  //index for inner array, also acts as a 'count' variable
  let j = 0;

  //looping through the outer array once. looking for matches.
  for (let i = 0; i < outer.length; i++) {
    if (inner[j] == outer[i]) {
      j++;
    }
  }

  return j == inner.length;

}

solutions.squareUp = function squareUp(n) {

  let subArray = [];
  let j = n;
  while (j > 0) {
    subArray.push(0);
    j--;
  }

  let output = [];

  for (let i = n - 1; i >= 0; i--) {
    subArray.splice(i, 1, n - i);
    output = output.concat(subArray);
  }
  return output;
}

solutions.seriesUp = function seriesUp(n) {
  let modArr = [];

  for (let i = 0; i < n; i++) {
    let j = i;
    let x = 1;
    while (j >= 0) {
      modArr.push(x);
      x += 1;
      j--;
    }
    x = 1;
  }
  return modArr;
}

solutions.maxMirror = function maxMirror(nums) {
  //This solution was made by Sung Ho Park. He took 5 hours to simplify the solution. You're welcome. 
  //.includes() method checks whether a specific string exists within an string or not.toString() converts a number to a string 
  if (nums.length == 0) {
    return 0;
  }
  //reverses nums and makes it into a string 
  let reverse = "";
  reverse = reverse + nums[nums.length - 1];
  for (let i = nums.length - 2; i >= 0; i--) {
    reverse = reverse + "," + nums[i].toString();
  }
  let maxNum = nums.length - 1;
  while (maxNum >= 0) {
    for (let i = 0; i < nums.length - maxNum; i++) {
      if (reverse.includes(createCandidate(nums, i, maxNum + i))) {
        return maxNum + i + 1 - i;
      }
    }
    maxNum = maxNum - 1;
  }
  function createCandidate(num, min, max) {//creates candidates between ranges of min and max
    let answer = "";
    answer = answer + num[min].toString();
    for (let c = min + 1; c < max + 1; c++) {
      answer = answer + "," + num[c].toString();
    }
    return answer;
  }
}

solutions.countClumps = function countClumps(nums) {
  let yardStick = -1;
  let clumps = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == nums[i + 1] && nums[i] != yardStick) {
      clumps += 1;
      yardStick = nums[i];
    } else {
      if (nums[i] != yardStick) {
        yardStick = -1
      }
    };
  }
  return clumps;
}
module.exports = solutions;

},{}],219:[function(require,module,exports){
module.exports = [
  {
    title: 'Collections',
    name: 'Count7s',
    inputType: "collection",
    inputs: [
      '({1, 2, 6})',
      '({3, 7, 7})',
      `({8, 11, 7, 3, 7})`,
      `({7, 7, 7, 7})`,
      `({7.2, 11, 3})`,
      '({2, 7, 2, 11, 7, 24, 7})'
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of numbers, count and then output how many 7s appear in the collection.`,
    solution: `method Count7s(NUMS)
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      if N = 7 then
        COUNT = COUNT + 1
      end if
    end loop
    
    output COUNT
  end method`,
  }, {
    title: 'Collections',
    name: 'NegativeOnetoOne',
    inputType: "collection",
    inputs: [
      '({0.3, 1, -0.7, 2.3, 0.2, 5.3})',
      '({1.1, 0.99, 1.0})',
      `({0.2, 0.3, 0.4, -0.2, -0.3, -0.4})`,
      `({2, -2, 3, -3, 4, -4})`,
      `({.2, -0.2, 0.3, -0.3, 0.4, -0.4})`,
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of real numbers, count how many elements are in the interval [-1, 1] inclusive. Output the count. (IB November 2018, question 8d)`,
    solution: `method NegativeOnetoOne(NUMS)
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      if N >= -1 AND N <= 1 then
        COUNT = COUNT + 1
      end if
    end loop
    output COUNT
  end method`,
  },
  {
    title: 'Collections',
    name: 'CountAs',
    inputType: "collection",
    inputs: [
      '({"abc", "ABC", "CBA", "cba", "bcbcbc"})',
      '({"bb","aa","AB","BA"})',
      '({"bat", "abacus"})'
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of strings, count all the strings whose first letter is "a" of "A" and output the count. You can use the STR.SubStr(i, c) method (look at the reference linked above).`,
    solution: `method CountAs(WORDS)
  COUNT = 0
  WORDS.resetNext()
  loop while WORDS.hasNext()
    W = WORDS.getNext()
    if W.SubStr(0,1) = "a" OR W.SubStr(0,1) = "A" then
      COUNT = COUNT + 1
    end if
  end loop
  
  output COUNT
end method`,
  },
  {
    title: 'Collections',
    name: 'SumCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3})',
      '({5, 11, 2, -3})',
      '({7, 0, 0, -7})',
      '({1, 2, 1, 1, 2})',
      '({1, 1, 1, 1})',
      '({2, 7, 2, 103})',
    ],
    question: 'Given a Collection of numbers, return the sum of all the elements.',
    solution: `method SumCollection(NUMS)
    SUM = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      SUM = SUM + N
    end loop
    output SUM
  end method`
  },
  {
    title: 'Collections',
    name: 'AverageCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3, 4, 5})',
      '({5, 11, 2, -8, 0})',
      '({7, 0, 0, -1, -1})',
      '({1, 2, 1, 2, 1})',
      '({1, 1, 1, 1, 1})',
      '({2, 7, 2})',
    ],
    question: 'Given a Collection of numbers, return the mean (average) of all the elements.',
    solution: `method AverageCollection(NUMS)
    SUM = 0
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      COUNT = COUNT + 1
      SUM = SUM + N
    end loop
    output (SUM / COUNT)
  end method`
  },
  {
    title: 'Collections',
    name: 'CountAM',
    inputType: "collection",
    inputs: [
      '({"Smith, Jane","Brown, James"})',
      '({"Duckworth, Eliza", "Altman, Phil"})',
      '({"Mizrahi, Marina", "Nelson, Judd"})',
      '({"A, B", "C, D", "M, N", "P, J", "Q, Z"})'
    ],
    question: `<p>Given a collection of names in the form "Last, First", output the number of names whose last name starts with a letter between A and M in the English alphabet.</p>

    <p>You can assume you have access to a method called <code>Compare(STR1, STR2)</code> that returns <code>0</code> if the two strings are identical, <code>-1</code> if <code>STR1</code> is earlier than <code>STR2</code> in the alphabet, and <code>1</code> if <code>STR1</code> is later than <code>STR2</code> in the alphabet.</p>`,
    solution: `method CountAM(NAMES)
  AM = 0
  NAMES.resetNext()
  loop while NAMES.hasNext()
    N = NAMES.getNext()
    if Compare(N, "N") = -1 then
      AM = AM + 1
    end if
  end loop
  output AM
end method`,
    preamble: `function Compare(str1, str2) { return str1.localeCompare(str2) }`,
  },
  {
    title: 'Collections',
    name: 'RotateLeftCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3, 4, 5})',
      '({5, 11, 2, -8, 0})',
      '({7, 0, 0, -1, -1})',
      '({1, 2, 1, 2, 1})',
      '({1, 1, 1, 1, 1})',
      '({2, 7, 2})',
    ],
    question: `Given an collection of numbers, create a new collection that is the same thing, but with the first element moved to the back. If the original collection is empty, return an empty collection. You can make an empty collection using the command "C = new Collection()"`,
    solution: `method RotateLeftCollection(NUMS)
    C = new Collection()
    if NOT NUMS.isEmpty() then
      FIRST = NUMS.getNext()
      loop while NUMS.hasNext()
        C.addItem(NUMS.getNext())
      end loop
      C.addItem(FIRST)
    end if
    output C  
  end method`
  }
]


},{}],220:[function(require,module,exports){
module.exports = [
  {
    title: 'Logic-1',
    name: 'cigarParty',
    inputs: [
      '(30, false)',
      '(50, false)',
      '(70, true)',
      '(30, true)',
      '(50, true)',
      '(60, false)',
      '(61, false)',
      '(40, false)',
      '(39, false)',
      '(40, true)',
      '(39, true)',
    ],
    question: `When squirrels get together for a party, they like to have cigars. A squirrel
    party is successful when the number of cigars is between 40 and 60, inclusive. Unless it
    is the weekend, in which case there is no upper bound on the number of cigars. Return
    true if the party with the given values is successful, or false otherwise.`,
  },
  {
    title: 'Logic-1',
    name: 'dateFashion',
    inputs: [
      '(5, 10)',
      '(5, 2)',
      '(5, 5)',
      '(3, 3)',
      '(10, 2)',
      '(2, 9)',
      '(9, 9)',
      '(10, 5)',
      '(2, 2)',
      '(3, 7)',
      '(2, 7)',
      '(6, 2)',
    ],
    question: `You and your date are trying to get a table at a restaurant. The parameter
    "you" is the stylishness of your clothes, in the range 0..10, and "date" is the stylishness
    of your date's clothes. The result getting the table is encoded as an int value with 0=no,
    1=maybe, 2=yes. If either of you is very stylish, 8 or more, then the result is 2 (yes).
    With the exception that if either of you has style of 2 or less, then the result is 0 (no).
    Otherwise the result is 1 (maybe).`,
  },
  {
    title: 'Logic-1',
    name: 'squirrelPlay',
    inputs: [
      '(70, false)',
      '(95, false)',
      '(95, true)',
      '(90, false)',
      '(90, true)',
      '(50, false)',
      '(50, true)',
      '(100, false)',
      '(100, true)',
      '(105, true)',
      '(59, false)',
      '(59, true)',
      '(60, false)',
    ],
    question: `The squirrels in Palo Alto spend most of the day playing. In particular,
    they play if the temperature is between 60 and 90 (inclusive). Unless it is summer,
    then the upper limit is 100 instead of 90. Given an int temperature and a boolean isSummer,
    return true if the squirrels play and false otherwise.`,
  },
  {
    title: 'Logic-1',
    name: 'caughtSpeeding',
    inputs: [
      '(60, false)',
      '(65, false)',
      '(65, true)',
      '(80, false)',
      '(85, false)',
      '(85, true)',
      '(70, false)',
      '(75, false)',
      '(75, true)',
      '(40, false)',
      '(40, true)',
      '(90, false)',
    ],
    question: `You are driving a little too fast, and a police officer stops you. Write code
    to compute the result, encoded as an int value: 0=no ticket, 1=small ticket, 2=big ticket.
    If speed is 60 or less, the result is 0. If speed is between 61 and 80 inclusive, the result
    is 1. If speed is 81 or more, the result is 2. Unless it is your birthday -- on that day,
    your speed can be 5 higher in all cases.`,
  },
  {
    title: 'Logic-1',
    name: 'sortaSum',
    inputs: [
      '(3, 4)',
      '(9, 4)',
      '(10, 11)',
      '(12, -3)',
      '(-3, 12)',
      '(4, 5)',
      '(4, 6)',
      '(14, 7)',
      '(14, 6)',
    ],
    question: `Given 2 ints, a and b, return their sum. However, sums in the range 10..19
    inclusive, are forbidden, so in that case just return 20.`,
  },
  {
    title: 'Logic-1',
    name: 'alarmClock',
    inputs: [
      '(1, false)',
      '(5, false)',
      '(0, false)',
      '(6, false)',
      '(0, true)',
      '(6, true)',
      '(1, true)',
      '(3, true)',
      '(5, true)',
    ],
    question: `Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, ...6=Sat, and a
    boolean indicating if we are on vacation, return a string of the form "7:00" indicating
    when the alarm clock should ring. Weekdays, the alarm should be "7:00" and on the weekend
    it should be "10:00". Unless we are on vacation -- then on weekdays it should be "10:00"
    and weekends it should be "off".`,
  },
  {
    title: 'Logic-1',
    name: 'love6',
    inputs: [
      '(6, 4)',
      '(4, 5)',
      '(1, 5)',
      '(1, 6)',
      '(1, 8)',
      '(1, 7)',
      '(7, 5)',
      '(8, 2)',
      '(6, 6)',
      '(-6, 2)',
      '(-4, -10)',
      '(-7, 1)',
      '(7, -1)',
      '(-6, 12)',
      '(-2, -4)',
      '(7, 1)',
      '(0, 9)',
      '(8, 3)',
      '(3, 3)',
      '(3, 4)',
    ],
    question: `The number 6 is a truly great number. Given two int values, a and b, return
    true if either one is 6. Or if their sum or difference is 6. Note: the function
    Math.abs(num) computes the absolute value of a number.`,
  },
  {
    title: 'Logic-1',
    name: 'in1To10',
    inputs: [
      '(5, false)',
      '(11, false)',
      '(11, true)',
      '(10, false)',
      '(10, true)',
      '(9, false)',
      '(9, true)',
      '(1, false)',
      '(1, true)',
      '(0, false)',
      '(0, true)',
      '(-1, false)',
    ],
    question: `Given a number n, return true if n is in the range 1..10, inclusive.
    Unless "outsideMode" is true, in which case return true if the number is less or
    equal to 1, or greater or equal to 10.`,
  },
  {
    title: 'Logic-1',
    name: 'specialEleven',
    inputs: [
      '(22)',
      '(23)',
      '(24)',
      '(21)',
      '(11)',
      '(12)',
      '(10)',
      '(9)',
      '(8)',
      '(0)',
      '(1)',
      '(2)',
      '(121)',
      '(122)',
      '(123)',
      '(46)',
      '(49)',
      '(52)',
      '(54)',
      '(55)',
    ],
    question: `We'll say a number is special if it is a multiple of 11 or if it is one more
    than a multiple of 11. Return true if the given non-negative number is special. Use the %
    "mod" operator.`, // TODO add info on mod, up to and incl exercise nearTen
  },
  {
    title: 'Logic-1',
    name: 'more20',
    inputs: [
      '(20)',
      '(21)',
      '(22)',
      '(23)',
      '(25)',
      '(30)',
      '(31)',
      '(59)',
      '(60)',
      '(61)',
      '(62)',
      '(1020)',
      '(1021)',
      '(1000)',
      '(1001)',
      '(50)',
      '(55)',
      '(40)',
      '(41)',
      '(39)',
      '(42)',
    ],
    question: `Return true if the given non-negative number is 1 or 2 more than a
    multiple of 20.`,
  },
  {
    title: 'Logic-1',
    name: 'old35',
    inputs: [
      '(3)',
      '(10)',
      '(15)',
      '(5)',
      '(9)',
      '(8)',
      '(7)',
      '(6)',
      '(17)',
      '(18)',
      '(29)',
      '(20)',
      '(21)',
      '(22)',
      '(45)',
      '(99)',
    ],
    question: `Return true if the given non-negative number is a multiple of 3 or 5,
    but not both. Use the % "mod" operator.`,
  },
  {
    title: 'Logic-1',
    name: 'less20',
    inputs: [
      '(18)',
      '(19)',
      '(20)',
      '(8)',
      '(17)',
      '(23)',
      '(25)',
      '(30)',
      '(31)',
      '(58)',
      '(59)',
      '(60)',
      '(61)',
      '(62)',
      '(1017)',
      '(1018)',
      '(1019)',
      '(1020)',
      '(1021)',
      '(1022)',
      '(1023)',
      '(37)',
    ],
    question: `Return true if the given non-negative number is 1 or 2 less than a
    multiple of 20. So for example 38 and 39 return true, but 40 returns false.`,
  },
  {
    title: 'Logic-1',
    name: 'nearTen',
    inputs: [
      '(12)',
      '(17)',
      '(19)',
      '(31)',
      '(6)',
      '(10)',
      '(11)',
      '(21)',
      '(22)',
      '(23)',
      '(54)',
      '(155)',
      '(158)',
      '(3)',
      '(1)',
    ],
    question: `Given a non-negative number "num", return true if num is within 2 of a
    multiple of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2.`,
  },
  {
    title: 'Logic-1',
    name: 'teenSum',
    inputs: [
      '(3, 4)',
      '(10, 13)',
      '(13, 2)',
      '(3, 19)',
      '(13, 13)',
      '(10, 10)',
      '(6, 14)',
      '(15, 2)',
      '(19, 19)',
      '(19, 20)',
      '(2, 18)',
      '(12, 4)',
      '(2, 20)',
      '(2, 17)',
      '(2, 16)',
      '(6, 7)',
    ],
    question: `Given 2 ints, a and b, return their sum. However, "teen" values in the range
    13..19 inclusive, are extra lucky. So if either value is a teen, just return 19.`,
  },
  {
    title: 'Logic-1',
    name: 'answerCell',
    inputs: [
      '(false, false, false)',
      '(false, false, true)',
      '(true, false, false)',
      '(true, true, false)',
      '(false, true, false)',
      '(true, true, true)',
    ],
    question: `Your cell phone rings. Return true if you should answer it. Normally you
    answer, except in the morning you only answer if it is your mom calling. In all cases,
    if you are asleep, you do not answer.`,
  },
  {
    title: 'Logic-1',
    name: 'teaParty',
    inputs: [
      '(6, 8)',
      '(3, 8)',
      '(20, 6)',
      '(12, 6)',
      '(11, 6)',
      '(11, 4)',
      '(4, 5)',
      '(5, 5)',
      '(6, 6)',
      '(5, 10)',
      '(5, 9)',
      '(10, 4)',
      '(10, 20)',
    ],
    question: `We are having a party with amounts of tea and candy. Return the int outcome
    of the party encoded as 0=bad, 1=good, or 2=great. A party is good (1) if both tea and
    candy are at least 5. However, if either tea or candy is at least double the amount of
    the other one, the party is great (2). However, in all cases, if either tea or candy is
    less than 5, the party is always bad (0).`,
  },
  {
    title: 'Logic-1',
    name: 'fizzString',
    inputs: [
      "('fig')",
      "('dib')",
      "('fib')",
      "('abc')",
      "('fooo')",
      "('booo')",
      "('ooob')",
      "('fooob')",
      "('f')",
      "('b')",
      "('abcb')",
      "('Hello')",
      "('Hellob')",
      "('af')",
      "('bf')",
      "('fb')",
    ],
    question: `Given a string str, if the string starts with "f" return "Fizz". If
    the string ends with "b" return "Buzz". If both the "f" and "b" conditions are true,
    return "FizzBuzz". In all other cases, return the string unchanged. `, // TODO add fizzbuzz link
  },
  {
    title: 'Logic-1',
    name: 'fizzString2',
    inputs: [
      '(1)',
      '(2)',
      '(3)',
      '(4)',
      '(5)',
      '(6)',
      '(7)',
      '(8)',
      '(9)',
      '(15)',
      '(16)',
      '(18)',
      '(19)',
      '(21)',
      '(44)',
      '(45)',
      '(100)',
    ],
    question: `Given an int n, return the string form of the number followed by "!". So the
    int 6 yields "6!". Except if the number is divisible by 3 use "Fizz" instead of the number,
    and if the number is divisible by 5 use "Buzz", and if divisible by both 3 and 5, use
    "FizzBuzz". Note: the % "mod" operator computes the remainder after division, so 23 % 10
    yields 3. What will the remainder be when one number divides evenly into another?`, // TODO fizzbuzz code and intro to mod
  },
  {
    title: 'Logic-1',
    name: 'twoAsOne',
    inputs: [
      '(1, 2, 3)',
      '(3, 1, 2)',
      '(3, 2, 2)',
      '(2, 3, 1)',
      '(5, 3, -2)',
      '(5, 3, -3)',
      '(2, 5, 3)',
      '(9, 5, 5)',
      '(9, 4, 5)',
      '(5, 4, 9)',
      '(3, 3, 0)',
      '(3, 3, 2)',
    ],
    question: `Given three ints, a b c, return true if it is possible to add two of the ints
    to get the third.`,
  },
  {
    title: 'Logic-1',
    name: 'inOrder',
    inputs: [
      '(1, 2, 4, false)',
      '(1, 2, 1, false)',
      '(1, 1, 2, true)',
      '(3, 2, 4, false)',
      '(2, 3, 4, false)',
      '(3, 2, 4, true)',
      '(4, 2, 2, true)',
      '(4, 5, 2, true)',
      '(2, 4, 6, true)',
      '(7, 9, 10, false)',
      '(7, 5, 6, true)',
      '(7, 5, 4, true)',
    ],
    question: `Given three ints, a b c, return true if b is greater than a, and c is greater
    than b. However, with the exception that if "bOk" is true, b does not need to be greater
    than a.`,
  },
  {
    title: 'Logic-1',
    name: 'inOrderEqual',
    inputs: [
      '(2, 5, 11, false)',
      '(5, 7, 6, false)',
      '(5, 5, 7, true)',
      '(5, 5, 7, false)',
      '(2, 5, 4, false)',
      '(3, 4, 3, false)',
      '(3, 4, 4, false)',
      '(3, 4, 3, true)',
      '(3, 4, 4, true)',
      '(1, 5, 5, true)',
      '(5, 5, 5, true)',
      '(2, 2, 1, true)',
      '(9, 2, 2, true)',
      '(0, 1, 0, true)',
    ],
    question: `Given three ints, a b c, return true if they are in strict increasing order,
    such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception that if
    "equalOk" is true, equality is allowed, such as 5 5 7 or 5 5 5.`,
  },
  {
    title: 'Logic-1',
    name: 'lastDigit',
    inputs: [
      '(23, 19, 13)',
      '(23, 19, 12)',
      '(23, 19, 3)',
      '(23, 19, 39)',
      '(1, 2, 3)',
      '(1, 1, 2)',
      '(1, 2, 2)',
      '(14, 25, 43)',
      '(14, 25, 45)',
      '(248, 106, 1002)',
      '(248, 106, 1008)',
      '(10, 11, 20)',
      '(0, 11, 0)',
    ],
    question: `Given three ints, a b c, return true if two or more of them have the same
    rightmost digit. The ints are non-negative. Note: the % "mod" operator computes the
    remainder, e.g. 17 % 10 is 7.`,
  },
  {
    title: 'Logic-1',
    name: 'lessBy10',
    inputs: [
      '(1, 7, 11)',
      '(1, 7, 10)',
      '(11, 1, 7)',
      '(10, 7, 1)',
      '(-10, 2, 2)',
      '(2, 11, 11)',
      '(3, 3, 30)',
      '(3, 3, 3)',
      '(10, 1, 11)',
      '(10, 11, 1)',
      '(10, 11, 2)',
      '(3, 30, 3)',
      '(2, 2, -8)',
      '(2, 8, 12)',
    ],
    question: `Given three ints, a b c, return true if one of them is 10 or more less
    than one of the others.`,
  },
  {
    title: 'Logic-1',
    name: 'withoutDoubles',
    inputs: [
      '(2, 3, true)',
      '(3, 3, true)',
      '(3, 3, false)',
      '(2, 3, false)',
      '(5, 4, true)',
      '(5, 4, false)',
      '(5, 5, true)',
      '(5, 5, false)',
      '(6, 6, true)',
      '(6, 6, false)',
      '(1, 6, true)',
      '(6, 1, false)',
    ],
    question: `Return the sum of two 6-sided dice rolls, each in the range 1..6. However,
    if noDoubles is true, if the two dice show the same value, increment one die to the next
    value, wrapping around to 1 if its value was 6.`,
  },
  {
    title: 'Logic-1',
    name: 'maxMod5',
    inputs: [
      '(2, 3)',
      '(6, 2)',
      '(3, 2)',
      '(8, 12)',
      '(7, 12)',
      '(11, 6)',
      '(2, 7)',
      '(7, 7)',
      '(9, 1)',
      '(9, 14)',
      '(1, 2)',
    ],
    question: `Given two int values, return whichever value is larger. However if the two
    values have the same remainder when divided by 5, then the return the smaller value.
    However, in all cases, if the two values are the same, return 0. Note: the % "mod"
    operator computes the remainder, e.g. 7 % 5 is 2.`,
  },
  {
    title: 'Logic-1',
    name: 'redTicket',
    inputs: [
      '(2, 2, 2)',
      '(2, 2, 1)',
      '(0, 0, 0)',
      '(2, 0, 0)',
      '(1, 1, 1)',
      '(1, 2, 1)',
      '(1, 2, 0)',
      '(0, 2, 2)',
      '(1, 2, 2)',
      '(0, 2, 0)',
      '(1, 1, 2)',
    ],
    question: `You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1,
    or 2. If they are all the value 2, the result is 10. Otherwise if they are all the same,
    the result is 5. Otherwise so long as both b and c are different from a, the result is 1.
    Otherwise the result is 0.`,
  },
  {
    title: 'Logic-1',
    name: 'greenTicket',
    inputs: [
      '(1, 2, 3)',
      '(2, 2, 2)',
      '(1, 1, 2)',
      '(2, 1, 1)',
      '(1, 2, 1)',
      '(3, 2, 1)',
      '(0, 0, 0)',
      '(2, 0, 0)',
      '(0, 9, 10)',
      '(0, 10, 0)',
      '(9, 9, 9)',
      '(9, 0, 9)',
    ],
    question: `You have a green lottery ticket, with ints a, b, and c on it. If the numbers
    are all different from each other, the result is 0. If all of the numbers are the same,
    the result is 20. If two of the numbers are the same, the result is 10.`,
  },
  {
    title: 'Logic-1',
    name: 'blueTicket',
    inputs: [
      '(9, 1, 0)',
      '(9, 2, 0)',
      '(6, 1, 4)',
      '(6, 1, 5)',
      '(10, 0, 0)',
      '(15, 0, 5)',
      '(5, 15, 5)',
      '(4, 11, 1)',
      '(13, 2, 3)',
      '(8, 4, 3)',
      '(8, 4, 2)',
      '(8, 4, 1)',
    ],
    question: `You have a blue lottery ticket, with ints a, b, and c on it. This makes
    three pairs, which we'll call ab, bc, and ac. Consider the sum of the numbers in each pair.
    If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum is exactly 10
    more than either bc or ac sums, the result is 5. Otherwise the result is 0.`,
  },
  {
    title: 'Logic-1',
    name: 'shareDigit',
    inputs: [
      '(12, 23)',
      '(12, 43)',
      '(12, 44)',
      '(23, 12)',
      '(23, 39)',
      '(23, 19)',
      '(30, 90)',
      '(30, 91)',
      '(55, 55)',
      '(55, 44)',
    ],
    question: `Given two ints, each in the range 10..99, return true if there is a digit
    that appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10, gives
      the left digit while the % "mod" n%10 gives the right digit.)`,
  },
  {
    title: 'Logic-1',
    name: 'sumLimit',
    inputs: [
      '(2, 3)',
      '(8, 3)',
      '(8, 1)',
      '(11, 39)',
      '(11, 99)',
      '(0, 0)',
      '(99, 0)',
      '(99, 1)',
      '(123, 1)',
      '(1, 123)',
      '(23, 60)',
      '(23, 80)',
      '(9000, 1)',
      '(90000000, 1)',
      '(9000, 1000)',
    ],
    question: `Given 2 non-negative ints, a and b, return their sum, so long as the sum has
    the same number of digits as a. If the sum has more digits than a, just return a without
    b. (Note: one way to compute the number of digits of a non-negative int n is to convert it
      to a string with String.valueOf(n) and then check the length of the string.)`,
  },
  { question: 'We want to make a row of bricks that is goal inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops. See also: Introduction to MakeBricks',
    title: 'Logic-2',
    name: 'makeBricks',
    inputs: [
      '(3, 1, 8)',
      '(3, 1, 9)',
      '(3, 2, 10)',
      '(3, 2, 8)',
      '(3, 2, 9)',
      '(6, 1, 11)',
      '(6, 0, 11)',
      '(1, 4, 11)',
      '(0, 3, 10)',
      '(1, 4, 12)',
      '(3, 1, 7)',
      '(1, 1, 7)',
      '(2, 1, 7)',
      '(7, 1, 11)',
      '(7, 1, 8)',
      '(7, 1, 13)',
      '(43, 1, 46)',
      '(40, 1, 46)',
      '(40, 2, 47)',
      '(40, 2, 50)',
      '(40, 2, 52)',
      '(22, 2, 33)',
      '(0, 2, 10)',
      '(1000000, 1000, 1000100)',
      '(2, 1000000, 100003)',
      '(20, 0, 19)',
      '(20, 0, 21)',
      '(20, 4, 51)',
      '(20, 4, 39)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if one of the values is the same as another of the values, it does not count towards the sum.',
    title: 'Logic-2',
    name: 'loneSum',
    inputs: [
      '(1, 2, 3)',
      '(3, 2, 3)',
      '(3, 3, 3)',
      '(9, 2, 2)',
      '(2, 2, 9)',
      '(2, 9, 2)',
      '(2, 9, 3)',
      '(4, 2, 3)',
      '(1, 3, 1)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if one of the values is 13 then it does not count towards the sum and values to its right do not count. So for example, if b is 13, then both b and c do not count.',
    title: 'Logic-2',
    name: 'luckySum',
    inputs: [
      '(1, 2, 3)',
      '(1, 2, 13)',
      '(1, 13, 3)',
      '(1, 13, 13)',
      '(6, 5, 2)',
      '(13, 2, 3)',
      '(13, 2, 13)',
      '(13, 13, 2)',
      '(9, 4, 13)',
      '(8, 13, 2)',
      '(7, 2, 1)',
      '(3, 3, 13)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if any of the values is a teen -- in the range 13..19 inclusive -- then that value counts as 0, except 15 and 16 do not count as a teens. Write a separate helper "public int fixTeen(int n) {"that takes in an int value and returns that value fixed for the teen rule. In this way, you avoid repeating the teen code 3 times (i.e. "decomposition"). Define the helper below and at the same indent level as the main noTeenSum().',
    title: 'Logic-2',
    name: 'noTeenSum',
    inputs: [
      '(1, 2, 3)',
      '(2, 13, 1)',
      '(2, 1, 14)',
      '(2, 1, 15)',
      '(2, 1, 16)',
      '(2, 1, 17)',
      '(17, 1, 2)',
      '(2, 15, 2)',
      '(16, 17, 18)',
      '(17, 18, 19)',
      '(15, 16, 1)',
      '(15, 15, 19)',
      '(15, 19, 16)',
      '(5, 17, 18)',
      '(17, 18, 16)',
      '(17, 19, 18)',
    ],
  },
  { question: 'For this problem, we\'ll round an int value up to the next multiple of 10 if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down to the previous multiple of 10 if its rightmost digit is less than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To avoid code repetition, write a separate helper "public int round10(int num) {" and call it 3 times. Write the helper entirely below and at the same indent level as roundSum().',
    title: 'Logic-2',
    name: 'roundSum',
    inputs: [
      '(16, 17, 18)',
      '(12, 13, 14)',
      '(6, 4, 4)',
      '(4, 6, 5)',
      '(4, 4, 6)',
      '(9, 4, 4)',
      '(0, 0, 1)',
      '(0, 9, 0)',
      '(10, 10, 19)',
      '(20, 30, 40)',
      '(45, 21, 30)',
      '(23, 11, 26)',
      '(23, 24, 25)',
      '(25, 24, 25)',
      '(23, 24, 29)',
      '(11, 24, 36)',
      '(24, 36, 32)',
      '(14, 12, 26)',
      '(12, 10, 24)',
    ],
  },
  { question: 'Given three ints, a b c, return true if one of b or c is "close" (differing from a by at most 1), while the other is "far", differing from both other values by 2 or more. Note: Math.abs(num) computes the absolute value of a number.',
    title: 'Logic-2',
    name: 'closeFar',
    inputs: [
      '(1, 2, 10)',
      '(1, 2, 3)',
      '(4, 1, 3)',
      '(4, 5, 3)',
      '(4, 3, 5)',
      '(-1, 10, 0)',
      '(0, -1, 10)',
      '(10, 10, 8)',
      '(10, 8, 9)',
      '(8, 9, 10)',
      '(8, 9, 7)',
      '(8, 6, 9)',
    ],
  },
  { question: 'Given 2 int values greater than 0, return whichever value is nearest to 21 without going over. Return 0 if they both go over.',
    title: 'Logic-2',
    name: 'blackjack',
    inputs: [
      '(19, 21)',
      '(21, 19)',
      '(19, 22)',
      '(22, 19)',
      '(22, 50)',
      '(22, 22)',
      '(33, 1)',
      '(1, 2)',
      '(34, 33)',
      '(17, 19)',
      '(18, 17)',
      '(16, 23)',
      '(3, 4)',
      '(3, 2)',
      '(21, 20)',
    ],
  },
  { question: 'Given three ints, a b c, one of them is small, one is medium and one is large. Return true if the three values are evenly spaced, so the difference between small and medium is the same as the difference between medium and large.',
    title: 'Logic-2',
    name: 'evenlySpaced',
    inputs: [
      '(2, 4, 6)',
      '(4, 6, 2)',
      '(4, 6, 3)',
      '(6, 2, 4)',
      '(6, 2, 8)',
      '(2, 2, 2)',
      '(2, 2, 3)',
      '(9, 10, 11)',
      '(10, 9, 11)',
      '(10, 9, 9)',
      '(2, 4, 4)',
      '(2, 2, 4)',
      '(3, 6, 12)',
      '(12, 3, 6)',
    ] },
  { question: 'We want make a package of goal kilos of chocolate. We have small bars (1 kilo each) and big bars (5 kilos each). Return the number of small bars to use, assuming we always use big bars before small bars. Return -1 if it can\'t be done.',
    title: 'Logic-2',
    name: 'makeChocolate',
    inputs: [
      '(4, 1, 9)',
      '(4, 1, 10)',
      '(4, 1, 7)',
      '(6, 2, 7)',
      '(4, 1, 5)',
      '(4, 1, 4)',
      '(5, 4, 9)',
      '(9, 3, 18)',
      '(3, 1, 9)',
      '(1, 2, 7)',
      '(1, 2, 6)',
      '(1, 2, 5)',
      '(6, 1, 10)',
      '(6, 1, 11)',
      '(6, 1, 12)',
      '(6, 1, 13)',
      '(6, 2, 10)',
      '(6, 2, 11)',
      '(6, 2, 12)',
      '(60, 100, 550)',
      '(1000, 1000000, 5000006)',
      '(7, 1, 12)',
      '(7, 1, 13)',
      '(7, 2, 13)',
    ] }
  ];

},{}],221:[function(require,module,exports){
/** --- Solutions --- **/

let solutions = {};
solutions.cigarParty = function cigarParty(cigars, isWeekend) {
    if (isWeekend) {
      return cigars >= 40;
    }
    return cigars >= 40 && cigars <= 60;
  };

  
  solutions.dateFashion = function dateFashion(you, date) {
    if (you <= 2 || date <= 2) {
      return 0;
    }
  
    if (you >= 8 || date >= 8) {
      return 2;
    }
  
    return 1;
  };
  
  solutions.squirrelPlay = function squirrelPlay(temp, isSummer) {
    if (isSummer && temp >= 60 && temp <= 100) {
      return true;
    }
  
    if (!isSummer && temp >= 60 && temp <= 90) {
      return true;
    }
  
    return false;
  };
  
  solutions.caughtSpeeding = function caughtSpeeding(speed, isBirthday) {
    if (isBirthday) {
      if (speed <= 65) {
        return 0;
      } else if (speed >= 66 && speed <= 85) {
        return 1;
      } else if (speed >= 86) {
        return 2;
      }
    }
  
    if (speed <= 60) {
      return 0;
    } else if (speed >= 61 && speed <= 80) {
      return 1;
    } else {
      return 2;
    }
  };
  
  solutions.sortaSum = function sortaSum(a, b) {
    const res = a + b;
    if (res >= 10 && res <= 19) {
      return 20;
    }
    return res;
  };
  
  solutions.alarmClock = function alarmClock(day, vacation) {
    if (vacation) {
      if (day >= 1 && day <= 5) {
        return '10:00';
      } else return 'off';
    }
  
    if (day >= 1 && day <= 5) {
      return '7:00';
    } else return '10:00';
  };
  
  solutions.love6 = function love6(a, b) {
    if (a == 6 || b == 6) {
      return true;
    }
  
    if (a + b == 6 || Math.abs(a - b) == 6) {
      return true;
    }
  
    return false;
  };
  
  solutions.in1To10 = function in1To10(n, outsideMode) {
    if (outsideMode) {
      return (n <= 1 || n >= 10);
    }
    return (n >= 1 && n <= 10);
  };
  
  solutions.specialEleven = function specialEleven(n) {
    if (n % 11 == 0 || n % 11 == 1) {
      return true;
    }
    return false;
  };
  
  solutions.more20 = function more20(n) {
    return (n % 20 == 1 || n % 20 == 2);
  };
  
  solutions.old35 = function old35(n) {
    return (n % 3 == 0) != (n % 5 == 0);
  };
  
  solutions.less20 = function less20(n) {
    return (n % 20 == 18 || n % 20 == 19);
  };
  
  solutions.nearTen = function nearTen(num) {
    return (num % 10 <= 2 || num % 10 >= 8);
  };
  
  solutions.teenSum = function teenSum(a, b) {
    if ((a >= 13 && a <= 19) || (b >= 13 && b <= 19)) {
      return 19;
    }
    return a + b;
  };
  
  solutions.answerCell = function answerCell(isMorning, isMom, isAsleep) {
    if (isAsleep) {
      return false;
    }
  
    if (isMorning && !isMom) {
      return false;
    }
  
    return true;
  };
  
  solutions.teaParty = function teaParty(tea, candy) {
    if (tea >= 5 && candy >= 5) {
      if (tea >= candy * 2 || candy >= tea * 2) {
        return 2;
      }
      return 1;
    }
    return 0;
  };
  
  solutions.fizzString = function fizzString(str) {
    if (str[0] == 'f' && str[str.length - 1] == 'b') {
      return 'FizzBuzz';
    } else if (str[0] == 'f') {
      return 'Fizz';
    } else if (str[str.length - 1] == 'b') {
      return 'Buzz';
    } else { return str; }
  };
  
  solutions.fizzString2 = function fizzString2(n) {
    if (n % 3 == 0 && n % 5 == 0) {
      return 'FizzBuzz!';
    } else if (n % 3 == 0) {
      return 'Fizz!';
    } else if (n % 5 == 0) {
      return 'Buzz!';
    }
    return `${n.toString()}!`;
  };
  
  solutions.twoAsOne = function twoAsOne(a, b, c) {
    return a + b == c || a + c == b || b + c == a;
  };
  
  solutions.inOrder = function inOrder(a, b, c, bOk) {
    if (bOk) {
      return c > b;
    }
    return b > a && c > b;
  };
  
  solutions.inOrderEqual = function inOrderEqual(a, b, c, equalOk) {
    if (equalOk) {
      return a <= b && b <= c;
    }
    return a < b && b < c;
  };
  
  solutions.lastDigit = function lastDigit(a, b, c) {
    return a % 10 == b % 10 || b % 10 == c % 10 || a % 10 == c;
  };
  
  solutions.lessBy10 = function lessBy10(a, b, c) {
    return Math.abs(a - b) >= 10 || Math.abs(b - c) >= 10 || Math.abs(c - a) >= 10;
  };
  
  solutions.withoutDoubles = function withoutDoubles(die1, die2, noDoubles) {
    if (noDoubles) {
      if (die1 == die2) {
        if (die1 == 6 || die2 == 6) {
          die1 = 1;
          return die1 + die2;
        }
        return die1 + die2 + 1;
      }
    }
    return die1 + die2;
  };
  
  solutions.maxMod5 = function maxMod5(a, b) {
    if (a == b) {
      return 0;
    }
  
    if (a % 5 == b % 5) {
      if (a < b) {
            return a;
      } else {
            return b;
      }
    }
    return a > b ? a : b;
  };
  
  solutions.redTicket = function redTicket(a, b, c) {
    if (a == 2 && b == 2 && c == 2) {
      return 10;
    }
  
    if (a == b && b == c && a == c) {
      return 5;
    }
  
    if (b != a && c != a) {
      return 1;
    }
  
    return 0;
  };
  
  solutions.greenTicket = function greenTicket(a, b, c) {
    if (a == b && b == c) {
      return 20;
    }
  
    if (a == b || b == c || c == a) {
      return 10;
    }
  
    return 0;
  };
  
  solutions.blueTicket = function blueTicket(a, b, c) {
    if (a + b == 10 || b + c == 10 || a + c == 10) {
      return 10;
    }
  
    if (a + b == b + c + 10 || a + b == c + a + 10) {
      return 5;
    }
  
    return 0;
  };
  
  solutions.shareDigit = function shareDigit(a, b) {
    const aFirst = Math.floor(a / 10);
    const aLast = a % 10;
  
    if (aFirst == Math.floor(b / 10) || aFirst == b % 10) {
      return true;
    }
  
    if (aLast == Math.floor(b / 10) || aLast == b % 10) {
      return true;
    }
  
    return false;
  };
  
  solutions.sumLimit = function sumLimit(a, b) {
    const aLen = Math.abs(a).toString().length;
    const bLen = Math.abs(b).toString().length;
    const res = a + b;
    const resLen = Math.abs(res).toString().length;
  
    if (resLen == aLen) {
      return res;
    } else if (resLen >= aLen) {
      return a;
    }
  };
  
  // Logic-2
  
  solutions.makeBricks = function makeBricks(small, big, goal) {
      // not enough bricks
    if (goal > big * 5 + small) {
      return false;
    }
  
      // not enough small bricks
    if (goal % 5 > small) {
      return false;
    }
  
    return true;
  };
  
  solutions.loneSum = function loneSum(a, b, c) {
    let sum = 0;
    if (a != b && a != c) {
      sum += a;
    }
  
    if (b != c && b != a) {
      sum += b;
    }
  
    if (c != a && c != b) {
      sum += c;
    }
  
    return sum;
  };
  
  solutions.luckySum = function luckySum(a, b, c) {
    let sum = 0;
    const arr = [a, b, c];
  
    for (let i = 0; i <= 2; i++) {
      if (arr[i] != 13) {
        sum += arr[i];
      } else {
        return sum;
      }
    }
    return sum;
  };
  
  
  // TODO: make it work for two funcs
  solutions.noTeenSum = function noTeenSum(a, b, c) {
    const fixTeen = function (n) {
      if (n >= 13 && n <= 19 && n != 15 && n != 16) {
        return 0;
      }
  
      return n;
    };
    return fixTeen(a) + fixTeen(b) + fixTeen(c);
  };
  
  
  solutions.roundSum = function roundSum(a, b, c) {
    const round10 = function (num) {
      return Math.round(num / 10) * 10;
    };
    return round10(a) + round10(b) + round10(c);
  };
  
  solutions.closeFar = function closeFar(a, b, c) {
    const far = function (x, y) {
      return (Math.abs(x - y) >= 2);
    };
  
    const close = function (x, y) {
      return Math.abs(x - y) <= 1;
    };
  
    if (close(a, b) && far(b, c) && far(a, c)) {
      return true;
    } else if (close(a, c) && far(b, c) && far(a, b)) {
      return true;
    }
  
    return false;
  };
  
  
  solutions.blackjack = function blackjack(a, b) {
    if (a > 21 && b > 21) {
      return 0;
    }
  
    const big = Math.max(a, b);
    const small = Math.min(a, b);
  
    if (big <= 21) {
      return big;
    } else if (small <= 21) {
      return small;
    }
  };
  
  solutions.evenlySpaced = function evenlySpaced(a, b, c) {
    const max = Math.max(a, b, c);
    const min = Math.min(a, b, c);
    const mid = a + b + c - max - min;
  
    return max - mid == mid - min;
  };
  
  solutions.makeChocolate = function makeChocolate(small, big, goal) {
      // not enough
    if (small + big * 5 < goal) {
      return -1;
    }
  
    const bigsNeeded = Math.floor(goal / 5);
  
    const bigsUsed = Math.min(big, bigsNeeded);
     // how many leftover
    const smallsNeeded = goal - bigsUsed * 5;
  
    return smallsNeeded;
  };
  
  
    // {
    //   title: 'AP-1',
    //   name: 'scoresIncreasing',
    //   question: 'Given an array of scores, return true if each score is equal or greater than the one before. The array will be length 2 or more.',
    //   inputs: [
    //     '([1, 3, 4])',
    //     '([1, 3, 2])',
    //     '([1, 1, 4])',
    //     '([1, 1, 2, 4, 4, 7])',
    //     '([1, 1, 2, 4, 3, 7])',
    //     '([-5, 4, 11])',
    //   ],
    // },
    // {
    //   title: 'AP-1',
    //   name: 'scores100',
    //   question: 'Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2.',
    //   inputs: [
    //     '([1, 100, 100])',
    //     '([1, 100, 99, 100])',
    //     '([100, 1, 100, 100])',
    //     '([100, 1, 100, 1])',
    //     '([1, 2, 3, 4, 5])',
    //     '([1, 2, 100, 4, 5])',
    //   ],
    // },

module.exports = solutions;
},{}],222:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.mapBully = function mapBully(someMap) {
  if (someMap.has("a")) {
    someMap.set("b", someMap.get("a"));
    someMap.set("a", "");
  }
  return someMap;
}

solutions.mapShare = function mapShare(someMap) {
  if (someMap.has("a")) {
    someMap.set("b", someMap.get("a"));
  }
  someMap.delete("c");
  return someMap;
}

solutions.mapAB = function mapAB(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    let combinedString = someMap.get("a") + someMap.get("b");
    someMap.set("ab", combinedString);
  }
  return someMap;
}

solutions.topping1 = function topping1(someMap) {
  if (someMap.has("ice cream")) {
    someMap.set("ice cream", "cherry");
  }
  someMap.set("bread", "butter");
  return someMap;
}

solutions.topping2 = function topping2(someMap) {
  if (someMap.has("ice cream")) {
    someMap.set("yogurt", someMap.get("ice cream"));
  }
  if (someMap.has("spinach")) {
    someMap.set("spinach", "nuts");
  }
  return someMap;
}

solutions.topping3 = function topping3(someMap) {
  if (someMap.has("potato")) {
    someMap.set("fries", someMap.get("potato"));
  }
  if (someMap.has("salad")) {
    someMap.set("spinach", someMap.get("salad"));
  }
  return someMap;
}

solutions.mapAB2 = function mapAB2(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    if (someMap.get("a") === someMap.get("b")) {
      someMap.delete("a");
      someMap.delete("b");
    }
  }
  return someMap;
}

solutions.mapAB3 = function mapAB3(someMap) {
  if (someMap.has("a") && !someMap.has("b")) {
    someMap.set("b", someMap.get("a"));
  }
  else if (!someMap.has("a") && someMap.has("b")) {
    someMap.set("a", someMap.get("b"));
  }
  return someMap;
}

solutions.mapAB4 = function mapAB4(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    aLength = someMap.get("a").length;
    bLength = someMap.get("b").length;

    if (aLength > bLength) {
      someMap.set("c", someMap.get("a"));
    }
    else if (bLength > aLength) {
      someMap.set("c", someMap.get("b"));
    }
    else {
      someMap.set("a", "");
      someMap.set("b", "");
    }
  }
  return someMap;
}

 module.exports = solutions;
},{}],223:[function(require,module,exports){
module.exports = [
  { question: 'Given an integer, n, return the sum of the positive integers n + (n-2) + (n-4) + ...    Note: Your solution must be recursive. In other words, there can be no for or while loops in your solution.',
    title: 'QuizQuestions',
    name: 'sumDownBy2',
  inputs: [
  "(7)",
  "(8)",
  "(0)",
  "(1)",
  "(-1)",
  "(10)",
  "(5)",
  "(-5)",
  "(50)",
  "(2)",
  "(3)"
] },
  { 
    title: 'QuizQuestions',
    name: 'makes8',
    question: 'Given 2 ints, a and b, return true if one if them is 8 or if their sum is 8.',
    inputs: [
      '(5, 8)',
      '(3, 8)',
      '(3, 4)',
      '(4, 4)',
      '(5, 2)',
      '(5, 3)',
      '(8, 7)',
      '(8, 8)',
      '(-16, 24)',
      '(9, 1)',
    ], 
  },
    {
      title: 'QuizQuestions',
      name: 'countOdds',
      inputs: [
        "([2, 1, 2, 3, 4])",
        "([2, 2, 0])",
        "([1, 3, 5])",
        "([])",
        "([11, 9, 0, 1])",
        "([2, 11, 9, 0])",
        "([2])",
        "([2, 5, 12])",
      ],
      question: `Return the number of odd integers in the given array. Note: the % "mod"
      operator computes the remainder, e.g. 5 % 2 is 1.`
    },
    { question: 'The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence.',
      title: 'QuizQuestions',
      name: 'fib',
      inputs: [
      "(0)",
      "(1)",
      "(2)",
      "(3)",
      "(4)",
      "(5)",
      "(6)",
      "(7)"
   ] },
];

},{}],224:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.sumDownBy2 = function sumDownBy2(n) {
    if (n <= 0) {
        return 0;
    }
    else if (n === 1) {
      return 1;
    }
    else {
      return n + this.sumDownBy2(n-2);
    }
 }
 
 
solutions.makes8 = function makes8(a, b) {
  return ((a == 8 || b == 8) || (a + b == 8));
};
 
solutions.countOdds = function countOdds(nums) {
   let count = 0;
 
     for (let i = 0; i < nums.length; i++){
         if (nums[i]%2 === 1){
             count += 1;
         }
     }
     return count;
 }
 
 solutions.fib = function fib(n) {
   if (n < 2) {
       return n;
   };
     return this.fib(n-1) + this.fib(n-2);
 }

 module.exports = solutions;
},{}],225:[function(require,module,exports){
module.exports = [
  { question: 'Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) ... 1. Compute the result recursively (without loops).',
    title: 'Recursion-1',
    name: 'factorial',
  inputs: [
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)",
  "(8)",
  "(12)"
] },
  { question: 'We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication).',
    title: 'Recursion-1',
    name: 'bunnyEars',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(12)",
  "(50)",
  "(234)"
] },
  { question: 'The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence.',
    title: 'Recursion-1',
    name: 'fibonacci',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)"
] },
  { question: 'We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we\'ll say have 3 ears, because they each have a raised foot. Recursively return the number of "ears" in the bunny line 1, 2, ... n (without loops or multiplication).',
    title: 'Recursion-1',
    name: 'bunnyEars2',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(10)"
] },
  { question: 'We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows.',
    title: 'Recursion-1',
    name: 'triangle',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)"
] },
  { question: 'Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'sumDigits1',
    inputs: [
  "(126)",
  "(49)",
  "(12)",
  "(10)",
  "(1)",
  "(0)",
  "(730)",
  "(1111)",
  "(11111)",
  "(10110)",
  "(235)"
] },
  { question: 'Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'count7',
    inputs: [
  "(717)",
  "(7)",
  "(123)",
  "(77)",
  "(7123)",
  "(771237)",
  "(771737)",
  "(47571)",
  "(777777)",
  "(70701277)",
  "(777576197)",
  "(99999)",
  "(99799)"
] },
  { question: 'Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'count8',
    inputs: [
  "(8)",
  "(818)",
  "(8818)",
  "(8088)",
  "(123)",
  "(81238)",
  "(88788)",
  "(8234)",
  "(2348)",
  "(23884)",
  "(0)",
  "(1818188)",
  "(8818181)",
  "(1080)",
  "(188)",
  "(88888)",
  "(9898)",
  "(78)"
] },
  { question: 'Given base and n that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared).',
    title: 'Recursion-1',
    name: 'powerN',
    inputs: [
  "(3, 1)",
  "(3, 2)",
  "(3, 3)",
  "(2, 1)",
  "(2, 2)",
  "(2, 3)",
  "(2, 4)",
  "(2, 5)",
  "(10, 1)",
  "(10, 2)",
  "(10, 3)"
] },
  { question: 'Given a string, compute recursively (no loops) the number of lowercase \'x\' chars in the string.',
    title: 'Recursion-1',
    name: 'countX',
    inputs: [
  "('xxhixx')",
  "('xhixhix')",
  "('hi')",
  "('h')",
  "('x')",
  "('')",
  "('hihi')",
  "('hiAAhi12hi')"
] },
  { question: 'Given a string, compute recursively (no loops) the number of times lowercase "hi" appears in the string.',
    title: 'Recursion-1',
    name: 'countHi',
    inputs: [
  "('xxhixx')",
  "('xhixhix')",
  "('hi')",
  "('hihih')",
  "('h')",
  "('')",
  "('ihihihihih')",
  "('ihihihihihi')",
  "('hiAAhi12hi')",
  "('xhixhxihihhhih')",
  "('ship')"
] },
  { question: 'Given a string, compute recursively (no loops) a new string where all the lowercase \'x\' chars have been changed to \'y\' chars.',
    title: 'Recursion-1',
    name: 'changeXY',
    inputs: [
  "('codex')",
  "('xxhixx')",
  "('xhixhix')",
  "('hiy')",
  "('h')",
  "('x')",
  "('')",
  "('xxx')",
  "('yyhxyi')",
  "('hihi')"
] },
  { question: 'Given a string, compute recursively (no loops) a new string where all appearances of "pi" have been replaced by "3.14".',
    title: 'Recursion-1',
    name: 'changePi',
    inputs: [
  "('xpix')",
  "('pipi')",
  "('pip')",
  "('pi')",
  "('hip')",
  "('p')",
  "('x')",
  "('')",
  "('pixx')",
  "('xyzzy')"
] },
  { question: 'Given a string, compute recursively a new string where all the \'x\' chars have been removed.',
    title: 'Recursion-1',
    name: 'noX',
    inputs: [
  "('xaxb')",
  "('abc')",
  "('xx')",
  "('')",
  "('axxbxx')",
  "('Hellox')"
] },
  { question: 'Given an array of ints, compute recursively if the array contains a 6. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array6',
    inputs: [
  "([1, 6, 4], 0)",
  "([1, 4], 0)",
  "([6], 0)",
  "([], 0)",
  "([6, 2, 2], 0)",
  "([2, 5], 0)",
  "([1, 9, 4, 6, 6], 0)",
  "([2, 5, 6], 0)"
] },
  { question: 'Given an array of ints, compute recursively the number of times that the value 11 appears in the array. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array11',
    inputs: [
  "([1, 2, 11], 0)",
  "([11, 11], 0)",
  "([1, 2, 3, 4], 0)",
  "([1, 11, 3, 11, 11], 0)",
  "([11], 0)",
  "([1], 0)",
  "([], 0)",
  "([11, 2, 3, 4, 11, 5], 0)",
  "([11, 5, 11], 0)"
] },
  { question: 'Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array220',
    inputs: [
  "([1, 2, 20], 0)",
  "([3, 30], 0)",
  "([3], 0)",
  "([], 0)",
  "([3, 3, 30, 4], 0)",
  "([2, 19, 4], 0)",
  "([20, 2, 21], 0)",
  "([20, 2, 21, 210], 0)",
  "([2, 200, 2000], 0)",
  "([0, 0], 0)",
  "([1, 2, 3, 4, 5, 6], 0)",
  "([1, 2, 3, 4, 5, 50, 6], 0)",
  "([1, 2, 3, 4, 5, 51, 6], 0)",
  "([1, 2, 3, 4, 4, 50, 500, 6], 0)"
] },
  { question: 'Given a string, compute recursively a new string where all the adjacent chars are now separated by a "*".',
    title: 'Recursion-1',
    name: 'allStar',
    inputs: [
  "('hello')",
  "('abc')",
  "('ab')",
  "('a')",
  "('')",
  "('3.14')",
  "('Chocolate')",
  "('1234')"
] },
  { question: 'Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a "*".',
    title: 'Recursion-1',
    name: 'pairStar',
    inputs: [
  "('hello')",
  "('xxyy')",
  "('aaaa')",
  "('aaab')",
  "('aa')",
  "('a')",
  "('')",
  "('noadjacent')",
  "('abba')",
  "('abbba')"
] },
  { question: 'Given a string, compute recursively a new string where all the lowercase \'x\' chars have been moved to the end of the string.',
    title: 'Recursion-1',
    name: 'endX',
    inputs: [
  "('xxre')",
  "('xxhixx')",
  "('xhixhix')",
  "('hiy')",
  "('h')",
  "('x')",
  "('xx')",
  "('')",
  "('bxx')",
  "('bxax')",
  "('axaxax')",
  "('xxhxi')"
] },
  { question: 'We\'ll say that a "pair" in a string is two instances of a char separated by a char. So "AxA" the A\'s make a pair. Pair\'s can overlap, so "AxAxA" contains 3 pairs -- 2 for A and 1 for x. Recursively compute the number of pairs in the given string.',
    title: 'Recursion-1',
    name: 'countPairs',
    inputs: [
  "('axa')",
  "('axax')",
  "('axbx')",
  "('hi')",
  "('hihih')",
  "('ihihhh')",
  "('ihjxhh')",
  "('')",
  "('a')",
  "('aa')",
  "('aaa')"
] },
  { question: 'Count recursively the total number of "abc" and "aba" substrings that appear in the given string.',
    title: 'Recursion-1',
    name: 'countAbc',
    inputs: [
  "('abc')",
  "('abcxxabc')",
  "('abaxxaba')",
  "('ababc')",
  "('abxbc')",
  "('aaabc')",
  "('hello')",
  "('')",
  "('ab')",
  "('aba')",
  "('aca')",
  "('aaa')"
] },
  { question: 'Given a string, compute recursively (no loops) the number of "11" substrings in the string. The "11" substrings should not overlap.',
    title: 'Recursion-1',
    name: 'count11',
    inputs: [
  "('11abc11')",
  "('abc11x11x11')",
  "('111')",
  "('1111')",
  "('1')",
  "('')",
  "('hi')",
  "('11x111x1111')",
  "('1x111')",
  "('1Hello1')",
  "('Hello')"
] },
  { question: 'Given a string, return recursively a "cleaned" string where adjacent chars that are the same have been reduced to a single char. So "yyzzza" yields "yza".',
    title: 'Recursion-1',
    name: 'stringClean',
    inputs: [
  "('yyzzza')",
  "('abbbcdd')",
  "('Hello')",
  "('XXabcYY')",
  "('112ab445')",
  "('Hello Bookkeeper')"
] },
  { question: 'Given a string, compute recursively the number of times lowercase "hi" appears in the string, however do not count "hi" that have an \'x\' immedately before them.',
    title: 'Recursion-1',
    name: 'countHi2',
    inputs: [
  "('ahixhi')",
  "('ahibhi')",
  "('xhixhi')",
  "('hixhi')",
  "('hixhhi')",
  "('hihihi')",
  "('hihihix')",
  "('xhihihix')",
  "('xxhi')",
  "('hixxhi')",
  "('hi')",
  "('xxxx')",
  "('h')",
  "('x')",
  "('')",
  "('Hellohi')"
] },
  { question: 'This question is modified from parenBit on CodingBat to starBit. Given a string that contains a dash and a star, compute recursively a new string made of only of the dash and star and their contents, so "xyz-abc*123" yields "-abc*".',
    title: 'Recursion-1',
    name: 'starBit',
    inputs: [
      "('xyz,-abc*123')",
      "('x,-hello*')",
      "(',-xy*1')",
      "('not really ,-possible*')",
      "(',-abc*')",
      "(',-abc*xyz')",
      "(',-abc*x')",
      "(',-x*')",
      "(',-)*')",
      "('res ,-ipsa* loquitor')",
      "('hello,-not really*there')",
      "('ab,-ab*ab')"
] },
  { question: 'Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like "(())" or "((()))". Suggestion: check the first and last chars, and then recur on what\'s inside them.',
    title: 'Recursion-1',
    name: 'nestParen',
    inputs: [
    "('(())')",
    "('((()))')",
    "('(((x))')",
    "('((())')",
    "('((()()')",
    "('()')",
    "('')",
    "('(yy)')",
    "('(())')",
    "('(((y))')",
    "('((y)))')",
    "('((()))')",
    "('(())))')",
    "('((yy())))')",
    "('(((())))')"
    ] },
  { question: 'Given a string and a non-empty substring sub, compute recursively the number of times that sub appears in the string, without the sub strings overlapping.',
    title: 'Recursion-1',
    name: 'strCount',
    inputs: [
  "('catcowcat', 'cat')",
  "('catcowcat', 'cow')",
  "('catcowcat', 'dog')",
  "('cacatcowcat', 'cat')",
  "('xyx', 'x')",
  "('iiiijj', 'i')",
  "('iiiijj', 'ii')",
  "('iiiijj', 'iii')",
  "('iiiijj', 'j')",
  "('iiiijj', 'jj')",
  "('aaabababab', 'ab')",
  "('aaabababab', 'aa')",
  "('aaabababab', 'a')",
  "('aaabababab', 'b')"
] },
  { question: 'Given a string and a non-empty substring sub, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative.',
    title: 'Recursion-1',
    name: 'strCopies',
    inputs: [
  "('catcowcat', 'cat', 2)",
  "('catcowcat', 'cow', 2)",
  "('catcowcat', 'cow', 1)",
  "('iiijjj', 'i', 3)",
  "('iiijjj', 'i', 4)",
  "('iiijjj', 'ii', 2)",
  "('iiijjj', 'ii', 3)",
  "('iiijjj', 'x', 3)",
  "('iiijjj', 'x', 0)",
  "('iiiiij', 'iii', 3)",
  "('iiiiij', 'iii', 4)",
  "('ijiiiiij', 'iiii', 2)",
  "('ijiiiiij', 'iiii', 3)",
  "('dogcatdogcat', 'dog', 2)"
] },
  { question: 'Given a string and a non-empty substring sub, compute recursively the largest substring which starts and ends with sub and return its length.',
    title: 'Recursion-1',
    name: 'strDist',
    inputs: [
  "('catcowcat', 'cat')",
  "('catcowcat', 'cow')",
  "('cccatcowcatxx', 'cat')",
  "('abccatcowcatcatxyz', 'cat')",
  "('xyx', 'x')",
  "('xyx', 'y')",
  "('xyx', 'z')",
  "('z', 'z')",
  "('x', 'z')",
  "('', 'z')",
  "('hiHellohihihi', 'hi')",
  "('hiHellohihihi', 'hih')",
  "('hiHellohihihi', 'o')",
  "('hiHellohihihi', 'll')"
] }
];

},{}],226:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.factorial = function factorial(n) {
    if (n === 0) {
        return 1;
    }
     return n * this.factorial(n-1)
 }
 
 solutions.bunnyEars = function bunnyEars(bunnies) {
     if (bunnies <= 0) {
       return 0;
     }
     else {
       return 2 + this.bunnyEars(bunnies-1);
     }
 }
 
 solutions.fibonacci = function fibonacci(n) {
   if (n < 2) {
       return n;;
   };
     return this.fibonacci(n-1) + this.fibonacci(n-2)
 }
 
 solutions.bunnyEars2 = function bunnyEars2(bunnies) {
 
  if (bunnies <= 0){
    return 0;
  }
 
  if (bunnies%2 == 0){
    return 3 + this.bunnyEars2(bunnies - 1);
  } else {
    return 2 + this.bunnyEars2(bunnies - 1);
  }
 }
 
 solutions.triangle = function triangle(rows) {
 
   if (rows <= 0){
     return 0;
   }
   return rows + this.triangle(rows-1)
 }
 
 solutions.sumDigits1 = function sumDigits1(n) {
     if(n <= 0){
        return 0;
     }
     return n % 10 + this.sumDigits1(Math.floor(n/10));
 }
 
 solutions.count7 = function count7(n) {
     if(n <= 0)
         return 0;
 
     if(n % 10 == 7)
         return 1 + this.count7(Math.floor(n/10));
 
     return this.count7(Math.floor(n/10));
 }
 
 solutions.count8 = function count8(n) {
     if(n == 0){
       return 0;
     }
 
     if(n % 10 == 8) {
         if(parseInt(n/10) % 10 == 8) {
            return 2 + this.count8(parseInt(n/10));
         } else {
           return 1 + this.count8(parseInt(n/10));
         }
     }
     return this.count8(parseInt(n/10));
 }
 
 solutions.powerN = function powerN(base, n) {
   if (n == 1){
     return base;
   }
   return base * this.powerN(base, n-1);
 }
 
 solutions.countX = function countX(str) {
     if(str.length == 0)
         return 0;
 
     if(str.charAt(0) == 'x'){
       return 1 + this.countX(str.substring(1));
     } else {
       return this.countX(str.substring(1));
     }
 }
 
 solutions.countHi = function countHi(str) {
   if (str.length == 0){
     return 0;
   }
 
   if (str.substring(0, 2) == "hi"){
     return 1 + this.countHi(str.substring(2))
   }
   return this.countHi(str.substring(1))
 }
 
 solutions.changeXY = function changeXY(str) {
   if (str.length == 0){
     return "";
   }
 
   if (str.charAt(0) == "x"){
     return "y" + this.changeXY(str.substring(1))
   }
   return str.charAt(0) + this.changeXY(str.substring(1))
 }
 
 solutions.changePi = function changePi(str) {
 
   if (str.length <= 0){
     return "";
   }
 
   if (str.substring(0, 2) == "pi"){
     return 3.14 + this.changePi(str.substring(2))
   } else {
     return str.charAt(0) + this.changePi(str.substring(1))
   }
 }
 
 solutions.noX = function noX(str) {
   if (str.length == 0){
     return "";
   }
 
   if (str.charAt(0) == "x"){
     return this.noX(str.substring(1));
   } else {
     return str.charAt(0) + this.noX(str.substring(1));
   }
 }
 
 solutions.array6 = function array6(nums, i) {
   if (i > nums.length){
     return false;
   }
 
   if (nums[i] == 6){
     return true;
   } else {
     return this.array6(nums, i+1)
   }
 }
 
 solutions.array11 = function array11(nums, i) {
   if (i >= nums.length){
     return 0;
   }
 
   if (nums[i] == 11){
     return 1 + this.array11(nums, i+1);
   } else {
     return this.array11(nums, i+1);
   }
 }
 
 solutions.array220 = function array220(nums, i) {
 
   if (i == nums.length-1 || nums.length == 0){
     return false;
   }
 
   if (nums[i] * 10 == nums[i+1]){
     return true;
   }
   return this.array220(nums, i+1);
 }
 
 solutions.allStar = function allStar(str) {
 
   if (str.length <= 1){
     return str;
   }
 
   return  str.charAt(0) + "*" + this.allStar(str.substring(1));
 }
 
 solutions.pairStar = function pairStar(str) {
 
   if (str.length <= 1){
     return str.charAt(0);
   }
 
   if (str.charAt(0) == str.charAt(1)){
     return str.charAt(0) + "*" + this.pairStar(str.substring(1));
   }
   return str.charAt(0) + this.pairStar(str.substring(1));
 }
 
 solutions.endX = function endX(str) {
     if(str.length <= 1) {
       return str;
     }
 
    if (str.charAt(0) == "x"){
      return this.endX(str.substring(1)) + "x";
    }
    return str.charAt(0) + this.endX(str.substring(1));
 }
 
 solutions.countPairs = function countPairs(str) {
 
   if (str.length <= 2){
     return 0;
   }
 
   if (str.charAt(0) == str.charAt(2)){
     return 1 + this.countPairs(str.substring(1));
   }
   return this.countPairs(str.substring(1));
 }
 
 solutions.countAbc = function countAbc(str){
 
   if (str.length <= 2) {
     return 0;
   }
 
   if (str.substring(0, 3) === "abc" || str.substring(0, 3) === "aba"){
     return 1 + this.countAbc(str.substring(2));
   }
   return this.countAbc(str.substring(1))
 }
 
 solutions.count11 = function count11(str) {
 
   if (str.length <= 1){
     return 0;
   }
 
   if (str.substring(0, 2) == "11"){
     return 1 + this.count11(str.substring(2))
   }
   return this.count11(str.substring(1));
 }
 
 solutions.stringClean = function stringClean(str) {
   if (str.length == 1){
     return str;
   }
 
   if (str.charAt(0) == str.charAt(1)){
     return this.stringClean(str.substring(1));
   }
   return str.charAt(0) + this.stringClean(str.substring(1));
 }
 
 solutions.countHi2 = function countHi2(str){
   if (str.length <= 1){
     return 0;
   }
 
   if (str.substring(0, 3) == "xhi"){
     return this.countHi2(str.substring(3))
   }
 
   if (str.substring(0, 2) == "hi"){
      return 1 + this.countHi2(str.substring(2))
   }
 
    return this.countHi2(str.substring(1))
 }
 
 solutions.starBit = function starBit(str) {
   if (str.charAt(0) == "-" && str.charAt(str.length - 1) == "*"){
     return str;
   }
 
   if (str.charAt(str.length-1) == "*"){
     return this.starBit(str.substring(1));
   }
 
   if (str.charAt(0) == "-"){
     return this.starBit(str.substring(0, str.length-1));
   }
 
   return this.starBit(str.substring(1, str.length - 1));
 }
 
 solutions.nestParen = function nestParen(str) {
     if(str.length == 0)
         return true;
 
     if(str.charAt(0) == '(' && str.charAt(str.length-1) == ')'){
         return this.nestParen(str.substring(1, str.length-1));
     }
 
     return false;
 }
 
 solutions.strCount = function strCount(str, sub) {
   if (str.length <= 0){
     return 0;
   }
 
   if (str.substring(0, sub.length) == sub){
     return 1 + this.strCount(str.substring(sub.length), sub)
   }
   return this.strCount(str.substring(1), sub);
 }
 
 solutions.strCopies = function strCopies(str, sub, n) {
   if (n == 0){
     return true;
   }
 
   if (str.length < sub.length){
     return false;
   }
 
   if (str.substring(0, sub.length) == sub){
     return this.strCopies(str.substring(1), sub, n-1)
   }
   return this.strCopies(str.substring(1), sub, n)
 }
 
 solutions.strDist = function strDist(str, sub) {
 
   if (str.length <= sub.length){
         if (str == sub){
         return str.length;
       } else {
           return 0;
       }
   }
 
   if (str.substring(0, sub.length) == sub && str.substring(str.length-sub.length) == sub){
     return str.length;
   }
 
   if (str.substring(0, sub.length) == sub){
     return this.strDist(str.substring(0, str.length-1), sub);
   }
 
    if (str.substring(str.length-sub.length) == sub){
     return this.strDist(str.substring(1), sub);
   }
 
   return this.strDist(str.substring(1, str.length-1), sub)
 }

 module.exports = solutions;
},{}],227:[function(require,module,exports){
/** --- Solutions --- **/
// String-1

let solutions = {};

solutions.helloName = function helloName(name) {
    return `Hello ${name}!`;
  };
  
solutions.makeAbba = function makeAbba(a, b) {
  return a + b + b + a;
};

solutions.makeOutWord = function makeOutWord(out, word) {
  front = out.substring(0, 2);
  back = out.substring(2, 4);
  return front + word + back;
};

solutions.extraEnd = function extraEnd(str) {
  if (str.length > 1) {
    back = str.substring(str.length - 2);
    return back + back + back;
  }
};

solutions.withoutEnd = function withoutEnd(str) {
  return str.substring(1, str.length - 1);
};

solutions.comboString = function comboString(a, b) {
  if (a.length < b.length) {
    return a + b + a;
  } else {
    return b + a + b;
  }
};

solutions.nonStart = function nonStart(a, b) {
  a = a.substring(1, a.length);
  b = b.substring(1, b.length);
  return a + b;
};

solutions.firstHalf = function firstHalf(str) {
  if (str.length % 2 == 0) {
    return str.substring(0, str.length);
  }
  return str;
};

solutions.firstTwo = function firstTwo(str) {
  if (str.length > 2) {
    return str.substring(0, 2);
  }
  return str;
};

solutions.left2 = function left2(str) {
  if (str.length > 1) {
    front = str.substring(0, 2);
    back = str.substring(2, str.length);
    return back + front;
  }
  return str;
};

solutions.right2 = function right2(str) {
  if (str.length > 1) {
    back = str.substring(str.length - 2, str.length);
    front = str.substring(0, str.length - 2);
    return back + front;
  }
  return str;
};

solutions.theEnd = function theEnd(str, front) {
  if (front) {
    return str.substring(0, 1);
  }
  return str.substring(str.length - 1);
};

solutions.withoutEnd2 = function withoutEnd2(str) {
  if (str.length <= 1) {
    return '';
  }
  return str.substring(1, str.length - 1);
};

solutions.middleTwo = function middleTwo(str) {
  if (str.length % 2 == 0) {
    temp = str.substring(str.length);
    mid = temp.substring(0, 2);
    return mid;
  }
  return str;
};

solutions.endsLy = function endsLy(str) {
  if (str.substring(str.length - 2, str.length) == 'ly') {
    return true;
  } else {
    return false;
  }
};

solutions.nTwice = function nTwice(str, n) {
  first = str.substring(0, n);
  end = str.substring(str.length - n);
  return first + end;
};

solutions.makeTags = function makeTags(tag, word) {
  const otag = `<${tag}>`;
  const ctag = `</${tag}>`;
  return otag + word + ctag;
};

solutions.twoChar = function twoChar(str, index) {
  if (index + 2 > str.length || index < 0) {
    return str.substring(0, 2);
  }

  return str.substring(index, index + 2);
};

solutions.middleThree = function middleThree(str) {
  const i = Math.floor(str.length / 2);

  return str.substring(i - 1, i + 2);
};

solutions.hasBad = function hasBad(str) {
  if (str.length == 3) {
    return str.substring(0, 3) == 'bad';
  }

  if (str.length >= 4) {
    return str.substring(0, 3) == 'bad' ||
            str.substring(1, 4) == 'bad';
  }

  return false;
};

solutions.atFirst = function atFirst(str) {
  if (str.length == 0) {
    return '@@';
  }

  if (str.length == 1) {
    return `${str}@`;
  }

  return str.substring(0, 2);
};

solutions.lastChars = function lastChars(a, b) {
  let res = '';
  if (a.length == 0) {
    res += '@';
  } else {
    res += a.charAt(0);
  }

  if (b.length == 0) {
    res += '@';
  } else {
    res += b.charAt(b.length - 1);
  }

  return res;
};

solutions.conCat = function conCat(a, b) {
  if (a.charAt(a.length - 1) == b.charAt(0)) {
    return a + b.substring(1);
  } else {
    return a + b;
  }
};

solutions.lastTwo = function lastTwo(str) {
  if (str.length < 2) {
    return str;
  }

  return str.substring(0, str.length - 2) + str.charAt(str.length - 1) +
        str.charAt(str.length - 2);
};

solutions.seeColor = function seeColor(str) {
  if (str.length >= 3 && str.substring(0, 3) == 'red') {
    return 'red';
  }

  if (str.length >= 4 && str.substring(0, 4) == 'blue') {
    return 'blue';
  }

  return '';
};

solutions.frontAgain = function frontAgain(str) {
  if (str.length < 2) {
    return false;
  }

  return str.substring(0, 2) == str.substring(str.length - 2);
};

solutions.minCat = function minCat(a, b) {
  const min = Math.min(a.length, b.length);

  return a.substring(a.length - min) + b.substring(b.length - min);
};

solutions.extraFront = function extraFront(str) {
  if (str.length >= 2) {
    str = str.substring(0, 2);
  }

  return str + str + str;
};

solutions.without2 = function without2(str) {
  if (str.length >= 2 &&
        str.substring(0, 2) == str.substring(str.length - 2)) {
    return str.substring(2);
  }

  return str;
};

solutions.deFront = function deFront(str) {
  if (str.length == 1 && str.charAt(0) != 'a') {
    return '';
  }

  if (str.length >= 2) {
    if (str.charAt(0) != 'a' && str.charAt(1) != 'b') {
      return str.substring(2);
    } else if (str.charAt(0) != 'a') {
      return str.substring(1);
    } else if (str.charAt(1) != 'b') {
      return `a${str.substring(2)}`;
    }
  }

  return str;
};

solutions.startWord = function startWord(str, word) {
  if (str.length >= word.length &&
        str.substring(1, word.length) == (word.substring(1))) {
    return str.substring(0, word.length);
  }

  return '';
};

solutions.withoutX = function withoutX(str) {
  let start = 0;
  let end = str.length;

  if (str.length > 0 && str.charAt(0) == 'x') { start = 1; }

  if (str.length > 1 && str.charAt(str.length - 1) == 'x') {
    end--;
  }

  return str.substring(start, end);
};

solutions.withoutX2 = function withoutX2(str) {
  if (str.length == 1 && str.charAt(0) == 'x') {
    return '';
  }

  if (str.length >= 2) {
    if (str.charAt(0) == 'x' && str.charAt(1) == 'x') {
      return str.substring(2);
    } else if (str.charAt(0) == 'x') {
      return str.substring(1);
    } else if (str.charAt(1) == 'x') {
      return str.charAt(0) + str.substring(2);
    }
  }

  return str;
};

// String-2

solutions.doubleChar = function doubleChar(str) {
  let dStr = "";

  for (let i = 0; i < str.length; i++){
      dStr += str[i]+str[i];
  }
  return dStr;
}

solutions.countHi = function countHi(str) {

  let count = 0;

  for (let i = 0; i < str.length; i++){
      if (str[i] + str[i+1] == "hi"){
          count +=1;
      }
  }
  return count;

}

solutions.catDog = function catDog(str) {
  let cat = 0;
  let dog = 0;

  for (let i = 0; i < str.length; i++) {
      if(str.substring(i, i+3) == "cat") {
          cat += 1;
      }
        if(str.substring(i, i+3) == "dog") {
          dog += 1;
          }

    }
    return cat == dog;
}

solutions.countCode = function countCode(str) {
  let count = 0;

    for (let i = 0; i < str.length; i++){
        if(str.substring(i, i+2) == "co" && str.substring(i+3, i+4) == "e"){
            count += 1;
        }
    }

    return count;
}

solutions.endOther = function endOther(a, b) {
  let short = "";
  let long = "";

    if (a == b) {
        return true;
    }

    if (a.length < b.length){
        short += a.toLowerCase();
        long += b.toLowerCase();
    } else {
        short += b.toLowerCase();
        long += a.toLowerCase();
    }

    let longEnd = long.substring(long.length -short.length);

    return longEnd == short;
}

solutions.xyzThere = function xyzThere(str) {
  let x = "xyz";
  for (let i = 0; i < str.length; i++){
    if(str.substring(i, i+3) == x && str.charAt(i-1, i) != "."){
        return true;
    }
  }
    return false;
}

solutions.bobThere = function bobThere(str) {
  for (let i = 0; i < str.length; i++){
      if (str.charAt(i) == "b" && str.charAt(i+2) == "b"){
          return true;
      }
  }
    return false;
}

solutions.xyBalance = function xyBalance(str) {
    let y = false;
    //backwards loop
    for(let i = str.length - 1; i >= 0; i--) {
        if(str.charAt(i) == 'y')
            y = true;

        if(str.charAt(i) == 'x' && !y)
            return false;
    }

    return true;
}

solutions.mixString = function mixString(a, b) {
    let large = "";
    let newStr = "";

    if (a.length > b.length) {
        large += a.length;
    } else {
        large += b.length;
    }

    for (let i = 0; i < large; i++) {
        if (a[i] != undefined) {
          newStr += a[i];
        }
        if (b[i] != undefined){
            newStr += b[i];
        }
    }

    return newStr;
}

solutions.repeatEnd = function repeatEnd(str, n) {
    let retStr = "";
  let sub = str.substring(str.length - n);

    while (n != 0) {
        retStr += sub;
        n--
    }

    return retStr;
}

solutions.repeatFront = function repeatFront(str, n) {

    let nu = "";

    for (let i = n; i > 0; i--){
        nu += str.substring(0, i);
    }

    return nu;
}

solutions.repeatSeparator = function repeatSeparator(word, sep, count) {
  let nu = "";

      if (count == 0){
        return "";
      }


    for (let i = 0; i < count - 1; i++){
        nu += word;
        nu += sep;
    }

    nu += word;

    return nu;
}

solutions.prefixAgain = function prefixAgain(str, n) {
    let prefix = str.substring(0, n);

    for (let i = str.length; i > n; i--){
        if(str.substring(i-n, i) == prefix) {
            return true;
        }
    }
    return false;
}

solutions.xyzMiddle = function xyzMiddle(str) {
    if(str.length < 3)
        return false;

    let start1 = str.length / 2 - 2;
    let start2 = str.length / 2 - 1;

    if(str.length % 2 == 0) {
        return str.substring(start1, start1 + 3) == "xyz" ||
            str.substring(start2, start2 + 3) == "xyz";
    }

    return str.substring(start2, start2 + 3) == "xyz";
}

solutions.getSandwich = function getSandwich(str) {
  let temp1 = "";
  let i1 = 0;
    for (let i = 0; i < str.length; i++){
        if (str.slice(i, i+5) == "bread") {
            temp1 = str.slice(i, i+5);
            i1 = i+5;
            break;
        }
    }
  let temp2 = "";
  let i2 = 0;
    for (let i = str.length; i >= 0; i--){
        if (str.slice(i-5, i) == "bread") {
            temp2 = str.slice(i-5, i);
            i2 = i-5;
            break;
        }
    }

    let res = "";

    for (let j = i1; j < i2; j++){
        res += str[j];
    }

    return res;
}

solutions.sameStarChar = function sameStarChar(str) {

    for (let i = 1; i < str.length - 1; i++){
        if (str.charAt(i) == '*' && str.charAt(i-1) != str.charAt(i+1)){
            return false;
        }
    }
    return true;
}

solutions.oneTwo = function oneTwo(str) {
    let nust = "";

    for (let i = 0; i < str.length-1; i+= 3){
        if (str[i+2] != undefined){
          nust += str[i+1]; //c
          nust += str[i+2]; //b
          nust += str[i]; //a
        }
  }
    return nust;
}

solutions.zipZap = function zipZap(str) {
  let nust = "";
  for (let i = 0; i < str.length; i++){
    if (str[i-1] != "z" || str[i+1] != "p"){
      nust += str[i];
    }
  }
  return nust;
}

solutions.starOut = function starOut(str) {
    if(str.length < 1)
        return "";

    if(str.length == 1) {
        if(str.charAt(0) == '*')
            return "";
        else
            return str;
    }

    let len = str.length;
    let arr = new Array();

    let count = 0;


    if(str.charAt(0) != '*' && str.charAt(1) != '*') {
        arr[count] = str.charAt(0);
        count++;
    }

    for(let i = 1; i < str.length - 1; i++) {
        if(str.charAt(i-1)!='*' && str.charAt(i) != '*' &&
            str.charAt(i+1) != '*') {
            arr[count] = str.charAt(i);
            count++;
        }
    }

    if(str.charAt(str.length-1) != '*' &&
        str.charAt(str.length-2) != '*') {
        arr[count] = str.charAt(str.length - 1);
        count++;
    }

    let x = arr.toString();

      return x.replace(/,/g, "");
}

solutions.plusOut = function plusOut(str, word) {
  let slen = str.length;
  let wlen = word.length;
  let fin = "";

  for (let i = 0; i < slen; i++) {
    if (i <= slen - wlen) {
      let tmp = str.substring(i,i+wlen);
      if (tmp == word) {
        fin += word;
        i += wlen-1;
      }
      else
        fin += "+";
    }
    else
      fin += "+";
  }
  return fin;
}

solutions.wordEnds = function wordEnds(str, word){
  let slen = str.length;
  let wlen = word.length;
  let res = "";

  if (slen.length < 1){
    return str;
  }

  for (let i = 0; i < slen; i++) {
    if (i <= slen - wlen){
      let temp = str.substring(i, i+wlen);
      if (temp == word){
        if (str[i-1] != undefined) {
          res += str[i-1];
        }
        if (str[i+wlen]){
          res+= str[i+wlen];
        }
        i += wlen-1;
      } else {

      }
    } else {

    }
  }
  return res;
}

// String-3

solutions.countYZ = function countYZ(str){
  let count=0;
  for (let i = 0; i < str.length; i++) {
    if (!str[i].match(/[a-z]/i) || str.charAt(i) == " ") {

        if (str.charAt(i-1).toLowerCase() == "y" || str.charAt(i-1).toLowerCase() == "z"){
        count += 1;
      }
    }
    if (i == str.length-1) {
        if (str.charAt(i).toLowerCase() == "y" || str.charAt(i).toLowerCase() == "z"){
        count += 1;
      }
    }
  }
  return count;
}

solutions.withoutString = function withoutString(base, remove){

  let rlen = remove.length;

  let res = "";

  for (let i = 0; i < base.length; i++){
    let subbie = base.substring(i, i+ rlen);
    if (subbie.toLowerCase() != remove.toLowerCase()) {
        if (base[i] == " " && res.charAt(res.length-1) == " "){
        }  else {
            res += base[i];
        }
    }  else {
      i += rlen-1;
    }
  }
  return res;
}

solutions.equalIsNot = function equalIsNot(str){
  let is = "is";
  let not = "not";

  let isCount = 0;
  let notCount = 0;

  for (let i = 0; i < str.length; i++) {
      let checkIs = str.substring(i, i+is.length);
      let checkNot = str.substring(i, i+not.length);

      if (checkIs == is){
        isCount += 1;
      }

      if (checkNot == not){
        notCount += 1;
      }
  }

  return isCount == notCount;

}

solutions.gHappy = function gHappy(str) {

  for (let i = 0; i < str.length; i++){
    if (str[i] == "g" && (str[i-1] != "g" && str[i+1] != "g")){
      return false;
    }
  }
  return true;
}

solutions.countTriple = function countTriple(str) {

  let count = 0;

  for (let i = 0; i <= str.length-2; i++) {
    let triple = str.substring(i, i+3);
    if (triple[0] == triple[1] && triple[1] == triple[2]){
      count += 1;
    }
  }
  return count;
}

solutions.sumDigits = function sumDigits(str) {

  let add = (a, b) => a+b;

  let nums = []

  for (let i = 0; i < str.length; i++) {

    if (Number.isInteger(parseInt(str[i]))) {
        nums.push(parseInt(str[i]))
    }
  }

    if (nums.length != 0) {
      return nums.reduce(add);
    } else {
      return 0;
    }
}

solutions.sameEnds = function sameEnds(string) {
    let start = Math.ceil(string.length/2);
    let end = string.length/2;

    for (let i = 0; i < string.length/2; i++){
      if (string.substring(0, end) == string.substring(start)){
        return string.substring(0, end);
      } else {
          start++;
          end--
      }
    }
  return "";
}

solutions.mirrorEnds = function mirrorEnds(string) {
    let result = "";

    for (let i = 0; i < string.length; i++) {
      if (string[i] == string[string.length - i - 1]) {
        result += string[i]
      } else {
        break;
      }
    }

    return result;
}

solutions.maxBlock = function maxBlock(str) {
  let count = 0;
  let stick = 1;

  for (let i = 0; i < str.length; i++){
    if (i < str.length-1 && str[i] == str[i+1]){
      stick += 1;
    } else {
      stick = 1;
    }

    if (stick > count){
      count= stick;
    }
  }

  return count;

}

solutions.sumNumbers = function sumNumbers(str) {

  let len = str.length;
  let temp = "";
  let sum = 0;

  for (let i = 0; i < str.length; i++){
    if (parseInt(str[i])){
      if (i < len-1 && parseInt(str[i+1])){
        temp+= str[i]
      } else {
        temp+= str[i]
        sum += parseInt(temp);
        temp="";
      }
    }
  }
  return sum;
}

solutions.notReplace = function notReplace(str) {

  let result = "";

  for (let i = 0; i < str.length; i++){
        /* using charAt here rather than bracket index, b/c bracket index shows undefined for chars at
      -1 index, causing error. charAt shows "", so no error*/
      if ((str.charAt(i-1).match(/[a-z]/i)
    || i+2 < str.length && str.charAt(i+2).match(/[a-z]/i))){
        result += str[i];
      } else if (str.substring(i, i+2) == "is"){
        result += "is not";
        i++;
      } else {

        result += str[i];
      }
    }
    return result;
}

module.exports = solutions;
},{}],228:[function(require,module,exports){
module.exports = [
  {
    title: "Warmup",
    name: "SleepIn",
    question: `The parameter WEEKDAY is TRUE if it is a weekday, and the parameter
         VACATION is FALSE if we are on vacation. We sleep in if it is not a weekday or
         we're on vacation. Output TRUE if we sleep in, FALSE if we do not.`,
    solution: `method sleepIn(WEEKDAY, VACATION)
  if NOT WEEKDAY OR VACATION then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [

      "(TRUE, TRUE)",
      "(TRUE, FALSE)",
      "(FALSE, TRUE)",
      "(FALSE, FALSE)"
    ],
  }, {
    title: "Warmup",
    name: "MonkeyTrouble",
    question: `We have two monkeys, a and b, and the parameters ASMILE and
              BSMILE indicate if each is smiling. We are in trouble if they are both smiling
              or if neither of them is smiling. Output TRUE if we are in trouble, FALSE otherwise.`,
    solution: `method MonkeyTrouble(ASMILE, BSMILE)
  if (ASMILE AND BSMILE) OR (NOT ASMILE AND NOT BSMILE) then
  // alternative: if ASMILE = BSMILE then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(TRUE, TRUE)",
      "(FALSE, FALSE)",
      "(TRUE, FALSE)",
      "(FALSE, TRUE)"
    ],
  }, {
    title: "Warmup",
    name: "SumDouble",
    question: `Given two numbers, output their sum. Unless the two values are the same,
       then output double their sum.`,
    solution: `method SumDouble(A, B)
  if A = B then
    output 2* (A + B)
  else
    output A + B
  end if
end method`,
    inputs: [
      "(1, 2)",
      "(3, 2)",
      "(2, 2)",
      "(-1, 0)",
      "(3, 3)",
      "(0, 0)",
      "(0, 1)",
      "(3, 4)"
    ],
  }, {
    title: "Warmup",
    name: "Diff21",
    question: `Given an number, N, output the absolute difference between N and 21,
                except output double the absolute difference if N is over 21.`,
    solution: `method Diff21(N)
  if N <= 21 then
    output 21 - N
  else
    output (N - 21) * 2
  end if
end method`,
    inputs: [
      "(19)",
      "(10)",
      "(21)",
      "(22)",
      "(25)",
      "(30)",
      "(0)",
      "(1)",
      "(2)",
      "(-1)",
      "(-2)",
      "(50)"
    ],
  }, {
    title: "Warmup",
    name: "ParrotTrouble",
    question: `We have a loud talking parrot. The "hour" parameter is the current hour time in the range 0..23.
    We are in trouble if the parrot is talking and the hour is before 7 or after 20.
    Output TRUE if we are in trouble.`,
    solution: `method ParrotTrouble(TALKING, HOUR)
  if TALKING AND (HOUR < 7 OR HOUR > 20) then
    output TRUE
  else 
    output FALSE
  end if
end method`,
    inputs: [
      "(TRUE, 6)",
      "(TRUE, 7)",
      "(FALSE, 6)",
      "(TRUE, 21)",
      "(FALSE, 21)",
      "(TRUE, 23)",
      "(FALSE, 23)",
      "(TRUE, 20)",
      "(FALSE, 12)"
    ],
  }, {
    title: "Warmup",
    name: "Makes10",
    question: `Given 2 numbers, A and B, Output TRUE if one if them is 10 or if their sum is 10.`,
    solution: `method Makes10(A, B)
  if A = 10 OR B = 10 OR (A + B = 10) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(9, 10)",
      "(9, 9)",
      "(1, 9)",
      "(10, 1)",
      "(10, 10)",
      "(8, 2)",
      "(8, 3)",
      "(10, 42)",
      "(12, -2)"
    ],
  }, {
    title: "Warmup",
    name: "NearHundred",
    question: `Given a number N, Output TRUE if it is within 10 of 100 or 200.`,
    solution: `method nearHundred(N) 
  if (100 - N) >= -10 AND (100 - N) <= 10 then
    output TRUE
  else if (200 - N) >= -10 AND (200 - N) <= 10 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(93)",
      "(90)",
      "(89)",
      "(110)",
      "(111)",
      "(121)",
      "(0)",
      "(5)",
      "(191)",
      "(189)"
    ],
  }, {
    title: "Warmup",
    name: "PosNeg",
    question: `Given 2 number values, Output TRUE if one is negative and one is positive.
          Except if the parameter NEGATIVE is TRUE, then output TRUE only if both are negative.`,
    solution: `method PosNeg(A, B, NEGATIVE) 
  if NEGATIVE then
    if A < 0 AND B < 0 then
      output TRUE
    else
      output FALSE
    end if
  else if (A < 0 AND B > 0) OR (A > 0 AND B < 0) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(1, -1, FALSE)",
      "(-1, 1, FALSE)",
      "(-4, -5, TRUE)",
      "(-4, -5, FALSE)",
      "(-4, 5, FALSE)",
      "(-4, 5, TRUE)",
      "(1, 1, FALSE)",
      "(-1, -1, FALSE)",
      "(1, -1, TRUE)",
      "(-1, 1, TRUE)",
      "(1, 1, TRUE)",
      "(-1, -1, TRUE)",
      "(5, -5, FALSE)",
      "(-6, 6, FALSE)",
      "(-5, -6, FALSE)",
      "(-2, -1, FALSE)",
      "(1, 2, FALSE)",
      "(-5, 6, TRUE)",
      "(-5, -5, TRUE)"
    ],
  }, {
    title: "Warmup",
    name: "NotString",
    question: `Given a string, output a new string where "not " has been added to the front. However,
      if the string already begins with "not", output the string unchanged. You can use the method STRING.SubStr(S,L)
      where S is the first index in the substring (first char is 0!) and L is how many chars you want`,
    solution: `method NotString(STR)
  if STR.SubStr(0,3) = "not" then
    output STR
  else 
    output "not"+ STR
  end if
end method`,
    inputs: [
      "('candy')",
      "('x')",
      "('not bad')",
      "('bad')",
      "('not')",
      "('is not')",
      "('no')"
    ],
  }, {
    title: "Warmup",
    name: "Front3",
    question: `Given a string, we'll say that the front is the first 3 chars of the string.
              If the string length is less than 3, the front is whatever is there. Output a new
              string which is 3 copies of the front. You can use the method STRING.SubStr(S,L)
              where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method Front3(STR) 
  FRONT = STR.SubStr(0,3)
  output FRONT + FRONT + FRONT
end method`,
    inputs: [
      "('Java')",
      "('Chocolate')",
      "('abc')",
      "('abcXYZ')",
      "('ab')",
      "('a')",
      "('')"
    ],
  }, {
    title: "Warmup",
    name: "Or35",
    question: `Output TRUE if the given non- negative number is a multiple of 3 or a
              multiple of 5.(Hint: Use the < code > mod operator)`,
    solution: `method Or35(n) 
  if n mod 3 = 0 OR n mod 5 = 0 then 
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(3)",
      "(10)",
      "(8)",
      "(15)",
      "(5)",
      "(4)",
      "(9)",
      "(4)",
      "(7)",
      "(6)",
      "(17)",
      "(18)",
      "(29)",
      "(20)",
      "(21)",
      "(22)",
      "(45)",
      "(99)",
      "(100)",
      "(101)",
      "(121)",
      "(122)",
      "(123)"
    ],
  }, {
    title: "Warmup",
    name: "Front22",
    question: `Given a string, take the first 2 chars and output the string with the 2
  chars added at both the front and back, so 'kitten' yields 'kikittenki'. You can use the method STRING.SubStr(S,L)
  where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method Front22(STR) 
  FRONT = STR.SubStr(0, 2)
  output FRONT + STR + FRONT
end method`,
    inputs: [
      "('kitten')",
      "('Ha')",
      "('abc')",
      "('ab')",
      "('a')",
      "('')",
      "('Logic')"
    ],
  }, {
    title: "Warmup",
    name: "StartHi",
    question: `Given a string, Output TRUE if the string starts with 'hi'and
  FALSE otherwise. You can use the method STRING.SubStr(S,L)
  where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method StartHi(STR) 
  FRONT = STR.SubStr(0,2);
  if FRONT = 'hi' then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "('hi there')",
      "('hi')",
      "('hello hi')",
      "('he')",
      "('h')",
      "('')",
      "('ho hi')",
      "('hi ho')"
    ],
  }, {
    title: "Warmup",
    name: "IcyHot",
    question: `Given two temperatures, Output TRUE if one is less than 0 and the
  other is greater than 100.`,
    solution: `method IcyHot(TEMP1, TEMP2) 
  if TEMP1 < 0 AND TEMP2 > 100 OR TEMP2 < 0 AND TEMP1 > 100 then
    output TRUE
  end if
  output FALSE
end method`,
    inputs: [
      "(120, -1)",
      "(-1, 120)",
      "(2, 120)",
      "(-1, 100)",
      "(-2, 120)",
      "(120, 120)"
    ],
  }, {
    title: "Warmup",
    name: "In1020",
    question: `Given 2 number values, Output TRUE if either or both of them is in the range
  10..20 inclusive.`,
    solution: `method In1020(A, B) 
  if (A >= 10 AND A <= 20) OR (B >= 10 AND B <= 20) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(12, 99)",
      "(21, 12)",
      "(8, 99)",
      "(99, 10)",
      "(20, 20)",
      "(21, 21)",
      "(9, 9)"
    ],
  }, {
    title: "Warmup",
    name: "HasTeen",
    question: `We'll say that a number is 'teen' if it is in the range 13..19 inclusive. Given 3 int values,
  Output TRUE if 1 or more of them are teen.`,
    solution: `method HasTeen(A, B, C) 
  if (A >= 13 AND A <= 19) OR (B >= 13 AND B <= 19) OR (C >= 13 AND C <= 19) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(13, 20, 10)",
      "(20, 19, 10)",
      "(20, 10, 13)",
      "(1, 20, 12)",
      "(19, 20, 12)",
      "(12, 20, 19)",
      "(12, 9, 20)",
      "(12, 18, 20)",
      "(14, 2, 20)",
      "(4, 2, 20)",
      "(11, 22, 22)"
    ],
  }, {
    title: "Warmup",
    name: "LoneTeen",
    question: `We'll say that a number is 'teen' if it is in the range 13..19 inclusive.
  Given 2 int values, Output TRUE if one or the other is teen, but not both.`,
    solution: `method LoneTeen(A, B) 
  if A >=13 AND A <=19 AND (B < 13 OR B > 19) then
    output TRUE
  else if (A < 13 OR A > 19) AND B >= 13 AND B <= 19 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(13, 99)",
      "(21, 19)",
      "(13, 13)",
      "(14, 20)",
      "(20, 15)",
      "(16, 17)",
      "(16, 9)",
      "(16, 18)",
      "(13, 19)",
      "(13, 20)",
      "(6, 18)",
      "(99, 13)",
      "(99, 99)"
    ],
  }, {
    title: "Warmup",
    name: "MixStart",
    question: `Output TRUE if the given string begins with 'mix', except the 'm' can be
  anything, so 'pix', '9ix'..all count. You can use the method STRING.SubStr(S,L) to get a substring
  where S is the first index in the substring (first char is 0!) and L is how many chars you want (at max).`,
    solution: `method MixStart(STR) 
  if STR.length < 3 then
    output FALSE
  end if
  TWO = STR.SubStr(1, 2);
  if TWO = 'ix' then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "('mix snacks')",
      "('pix snacks')",
      "('piz snacks')",
      "('nix')",
      "('ni')",
      "('n')"
    ],
  }, {
    title: "Warmup",
    name: "IntMax",
    question: `Given three int values, A, B, and C, output the largest.`,
    solution: `method IntMax(A, B, C) 
  MAX = 0
  if A > B then
    MAX = A
  else
    MAX = B
  end if
  if C > MAX then
    MAX = C
  end if
  output MAX
end method`,
    inputs: [
      "(1, 2, 3)",
      "(1, 3, 2)",
      "(3, 2, 1)",
      "(9, 3, 3)",
      "(3, 9, 3)",
      "(3, 3, 9)",
      "(8, 2, 3)",
      "(-3, -1, -2)",
      "(6, 2, 5)",
      "(5, 6, 2)",
      "(5, 2, 6)"
    ],
  }, {
    title: "Warmup",
    name: "Close10",
    question: `Given 2 int values, output whichever value is nearest to the value 10,
    or output 0 in the event of a tie.`,
    solution: `method Close10(A, B) 
  ADF = A - 10
  if ADF < 0 then
    ADF = 10 - A
  end if

  BDF = B - 10
  if BDF < 0 then
    BDF = 10 - B
  end if

  if ADF < BDF then
    output A
  else if BDF < ADF then
    output B
  else
    output 0
  end if
end method`,
    inputs: [
      "(8, 13)",
      "(13, 8)",
      "(13, 7)",
      "(7, 13)",
      "(9, 13)",
      "(13, 8)",
      "(10, 12)",
      "(11, 10)",
      "(5, 21)",
      "(0, 20)",
      "(0, 20)",
      "(10, 10)"
    ],
  }, {
    title: "Warmup",
    name: "StringE",
    question: `Output TRUE if the given string contains between 1 and 3 e chars. 
      Hint: the length of a string can be found using the STR.Length() method, and you can access one char
      within a string using brackets, so if ST = "ABC" then ST[1] gives you a B`,
    solution: `method StringE(STR) 
  COUNT = 0
  loop I from 0 to STR.Length()
    if STR[I] = 'e' then
      COUNT = COUNT + 1
    end if
  end loop
  if COUNT >= 1 AND COUNT <= 3 then
    output TRUE
  else
    output FALSE 
  end if
end method`,
    inputs: [
      "('Hello')",
      "('Heelle')",
      "('Heelele')",
      "('HII')",
      "('e')",
      "('')"
    ],
  }, {
    title: "Warmup",
    name: "LastDigit",
    question: `Given two non - negative int values, Output TRUE if they have the same
  last digit, such as with 27 and 57. Note that the mod operator computes
  remainders, so 17 mod 10 is 7.`,
    solution: `method LastDigit(A, B) 
  if A mod 10 = B mod 10 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(7, 17)",
      "(6, 17)",
      "(3, 113)",
      "(114, 113)",
      "(114, 4)",
      "(10, 0)",
      "(11, 0)"
    ],
  }, {
    title: "Warmup",
    name: "EveryNth",
    question: `Given a non - empty string and an int N, output the string made starting
  with char 0, and then every Nth char of the string. So if N is 3, use char 0, 3, 6,
                     ...and so on. N will always be 1 or more.`,
    solution: `method EveryNth(STR, N) 
  RESULT = ""
  COUNT = 0
  loop while COUNT < STR.Length()
    RESULT = RESULT + STR[COUNT]
    COUNT = COUNT + N
  }
  output RESULT
end method`,
    inputs: [
      "('Miracle', 2)",
      "('abcdefg', 2)",
      "('abcdefg', 3)",
      "('Chocolate', 3)",
      "('Chocolates', 3)",
      "('Chocolates', 4)",
      "('Chocolates', 100)"
    ],
  }, {
    title: "Warmup",
    name: "StringTimes",
    question: `Given a string and a non-negative integer N, output a larger string that is N
  copies of the original string.`,
    solution: `method StringTimes(STR, N) 
  FINAL = ""
  loop I from 1 to N 
    FINAL = FINAL + STR
  end loop
  output FINAL
end method`,
    inputs: [
      "('Hi', 2)",
      "('Hi', 3)",
      "('Hi', 1)",
      "('Hi', 0)",
      "('Hi', 5)",
      "('Oh Boy!', 2)",
      "('x', 4)",
      "('', 4)",
      "('code', 2)",
      "('code', 3)"
    ],
  }, {
    title: "Warmup",
    name: "FrontTimes",
    question: `Given a string and a non - negative int n, we'll say that the front of the string is the first 3 chars,
  or whatever is there if the string is less than length 3. Output n copies of the front.`,
    solution: `method FrontTimes(STR, N) 
  FRONT = STR.SubStr(0,3)
  RESULT = ""
  loop X from 1 to N 
    RESULT = RESULT + FRONT
  end loop
  output RESULT
end method`,
    inputs: [
      "('Chocolate', 2)",
      "('Chocolate', 3)",
      "('Abc', 3)",
      "('Ab', 4)",
      "('A', 4)",
      "('',4)",
      "('Abc', 0)"
    ],
  }, {
    title: "Warmup",
    name: "StringBits",
    question: `Given a string, output a new string made of every other char starting
  with the first, so "Hello" yields "Hlo".`,
    solution: `method StringBits(STR) 
  OUT = ""
  X = 0
  loop while X < STR.length
    OUT = OUT + STR.SubStr(X, 1)
    X = X + 2
  end loop
  output OUT
end method`,
    inputs: [
      "('Hello')",
      "('Hi')",
      "('Heeololeo')",
      "('HiHiHi')",
      "('')",
      "('Greetings')",
      "('Chocolate')",
      "('pi')",
      "('Hello Kitten')",
      "('hxaxpxpxy')"
    ],
  }, {
    title: "Warmup",
    name: "StringSplosion",
    question: `Given a non-empty string like "Code" output a string like "CCoCodCode".`,
    solution: `method StringSplosion(STR) 
  RESULT = ""
  loop X from 1 to STR.Length()
    RESULT = RESULT + STR.SubStr(0, X)
  end loop
  output RESULT
end method`,
    inputs: [
      '("Code")',
      '("Bob")',
      '("Apple")',
      '("Str")',
      '("123")'
    ],
  }, {
    title: "Warmup",
    name: "ArrayCount9",
    question: `Given an array of ints, output the number of 9's in the array.`,
    solution: `method ArrayCount9(NUMS) 
  COUNT = 0
  loop X from 0 to NUMS.Length()-1
    if NUMS[X] = 9 then
      COUNT = COUNT + 1
    end if
  end loop
  output COUNT
end method`,
    inputs: [
      "([1,2,9])",
      "([1,9,9])",
      "([1,9,9,3,9])",
      "([1,2,3])",
      "([])",
      "([4,2,4,3,1])",
      "([9,2,4,3,1])"
    ],
  }, {
    title: "Warmup",
    name: "ArrayFront9",
    question: `Given an array of ints, Output TRUE if one of the first 4 elements in
            the array is a 9. The array length may be less than 4.`,
    solution: `method ArrayFront9(NUMS) 
  END = 3
  FOUND = FALSE
  if NUMS.Length() < 4 then
    END = NUMS.Length() - 1
  end if
  loop X from 0 to END
    if NUMS[X] = 9 then
      FOUND = TRUE
    end if
  end loop
  output FOUND
end method`,
    inputs: [
      "([1,2,9,3,4])",
      "([1,2,3,4,9])",
      "([1,2,3,4,5])",
      "([9,2,3])",
      "([1,9,9])",
      "([1,2,3])",
      "([1,9])",
      "([5,5])",
      "([2])",
      "([9])",
      "([])",
      "([3,9,2,3,3])"
    ],
  }, {
    title: "Warmup",
    name: "Array123",
    question: `Given an array of ints, Output TRUE if the sequence of numbers 1, 2, 3
          appears in the array somewhere.`,
    solution: `method Array123(NUMS) 
    FOUND = FALSE
    loop I from 0 to NUMS.Length()-3
      if NUMS[I] = 1 AND NUMS[I+1] = 2 AND NUMS[I+2] = 3 then
        FOUND = TRUE
      end if
    end loop
    output FOUND
end method`,
    inputs: [
      '([1,2,3,4])',
      '([4, 5, 1, 2, 3, 4])',
      '([1, 2, 1, 3, 3])',
      '([3, 2, 1])',
      '([0, 0, 1, 2, 0, 1, 2, 3])'
    ],
  }, {
    title: "Warmup",
    name: "StringX",
    question: `Given a string, output a version where all the "x" have been removed.
              Except an "x" at the very start or end should not be removed.`,
    solution: `method StringX(STR) 
  RESULT= STR.SubStr(0,1)
  
  loop I from 1 to STR.Length() - 2
    if STR.SubStr(I,1) != "x" then
      RESULT = RESULT + STR.SubStr(I,1)
    end if
  end loop
  RESULT = RESULT + STR.SubStr(STR.Length() - 1,1)
  output RESULT
end method`,
    inputs: [
      "('xxHxix')",
      "('abxxxcd')",
      "('xabxxxcdx')",
      "('xKxixtxtxexn')",
      "('Hello')",
      "('xx')",
    ],
  }, {
    title: "Warmup",
    name: "Array667",
    question: `Given an array of integers, output the number of times that the array has a 6 followed by either a 6 or a 7`,
    solution: `method Array667(NUMS) 
  COUNT = 0
  loop X from 0 to NUMS.length -1
    if NUMS[X] = 6 then
      if NUMS[X + 1] = 6 OR NUMS[X + 1] = 7 then
        COUNT = COUNT + 1
      end if
    end if
  end loop
  output COUNT
end method`,
    inputs: [
      "([6,6,2])",
      "([6,6,2,6])",
      "([6,7,2,6])",
      "([6,6,2,7,6,7])",
      "([1,6,3])",
      "([6,1])",
      "([])",
      "([3,6,7,6])",
      "([3,6,6,7])",
      "([6,3,6,6])",
      "([6,7,6,6])",
      "([1,2,3,5,6])",
      "([1,2,3,6,6])"
    ],
  }, {
    title: "Warmup",
    name: "NoTriples",
    question: `Given an array of integers, we'll say that a triple is a value appearing 3 times
                  in a row in the array. Output TRUE if the array does not contain any triples.`,
    solution: `method NoTriples(NUMS) 
    TRIPLEFOUND = FALSE
    loop X from 0 to NUMS.length - 3
    if NUMS[X] = NUMS[X+1] AND NUMS[X] = NUMS[X+2] then
        TRIPLEFOUND = TRUE
    end if
  end loop 
  output NOT TRIPLEFOUND
end method`,
    inputs: [
      "([1,1,2,2,1])",
      "([1,1,2,2,2,1])",
      "([1,1,2,2,2,1])",
      "([1,2,1])",
      "([1,1,1])",
      "([1,1])",
      "([1])",
      "([1])",
      "([])"
    ],
  }, {
    title: "Warmup",
    name: "Has271",
    question: `Given an array of ints, Output TRUE if it contains a 2, 7, 1
                  pattern -- a value, followed by the value plus 5, followed by the value
                  minus 1.`,
    solution: `method Has271(NUMS) 
    FOUND = FALSE
    loop X from 0 to NUMS.length - 3
    if NUMS[X] + 5 = NUMS[X + 1] AND NUMS[X] - 1 = NUMS[X+2] then
        FOUND = TRUE
    end if
  end loop 
  output FOUND
end method`,
    inputs: [
      "([1,2,7,1])",
      "([1,2,8,1])",
      "([2,7,1])",
      "([3,8,2])",
      "([2,7,3])",
      "([2,7,4])",
      "([2,7,-1])",
      "([2,7,-2])",
      "([4,5,3,8,0])",
      "([2,7,5,10,4])",
      "([2,7,-2,4,9,3])",
      "([2,7,5,10,1])",
      "([2,7,-2,10,2])"
    ],
  },
];
},{}],229:[function(require,module,exports){
const CodeMirror = require("codemirror-minified");
const runPS = require("./utility/convertPStoJS");
const exercises = require("./allExercisesIncludingHidden.js");
const solutions = require("./solutions.js");
const defaultInput = require("./utility/defaultInput.js");
const deParam = require("./utility/deParam.js");
const inputParser = require("./utility/inputParser.js");
const tableHeader = require("./utility/tableHeader.js");
const formatResults = require("./utility/formatResults.js");
const setInitialEditorContents = require("./utility/setInitialEditorContents.js");
const displayExampleRuns = require("./utility/displayExampleRuns.js");
const prettyPrintMap = require("./utility/prettyPrintMap.js");
const exerciseListeners = require("./listeners/exerciseListeners");
const keyboardShortcuts = require("./listeners/keyboardShortcuts");
require("./listeners/darkModeCheckbox.js");


require("../node_modules/codemirror-minified/addon/edit/matchbrackets.js");
const CodeMirrorPSHighlighting = require("./utility/cmps.js");
CodeMirrorPSHighlighting(CodeMirror);
// define codemirror editor to interact with code on page
const editor = CodeMirror.fromTextArea(document.getElementById("answer"), {
  lineNumbers: true,
  matchBrackets: true,
  mode: "pseudocode",
  viewportMargin: Infinity,
  lineWrapping: true,
  extraKeys: {
    "Cmd-/": "toggleComment",
    "Ctrl-/": "toggleComment",
    Tab: cm => cm.execCommand("indentMore"),
    "Shift-Tab": cm => cm.execCommand("indentLess"),
  },
});
editor.getWrapperElement().style.height = "auto";
editor.setSize("100%", "auto");

const solutionArea = CodeMirror.fromTextArea(document.getElementById("solution"), {
  readOnly: true,
  mode: "pseudocode",
  viewportMargin: Infinity,
  lineWrapping: true,
  lineNumbers: true,
  cursorBlinkRate: -1,
});
solutionArea.getWrapperElement().style.display = "none";


// Work out which excercise to show
const urlParams = deParam(window.location.search);
const exerciseName = urlParams.name || exercises[0].name;
/** here we match the exerciseName (from querystring) to the problem in exercise obj**/
const exercise = exercises.filter(ex => ex.name === exerciseName)[0];
let solution = exercise.solution || solutions[exerciseName];

exerciseListeners(editor, exerciseName);
keyboardShortcuts(editor, exerciseName);

// display exercise page
document.getElementById('title').innerText = exercise.title;
document.getElementById('name').innerText = exercise.name;
document.getElementById('problem').innerHTML = exercise.question;

setInitialEditorContents(editor, exerciseName, exercise);
displayExampleRuns(exercise, exerciseName);


document.getElementById("defaults").addEventListener('click', () => {
  editor.setValue(`${defaultInput(exercise)}`);
});

document.getElementById("solve").addEventListener('click', () => {
  document.querySelectorAll('tr').forEach((e) => e.remove());
  document.getElementById("tests").append(tableHeader());
  const answer = editor.getValue();

  // whenever the user checks their solution,
  // save the most recent version of their code to localStorage
  const exerciseCode = `${exerciseName} - code`;
  localStorage.setItem(exerciseName, "attempted");
  localStorage.setItem(exerciseCode, answer);


  try {
    document.querySelectorAll(".congrats").forEach((e) => e.innerText = "");
    document.querySelectorAll(".errorMessage").forEach((e) => e.innerText = "");
    const inputs = exercise.inputs;

    const results = [];
    inputs.forEach((inputStr) => {
      const input = inputParser(exercise, inputStr);
      let result;
      let idealResult;

      // if the input is an array/object, make a copy to avoid user changing the passed version...
      const inputCopy = inputParser(exercise, inputStr);

      if (exercise.inputType === "map") {
        const formattedInput = prettyPrintMap(input, "parentheses");
        if (typeof (solution) === "string") {
          //we have a pseudocode solution!
          [idealResult, idealOut] = runPS(solution, input, exercise.preamble);
        } else {
          idealOut = "";
          idealResult = solution(...input);
        }
        [result, output] = runPS(answer, input);
        const formattedMapIdealResult = prettyPrintMap(idealResult);
        const formattedMapUserResult = prettyPrintMap(result);

        document.getElementById("tests").append(formatResults(exerciseName, formattedInput, formattedMapIdealResult, formattedMapUserResult, idealOut, output));
      } else {
        if (typeof (solution) === "string") {
          //we have a pseudocode solution!
          [idealResult, idealOut] = runPS(solution, inputCopy, exercise.preamble);
        } else {
          idealOut = "";
          idealResult = solution(...inputCopy);
        }
        [result, output] = runPS(answer, inputCopy, exercise.preamble);

        document.getElementById("tests").append(formatResults(input, idealResult, result, idealOut, output));
      }

      if (idealOut === "") {
        results.push(result === idealResult);
      } else {
        results.push(output === idealOut);
      }
    });

    if (results.every(isTrue)) {
      document.querySelectorAll(".congrats").forEach((e) => e.innerText = "100% Passing. Well Done!");
      localStorage.setItem(exerciseName, "solved");
    }
  } catch (theError) {
    document.querySelectorAll(".congrats").forEach((e) => e.innerText = "");
    document.querySelectorAll('th').forEach((e) => e.remove());
    document.querySelectorAll(".errorMessage").forEach((e) => e.innerText = theError);
    console.log(theError.stack);
  }
});

document.getElementById("showSolution").addEventListener('click', () => {
  if (document.getElementById("showSolution").innerText === "Show Solution") {
    const s = solution.toString();
    const r = new RegExp(/function/);
    // eslint-disable-next-line no-unused-vars
    const n = s.replace(r, `function ${exercise.name}`);
    editor.getWrapperElement().style.display = "none";

    solutionArea.setValue(s);
    solutionArea.getWrapperElement().style.display = "block";
    solutionArea.setSize("100%", "auto");
    document.getElementById("showSolution").innerText = "Hide Solution";
  } else {
    document.getElementById("showSolution").innerText = "Show Solution";
    editor.getWrapperElement().style.display = "block";
    solutionArea.getWrapperElement().style.display = "none";
  }
});

function isTrue(someValue) {
  return someValue === true;
}

},{"../node_modules/codemirror-minified/addon/edit/matchbrackets.js":34,"./allExercisesIncludingHidden.js":213,"./listeners/darkModeCheckbox.js":236,"./listeners/exerciseListeners":237,"./listeners/keyboardShortcuts":239,"./solutions.js":241,"./utility/cmps.js":242,"./utility/convertPStoJS":244,"./utility/deParam.js":245,"./utility/defaultInput.js":246,"./utility/displayExampleRuns.js":247,"./utility/formatResults.js":248,"./utility/inputParser.js":249,"./utility/prettyPrintMap.js":250,"./utility/setInitialEditorContents.js":252,"./utility/tableHeader.js":254,"codemirror-minified":35}],230:[function(require,module,exports){

let warmupExercises = require("./data/warmup.js");
//let stringExercises = require("./data/string.js");
let recursionExercises = require("./data/recursion.js");
let logicExercises = require("./data/logic.js");
let arrayExercises = require("./data/array.js");
let apExercises = require("./data/ap.js");
let collectionsExercises = require("./data/collections.js");
//let mapExercises = require("./data/map.js");
let advExercises = require("./data/advancedDataStructures.js")

let mainPageExercises = [...warmupExercises, ...arrayExercises,
...collectionsExercises, ...advExercises, ...logicExercises,
...recursionExercises, ...apExercises];

module.exports = mainPageExercises;
},{"./data/advancedDataStructures.js":214,"./data/ap.js":215,"./data/array.js":217,"./data/collections.js":219,"./data/logic.js":220,"./data/recursion.js":225,"./data/warmup.js":228}],231:[function(require,module,exports){
let deParam = require("./utility/deParam.js");
let exercises = require("./exercisesToShowOnIndex.js");
require("./listeners/indexSaveLoadAll.js");
require("./listeners/darkModeCheckbox.js");

function uniq(a) {
  var temp = {};
  for (var i = 0; i < a.length; i++)
    temp[a[i]] = true;
  return Object.keys(temp);
}

let title = deParam(window.location.search).title;
let allTitles = uniq(exercises.map(e => e.title));
let titles = title ? [title] : allTitles;

// display all problems
for (title of titles) {
  let outerDiv = document.getElementById('exerciseIndex');
  outerDiv.innerHTML += `<h3 class="probTitle" id="${title}">${title}</h3>`;

  let div = document.createElement("div");
  div.classList.add("problems");
  document.getElementById("exerciseIndex").appendChild(div);

  let x = exercises.filter((ex) => ex.title == title);

  x.forEach((ex) => {
    let sp = document.createElement("sp");
    sp.classList.add("exercise-link");
    sp.id = `${ex.name}`;
    sp.innerHTML = `<a href='exercise.html?name=${ex.name}&title=${ex.title}'>${ex.name}</a>&nbsp;`;
    div.appendChild(sp);
    sp.insertAdjacentHTML("afterend", "<br>");
    if (localStorage[ex.name] === "solved") {
      sp.insertAdjacentHTML('beforeend', '<span class="tick"><b></b></span>');
    } else if (localStorage[ex.name] === "attempted") {
      sp.insertAdjacentHTML('beforeend', '<span class="wrong"><b></b></span>')
    }
  });

}


},{"./exercisesToShowOnIndex.js":230,"./listeners/darkModeCheckbox.js":236,"./listeners/indexSaveLoadAll.js":238,"./utility/deParam.js":245}],232:[function(require,module,exports){

function loadAllSolutionsFromFile() {
  let fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
      // localStorage.clear();
      let parsedFile = JSON.parse(reader.result);
      writeLocalStorage(parsedFile);
      location.reload();
      fileInput.value = '';
    };
    reader.readAsText(file);
  });
  $("#fileInput").click(); // activate the hidden file input
}

function writeLocalStorage(data) {
  Object.keys(data).forEach(function (key) { localStorage.setItem(key, data[key]) });
}

module.exports = loadAllSolutionsFromFile;
},{}],233:[function(require,module,exports){
module.exports = function loadCodeFile(editor) {
  // remove_fileInput_listener();
  let fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
      editor.setValue(reader.result);
      fileInput.value = '';
    };
    reader.readAsText(file);
  });
  document.querySelector("#fileInput").click(); // activate the hidden file input
}
},{}],234:[function(require,module,exports){
//let FileSaver = require('file-saver');

function saveAllSolutionsToFile() {
  let allSolutions = getLocalStorage();
  let blob = new Blob([allSolutions], {
    type: "text/javascript;charset=utf-8"
  });
  //FileSaver.saveAs(blob, "combinedSolutions.js", true);
}

function getLocalStorage() {
  return JSON.stringify(localStorage);
}

module.exports = saveAllSolutionsToFile;
},{}],235:[function(require,module,exports){
//let FileSaver = require('file-saver');

module.exports = function saveCodeFile(editor, exerciseName) {
  // event.preventDefault(); // is this needed?
  let blob = new Blob([editor.getValue()], {
    type: "text/javascript;charset=utf-8"
  });
  //FileSaver.saveAs(blob, exerciseName + ".js", true);
}

},{}],236:[function(require,module,exports){
var checkbox = document.querySelector("#darkmodecheckbox");
if (localStorage.getItem("darkMode") === "true") {
  checkbox.checked = true;
  document.querySelector("html").classList.remove("light");
  document.querySelector("html").classList.add("dark");
} else {
  checkbox.checked = false;
  document.querySelector("html").classList.add("light");
  document.querySelector("html").classList.remove("dark");
}

checkbox.addEventListener("input", (e) => {
  if (checkbox.checked === true) {
    localStorage.setItem("darkMode", "true");
    document.querySelector("html").classList.remove("light");
    document.querySelector("html").classList.add("dark");
  } else {
    localStorage.setItem("darkMode", "false");
    document.querySelector("html").classList.add("light");
    document.querySelector("html").classList.remove("dark");
  }
});

},{}],237:[function(require,module,exports){
let exercises = require("../exercisesToShowOnIndex");
let saveCodeFile = require("../io/saveCodeFile.js");
let loadCodeFile = require("../io/loadCodeFile.js");

function findIndex(array, name) {
    for (let i = 0; i < array.length; i++) {
        if (array[i].name === name) {
            return i;
        }
    }
    return i;
}

module.exports = function (editor, exerciseName) {

    document.querySelector('#next').addEventListener('click', () => {
        let indx = findIndex(exercises, exerciseName) + 1;
        if (indx >= exercises.length) indx = exercises.length - 1;
        let x = exercises[indx];
        window.location.search = `?name=${x.name}&title=${x.title}`
    })

    document.querySelector('#previous').addEventListener('click', () => {
        let indx = findIndex(exercises, exerciseName) - 1;
        if (indx < 0) indx = 0;
        let x = exercises[indx];
        window.location.search = `?name=${x.name}&title=${x.title}`
    })

    document.querySelector('#save').addEventListener('click', () => {
        saveCodeFile(editor, exerciseName);
    })

    document.querySelector('#open').addEventListener('click', () => {
        loadCodeFile(editor);
    })

};
},{"../exercisesToShowOnIndex":230,"../io/loadCodeFile.js":233,"../io/saveCodeFile.js":235}],238:[function(require,module,exports){

let saveAllSolutionsToFile = require("../io/saveAllSolutionsToFile.js");
let loadAllSolutionsFromFile = require("../io/loadAllSolutionsFromFile.js");


document.querySelector('#saveAll').addEventListener('click', () => {
    saveAllSolutionsToFile();
})

document.querySelector('#loadAll').addEventListener('click', () => {
    loadAllSolutionsFromFile();
})
},{"../io/loadAllSolutionsFromFile.js":232,"../io/saveAllSolutionsToFile.js":234}],239:[function(require,module,exports){
let saveCodeFile = require("../io/saveCodeFile.js");
let loadCodeFile = require("../io/loadCodeFile.js");

module.exports = function (editor, exerciseName) {
  //allow user to save/open code with keyboard shortcuts
  document.addEventListener("keydown", function (e) {
    if (e.keyCode == 83 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      saveCodeFile(editor, exerciseName);
    }
    if (e.keyCode == 79 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      loadCodeFile(editor);
    }
    if (e.key == "Enter" && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      document.querySelector("#solve").click(); //run code on ctrl-enter
    }
    // if (e.keyCode == 74 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
    //   e.preventDefault();
    //   $("#jsref-link").click(); //help screen on ctrl-j
    // }
    // if (e.keyCode == 191 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
    //   e.preventDefault();
    //   editor.toggleComment();
    // }
  });
};
},{"../io/loadCodeFile.js":233,"../io/saveCodeFile.js":235}],240:[function(require,module,exports){
var pathSuffix = location.pathname.split('/').splice(-1)[0]
if (pathSuffix === "") {
  // main page
  require("./indexPage.js");
}

else if (pathSuffix === "exercise.html") {
  // individual problem/exercise page
  require("./exercisePage.js");
}

// this lets you not display anything until the entire page is ready (since we set html
//  to invisible in style.css)
// useful, since otherwise you see the transition from textarea to codemirror, etc...
document.addEventListener("DOMContentLoaded", () =>
  document.getElementsByTagName("html")[0].style.visibility = "visible");
},{"./exercisePage.js":229,"./indexPage.js":231}],241:[function(require,module,exports){
let stringSolutions = require("./data/stringSolutions.js");
let recursionSolutions = require("./data/recursionSolutions.js");
let logicSolutions = require("./data/logicSolutions.js");
let arraySolutions = require("./data/arraySolutions.js");
let apSolutions = require("./data/apSolutions.js");
let mapSolutions = require("./data/mapSolutions.js");
let quizSolutions = require("./data/quizSolutions.js");
// this ES2018 spread syntax was causing browserify problems, so I replaced it below...
// let solutions = {...warmupSolutions, ...stringSolutions };

/** There's no limit to the number of objects you can merge.
 *  All objects get merged into the first object. 
 *  Only the object in the first argument is mutated and returned.
 *  Later properties overwrite earlier properties with the same name. */
let solutions = Object.assign({},
  stringSolutions,
  recursionSolutions,
  logicSolutions,
  arraySolutions,
  apSolutions,
  mapSolutions,
  quizSolutions
);

module.exports = solutions;
},{"./data/apSolutions.js":216,"./data/arraySolutions.js":218,"./data/logicSolutions.js":221,"./data/mapSolutions.js":222,"./data/quizSolutions.js":224,"./data/recursionSolutions.js":226,"./data/stringSolutions.js":227}],242:[function(require,module,exports){
module.exports = function CodeMirrorPSHighlighting(CodeMirror) {
  CodeMirror.defineMode("pseudocode", function () {
    var define = ["method", "class"];
    var keywords = ["override", "overload", "new", "loop", "from",
      "while", "if", "then", "else", "AND", "OR", "NOT", "end", "method", "mod", "div"];
    var operator = /^[+\-*&%=<>!?|~^]/;
    var bracket = /^[:;\(\)\[\]\{\}]/;
    var atom = ["TRUE", "FALSE", "output", "input"];
    var number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;
    var word = /^\w+(?:'\w+)?/;
    var uword = /^[A-Z_][A-Z_0-9]+/;

    define = new RegExp("((" + define.join(")|(") + "))\\b");
    keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
    atom = new RegExp("((" + atom.join(")|(") + "))\\b");

    function tokenBase(stream, state) {
      function internalTokenBase(stream, state) {
        var ch = stream.peek();

        if (stream.eol()) {
          state.define = false;
        }

        if (state.incomment) {
          if (!stream.skipTo("*/")) {
            stream.skipToEnd();
          } else {
            stream.eatWhile(/\*|\//);
            state.incomment = false;
          }
          return "doc-multiline";
        }
        else if (state.instring) {
          if (ch == state.instring) {
            state.instring = false;
          }
          stream.next();
          return "string";
        }
        else if (ch == "'" || ch == '"') {
          state.instring = ch;
          stream.next();
          return "string";
        }
        else if (stream.eat("/")) {
          if (stream.eat("*")) {
            state.incomment = true;
            if (!stream.skipTo("*/")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\*|\//);
              state.incomment = false;
            }
            return "doc-multiline";
          }
          else if (stream.eat("/")) {
            if (stream.match(/\s*\.\.\.+\s*$/)) {
              stream.skipToEnd();
              return "comment";
            }
            stream.skipToEnd();
            return "doc";
          }
        } else {
          if (stream.eat(" ")) {
            stream.eatSpace();
            return;
          }
          else {
            if (state.sol && stream.match(define)) {
              state.define = true;
              state.def_mode = 1;
              return "keyword";
            }
            if (stream.match(keywords)) {
              state.define = false;
              state.def_mode = null;
              return "keyword";
            }
            if (stream.match(atom)) {
              return "atom";
            }
            if (stream.match(operator)) {
              return "operator";
            }
            if (stream.match(bracket)) {
              state.define = false;
              state.def_mode = null;
              return "bracket";
            }
            if (stream.match(number)) {
              return "number";
            }
            if (stream.match(uword)) {
              return "variable";
            }
            if (stream.match(word)) {
              if (state.define) {
                var token = "def";
                return token;
              }
              return "variable";
            }
          }
        }

        stream.next();
      }

      if (stream.sol()) {
        state.sol = true;
      }
      var result = internalTokenBase(stream, state);
      if (result) {
        state.sol = false;
      }
      return result;
    }

    return {
      startState: function () {
        return {};
      },
      token: function (stream, state) {
        return tokenBase(stream, state);
      }
    };
  });

  CodeMirror.defineMIME("text/x-pseudocode", "pseudocode");
}
},{}],243:[function(require,module,exports){
const JSON5 = require('json5');
const { strCount } = require('../data/recursionSolutions');
module.exports = class Collection {

  elements = [];
  index = 0;

  /**
   * Creates an IB style collection from the elements in an array
   * @param {Array} [arr=[]] - Array with starting values, defaults to empty
   */
  constructor(arr) {
    if (Array.isArray(arr)) {
      this.elements = arr;
    }
  }

  addItem(a) {
    this.elements.push(a);
  }

  resetNext() {
    this.index = 0;
  }

  hasNext() {
    return (this.index < this.elements.length)
  }

  getNext() {
    this.index++;
    return this.elements[this.index - 1];
  }

  isEmpty() {
    return this.elements.length === 0;
  }

  toString() {
    var str = JSON5.stringify(this.elements);
    str = str.replaceAll(",", ", ").replaceAll("[", "{").replaceAll("]", "}");
    return str;
  }
}
},{"../data/recursionSolutions":226,"json5":98}],244:[function(require,module,exports){
const Collection = require("./collections")
const Queue = require("./queues")
const Stack = require("./stacks")
const JSON5 = require("json5");
// these three variables help the translation work
var out;
var TRUE = true;
var FALSE = false;

/**
 * takes pseudocode, converts to javascript, and runs it on the input
 * @param {function} f
 * @param {any} input
 * @return {any}
 */
module.exports = function runPS(code, i, preamble) {
  if (preamble === undefined) preamble = "";
  let lines = getLines(code);
  var c = "";
  for (const line of lines) {
    c += translate(line) + "\n";
  }
  let userCode;
  try {
    eval(`${preamble};out="";TRUE=true;FALSE=false;userCode=${c}`);
  } catch (e) {
    console.log("Error, here is the translated function")
    console.log(c);
    throw (e);
  }
  var ret = userCode(...i);
  return [ret, out];
}

//The next batch of functions are used BY the pseudocode. Don't delete them!

function input(str) {
  var answer = prompt(str)
  if (answer != null && answer.length > 0 && !isNaN(answer)) {
    return parseFloat(answer)
  }
  else {
    return answer
  }
}

function output() {
  var a = 0;
  var output = "";
  if (out != "") { out += "\n" }
  for (a = 0; a < arguments.length; a++) {
    if (arguments[a] instanceof Collection ||
      arguments[a] instanceof Stack ||
      arguments[a] instanceof Queue) {
      output = arguments[a].toString()
    } else {
      output = JSON5.stringify(arguments[a])
    }
    output = output.replaceAll("true", "TRUE").replaceAll("false", "FALSE");
    // Spaces in arrays...
    if (output.substring(0, 1) == "[" || output.substring(0, 1) == "{") {
      output = output.replaceAll(",", ", ")
    }
    if (output.substring(0, 2) == "[[") {
      output = output.replaceAll("], [", "],\n [");
    }
    out += output;
  }

}

function div(A, B) {
  return Math.floor(A / B)
}




function Array2D(rows, cols) {
  a2d = new Array(rows)
  for (r = 0; r < rows; r++) {
    a2d[r] = new Array(cols)
  }
  return a2d
}

Array.prototype.Length = function () {
  return this.length;
}

Array.prototype.Slice = function (S, L) {
  return this.slice(S, S + L);
}

String.prototype.Length = function () {
  return this.length;
}

String.prototype.SubStr = function (S, L) {
  return this.substr(S, L);
}

/** Translates a single line from PS (or JS) to JS */
function translate(line) {
  //do a sanity check - if this is javascript, leave it alone
  if (line.indexOf("{") !== -1) return line;
  line = line.replace(/ mod /g, " % ")
  //oof this is ugly. However, it should successfully match all div statements (??)
  line = line.replaceAll(/([0-9A-Za-z]+| \(.+\)|[0-9A-Za-z]+\.[0-9A-Za-z]+\(\)) div ([0-9A-Za-z]+|\(.+\)|[0-9A-Za-z]+\.[0-9A-Za-z]+\(\))/g, "div($1, $2)");

  line = line.replaceAll(/([^"])TRUE/g, "$1true");
  line = line.replaceAll(/([^"])FALSE/g, "$1false");
  var lin = line.trim();
  var sp = lin.indexOf(" ");
  var first = "";
  if (startswith(lin, "if")) { first = "if" }
  else if (startswith(lin, "return")) { first = "return" }
  else if (startswith(lin, "output")) { first = "output" }
  else if (startswith(lin, "else if")) { first = "else if" }
  else if (startswith(lin, "else")) { first = "else" }
  else if (startswith(lin, "loop while")) { first = "loop while" }
  else if (startswith(lin, "loop for")) { first = "loop for" }
  else if (startswith(lin, "loop until")) { first = "loop until" }
  else if (startswith(lin, "loop ")) { first = "loop" }
  else if (startswith(lin, "output")) { first = "output" }
  else if (startswith(lin, "method ")) { first = "method" }
  else if (startswith(lin, "Class ")) { first = "class" }
  else if (startswith(lin, "input")) { first = "input" }
  else {
    if (sp >= 0) { first = lin.substring(0, sp); }
  }
  if ((first == "if" || first == "else if" || first == "return" || first == "output")) {
    line = line.replace(/ NOT /g, " ! ");
    line = line.replace("if ", "if ( ");
    if (first == "else if") { line = line.replace("else if", "} else if") }
    line = line.replace(" then", "){");
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");


    line = line.replace(/<>/g, "!=");
    line = line.replace(/([ \]\w])=([ \]\w])/g, "$1==$2")
  }
  if (first == "else") { line = line.replace("else", "}else{") }
  if (first == "loop while") {
    line = line.replace("loop while", "while(") + "){";
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");

    line = line.replace(/NOT/g, "!");
    line = line.replace(/<>/g, "!=");
    line = line.replace(/ = /g, " == ")
  }
  if (first == "loop for") {
    var v = line.indexOf("loop for") + 9;
    var ve = line.indexOf(" ", v);
    var vname = line.substring(v, ve);

    var vs = line.indexOf(" from ") + 6;
    var vt = line.indexOf(" to ");
    var vstart = line.substring(vs, vt);

    var vend = line.substring(vt + 4);

    line = "for(" + vname + "=" + vstart + ";" + vname + "<=" + vend + ";" + vname + "++){"

  }
  if (first == "loop until") {
    line = line.replace("loop until", "while(!(") + ")){";
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");

    line = line.replace(/NOT/g, "!");
    line = line.replace(/<>/g, "!=");
    line = line.replace(/ = /g, " == ")
  }
  if (first == "loop") {
    var v = line.indexOf("loop") + 5;
    var ve = line.indexOf(" ", v);
    var vname = line.substring(v, ve);

    var vs = line.indexOf(" from ") + 6;
    var vt = line.indexOf(" to ");
    var vstart = line.substring(vs, vt);

    var vend = line.substring(vt + 4);

    line = "for(" + vname + "=" + vstart + ";" + vname + "<=" + vend + ";" + vname + "++){"

  }
  if (first == "end") { line = "}"; }
  if (first == "output") {
    var t = line.indexOf("output") + 6
    line = "output(" + line.substring(t) + ")"
  }
  if (first == "input") {
    var v = line.indexOf("input") + 6
    var name = line.substring(v)
    line = name + " = input(\"" + name + "\")"
  }
  if (first == "method") {
    line = line.replace(/method/, "function") + "{"
  }

  if (first == "class") {
    line = line.replace(/Class/, "function") + "{"
  }

  return line
}

function startswith(whole, part) {
  var n = part.length
  if (whole.substring(0, n) == part) {
    return true
  }
  else { return false }
}

function trim(s) {
  var b = 0
  var e = s.length
  while (e > 0 && s.charAt(e - 1) <= ' ') { e-- }
  while (b < e && s.charAt(b) <= ' ') { b++ }
  return s.substring(b, e)
}

function getLines(code) {
  var lines = code.split("\n")
  for (c = 0; c < lines.length; c++) { lines[c] = trim(lines[c]) }

  return lines
}

function replacePairs(s, a, b, ar, br) {
  var p = s.indexOf(a)
  while (p >= 0) {
    s = s.substring(0, p) + ar + s.substring(p + a.length)
    p = s.indexOf(b)
    if (p < 0) { s = s + br }
    else { s = s.substring(0, p) + br + s.substring(p + b.length) }
    p = s.indexOf(a)
  }
  return s
}
},{"./collections":243,"./queues":251,"./stacks":253,"json5":98}],245:[function(require,module,exports){
/** takes url parameter and transforms into object **/
function deParam(urlStr) {
  const subbie = urlStr.substring(1);
  const x = subbie.split('&').map(s => s.split('='));
  return x.reduce((accum, arr) => { accum[arr[0]] = arr[1]; return accum; }, {});
}

module.exports = deParam;
},{}],246:[function(require,module,exports){
/** creates default input to start function **/
solutions = require("../solutions.js");

module.exports = function defaultInput(exercise) {
  let solution = exercise.solution || solutions[exercise.name];
  if (typeof (solution) === "string") {
    // we have a string solution, likely pseudocode
    var lines = solution.split("\n");
    return (lines[0].trim() + "\n \n \n \n" + lines[lines.length - 1].trim());
  }
  let solutionFullText = solution.toString();
  let openingBracket = solutionFullText.indexOf("{")
  return solutionFullText.substring(0, openingBracket) + "{\n \n \n}";
}
},{"../solutions.js":241}],247:[function(require,module,exports){

let inputParser = require("./inputParser.js");
let solutions = require("../solutions.js");
let runPS = require("./convertPStoJS.js");
let prettyPrintMap = require("./prettyPrintMap.js");

module.exports = function (exercise) {
    // example/sample runs
    let solution = exercise.solution || solutions[exercise.name];
    for (let i = 0; i <= 2; i++) {
        try {
            let input = inputParser(exercise, exercise.inputs[i]);
            let result;
            if (exercise.inputType === "map") {
                // display syntax message
                if (i === 0) {
                    document.querySelector(".examples")
                    insertAdjacentHTML('beforeend',
                        `<p><em>Note that the Map syntax for the example runs and output has been simplified for user readability, but would not actually create a Map() properly.</em></p>`);
                }

                let inputCopy = inputParser(exercise, exercise.inputs[i]);
                let formattedInput = prettyPrintMap(inputCopy, "parentheses");
                if (typeof (solution) === "string") {
                    [result, out] = runPS(solution, inputCopy, exercise.preamble);
                    if (!result) result = out;
                } else {
                    result = solution(inputCopy);
                }
                let formattedResult = prettyPrintMap(result);
                document.querySelector('.examples')
                    .insertAdjacentHTML('beforeend',
                        `<li>${exerciseName}${formattedInput}  ${formattedResult}</li>`);
            }
            else {
                if (typeof (solution) === "string") {
                    [result, out] = runPS(solution, input, exercise.preamble);
                    if (!result) result = out;
                } else {
                    result = solution(...input);
                }
                document.querySelector('.examples')
                    .insertAdjacentHTML('beforeend',
                        `<li>${exercise.name}${exercise.inputs[i]}  ${result}</li>`);
            }
        } catch (e) {
            console.log(e);
            break;
        }
    }
}
},{"../solutions.js":241,"./convertPStoJS.js":244,"./inputParser.js":249,"./prettyPrintMap.js":250}],248:[function(require,module,exports){
const Collection = require("./collections")
const Queue = require("./queues")
const Stack = require("./stacks")
/** Return row for html table **/
function formatResults(input, idealResult, result, idealOutput, output) {
    var inputStr = "";
    if (idealOutput !== "") {
        result = output;
        idealResult = idealOutput;
    }
    const ok = (idealResult === result);
    if (input instanceof Collection ||
        input instanceof Stack ||
        input instanceof Queue) {
        inputStr = input.toString();
    } else {

        inputStr = inputStr.replaceAll(",", ", ");
        inputStr = inputStr.replaceAll("], [", "], \n [");
        inputStr = inputStr.substring(1, inputStr.length - 1);
    }
    inputStr = inputStr.replaceAll("true", "TRUE");
    inputStr = inputStr.replaceAll("false", "FALSE");
    var row = document.createElement("tr");
    row.innerHTML = `<td>${inputStr}</td>
            <td>${idealResult}</td>
            <td>${result}</td>
            <td>${ok ? '' : ''}</td>
            <td class="status-box" style="background-color:${ok ? '#318d07' : '#ce0303'}"></td>`;
    return row;
}

module.exports = formatResults;
},{"./collections":243,"./queues":251,"./stacks":253}],249:[function(require,module,exports){

const { args } = require("watchify");
const Collection = require("./collections.js");
const Stack = require("./stacks.js")
const Queue = require("./queues.js")

/**
 * it converts nodingbat input (as stored) to js
 *     e.g. inputParser('(1,2)')=>[1,2]
 **/


module.exports = function inputParser(exercise, inputStr) {
  /**
   * @type String
   */
  var argsWithoutParentheses = inputStr.slice(1, -1);
  argsWithoutParentheses = argsWithoutParentheses.replaceAll("TRUE", "true");
  argsWithoutParentheses = argsWithoutParentheses.replaceAll("FALSE", "false");
  let functionInput;

  if (exercise.inputType === "map") {
    if (argsWithoutParentheses === "[[]]") {
      return new Map();
    }
    else {
      let tempArrayOfArgs = JSON.parse(argsWithoutParentheses);
      functionInput = new Map();
      for (let item of tempArrayOfArgs) {
        functionInput.set(item[0], item[1]);
      }
    }
  } else if (exercise.inputType === "collection") {
    let arrayInputString = argsWithoutParentheses.replaceAll("{", "[").replaceAll("}", "]");
    let arrayInput = JSON.parse(arrayInputString);
    functionInput = [new Collection(arrayInput)];
  } else if (exercise.inputType === "stack") {
    let arrayInputString = argsWithoutParentheses
      .substring(argsWithoutParentheses.indexOf("["),
        argsWithoutParentheses.indexOf("]") + 1);
    let arrayInput = JSON.parse(arrayInputString);
    functionInput = [new Stack(arrayInput)]
  } else if (exercise.inputType === "queue") {
    let arrayInputString = argsWithoutParentheses
      .substring(argsWithoutParentheses.indexOf("["),
        argsWithoutParentheses.indexOf("]") + 1);
    let arrayInput = JSON.parse(arrayInputString);
    functionInput = [new Queue(arrayInput)]
  }
  else {
    try {
      let arrayOfArgs = '[' + argsWithoutParentheses + ']';
      eval("functionInput = " + arrayOfArgs);
    } catch (e) {
      functionInput = e.toString();
    }
  }
  return functionInput;
}
},{"./collections.js":243,"./queues.js":251,"./stacks.js":253,"watchify":204}],250:[function(require,module,exports){
// function to show the Map data type in a user-friendly way
//  - without doing something like this, it just shows up as Object()


function prettyPrintMap(theMap, style = "no_parentheses") {
  let formattedMapResult = "";
  if (style == "parentheses") {
    formattedMapResult = "(";
  }
  formattedMapResult = formattedMapResult + "{";

  //check if it is an empty map
  let emtpyMap = new Map();
  let isEmpty = (theMap === emtpyMap);
  if (!isEmpty) {
    for (let item of theMap) {
      formattedMapResult += `'${item[0]}': '${item[1]}', `;
    }

    formattedMapResult = formattedMapResult.slice(0, -2);
  }

  formattedMapResult = formattedMapResult + "}";

  if (style == "parentheses") {
    formattedMapResult = formattedMapResult + ")";
  }
  return formattedMapResult;
}

module.exports = prettyPrintMap;

},{}],251:[function(require,module,exports){
const JSON5 = require("json5");

module.exports = class Queue {
  values = new Array();
  next = 0;

  constructor(arr) {
    if (arr && Array.isArray(arr))
      this.values = arr;
  }

  isEmpty = function () {
    if (this.values.length) {
      return (this.values.length < 1)
    }
    else { return true }
  }

  enqueue = function (value) {
    this.values.push(value);
  }

  dequeue = function () {
    return this.values.shift();
  }

  toString = function () {
    return "Fr" + JSON5.stringify(this.values).replaceAll(",", ", ") + "Bk";
  }
}
},{"json5":98}],252:[function(require,module,exports){
let defaultInput = require("./defaultInput.js");

module.exports = function (editor, exerciseName, exercise) {
    let exerciseCode = exerciseName + " - code";
    if (localStorage.getItem(exerciseCode)) {
        //load previous solution from localStorage, if possible
        editor.setValue(localStorage.getItem(exerciseCode));
    } else {
        // no previous solution, just display the default...
        editor.setValue(defaultInput(exercise));
        editor.focus();
        editor.setCursor({
            line: 1,
            ch: 2
        });
    }
};
},{"./defaultInput.js":246}],253:[function(require,module,exports){
const JSON5 = require("json5")
module.exports = class Stack {
  values = new Array();
  next = 0;

  constructor(arr) {
    if (arr && Array.isArray(arr))
      this.values = arr;
  }

  push = function (el) {
    this.values.push(el);
  }
  pop = function () {
    return this.values.pop();
  }
  isEmpty = function () {
    if (this.values.length) {
      return (this.values.length < 1)
    }
    else { return true }
  }

  toString = function () {
    var out = "B" + JSON5.stringify(this.values).replaceAll(",", ", ") + "T";
    return out;
  }

}

},{"json5":98}],254:[function(require,module,exports){
function tableHeader() {
    var row = document.createElement("tr");
    row.innerHTML = `<th>Inputs</th>
                <th>Expected result</th>
                <th>Your result</th>
                <th colspan="2">Correct?</th>`;
    return row;
}

module.exports = tableHeader;
},{}]},{},[240])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYW55bWF0Y2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLWRpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLWZsYXR0ZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLXVuaW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXVuaXF1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYXNzaWduLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZS9ub2RlX21vZHVsZXMvaXMtYWNjZXNzb3ItZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL25vZGVfbW9kdWxlcy9pcy1kYXRhLWRlc2NyaXB0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZS9ub2RlX21vZHVsZXMvaXMtZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktZXh0ZW5zaW9ucy9iaW5hcnktZXh0ZW5zaW9ucy5qc29uIiwibm9kZV9tb2R1bGVzL2JyYWNlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2JyYWNlcy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2NvbXBpbGVycy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL3BhcnNlcnMuanMiLCJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbm9kZV9tb2R1bGVzL2V4dGVuZC1zaGFsbG93L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FjaGUtYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvZnNldmVudHMtaGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvbm9kZWZzLWhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvY2hva2lkYXIvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLXV0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLXV0aWxzL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci1taW5pZmllZC9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHMuanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci1taW5pZmllZC9saWIvY29kZW1pcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9jb2xsZWN0aW9uLXZpc2l0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnN0YW50cy1icm93c2VyaWZ5L2NvbnN0YW50cy5qc29uIiwibm9kZV9tb2R1bGVzL2NvcHktZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHBhbmQtYnJhY2tldHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwYW5kLWJyYWNrZXRzL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvZXhwYW5kLWJyYWNrZXRzL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V4cGFuZC1icmFja2V0cy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvbm9kZV9tb2R1bGVzL2lzLWV4dGVuZGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0Z2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHRnbG9iL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvZXh0Z2xvYi9saWIvZXh0Z2xvYi5qcyIsIm5vZGVfbW9kdWxlcy9leHRnbG9iL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V4dGdsb2IvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZpbGwtcmFuZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9yLWluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZyYWdtZW50LWNhY2hlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9ub2RlX21vZHVsZXMvaXMtZ2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9ncmFjZWZ1bC1mcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9sZWdhY3ktc3RyZWFtcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJub2RlX21vZHVsZXMvaGFzLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy12YWx1ZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXZhbHVlcy9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYWNjZXNzb3ItZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yL25vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJpbmFyeS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kYXRhLWRlc2NyaXB0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGVzY3JpcHRvci9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1leHRlbmRhYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWV4dGdsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZ2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1udW1iZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXdpbmRvd3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc29iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uNS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2tpbmQtb2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwLWNhY2hlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcC12aXNpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWF0Y2gvbGliL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWF0Y2gvbGliL2NvbXBpbGVycy5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvbWF0Y2gvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21peGluLWRlZXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmFub21hdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9tYXRjaC9saWIvY29tcGlsZXJzLmpzIiwibm9kZV9tb2R1bGVzL25hbm9tYXRjaC9saWIvcGFyc2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vbWF0Y2gvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL25vcm1hbGl6ZS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWNvcHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LXZpc2l0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC5waWNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXNjYWxjYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtZGlybmFtZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWlzLWFic29sdXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Bvc2l4LWNoYXJhY3Rlci1jbGFzc2VzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRkaXJwL3JlYWRkaXJwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRkaXJwL3N0cmVhbS1hcGkuanMiLCJub2RlX21vZHVsZXMvcmVnZXgtbm90L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlbW92ZS10cmFpbGluZy1zZXBhcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVwZWF0LWVsZW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVwZWF0LXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvbHZlLXVybC9yZXNvbHZlLXVybC5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JldC9saWIvcG9zaXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JldC9saWIvc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JldC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLXJlZ2V4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NldC12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uLW5vZGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc25hcGRyYWdvbi11dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc25hcGRyYWdvbi9saWIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvc25hcGRyYWdvbi9saWIvcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL3Bvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL3NvdXJjZS1tYXBzLmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtcmVzb2x2ZS9zb3VyY2UtbWFwLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC11cmwvc291cmNlLW1hcC11cmwuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9zcGxpdC1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RhdGljLWV4dGVuZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi90aHJvdWdoMi5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3RvLW9iamVjdC1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXJlZ2V4LXJhbmdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXJlZ2V4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuaW9uLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vuc2V0LXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vuc2V0LXZhbHVlL25vZGVfbW9kdWxlcy9oYXMtdmFsdWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5zZXQtdmFsdWUvbm9kZV9tb2R1bGVzL2hhcy12YWx1ZS9ub2RlX21vZHVsZXMvaXNvYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5zZXQtdmFsdWUvbm9kZV9tb2R1bGVzL2hhcy12YWx1ZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXBhdGgvYnVpbGQvY29kZS91cGF0aC5qcyIsIm5vZGVfbW9kdWxlcy91c2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsInNyYy9hbGxFeGVyY2lzZXNJbmNsdWRpbmdIaWRkZW4uanMiLCJzcmMvZGF0YS9hZHZhbmNlZERhdGFTdHJ1Y3R1cmVzLmpzIiwic3JjL2RhdGEvYXAuanMiLCJzcmMvZGF0YS9hcFNvbHV0aW9ucy5qcyIsInNyYy9kYXRhL2FycmF5LmpzIiwic3JjL2RhdGEvYXJyYXlTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9jb2xsZWN0aW9ucy5qcyIsInNyYy9kYXRhL2xvZ2ljLmpzIiwic3JjL2RhdGEvbG9naWNTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9tYXBTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9xdWl6LmpzIiwic3JjL2RhdGEvcXVpelNvbHV0aW9ucy5qcyIsInNyYy9kYXRhL3JlY3Vyc2lvbi5qcyIsInNyYy9kYXRhL3JlY3Vyc2lvblNvbHV0aW9ucy5qcyIsInNyYy9kYXRhL3N0cmluZ1NvbHV0aW9ucy5qcyIsInNyYy9kYXRhL3dhcm11cC5qcyIsInNyYy9leGVyY2lzZVBhZ2UuanMiLCJzcmMvZXhlcmNpc2VzVG9TaG93T25JbmRleC5qcyIsInNyYy9pbmRleFBhZ2UuanMiLCJzcmMvaW8vbG9hZEFsbFNvbHV0aW9uc0Zyb21GaWxlLmpzIiwic3JjL2lvL2xvYWRDb2RlRmlsZS5qcyIsInNyYy9pby9zYXZlQWxsU29sdXRpb25zVG9GaWxlLmpzIiwic3JjL2lvL3NhdmVDb2RlRmlsZS5qcyIsInNyYy9saXN0ZW5lcnMvZGFya01vZGVDaGVja2JveC5qcyIsInNyYy9saXN0ZW5lcnMvZXhlcmNpc2VMaXN0ZW5lcnMuanMiLCJzcmMvbGlzdGVuZXJzL2luZGV4U2F2ZUxvYWRBbGwuanMiLCJzcmMvbGlzdGVuZXJzL2tleWJvYXJkU2hvcnRjdXRzLmpzIiwic3JjL21haW4uanMiLCJzcmMvc29sdXRpb25zLmpzIiwic3JjL3V0aWxpdHkvY21wcy5qcyIsInNyYy91dGlsaXR5L2NvbGxlY3Rpb25zLmpzIiwic3JjL3V0aWxpdHkvY29udmVydFBTdG9KUy5qcyIsInNyYy91dGlsaXR5L2RlUGFyYW0uanMiLCJzcmMvdXRpbGl0eS9kZWZhdWx0SW5wdXQuanMiLCJzcmMvdXRpbGl0eS9kaXNwbGF5RXhhbXBsZVJ1bnMuanMiLCJzcmMvdXRpbGl0eS9mb3JtYXRSZXN1bHRzLmpzIiwic3JjL3V0aWxpdHkvaW5wdXRQYXJzZXIuanMiLCJzcmMvdXRpbGl0eS9wcmV0dHlQcmludE1hcC5qcyIsInNyYy91dGlsaXR5L3F1ZXVlcy5qcyIsInNyYy91dGlsaXR5L3NldEluaXRpYWxFZGl0b3JDb250ZW50cy5qcyIsInNyYy91dGlsaXR5L3N0YWNrcy5qcyIsInNyYy91dGlsaXR5L3RhYmxlSGVhZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzN1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzJCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0MEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlNBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1pY3JvbWF0Y2ggPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpOyAvLyByZXF1aXJlZCBmb3IgdGVzdHMuXG52YXIgYXJyaWZ5ID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYSA9PSBudWxsID8gW10gOiAoQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV0pOyB9O1xuXG52YXIgYW55bWF0Y2ggPSBmdW5jdGlvbihjcml0ZXJpYSwgdmFsdWUsIHJldHVybkluZGV4LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBjcml0ZXJpYSA9IGFycmlmeShjcml0ZXJpYSk7XG4gIHZhbHVlID0gYXJyaWZ5KHZhbHVlKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYW55bWF0Y2guYmluZChudWxsLCBjcml0ZXJpYS5tYXAoZnVuY3Rpb24oY3JpdGVyaW9uKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGNyaXRlcmlvbiA9PT0gJ3N0cmluZycgJiYgY3JpdGVyaW9uWzBdICE9PSAnIScgP1xuICAgICAgICBtaWNyb21hdGNoLm1hdGNoZXIoY3JpdGVyaW9uKSA6IGNyaXRlcmlvbjtcbiAgICB9KSk7XG4gIH1cbiAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgdmFyIHN0cmluZyA9IHZhbHVlWzBdO1xuICB2YXIgYWx0U3RyaW5nLCBhbHRWYWx1ZTtcbiAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgdmFyIG1hdGNoSW5kZXggPSAtMTtcbiAgZnVuY3Rpb24gdGVzdENyaXRlcmlhKGNyaXRlcmlvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNyaXRlcmlvbikpIHtcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgcmVzdWx0ID0gc3RyaW5nID09PSBjcml0ZXJpb24gfHwgYWx0U3RyaW5nICYmIGFsdFN0cmluZyA9PT0gY3JpdGVyaW9uO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IG1pY3JvbWF0Y2guaXNNYXRjaChzdHJpbmcsIGNyaXRlcmlvbik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgcmVzdWx0ID0gY3JpdGVyaW9uLnRlc3Qoc3RyaW5nKSB8fCBhbHRTdHJpbmcgJiYgY3JpdGVyaW9uLnRlc3QoYWx0U3RyaW5nKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzpcbiAgICAgIHJlc3VsdCA9IGNyaXRlcmlvbi5hcHBseShudWxsLCB2YWx1ZSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQgfHwgYWx0VmFsdWUgJiYgY3JpdGVyaW9uLmFwcGx5KG51bGwsIGFsdFZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgbWF0Y2hJbmRleCA9IGluZGV4ICsgc3RhcnRJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgY3JpdCA9IGNyaXRlcmlhO1xuICB2YXIgbmVnR2xvYnMgPSBjcml0LnJlZHVjZShmdW5jdGlvbihhcnIsIGNyaXRlcmlvbiwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGNyaXRlcmlvbiA9PT0gJ3N0cmluZycgJiYgY3JpdGVyaW9uWzBdID09PSAnIScpIHtcbiAgICAgIGlmIChjcml0ID09PSBjcml0ZXJpYSkge1xuICAgICAgICAvLyBtYWtlIGEgY29weSBiZWZvcmUgbW9kaWZ5aW5nXG4gICAgICAgIGNyaXQgPSBjcml0LnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBjcml0W2luZGV4XSA9IG51bGw7XG4gICAgICBhcnIucHVzaChjcml0ZXJpb24uc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfSwgW10pO1xuICBpZiAoIW5lZ0dsb2JzLmxlbmd0aCB8fCAhbWljcm9tYXRjaC5hbnkoc3RyaW5nLCBuZWdHbG9icykpIHtcbiAgICBpZiAocGF0aC5zZXAgPT09ICdcXFxcJyAmJiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYWx0U3RyaW5nID0gbm9ybWFsaXplKHN0cmluZyk7XG4gICAgICBhbHRTdHJpbmcgPSBhbHRTdHJpbmcgPT09IHN0cmluZyA/IG51bGwgOiBhbHRTdHJpbmc7XG4gICAgICBpZiAoYWx0U3RyaW5nKSBhbHRWYWx1ZSA9IFthbHRTdHJpbmddLmNvbmNhdCh2YWx1ZS5zbGljZSgxKSk7XG4gICAgfVxuICAgIG1hdGNoZWQgPSBjcml0LnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KS5zb21lKHRlc3RDcml0ZXJpYSk7XG4gIH1cbiAgcmV0dXJuIHJldHVybkluZGV4ID09PSB0cnVlID8gbWF0Y2hJbmRleCA6IG1hdGNoZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFueW1hdGNoO1xuIiwiLyohXG4gKiBhcnItZGlmZiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXJyLWRpZmY+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaWZmKGFyci8qLCBhcnJheXMqLykge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIGFyciA9IGRpZmZBcnJheShhcnIsIGFyZ3VtZW50c1tpZHhdKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuZnVuY3Rpb24gZGlmZkFycmF5KG9uZSwgdHdvKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0d28pKSB7XG4gICAgcmV0dXJuIG9uZS5zbGljZSgpO1xuICB9XG5cbiAgdmFyIHRsZW4gPSB0d28ubGVuZ3RoXG4gIHZhciBvbGVuID0gb25lLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgYXJyID0gW107XG5cbiAgd2hpbGUgKCsraWR4IDwgb2xlbikge1xuICAgIHZhciBlbGUgPSBvbmVbaWR4XTtcblxuICAgIHZhciBoYXNFbGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRsZW47IGkrKykge1xuICAgICAgdmFyIHZhbCA9IHR3b1tpXTtcblxuICAgICAgaWYgKGVsZSA9PT0gdmFsKSB7XG4gICAgICAgIGhhc0VsZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNFbGUgPT09IGZhbHNlKSB7XG4gICAgICBhcnIucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuIiwiLyohXG4gKiBhcnItZmxhdHRlbiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXJyLWZsYXR0ZW4+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBmbGF0KGFyciwgW10pO1xufTtcblxuZnVuY3Rpb24gZmxhdChhcnIsIHJlcykge1xuICB2YXIgaSA9IDAsIGN1cjtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjdXIgPSBhcnJbaV07XG4gICAgQXJyYXkuaXNBcnJheShjdXIpID8gZmxhdChjdXIsIHJlcykgOiByZXMucHVzaChjdXIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5pb24oaW5pdCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5pdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcnItdW5pb24gZXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gYXJyYXkuJyk7XG4gIH1cblxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICghYXJnKSBjb250aW51ZTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBhcmcgPSBbYXJnXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGVsZSA9IGFyZ1tqXTtcblxuICAgICAgaWYgKGluaXQuaW5kZXhPZihlbGUpID49IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbml0LnB1c2goZWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59O1xuIiwiLyohXG4gKiBhcnJheS11bmlxdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2FycmF5LXVuaXF1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcnJheS11bmlxdWUgZXhwZWN0cyBhbiBhcnJheS4nKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaSA9IC0xO1xuXG4gIHdoaWxlIChpKysgPCBsZW4pIHtcbiAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgZm9yICg7IGogPCBhcnIubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGFycltqXSkge1xuICAgICAgICBhcnIuc3BsaWNlKGotLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pbW11dGFibGUgPSBmdW5jdGlvbiB1bmlxdWVJbW11dGFibGUoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJyYXktdW5pcXVlIGV4cGVjdHMgYW4gYXJyYXkuJyk7XG4gIH1cblxuICB2YXIgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShhcnJMZW4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyTGVuOyBpKyspIHtcbiAgICBuZXdBcnJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMobmV3QXJyKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcbmZ1bmN0aW9uIHN0cmljdCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBzdHJpY3QpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyohXG4gKiBhc3NpZ24tc3ltYm9scyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXNzaWduLXN5bWJvbHM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIG9iamVjdHMpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8IHR5cGVvZiByZWNlaXZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iamVjdHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBTeW1ib2wgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHJlY2VpdmVyO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlY2VpdmVyO1xuICB9XG5cbiAgdmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QocmVjZWl2ZXIpO1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHZhciBwcm92aWRlciA9IE9iamVjdChhcmd1bWVudHNbaV0pO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvdmlkZXIpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGtleSA9IG5hbWVzW2pdO1xuXG4gICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwocHJvdmlkZXIsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBwcm92aWRlcltrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIi8vIGFzeW5jLWVhY2ggTUlUIGxpY2Vuc2UgKGJ5IFBhdWwgTWlsbGVyIGZyb20gaHR0cHM6Ly9wYXVsbWlsbHIuY29tKS5cbihmdW5jdGlvbihnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGVhY2ggPSBmdW5jdGlvbihpdGVtcywgbmV4dCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlYWNoKCkgZXhwZWN0cyBhcnJheSBhcyBmaXJzdCBhcmd1bWVudCcpO1xuICAgIGlmICh0eXBlb2YgbmV4dCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZWFjaCgpIGV4cGVjdHMgZnVuY3Rpb24gYXMgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIG5vLW9wXG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCBpdGVtcyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtZWQgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgbmV4dChpdGVtLCBmdW5jdGlvbihlcnJvciwgdHJhbnNmb3JtZWRJdGVtKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1lZFtpbmRleF0gPSB0cmFuc2Zvcm1lZEl0ZW07XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gaXRlbXMubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCB0cmFuc2Zvcm1lZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZWFjaDtcbiAgICB9KTsgLy8gUmVxdWlyZUpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhY2g7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFscy5hc3luY0VhY2ggPSBlYWNoOyAvLyA8c2NyaXB0PlxuICB9XG59KSh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIENhY2hlQmFzZSA9IHJlcXVpcmUoJ2NhY2hlLWJhc2UnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgbWVyZ2UgPSByZXF1aXJlKCdtaXhpbi1kZWVwJyk7XG52YXIgcGFzY2FsID0gcmVxdWlyZSgncGFzY2FsY2FzZScpO1xudmFyIGN1ID0gcmVxdWlyZSgnY2xhc3MtdXRpbHMnKTtcblxuLyoqXG4gKiBPcHRpb25hbGx5IGRlZmluZSBhIGN1c3RvbSBgY2FjaGVgIG5hbWVzcGFjZSB0byB1c2UuXG4gKi9cblxuZnVuY3Rpb24gbmFtZXNwYWNlKG5hbWUpIHtcbiAgdmFyIENhY2hlID0gbmFtZSA/IENhY2hlQmFzZS5uYW1lc3BhY2UobmFtZSkgOiBDYWNoZUJhc2U7XG4gIHZhciBmbnMgPSBbXTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBCYXNlYCB3aXRoIHRoZSBnaXZlbiBgY29uZmlnYCBhbmQgYG9wdGlvbnNgLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBpbml0aWFsaXplIHdpdGggYGNvbmZpZ2AgYW5kIGBvcHRpb25zYFxuICAgKiB2YXIgYXBwID0gbmV3IEJhc2Uoe2lzQXBwOiB0cnVlfSwge2FiYzogdHJ1ZX0pO1xuICAgKiBhcHAuc2V0KCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqIC8vIHZhbHVlcyBkZWZpbmVkIHdpdGggdGhlIGdpdmVuIGBjb25maWdgIG9iamVjdCB3aWxsIGJlIG9uIHRoZSByb290IG9mIHRoZSBpbnN0YW5jZVxuICAgKiBjb25zb2xlLmxvZyhhcHAuYmF6KTsgLy89PiB1bmRlZmluZWRcbiAgICogY29uc29sZS5sb2coYXBwLmZvbyk7IC8vPT4gJ2JhcidcbiAgICogLy8gb3IgdXNlIGAuZ2V0YFxuICAgKiBjb25zb2xlLmxvZyhhcHAuZ2V0KCdpc0FwcCcpKTsgLy89PiB0cnVlXG4gICAqIGNvbnNvbGUubG9nKGFwcC5nZXQoJ2ZvbycpKTsgLy89PiAnYmFyJ1xuICAgKlxuICAgKiAvLyB2YWx1ZXMgZGVmaW5lZCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2Agb2JqZWN0IHdpbGwgYmUgb24gYGFwcC5vcHRpb25zXG4gICAqIGNvbnNvbGUubG9nKGFwcC5vcHRpb25zLmFiYyk7IC8vPT4gdHJ1ZVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGBjb25maWdgIElmIHN1cHBsaWVkLCB0aGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gW2NhY2hlLWJhc2VdW10gdG8gbWVyZ2Ugb250byB0aGUgdGhlIGluc3RhbmNlIHVwb24gaW5zdGFudGlhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBJZiBzdXBwbGllZCwgdGhpcyBvYmplY3QgaXMgdXNlZCB0byBpbml0aWFsaXplIHRoZSBgYmFzZS5vcHRpb25zYCBvYmplY3QuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEJhc2UoY29uZmlnLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJhc2UpKSB7XG4gICAgICByZXR1cm4gbmV3IEJhc2UoY29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ2FjaGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgIHRoaXMuaXMoJ2Jhc2UnKTtcbiAgICB0aGlzLmluaXRCYXNlKGNvbmZpZywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSW5oZXJpdCBjYWNoZS1iYXNlXG4gICAqL1xuXG4gIHV0aWwuaW5oZXJpdHMoQmFzZSwgQ2FjaGUpO1xuXG4gIC8qKlxuICAgKiBBZGQgc3RhdGljIGVtaXR0ZXIgbWV0aG9kc1xuICAgKi9cblxuICBFbWl0dGVyKEJhc2UpO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGBCYXNlYCBkZWZhdWx0cyB3aXRoIHRoZSBnaXZlbiBgY29uZmlnYCBvYmplY3RcbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUuaW5pdEJhc2UgPSBmdW5jdGlvbihjb25maWcsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZSh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZSB8fCB7fTtcbiAgICB0aGlzLmRlZmluZSgncmVnaXN0ZXJlZCcsIHt9KTtcbiAgICBpZiAobmFtZSkgdGhpc1tuYW1lXSA9IHt9O1xuXG4gICAgLy8gbWFrZSBgYXBwLl9jYWxsYmFja3NgIG5vbi1lbnVtZXJhYmxlXG4gICAgdGhpcy5kZWZpbmUoJ19jYWxsYmFja3MnLCB0aGlzLl9jYWxsYmFja3MpO1xuICAgIGlmIChpc09iamVjdChjb25maWcpKSB7XG4gICAgICB0aGlzLnZpc2l0KCdzZXQnLCBjb25maWcpO1xuICAgIH1cbiAgICBCYXNlLnJ1bih0aGlzLCAndXNlJywgZm5zKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBnaXZlbiBgbmFtZWAgb24gYGFwcC5fbmFtZWAgYW5kIGBhcHAuaXMqYCBwcm9wZXJ0aWVzLiBVc2VkIGZvciBkb2luZ1xuICAgKiBsb29rdXBzIGluIHBsdWdpbnMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5pcygnZm9vJyk7XG4gICAqIGNvbnNvbGUubG9nKGFwcC5fbmFtZSk7XG4gICAqIC8vPT4gJ2ZvbydcbiAgICogY29uc29sZS5sb2coYXBwLmlzRm9vKTtcbiAgICogLy89PiB0cnVlXG4gICAqIGFwcC5pcygnYmFyJyk7XG4gICAqIGNvbnNvbGUubG9nKGFwcC5pc0Zvbyk7XG4gICAqIC8vPT4gdHJ1ZVxuICAgKiBjb25zb2xlLmxvZyhhcHAuaXNCYXIpO1xuICAgKiAvLz0+IHRydWVcbiAgICogY29uc29sZS5sb2coYXBwLl9uYW1lKTtcbiAgICogLy89PiAnYmFyJ1xuICAgKiBgYGBcbiAgICogQG5hbWUgLmlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgbmFtZSB0byBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICB0aGlzLmRlZmluZSgnaXMnICsgcGFzY2FsKG5hbWUpLCB0cnVlKTtcbiAgICB0aGlzLmRlZmluZSgnX25hbWUnLCBuYW1lKTtcbiAgICB0aGlzLmRlZmluZSgnX2FwcG5hbWUnLCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgcGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBvbiBhbiBpbnN0YW5jZS5cbiAgICpcbiAgICogUGx1Z2luIGltcGxlbWVudG9ycyBhcmUgZW5jb3VyYWdlZCB0byB1c2UgdGhpcyBmaXJzdCB0aGluZyBpbiBhIHBsdWdpblxuICAgKiB0byBwcmV2ZW50IHRoZSBwbHVnaW4gZnJvbSBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugb24gdGhlIHNhbWVcbiAgICogaW5zdGFuY2UuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBiYXNlID0gbmV3IEJhc2UoKTtcbiAgICogYmFzZS51c2UoZnVuY3Rpb24oYXBwKSB7XG4gICAqICAgaWYgKGFwcC5pc1JlZ2lzdGVyZWQoJ215UGx1Z2luJykpIHJldHVybjtcbiAgICogICAvLyBkbyBzdHVmZiB0byBgYXBwYFxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gdG8gYWxzbyByZWNvcmQgdGhlIHBsdWdpbiBhcyBiZWluZyByZWdpc3RlcmVkXG4gICAqIGJhc2UudXNlKGZ1bmN0aW9uKGFwcCkge1xuICAgKiAgIGlmIChhcHAuaXNSZWdpc3RlcmVkKCdteVBsdWdpbicsIHRydWUpKSByZXR1cm47XG4gICAqICAgLy8gZG8gc3R1ZmYgdG8gYGFwcGBcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuaXNSZWdpc3RlcmVkXG4gICAqIEBlbWl0cyBgcGx1Z2luYCBFbWl0cyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luIGJlaW5nIHJlZ2lzdGVyZWQuIFVzZWZ1bCBmb3IgdW5pdCB0ZXN0cywgdG8gZW5zdXJlIHBsdWdpbnMgYXJlIG9ubHkgcmVnaXN0ZXJlZCBvbmNlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgIFRoZSBwbHVnaW4gbmFtZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBgcmVnaXN0ZXJgIElmIHRoZSBwbHVnaW4gaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZCwgdG8gcmVjb3JkIGl0IGFzIGJlaW5nIHJlZ2lzdGVyZWQgcGFzcyBgdHJ1ZWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGEgcGx1Z2luIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUuaXNSZWdpc3RlcmVkID0gZnVuY3Rpb24obmFtZSwgcmVnaXN0ZXIpIHtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmVkLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlZ2lzdGVyICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkW25hbWVdID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdCgncGx1Z2luJywgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGVmaW5lIGEgcGx1Z2luIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbW1lZGlhdGVseSB1cG9uIGluaXQuIFBsdWdpbnMgYXJlIGNoYWluYWJsZVxuICAgKiBhbmQgZXhwb3NlIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIHRvIHRoZSBwbHVnaW4gZnVuY3Rpb246XG4gICAqXG4gICAqIC0gYGFwcGA6IHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIGBCYXNlYFxuICAgKiAtIGBiYXNlYDogdGhlIFtmaXJzdCBhbmNlc3RvciBpbnN0YW5jZV0oI2Jhc2UpIG9mIGBCYXNlYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYXBwID0gbmV3IEJhc2UoKVxuICAgKiAgIC51c2UoZm9vKVxuICAgKiAgIC51c2UoYmFyKVxuICAgKiAgIC51c2UoYmF6KVxuICAgKiBgYGBcbiAgICogQG5hbWUgLnVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gIHBsdWdpbiBmdW5jdGlvbiB0byBjYWxsXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgaXRlbSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgZm4uY2FsbCh0aGlzLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGAuZGVmaW5lYCBtZXRob2QgaXMgdXNlZCBmb3IgYWRkaW5nIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZS5cbiAgICogRG90LW5vdGF0aW9uIGlzICoqbm90IHN1cHBvcnRlZCoqIHdpdGggYGRlZmluZWAuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGFyYml0cmFyeSBgcmVuZGVyYCBmdW5jdGlvbiB1c2luZyBsb2Rhc2ggYHRlbXBsYXRlYFxuICAgKiBhcHAuZGVmaW5lKCdyZW5kZXInLCBmdW5jdGlvbihzdHIsIGxvY2Fscykge1xuICAgKiAgIHJldHVybiBfLnRlbXBsYXRlKHN0cikobG9jYWxzKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuZGVmaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZGVmaW5lLlxuICAgKiBAcGFyYW0ge2FueX0gYHZhbHVlYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXQoJ2RlZmluZScsIGtleSk7XG4gICAgfVxuICAgIGRlZmluZSh0aGlzLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1peCBwcm9wZXJ0eSBga2V5YCBvbnRvIHRoZSBCYXNlIHByb3RvdHlwZS4gSWYgYmFzZSBpcyBpbmhlcml0ZWQgdXNpbmdcbiAgICogYEJhc2UuZXh0ZW5kYCB0aGlzIG1ldGhvZCB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgYSBuZXcgYG1peGluYCBtZXRob2QgdGhhdCB3aWxsXG4gICAqIG9ubHkgYWRkIHByb3BlcnRpZXMgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgaW5oZXJpdGluZyBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogYGBganNcbiAgICogYXBwLm1peGluKCdmb28nLCBmdW5jdGlvbigpIHtcbiAgICogICAvLyBkbyBzdHVmZlxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5taXhpblxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGB2YWxgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYGJhc2VgIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUubWl4aW4gPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIEJhc2UucHJvdG90eXBlW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vbi1lbnVtYmVyYWJsZSBtaXhpbiBhcnJheSwgdXNlZCBieSB0aGUgc3RhdGljIFtCYXNlLm1peGluXSgpIG1ldGhvZC5cbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUubWl4aW5zID0gQmFzZS5wcm90b3R5cGUubWl4aW5zIHx8IFtdO1xuXG4gIC8qKlxuICAgKiBHZXR0ZXIvc2V0dGVyIHVzZWQgd2hlbiBjcmVhdGluZyBuZXN0ZWQgaW5zdGFuY2VzIG9mIGBCYXNlYCwgZm9yIHN0b3JpbmcgYSByZWZlcmVuY2VcbiAgICogdG8gdGhlIGZpcnN0IGFuY2VzdG9yIGluc3RhbmNlLiBUaGlzIHdvcmtzIGJ5IHNldHRpbmcgYW4gaW5zdGFuY2Ugb2YgYEJhc2VgIG9uIHRoZSBgcGFyZW50YFxuICAgKiBwcm9wZXJ0eSBvZiBhIFwiY2hpbGRcIiBpbnN0YW5jZS4gVGhlIGBiYXNlYCBwcm9wZXJ0eSBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBpbnN0YW5jZSBpZlxuICAgKiBubyBgcGFyZW50YCBwcm9wZXJ0eSBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYEJhc2VgLCB0aGlzIGlzIG91ciBmaXJzdCAoXCJiYXNlXCIpIGluc3RhbmNlXG4gICAqIHZhciBmaXJzdCA9IG5ldyBCYXNlKCk7XG4gICAqIGZpcnN0LmZvbyA9ICdiYXInOyAvLyBhcmJpdHJhcnkgcHJvcGVydHksIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHNlZSB3aGF0J3MgaGFwcGVuaW5nIGxhdGVyXG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhbm90aGVyIGluc3RhbmNlXG4gICAqIHZhciBzZWNvbmQgPSBuZXcgQmFzZSgpO1xuICAgKiAvLyBjcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIGZpcnN0IGluc3RhbmNlIChgZmlyc3RgKVxuICAgKiBzZWNvbmQucGFyZW50ID0gZmlyc3Q7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhbm90aGVyIGluc3RhbmNlXG4gICAqIHZhciB0aGlyZCA9IG5ldyBCYXNlKCk7XG4gICAqIC8vIGNyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgaW5zdGFuY2UgKGBzZWNvbmRgKVxuICAgKiAvLyByZXBlYXQgdGhpcyBwYXR0ZXJuIGV2ZXJ5IHRpbWUgYSBcImNoaWxkXCIgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiB0aGlyZC5wYXJlbnQgPSBzZWNvbmQ7XG4gICAqXG4gICAqIC8vIHdlIGNhbiBhbHdheXMgYWNjZXNzIHRoZSBmaXJzdCBpbnN0YW5jZSB1c2luZyB0aGUgYGJhc2VgIHByb3BlcnR5XG4gICAqIGNvbnNvbGUubG9nKGZpcnN0LmJhc2UuZm9vKTtcbiAgICogLy89PiAnYmFyJ1xuICAgKiBjb25zb2xlLmxvZyhzZWNvbmQuYmFzZS5mb28pO1xuICAgKiAvLz0+ICdiYXInXG4gICAqIGNvbnNvbGUubG9nKHRoaXJkLmJhc2UuZm9vKTtcbiAgICogLy89PiAnYmFyJ1xuICAgKiAvLyBhbmQgbm93IHlvdSBrbm93IGhvdyB0byBnZXQgdG8gdGhpcmQgYmFzZSA7KVxuICAgKiBgYGBcbiAgICogQG5hbWUgLmJhc2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2UucHJvdG90eXBlLCAnYmFzZScsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmJhc2UgOiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGFkZGluZyBnbG9iYWwgcGx1Z2luIGZ1bmN0aW9ucyB0aGF0IHdpbGxcbiAgICogYmUgYWRkZWQgdG8gYW4gaW5zdGFuY2Ugd2hlbiBjcmVhdGVkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBCYXNlLnVzZShmdW5jdGlvbihhcHApIHtcbiAgICogICBhcHAuZm9vID0gJ2Jhcic7XG4gICAqIH0pO1xuICAgKiB2YXIgYXBwID0gbmV3IEJhc2UoKTtcbiAgICogY29uc29sZS5sb2coYXBwLmZvbyk7XG4gICAqIC8vPT4gJ2JhcidcbiAgICogYGBgXG4gICAqIEBuYW1lICN1c2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYCBQbHVnaW4gZnVuY3Rpb24gdG8gdXNlIG9uIGVhY2ggaW5zdGFuY2UuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYEJhc2VgIGNvbnN0cnVjdG9yIGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoQmFzZSwgJ3VzZScsIGZ1bmN0aW9uKGZuKSB7XG4gICAgZm5zLnB1c2goZm4pO1xuICAgIHJldHVybiBCYXNlO1xuICB9KTtcblxuICAvKipcbiAgICogUnVuIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyBieSBwYXNzaW5nIGVhY2ggZnVuY3Rpb25cbiAgICogdG8gYSBtZXRob2Qgb24gdGhlIGdpdmVuIG9iamVjdCBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGBvYmpgIE9iamVjdCBjb250YWluaW5nIG1ldGhvZCB0byB1c2UuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYHByb3BgIE5hbWUgb2YgdGhlIG1ldGhvZCBvbiB0aGUgb2JqZWN0IHRvIHVzZS5cbiAgICogQHBhcmFtICB7QXJyYXl9IGBhcnJgIEFycmF5IG9mIGZ1bmN0aW9ucyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqL1xuXG4gIGRlZmluZShCYXNlLCAncnVuJywgZnVuY3Rpb24ob2JqLCBwcm9wLCBhcnIpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCwgaSA9IDA7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBvYmpbcHJvcF0oYXJyW2krK10pO1xuICAgIH1cbiAgICByZXR1cm4gQmFzZTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGluaGVyaXRpbmcgdGhlIHByb3RvdHlwZSBhbmQgc3RhdGljIG1ldGhvZHMgb2YgdGhlIGBCYXNlYCBjbGFzcy5cbiAgICogVGhpcyBtZXRob2QgZ3JlYXRseSBzaW1wbGlmaWVzIHRoZSBwcm9jZXNzIG9mIGNyZWF0aW5nIGluaGVyaXRhbmNlLWJhc2VkIGFwcGxpY2F0aW9ucy5cbiAgICogU2VlIFtzdGF0aWMtZXh0ZW5kXVtdIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBleHRlbmQgPSBjdS5leHRlbmQoUGFyZW50KTtcbiAgICogUGFyZW50LmV4dGVuZChDaGlsZCk7XG4gICAqXG4gICAqIC8vIG9wdGlvbmFsIG1ldGhvZHNcbiAgICogUGFyZW50LmV4dGVuZChDaGlsZCwge1xuICAgKiAgIGZvbzogZnVuY3Rpb24oKSB7fSxcbiAgICogICBiYXI6IGZ1bmN0aW9uKCkge31cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAjZXh0ZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBDdG9yYCBjb25zdHJ1Y3RvciB0byBleHRlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGBtZXRob2RzYCBPcHRpb25hbCBwcm90b3R5cGUgcHJvcGVydGllcyB0byBtaXggaW4uXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYEJhc2VgIGNvbnN0cnVjdG9yIGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoQmFzZSwgJ2V4dGVuZCcsIGN1LmV4dGVuZChCYXNlLCBmdW5jdGlvbihDdG9yLCBQYXJlbnQpIHtcbiAgICBDdG9yLnByb3RvdHlwZS5taXhpbnMgPSBDdG9yLnByb3RvdHlwZS5taXhpbnMgfHwgW107XG5cbiAgICBkZWZpbmUoQ3RvciwgJ21peGluJywgZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhciBtaXhpbiA9IGZuKEN0b3IucHJvdG90eXBlLCBDdG9yKTtcbiAgICAgIGlmICh0eXBlb2YgbWl4aW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQ3Rvci5wcm90b3R5cGUubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEN0b3I7XG4gICAgfSk7XG5cbiAgICBkZWZpbmUoQ3RvciwgJ21peGlucycsIGZ1bmN0aW9uKENoaWxkKSB7XG4gICAgICBCYXNlLnJ1bihDaGlsZCwgJ21peGluJywgQ3Rvci5wcm90b3R5cGUubWl4aW5zKTtcbiAgICAgIHJldHVybiBDdG9yO1xuICAgIH0pO1xuXG4gICAgQ3Rvci5wcm90b3R5cGUubWl4aW4gPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBDdG9yLnByb3RvdHlwZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBCYXNlO1xuICB9KSk7XG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIGFkZGluZyBtZXRob2RzIHRvIHRoZSBgQmFzZWAgcHJvdG90eXBlLCBhbmQvb3IgdG8gdGhlIHByb3RvdHlwZSBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIFdoZW4gYSBtaXhpbiBmdW5jdGlvbiByZXR1cm5zIGEgZnVuY3Rpb24sIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBwdXNoZWQgb250byB0aGUgYC5taXhpbnNgXG4gICAqIGFycmF5LCBtYWtpbmcgaXQgYXZhaWxhYmxlIHRvIGJlIHVzZWQgb24gaW5oZXJpdGluZyBjbGFzc2VzIHdoZW5ldmVyIGBCYXNlLm1peGlucygpYCBpc1xuICAgKiBjYWxsZWQgKGUuZy4gYEJhc2UubWl4aW5zKENoaWxkKWApLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBCYXNlLm1peGluKGZ1bmN0aW9uKHByb3RvKSB7XG4gICAqICAgcHJvdG8uZm9vID0gZnVuY3Rpb24obXNnKSB7XG4gICAqICAgICByZXR1cm4gJ2ZvbyAnICsgbXNnO1xuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG5hbWUgI21peGluXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmAgRnVuY3Rpb24gdG8gY2FsbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGBCYXNlYCBjb25zdHJ1Y3RvciBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKEJhc2UsICdtaXhpbicsIGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIG1peGluID0gZm4oQmFzZS5wcm90b3R5cGUsIEJhc2UpO1xuICAgIGlmICh0eXBlb2YgbWl4aW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIEJhc2UucHJvdG90eXBlLm1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2U7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBydW5uaW5nIGdsb2JhbCBtaXhpbiBmdW5jdGlvbnMgYWdhaW5zdCBhIGNoaWxkIGNvbnN0cnVjdG9yLlxuICAgKiBNaXhpbnMgbXVzdCBiZSByZWdpc3RlcmVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBCYXNlLmV4dGVuZChDaGlsZCk7XG4gICAqIEJhc2UubWl4aW5zKENoaWxkKTtcbiAgICogYGBgXG4gICAqIEBuYW1lICNtaXhpbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYENoaWxkYCBDb25zdHJ1Y3RvciBmdW5jdGlvbiBvZiBhIGNoaWxkIGNsYXNzXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYEJhc2VgIGNvbnN0cnVjdG9yIGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoQmFzZSwgJ21peGlucycsIGZ1bmN0aW9uKENoaWxkKSB7XG4gICAgQmFzZS5ydW4oQ2hpbGQsICdtaXhpbicsIEJhc2UucHJvdG90eXBlLm1peGlucyk7XG4gICAgcmV0dXJuIEJhc2U7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIGB1dGlsLmluaGVyaXRgLCBidXQgY29waWVzIGFsbCBzdGF0aWMgcHJvcGVydGllcywgcHJvdG90eXBlIHByb3BlcnRpZXMsIGFuZFxuICAgKiBnZXR0ZXJzL3NldHRlcnMgZnJvbSBgUHJvdmlkZXJgIHRvIGBSZWNlaXZlcmAuIFNlZSBbY2xhc3MtdXRpbHNdW117I2luaGVyaXR9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEJhc2UuaW5oZXJpdChGb28sIEJhcik7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAjaW5oZXJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgUmVjZWl2ZXJgIFJlY2VpdmluZyAoY2hpbGQpIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBQcm92aWRlcmAgUHJvdmlkaW5nIChwYXJlbnQpIGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYEJhc2VgIGNvbnN0cnVjdG9yIGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoQmFzZSwgJ2luaGVyaXQnLCBjdS5pbmhlcml0KTtcbiAgZGVmaW5lKEJhc2UsICdidWJibGUnLCBjdS5idWJibGUpO1xuICByZXR1cm4gQmFzZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYEJhc2VgIHdpdGggZGVmYXVsdCBzZXR0aW5nc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbmFtZXNwYWNlKCk7XG5cbi8qKlxuICogQWxsb3cgdXNlcnMgdG8gZGVmaW5lIGEgbmFtZXNwYWNlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuIiwiLyohXG4gKiBkZWZpbmUtcHJvcGVydHkgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2RlZmluZS1wcm9wZXJ0eT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIDIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRGVzY3JpcHRvciA9IHJlcXVpcmUoJ2lzLWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHZhbCkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdCBvciBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBgcHJvcGAgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAoaXNEZXNjcmlwdG9yKHZhbCkgJiYgKCdzZXQnIGluIHZhbCB8fCAnZ2V0JyBpbiB2YWwpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHZhbCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xufTtcbiIsIi8qIVxuICogaXMtYWNjZXNzb3ItZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtYWNjZXNzb3ItZGVzY3JpcHRvcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG4vLyBhY2Nlc3NvciBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbnZhciBhY2Nlc3NvciA9IHtcbiAgZ2V0OiAnZnVuY3Rpb24nLFxuICBzZXQ6ICdmdW5jdGlvbicsXG4gIGNvbmZpZ3VyYWJsZTogJ2Jvb2xlYW4nLFxuICBlbnVtZXJhYmxlOiAnYm9vbGVhbidcbn07XG5cbmZ1bmN0aW9uIGlzQWNjZXNzb3JEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAodHlwZU9mKG9iaikgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhhcyhvYmosICd2YWx1ZScpIHx8IGhhcyhvYmosICd3cml0YWJsZScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFoYXMob2JqLCAnZ2V0JykgfHwgdHlwZW9mIG9iai5nZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0bGRyOiBpdCdzIHZhbGlkIHRvIGhhdmUgXCJzZXRcIiBiZSB1bmRlZmluZWRcbiAgLy8gXCJzZXRcIiBtaWdodCBiZSB1bmRlZmluZWQgaWYgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgXG4gIC8vIHdhcyB1c2VkIHRvIGdldCB0aGUgdmFsdWUsIGFuZCBvbmx5IGBnZXRgIHdhcyBkZWZpbmVkIGJ5IHRoZSB1c2VyXG4gIGlmIChoYXMob2JqLCAnc2V0JykgJiYgdHlwZW9mIG9ialtrZXldICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFhY2Nlc3Nvci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZU9mKG9ialtrZXldKSA9PT0gYWNjZXNzb3Jba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGBpc0FjY2Vzc29yRGVzY3JpcHRvcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWNjZXNzb3JEZXNjcmlwdG9yO1xuIiwiLyohXG4gKiBpcy1kYXRhLWRlc2NyaXB0b3IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWRhdGEtZGVzY3JpcHRvcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGF0YURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gIC8vIGRhdGEgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHZhciBkYXRhID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogJ2Jvb2xlYW4nLFxuICAgIGVudW1lcmFibGU6ICdib29sZWFuJyxcbiAgICB3cml0YWJsZTogJ2Jvb2xlYW4nXG4gIH07XG5cbiAgaWYgKHR5cGVPZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmFsID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICghKCd2YWx1ZScgaW4gb2JqKSAmJiAhKCd3cml0YWJsZScgaW4gb2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSBjb250aW51ZTtcblxuICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZU9mKG9ialtrZXldKSA9PT0gZGF0YVtrZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIGlzLWRlc2NyaXB0b3IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWRlc2NyaXB0b3I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcbnZhciBpc0FjY2Vzc29yID0gcmVxdWlyZSgnaXMtYWNjZXNzb3ItZGVzY3JpcHRvcicpO1xudmFyIGlzRGF0YSA9IHJlcXVpcmUoJ2lzLWRhdGEtZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGVzY3JpcHRvcihvYmosIGtleSkge1xuICBpZiAodHlwZU9mKG9iaikgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgnZ2V0JyBpbiBvYmopIHtcbiAgICByZXR1cm4gaXNBY2Nlc3NvcihvYmosIGtleSk7XG4gIH1cbiAgcmV0dXJuIGlzRGF0YShvYmosIGtleSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9W1xuXHRcIjNkbVwiLFxuXHRcIjNkc1wiLFxuXHRcIjNnMlwiLFxuXHRcIjNncFwiLFxuXHRcIjd6XCIsXG5cdFwiYVwiLFxuXHRcImFhY1wiLFxuXHRcImFkcFwiLFxuXHRcImFpXCIsXG5cdFwiYWlmXCIsXG5cdFwiYWlmZlwiLFxuXHRcImFselwiLFxuXHRcImFwZVwiLFxuXHRcImFwa1wiLFxuXHRcImFyXCIsXG5cdFwiYXJqXCIsXG5cdFwiYXNmXCIsXG5cdFwiYXVcIixcblx0XCJhdmlcIixcblx0XCJiYWtcIixcblx0XCJiYW1sXCIsXG5cdFwiYmhcIixcblx0XCJiaW5cIixcblx0XCJia1wiLFxuXHRcImJtcFwiLFxuXHRcImJ0aWZcIixcblx0XCJiejJcIixcblx0XCJiemlwMlwiLFxuXHRcImNhYlwiLFxuXHRcImNhZlwiLFxuXHRcImNnbVwiLFxuXHRcImNsYXNzXCIsXG5cdFwiY214XCIsXG5cdFwiY3Bpb1wiLFxuXHRcImNyMlwiLFxuXHRcImN1clwiLFxuXHRcImRhdFwiLFxuXHRcImRjbVwiLFxuXHRcImRlYlwiLFxuXHRcImRleFwiLFxuXHRcImRqdnVcIixcblx0XCJkbGxcIixcblx0XCJkbWdcIixcblx0XCJkbmdcIixcblx0XCJkb2NcIixcblx0XCJkb2NtXCIsXG5cdFwiZG9jeFwiLFxuXHRcImRvdFwiLFxuXHRcImRvdG1cIixcblx0XCJkcmFcIixcblx0XCJEU19TdG9yZVwiLFxuXHRcImRza1wiLFxuXHRcImR0c1wiLFxuXHRcImR0c2hkXCIsXG5cdFwiZHZiXCIsXG5cdFwiZHdnXCIsXG5cdFwiZHhmXCIsXG5cdFwiZWNlbHA0ODAwXCIsXG5cdFwiZWNlbHA3NDcwXCIsXG5cdFwiZWNlbHA5NjAwXCIsXG5cdFwiZWdnXCIsXG5cdFwiZW9sXCIsXG5cdFwiZW90XCIsXG5cdFwiZXB1YlwiLFxuXHRcImV4ZVwiLFxuXHRcImY0dlwiLFxuXHRcImZic1wiLFxuXHRcImZoXCIsXG5cdFwiZmxhXCIsXG5cdFwiZmxhY1wiLFxuXHRcImZsaVwiLFxuXHRcImZsdlwiLFxuXHRcImZweFwiLFxuXHRcImZzdFwiLFxuXHRcImZ2dFwiLFxuXHRcImczXCIsXG5cdFwiZ2hcIixcblx0XCJnaWZcIixcblx0XCJncmFmZmxlXCIsXG5cdFwiZ3pcIixcblx0XCJnemlwXCIsXG5cdFwiaDI2MVwiLFxuXHRcImgyNjNcIixcblx0XCJoMjY0XCIsXG5cdFwiaWNuc1wiLFxuXHRcImljb1wiLFxuXHRcImllZlwiLFxuXHRcImltZ1wiLFxuXHRcImlwYVwiLFxuXHRcImlzb1wiLFxuXHRcImphclwiLFxuXHRcImpwZWdcIixcblx0XCJqcGdcIixcblx0XCJqcGd2XCIsXG5cdFwianBtXCIsXG5cdFwianhyXCIsXG5cdFwia2V5XCIsXG5cdFwia3R4XCIsXG5cdFwibGhhXCIsXG5cdFwibGliXCIsXG5cdFwibHZwXCIsXG5cdFwibHpcIixcblx0XCJsemhcIixcblx0XCJsem1hXCIsXG5cdFwibHpvXCIsXG5cdFwibTN1XCIsXG5cdFwibTRhXCIsXG5cdFwibTR2XCIsXG5cdFwibWFyXCIsXG5cdFwibWRpXCIsXG5cdFwibWh0XCIsXG5cdFwibWlkXCIsXG5cdFwibWlkaVwiLFxuXHRcIm1qMlwiLFxuXHRcIm1rYVwiLFxuXHRcIm1rdlwiLFxuXHRcIm1tclwiLFxuXHRcIm1uZ1wiLFxuXHRcIm1vYmlcIixcblx0XCJtb3ZcIixcblx0XCJtb3ZpZVwiLFxuXHRcIm1wM1wiLFxuXHRcIm1wNFwiLFxuXHRcIm1wNGFcIixcblx0XCJtcGVnXCIsXG5cdFwibXBnXCIsXG5cdFwibXBnYVwiLFxuXHRcIm14dVwiLFxuXHRcIm5lZlwiLFxuXHRcIm5weFwiLFxuXHRcIm51bWJlcnNcIixcblx0XCJudXBrZ1wiLFxuXHRcIm9cIixcblx0XCJvZ2FcIixcblx0XCJvZ2dcIixcblx0XCJvZ3ZcIixcblx0XCJvdGZcIixcblx0XCJwYWdlc1wiLFxuXHRcInBibVwiLFxuXHRcInBjeFwiLFxuXHRcInBkYlwiLFxuXHRcInBkZlwiLFxuXHRcInBlYVwiLFxuXHRcInBnbVwiLFxuXHRcInBpY1wiLFxuXHRcInBuZ1wiLFxuXHRcInBubVwiLFxuXHRcInBvdFwiLFxuXHRcInBvdG1cIixcblx0XCJwb3R4XCIsXG5cdFwicHBhXCIsXG5cdFwicHBhbVwiLFxuXHRcInBwbVwiLFxuXHRcInBwc1wiLFxuXHRcInBwc21cIixcblx0XCJwcHN4XCIsXG5cdFwicHB0XCIsXG5cdFwicHB0bVwiLFxuXHRcInBwdHhcIixcblx0XCJwc2RcIixcblx0XCJweWFcIixcblx0XCJweWNcIixcblx0XCJweW9cIixcblx0XCJweXZcIixcblx0XCJxdFwiLFxuXHRcInJhclwiLFxuXHRcInJhc1wiLFxuXHRcInJhd1wiLFxuXHRcInJlc291cmNlc1wiLFxuXHRcInJnYlwiLFxuXHRcInJpcFwiLFxuXHRcInJsY1wiLFxuXHRcInJtZlwiLFxuXHRcInJtdmJcIixcblx0XCJydGZcIixcblx0XCJyelwiLFxuXHRcInMzbVwiLFxuXHRcInM3elwiLFxuXHRcInNjcHRcIixcblx0XCJzZ2lcIixcblx0XCJzaGFyXCIsXG5cdFwic2lsXCIsXG5cdFwic2tldGNoXCIsXG5cdFwic2xrXCIsXG5cdFwic212XCIsXG5cdFwic25rXCIsXG5cdFwic29cIixcblx0XCJzdGxcIixcblx0XCJzdW9cIixcblx0XCJzdWJcIixcblx0XCJzd2ZcIixcblx0XCJ0YXJcIixcblx0XCJ0YnpcIixcblx0XCJ0YnoyXCIsXG5cdFwidGdhXCIsXG5cdFwidGd6XCIsXG5cdFwidGhteFwiLFxuXHRcInRpZlwiLFxuXHRcInRpZmZcIixcblx0XCJ0bHpcIixcblx0XCJ0dGNcIixcblx0XCJ0dGZcIixcblx0XCJ0eHpcIixcblx0XCJ1ZGZcIixcblx0XCJ1dmhcIixcblx0XCJ1dmlcIixcblx0XCJ1dm1cIixcblx0XCJ1dnBcIixcblx0XCJ1dnNcIixcblx0XCJ1dnVcIixcblx0XCJ2aXZcIixcblx0XCJ2b2JcIixcblx0XCJ3YXJcIixcblx0XCJ3YXZcIixcblx0XCJ3YXhcIixcblx0XCJ3Ym1wXCIsXG5cdFwid2RwXCIsXG5cdFwid2ViYVwiLFxuXHRcIndlYm1cIixcblx0XCJ3ZWJwXCIsXG5cdFwid2hsXCIsXG5cdFwid2ltXCIsXG5cdFwid21cIixcblx0XCJ3bWFcIixcblx0XCJ3bXZcIixcblx0XCJ3bXhcIixcblx0XCJ3b2ZmXCIsXG5cdFwid29mZjJcIixcblx0XCJ3cm1cIixcblx0XCJ3dnhcIixcblx0XCJ4Ym1cIixcblx0XCJ4aWZcIixcblx0XCJ4bGFcIixcblx0XCJ4bGFtXCIsXG5cdFwieGxzXCIsXG5cdFwieGxzYlwiLFxuXHRcInhsc21cIixcblx0XCJ4bHN4XCIsXG5cdFwieGx0XCIsXG5cdFwieGx0bVwiLFxuXHRcInhsdHhcIixcblx0XCJ4bVwiLFxuXHRcInhtaW5kXCIsXG5cdFwieHBpXCIsXG5cdFwieHBtXCIsXG5cdFwieHdkXCIsXG5cdFwieHpcIixcblx0XCJ6XCIsXG5cdFwiemlwXCIsXG5cdFwiemlweFwiXG5dXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciB1bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9saWIvcGFyc2VycycpO1xudmFyIEJyYWNlcyA9IHJlcXVpcmUoJy4vbGliL2JyYWNlcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xudmFyIGNhY2hlID0ge307XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYGJyYWNlc2AgcGF0dGVybiBpbnRvIGEgcmVnZXgtY29tcGF0aWJsZSBzdHJpbmcuIEJ5IGRlZmF1bHQsIG9ubHkgb25lIHN0cmluZyBpcyBnZW5lcmF0ZWQgZm9yIGV2ZXJ5IGlucHV0IHN0cmluZy4gU2V0IGBvcHRpb25zLmV4cGFuZGAgdG8gdHJ1ZSB0byByZXR1cm4gYW4gYXJyYXkgb2YgcGF0dGVybnMgKHNpbWlsYXIgdG8gQmFzaCBvciBtaW5pbWF0Y2guIEJlZm9yZSB1c2luZyBgb3B0aW9ucy5leHBhbmRgLCBpdCdzIHJlY29tbWVuZGVkIHRoYXQgeW91IHJlYWQgdGhlIFtwZXJmb3JtYW5jZSBub3Rlc10oI3BlcmZvcm1hbmNlKSkuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcygne2EsYixjfScpKTtcbiAqIC8vPT4gWycoYXxifGMpJ11cbiAqXG4gKiBjb25zb2xlLmxvZyhicmFjZXMoJ3thLGIsY30nLCB7ZXhwYW5kOiB0cnVlfSkpO1xuICogLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGJyYWNlcyhwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkoU3RyaW5nKHBhdHRlcm4pLCBvcHRpb25zKTtcbiAgdmFyIGFyciA9IFtdO1xuXG4gIHZhciBkaXNhYmxlZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSA9PT0gZmFsc2U7XG4gIGlmICghZGlzYWJsZWQgJiYgY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIHJldHVybiBjYWNoZVtrZXldO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgYnJhY2VzLmNyZWF0ZShwYXR0ZXJuW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyciA9IGJyYWNlcy5jcmVhdGUocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vZHVwZXMgPT09IHRydWUpIHtcbiAgICBhcnIgPSB1bmlxdWUoYXJyKTtcbiAgfVxuXG4gIGlmICghZGlzYWJsZWQpIHtcbiAgICBjYWNoZVtrZXldID0gYXJyO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogRXhwYW5kcyBhIGJyYWNlIHBhdHRlcm4gaW50byBhbiBhcnJheS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBtYWluIFticmFjZXNdKCNicmFjZXMpIGZ1bmN0aW9uIHdoZW4gYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlLiBCZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QgaXQncyByZWNvbW1lbmRlZCB0aGF0IHlvdSByZWFkIHRoZSBbcGVyZm9ybWFuY2Ugbm90ZXNdKCNwZXJmb3JtYW5jZSkpIGFuZCBhZHZhbnRhZ2VzIG9mIHVzaW5nIFsub3B0aW1pemVdKCNvcHRpbWl6ZSkgaW5zdGVhZC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmV4cGFuZCgnYS97YixjfS9kJykpO1xuICogLy89PiBbJ2EvYi9kJywgJ2EvYy9kJ107XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQnJhY2UgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZXhwYW5kZWQgdmFsdWVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMuZXhwYW5kID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2VzLmNyZWF0ZShwYXR0ZXJuLCBleHRlbmQoe30sIG9wdGlvbnMsIHtleHBhbmQ6IHRydWV9KSk7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBicmFjZSBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlLCBvcHRpbWl6ZWQgc3RyaW5nLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1haW4gW2JyYWNlc10oI2JyYWNlcykgZnVuY3Rpb24gYnkgZGVmYXVsdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmV4cGFuZCgnYS97YixjfS9kJykpO1xuICogLy89PiBbJ2EvKGJ8YykvZCddXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQnJhY2UgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZXhwYW5kZWQgdmFsdWVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMub3B0aW1pemUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZXMuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgYSBicmFjZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGVpdGhlciBhbiBleHBhbmRlZCBhcnJheSAoaWYgYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlKSwgYSBoaWdobHkgb3B0aW1pemVkIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1haW4gW2JyYWNlc10oI2JyYWNlcykgZnVuY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcy5jcmVhdGUoJ3VzZXItezIwMC4uMzAwfS9wcm9qZWN0LXthLGIsY30tezEuLjEwfScpKVxuICogLy89PiAndXNlci0oMjBbMC05XXwyWzEtOV1bMC05XXwzMDApL3Byb2plY3QtKGF8YnxjKS0oWzEtOV18MTApJ1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEJyYWNlIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGV4cGFuZGVkIHZhbHVlcy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbWF4TGVuZ3RoID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhMZW5ndGgpIHx8IE1BWF9MRU5HVEg7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBtYXhMZW5ndGggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICBpZiAocGF0dGVybiA9PT0gJycgfHwgcGF0dGVybi5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0VtcHR5U2V0cyhwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1F1b3RlZFN0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIFtwYXR0ZXJuLnNsaWNlKDEsIC0xKV07XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gbmV3IEJyYWNlcyhvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5leHBhbmQgIT09IHRydWVcbiAgICAgID8gcHJvdG8ub3B0aW1pemUocGF0dGVybiwgb3B0aW9ucylcbiAgICAgIDogcHJvdG8uZXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gICAgLy8gZ2V0IHRoZSBnZW5lcmF0ZWQgcGF0dGVybihzKVxuICAgIHZhciBhcnIgPSByZXN1bHQub3V0cHV0O1xuXG4gICAgLy8gZmlsdGVyIG91dCBlbXB0eSBzdHJpbmdzIGlmIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9lbXB0eSA9PT0gdHJ1ZSkge1xuICAgICAgYXJyID0gYXJyLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGR1cGxpY2F0ZXMgaWYgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2R1cGVzID09PSB0cnVlKSB7XG4gICAgICBhcnIgPSB1bmlxdWUoYXJyKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCAncmVzdWx0Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2NyZWF0ZScsIHBhdHRlcm4sIG9wdGlvbnMsIGNyZWF0ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKlxuICogY29uc29sZS5sb2coYnJhY2VzLm1ha2VSZSgnaWQtezIwMC4uMzAwfScpKTtcbiAqIC8vPT4gL14oPzppZC0oMjBbMC05XXwyWzEtOV1bMC05XXwzMDApKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgVGhlIHBhdHRlcm4gdG8gY29udmVydCB0byByZWdleC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLm1ha2VSZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbWF4TGVuZ3RoID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhMZW5ndGgpIHx8IE1BWF9MRU5HVEg7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBtYXhMZW5ndGggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZSgpIHtcbiAgICB2YXIgYXJyID0gYnJhY2VzKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHZhciBvcHRzID0gZXh0ZW5kKHtzdHJpY3RFcnJvcnM6IGZhbHNlfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRvUmVnZXgoYXJyLCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdtYWtlUmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYWtlUmUpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKiB2YXIgYXN0ID0gYnJhY2VzLnBhcnNlKCdhL3tiLGN9L2QnKTtcbiAqIGNvbnNvbGUubG9nKGFzdCk7XG4gKiAvLyB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgaW5wdXQ6ICdhL3tiLGN9L2QnLFxuICogLy8gICBub2RlczpcbiAqIC8vICAgIFsgeyB0eXBlOiAnYm9zJywgdmFsOiAnJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYS8nIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ2JyYWNlJyxcbiAqIC8vICAgICAgICBub2RlczpcbiAqIC8vICAgICAgICAgWyB7IHR5cGU6ICdicmFjZS5vcGVuJywgdmFsOiAneycgfSxcbiAqIC8vICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYixjJyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ2JyYWNlLmNsb3NlJywgdmFsOiAnfScgfSBdIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICcvZCcgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnZW9zJywgdmFsOiAnJyB9IF0gfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEJyYWNlIHBhdHRlcm4gdG8gcGFyc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLnBhcnNlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgcHJvdG8gPSBuZXcgQnJhY2VzKG9wdGlvbnMpO1xuICByZXR1cm4gcHJvdG8ucGFyc2UocGF0dGVybiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIGdpdmVuIGBhc3RgIG9yIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIHZhciBhc3QgPSBicmFjZXMucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmNvbXBpbGUoYXN0KSk7XG4gKiAvLyB7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJyB9LFxuICogLy8gICBzdGF0ZToge30sXG4gKiAvLyAgIGNvbXBpbGVyczpcbiAqIC8vICAgIHsgZW9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBub29wOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBib3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJyYWNlOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2Uub3Blbic6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHRleHQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5jbG9zZSc6IFtGdW5jdGlvbl0gfSxcbiAqIC8vICAgb3V0cHV0OiBbICdhLyhifGMpL2QnIF0sXG4gKiAvLyAgIGFzdDpcbiAqIC8vICAgIHsgLi4uIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBgYXN0YCBBU1QgZnJvbSBbLnBhcnNlXSgjcGFyc2UpLiBJZiBhIHN0cmluZyBpcyBwYXNzZWQgaXQgd2lsbCBiZSBwYXJzZWQgZmlyc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIGFuIGBvdXRwdXRgIHByb3BlcnR5IHdpdGggdGhlIGNvbXBpbGVkIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHByb3RvID0gbmV3IEJyYWNlcyhvcHRpb25zKTtcbiAgcmV0dXJuIHByb3RvLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHJlZ2V4IGNhY2hlLlxuICpcbiAqIGBgYGpzXG4gKiBicmFjZXMuY2xlYXJDYWNoZSgpO1xuICogYGBgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGNhY2hlID0gYnJhY2VzLmNhY2hlID0ge307XG59O1xuXG4vKipcbiAqIE1lbW9pemUgYSBnZW5lcmF0ZWQgcmVnZXggb3IgZnVuY3Rpb24uIEEgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGZyb20gdGhlIG1ldGhvZCBuYW1lLCBwYXR0ZXJuLCBhbmQgdXNlci1kZWZpbmVkIG9wdGlvbnMuIFNldFxuICogb3B0aW9ucy5tZW1vaXplIHRvIGZhbHNlIHRvIGRpc2FibGUuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZSh0eXBlLCBwYXR0ZXJuLCBvcHRpb25zLCBmbikge1xuICB2YXIga2V5ID0gdXRpbHMuY3JlYXRlS2V5KHR5cGUgKyAnOicgKyBwYXR0ZXJuLCBvcHRpb25zKTtcbiAgdmFyIGRpc2FibGVkID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlID09PSBmYWxzZTtcbiAgaWYgKGRpc2FibGVkKSB7XG4gICAgYnJhY2VzLmNsZWFyQ2FjaGUoKTtcbiAgICByZXR1cm4gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIHJldHVybiBjYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHJlcyA9IGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBjYWNoZVtrZXldID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgQnJhY2VzYCBjb25zdHJ1Y3RvciBhbmQgbWV0aG9kc1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmJyYWNlcy5CcmFjZXMgPSBCcmFjZXM7XG5icmFjZXMuY29tcGlsZXJzID0gY29tcGlsZXJzO1xuYnJhY2VzLnBhcnNlcnMgPSBwYXJzZXJzO1xuYnJhY2VzLmNhY2hlID0gY2FjaGU7XG5cbi8qKlxuICogRXhwb3NlIGBicmFjZXNgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBicmFjZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ3VzdG9taXplIFNuYXBkcmFnb24gcGFyc2VyIGFuZCByZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIEJyYWNlcyhvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBicmFjZXNcbiAqL1xuXG5CcmFjZXMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgdmFyIG9wdHMgPSB1dGlscy5jcmVhdGVPcHRpb25zKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB0aGlzLnNuYXBkcmFnb24gPSB0aGlzLm9wdGlvbnMuc25hcGRyYWdvbiB8fCBuZXcgU25hcGRyYWdvbihvcHRzKTtcbiAgdGhpcy5jb21waWxlciA9IHRoaXMuc25hcGRyYWdvbi5jb21waWxlcjtcbiAgdGhpcy5wYXJzZXIgPSB0aGlzLnNuYXBkcmFnb24ucGFyc2VyO1xuXG4gIGNvbXBpbGVycyh0aGlzLnNuYXBkcmFnb24sIG9wdHMpO1xuICBwYXJzZXJzKHRoaXMuc25hcGRyYWdvbiwgb3B0cyk7XG5cbiAgLyoqXG4gICAqIENhbGwgU25hcGRyYWdvbiBgLnBhcnNlYCBtZXRob2QuIFdoZW4gQVNUIGlzIHJldHVybmVkLCB3ZSBjaGVjayB0b1xuICAgKiBzZWUgaWYgYW55IHVuY2xvc2VkIGJyYWNlcyBhcmUgbGVmdCBvbiB0aGUgc3RhY2sgYW5kLCBpZiBzbywgd2UgaXRlcmF0ZVxuICAgKiBvdmVyIHRoZSBzdGFjayBhbmQgY29ycmVjdCB0aGUgQVNUIHNvIHRoYXQgY29tcGlsZXJzIGFyZSBjYWxsZWQgaW4gdGhlIGNvcnJlY3RcbiAgICogb3JkZXIgYW5kIHVuYmFsYW5jZSBicmFjZXMgYXJlIHByb3Blcmx5IGVzY2FwZWQuXG4gICAqL1xuXG4gIHV0aWxzLmRlZmluZSh0aGlzLnNuYXBkcmFnb24sICdwYXJzZScsIGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkID0gU25hcGRyYWdvbi5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhcnNlci5hc3QuaW5wdXQgPSBwYXR0ZXJuO1xuXG4gICAgdmFyIHN0YWNrID0gdGhpcy5wYXJzZXIuc3RhY2s7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgYWRkUGFyZW50KHt0eXBlOiAnYnJhY2UuY2xvc2UnLCB2YWw6ICcnfSwgc3RhY2sucG9wKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFBhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICAgIHV0aWxzLmRlZmluZShub2RlLCAncGFyZW50JywgcGFyZW50KTtcbiAgICAgIHBhcmVudC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gICAgdXRpbHMuZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVjb3JhdGUgYC5wYXJzZWAgbWV0aG9kXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICBpZiAoYXN0ICYmIHR5cGVvZiBhc3QgPT09ICdvYmplY3QnICYmIGFzdC5ub2RlcykgcmV0dXJuIGFzdDtcbiAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5zbmFwZHJhZ29uLnBhcnNlKGFzdCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRlIGAuY29tcGlsZWAgbWV0aG9kXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgYXN0ID09PSAnc3RyaW5nJykge1xuICAgIGFzdCA9IHRoaXMucGFyc2UoYXN0LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc25hcGRyYWdvbi5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4cGFuZFxuICovXG5cbkJyYWNlcy5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgYXN0ID0gdGhpcy5wYXJzZShwYXR0ZXJuLCB7ZXhwYW5kOiB0cnVlfSk7XG4gIHJldHVybiB0aGlzLmNvbXBpbGUoYXN0LCB7ZXhwYW5kOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIE9wdGltaXplXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIGFzdCA9IHRoaXMucGFyc2UocGF0dGVybiwge29wdGltaXplOiB0cnVlfSk7XG4gIHJldHVybiB0aGlzLmNvbXBpbGUoYXN0LCB7b3B0aW1pemU6IHRydWV9KTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBCcmFjZXNgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCcmFjZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihicmFjZXMsIG9wdGlvbnMpIHtcbiAgYnJhY2VzLmNvbXBpbGVyXG5cbiAgICAvKipcbiAgICAgKiBib3NcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JvcycsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0KSByZXR1cm47XG4gICAgICB0aGlzLmFzdC5xdWV1ZSA9IGlzRXNjYXBlZCh0aGlzLmFzdCkgPyBbdGhpcy5hc3QudmFsXSA6IFtdO1xuICAgICAgdGhpcy5hc3QuY291bnQgPSAxO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmUgYnJhY2tldHNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2xvc2UgPSBub2RlLmNsb3NlO1xuICAgICAgdmFyIG9wZW4gPSAhbm9kZS5lc2NhcGVkID8gJ1snIDogJ1xcXFxbJztcbiAgICAgIHZhciBuZWdhdGVkID0gbm9kZS5uZWdhdGVkO1xuICAgICAgdmFyIGlubmVyID0gbm9kZS5pbm5lcjtcblxuICAgICAgaW5uZXIgPSBpbm5lci5yZXBsYWNlKC9cXFxcKD89W1xcXFxcXHddfCQpL2csICdcXFxcXFxcXCcpO1xuICAgICAgaWYgKGlubmVyID09PSAnXS0nKSB7XG4gICAgICAgIGlubmVyID0gJ1xcXFxdXFxcXC0nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcuJztcbiAgICAgIH1cbiAgICAgIGlmIChuZWdhdGVkICYmIGlubmVyLmluZGV4T2YoJy8nKSA9PT0gLTEpIHtcbiAgICAgICAgaW5uZXIgKz0gJy8nO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gb3BlbiArIG5lZ2F0ZWQgKyBpbm5lciArIGNsb3NlO1xuICAgICAgdmFyIHF1ZXVlID0gbm9kZS5wYXJlbnQucXVldWU7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmFycmF5aWZ5KHF1ZXVlLnBvcCgpKTtcblxuICAgICAgcXVldWUucHVzaCh1dGlscy5qb2luKGxhc3QsIHZhbCkpO1xuICAgICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgW10pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFjZVxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2UnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnF1ZXVlID0gaXNFc2NhcGVkKG5vZGUpID8gW25vZGUudmFsXSA6IFtdO1xuICAgICAgbm9kZS5jb3VudCA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5tYXBWaXNpdChub2RlLm5vZGVzKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogT3BlblxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2Uub3BlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUucGFyZW50Lm9wZW4gPSBub2RlLnZhbDtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogSW5uZXJcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcXVldWUgPSBub2RlLnBhcmVudC5xdWV1ZTtcbiAgICAgIHZhciBlc2NhcGVkID0gbm9kZS5lc2NhcGVkO1xuICAgICAgdmFyIHNlZ3MgPSBbbm9kZS52YWxdO1xuXG4gICAgICBpZiAobm9kZS5vcHRpbWl6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucywge29wdGltaXplOiBmYWxzZX0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5tdWx0aXBsaWVyID4gMSkge1xuICAgICAgICBub2RlLnBhcmVudC5jb3VudCAqPSBub2RlLm11bHRpcGxpZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnF1YW50aWZpZXJzID09PSB0cnVlICYmIHV0aWxzLmlzUXVhbnRpZmllcihub2RlLnZhbCkpIHtcbiAgICAgICAgZXNjYXBlZCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWwubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoaXNUeXBlKG5vZGUucGFyZW50LCAnYnJhY2UnKSAmJiAhaXNFc2NhcGVkKG5vZGUpKSB7XG4gICAgICAgICAgdmFyIGV4cGFuZGVkID0gdXRpbHMuZXhwYW5kKG5vZGUudmFsLCBvcHRpb25zKTtcbiAgICAgICAgICBzZWdzID0gZXhwYW5kZWQuc2VncztcblxuICAgICAgICAgIGlmIChleHBhbmRlZC5pc09wdGltaXplZCkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQuaXNPcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIG5vdGhpbmcgd2FzIGV4cGFuZGVkLCB3ZSBwcm9iYWJseSBoYXZlIGEgbGl0ZXJhbCBicmFjZVxuICAgICAgICAgIGlmICghc2Vncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSAoZXhwYW5kZWQudmFsIHx8IG5vZGUudmFsKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVuZXNjYXBlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAvLyB1bmVzY2FwZSB1bmV4cGFuZGVkIGJyYWNlIHNlcXVlbmNlL3NldCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXFxcKFssLl0pL2csICckMScpO1xuICAgICAgICAgICAgICAvLyBzdHJpcCBxdW90ZXNcbiAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1tcIidgXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZ3MgPSBbdmFsXTtcbiAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsID09PSAnLCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnQucXVldWUucHVzaChbJyddKTtcbiAgICAgICAgICBzZWdzID0gWycnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdzID0gWyd8J107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXNjYXBlZCAmJiBpc1R5cGUobm9kZS5wYXJlbnQsICdicmFjZScpKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudC5ub2Rlcy5sZW5ndGggPD0gNCAmJiBub2RlLnBhcmVudC5jb3VudCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucGFyZW50LmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Lmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnQuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNRdWV1ZShub2RlLnBhcmVudCkpIHtcbiAgICAgICAgbm9kZS5wYXJlbnQucXVldWUgPSBzZWdzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0ID0gdXRpbHMuYXJyYXlpZnkocXVldWUucG9wKCkpO1xuICAgICAgaWYgKG5vZGUucGFyZW50LmNvdW50ID4gMSAmJiBvcHRpb25zLmV4cGFuZCkge1xuICAgICAgICBsYXN0ID0gbXVsdGlwbHkobGFzdCwgbm9kZS5wYXJlbnQuY291bnQpO1xuICAgICAgICBub2RlLnBhcmVudC5jb3VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2godXRpbHMuam9pbih1dGlscy5mbGF0dGVuKGxhc3QpLCBzZWdzLnNoaWZ0KCkpKTtcbiAgICAgIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIHNlZ3MpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZVxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2UuY2xvc2UnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcXVldWUgPSBub2RlLnBhcmVudC5xdWV1ZTtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgdmFyIGxhc3QgPSBwcmV2LnF1ZXVlLnBvcCgpO1xuICAgICAgdmFyIG9wZW4gPSBub2RlLnBhcmVudC5vcGVuO1xuICAgICAgdmFyIGNsb3NlID0gbm9kZS52YWw7XG5cbiAgICAgIGlmIChvcGVuICYmIGNsb3NlICYmIGlzT3B0aW1pemVkKG5vZGUsIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wZW4gPSAnKCc7XG4gICAgICAgIGNsb3NlID0gJyknO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhIGNsb3NlIGJyYWNlIGV4aXN0cywgYW5kIHRoZSBwcmV2aW91cyBzZWdtZW50IGlzIG9uZSBjaGFyYWN0ZXJcbiAgICAgIC8vIGRvbid0IHdyYXAgdGhlIHJlc3VsdCBpbiBicmFjZXMgb3IgcGFyZW5zXG4gICAgICB2YXIgZWxlID0gdXRpbHMubGFzdChxdWV1ZSk7XG4gICAgICBpZiAobm9kZS5wYXJlbnQuY291bnQgPiAxICYmIG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgIGVsZSA9IG11bHRpcGx5KHF1ZXVlLnBvcCgpLCBub2RlLnBhcmVudC5jb3VudCk7XG4gICAgICAgIG5vZGUucGFyZW50LmNvdW50ID0gMTtcbiAgICAgICAgcXVldWUucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xvc2UgJiYgdHlwZW9mIGVsZSA9PT0gJ3N0cmluZycgJiYgZWxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBvcGVuID0gJyc7XG4gICAgICAgIGNsb3NlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNMaXRlcmFsQnJhY2Uobm9kZSwgb3B0aW9ucykgfHwgbm9Jbm5lcihub2RlKSkgJiYgIW5vZGUucGFyZW50Lmhhc0VtcHR5KSB7XG4gICAgICAgIHF1ZXVlLnB1c2godXRpbHMuam9pbihvcGVuLCBxdWV1ZS5wb3AoKSB8fCAnJykpO1xuICAgICAgICBxdWV1ZSA9IHV0aWxzLmZsYXR0ZW4odXRpbHMuam9pbihxdWV1ZSwgY2xvc2UpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmV2LnF1ZXVlID0gW3F1ZXVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYucXVldWUucHVzaCh1dGlscy5mbGF0dGVuKHV0aWxzLmpvaW4obGFzdCwgcXVldWUpKSk7XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIGVvc1xuICAgICAqL1xuXG4gICAgLnNldCgnZW9zJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQpIHJldHVybjtcblxuICAgICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMubGFzdCh1dGlscy5mbGF0dGVuKHRoaXMuYXN0LnF1ZXVlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodXRpbHMubGFzdCh0aGlzLmFzdC5xdWV1ZSkpKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMuZmxhdHRlbih0aGlzLmFzdC5xdWV1ZS5wb3AoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmZsYXR0ZW4odGhpcy5hc3QucXVldWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5wYXJlbnQuY291bnQgPiAxICYmIG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gbXVsdGlwbHkodGhpcy5vdXRwdXQsIG5vZGUucGFyZW50LmNvdW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5hcnJheWlmeSh0aGlzLm91dHB1dCk7XG4gICAgICB0aGlzLmFzdC5xdWV1ZSA9IFtdO1xuICAgIH0pO1xuXG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBzZWdtZW50cyBpbiB0aGUgY3VycmVudCBicmFjZSBsZXZlbFxuICovXG5cbmZ1bmN0aW9uIG11bHRpcGx5KHF1ZXVlLCBuLCBvcHRpb25zKSB7XG4gIHJldHVybiB1dGlscy5mbGF0dGVuKHV0aWxzLnJlcGVhdCh1dGlscy5hcnJheWlmeShxdWV1ZSksIG4pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgbm9kZWAgaXMgZXNjYXBlZFxuICovXG5cbmZ1bmN0aW9uIGlzRXNjYXBlZChub2RlKSB7XG4gIHJldHVybiBub2RlLmVzY2FwZWQgPT09IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHJlZ2V4IHBhcmVucyBzaG91bGQgYmUgdXNlZCBmb3Igc2V0cy4gSWYgdGhlIHBhcmVudCBgdHlwZWBcbiAqIGlzIG5vdCBgYnJhY2VgLCB0aGVuIHdlJ3JlIG9uIGEgcm9vdCBub2RlLCB3aGljaCBtZWFucyB3ZSBzaG91bGQgbmV2ZXJcbiAqIGV4cGFuZCBzZWdtZW50cyBhbmQgb3Blbi9jbG9zZSBicmFjZXMgc2hvdWxkIGJlIGB7fWAgKHNpbmNlIHRoaXMgaW5kaWNhdGVzXG4gKiBhIGJyYWNlIGlzIG1pc3NpbmcgZnJvbSB0aGUgc2V0KVxuICovXG5cbmZ1bmN0aW9uIGlzT3B0aW1pemVkKG5vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKG5vZGUucGFyZW50LmlzT3B0aW1pemVkKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGlzVHlwZShub2RlLnBhcmVudCwgJ2JyYWNlJylcbiAgICAmJiAhaXNFc2NhcGVkKG5vZGUucGFyZW50KVxuICAgICYmIG9wdGlvbnMuZXhwYW5kICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaW4gYG5vZGVgIHNob3VsZCBiZSB3cmFwcGVkIGluIGEgbGl0ZXJhbCBicmFjZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNMaXRlcmFsQnJhY2Uobm9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gaXNFc2NhcGVkKG5vZGUucGFyZW50KSB8fCBvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBkb2VzIG5vdCBoYXZlIGFuIGlubmVyIHZhbHVlLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBub0lubmVyKG5vZGUsIHR5cGUpIHtcbiAgaWYgKG5vZGUucGFyZW50LnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBub2RlcyA9IG5vZGUucGFyZW50Lm5vZGVzO1xuICByZXR1cm4gbm9kZXMubGVuZ3RoID09PSAzXG4gICAgJiYgaXNUeXBlKG5vZGVzWzBdLCAnYnJhY2Uub3BlbicpXG4gICAgJiYgIWlzVHlwZShub2Rlc1sxXSwgJ3RleHQnKVxuICAgICYmIGlzVHlwZShub2Rlc1syXSwgJ2JyYWNlLmNsb3NlJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgdGhlIGdpdmVuIGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1R5cGUobm9kZSwgdHlwZSkge1xuICByZXR1cm4gdHlwZW9mIG5vZGUgIT09ICd1bmRlZmluZWQnICYmIG5vZGUudHlwZSA9PT0gdHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBoYXMgYSBub24tZW1wdHkgcXVldWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc1F1ZXVlKG5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobm9kZS5xdWV1ZSkgJiYgbm9kZS5xdWV1ZS5sZW5ndGg7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQnJhY2VzIHBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJyYWNlcywgb3B0aW9ucykge1xuICBicmFjZXMucGFyc2VyXG4gICAgLnNldCgnYm9zJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgIHRoaXMuYXN0ID0gdGhpcy5ub2Rlc1swXSA9IG5ldyBOb2RlKHRoaXMuYXN0KTtcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIHBhcnNlcnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2VzY2FwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXig/OlxcXFwoLil8XFwkXFx7KS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG5cbiAgICAgIHZhciBub2RlID0gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBtdWx0aXBsaWVyOiAxLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pKTtcblxuICAgICAgaWYgKG5vZGUudmFsID09PSAnXFxcXFxcXFwnKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS52YWwgPT09ICckeycpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHdoaWxlICgoY2ggPSBzdHJbKytpZHhdKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgICBub2RlLnZhbCArPSBjaDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgbm9kZS52YWwgKz0gc3RyWysraWR4XTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudW5lc2NhcGUgIT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUudmFsID0gbm9kZS52YWwucmVwbGFjZSgvXFxcXChbe31dKS9nLCAnJDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3QudmFsID09PSAnXCInICYmIHRoaXMuaW5wdXQuY2hhckF0KDApID09PSAnXCInKSB7XG4gICAgICAgIGxhc3QudmFsID0gbm9kZS52YWw7XG4gICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0Tm9kZXMuY2FsbCh0aGlzLCBwb3MsIG5vZGUsIHByZXYsIG9wdGlvbnMpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFja2V0czogXCJbLi4uXVwiIChiYXNpYywgdGhpcyBpcyBvdmVycmlkZGVuIGJ5XG4gICAgICogb3RoZXIgcGFyc2VycyBpbiBtb3JlIGFkdmFuY2VkIGltcGxlbWVudGF0aW9ucylcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0luc2lkZSA9IHRoaXMuaXNJbnNpZGUoJ2JyYWNlJyk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKD86XFxbKFshXl0/KShbXlxcXV17Mix9fFxcXS0pKFxcXXxbXiorP10rKXxcXFspLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuICAgICAgdmFyIG5lZ2F0ZWQgPSBtWzFdID8gJ14nIDogJyc7XG4gICAgICB2YXIgaW5uZXIgPSBtWzJdIHx8ICcnO1xuICAgICAgdmFyIGNsb3NlID0gbVszXSB8fCAnJztcblxuICAgICAgaWYgKGlzSW5zaWRlICYmIHByZXYudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBwcmV2LnRleHQgPSBwcmV2LnRleHQgfHwgJyc7XG4gICAgICAgIHByZXYudGV4dCArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBlc2MgPSB0aGlzLmlucHV0LnNsaWNlKDAsIDIpO1xuICAgICAgaWYgKGlubmVyID09PSAnJyAmJiBlc2MgPT09ICdcXFxcXScpIHtcbiAgICAgICAgaW5uZXIgKz0gZXNjO1xuICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHdoaWxlICgoY2ggPSBzdHJbKytpZHhdKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgY2xvc2UgPSBjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbm5lciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQnLFxuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgZXNjYXBlZDogY2xvc2UgIT09ICddJyxcbiAgICAgICAgbmVnYXRlZDogbmVnYXRlZCxcbiAgICAgICAgaW5uZXI6IGlubmVyLFxuICAgICAgICBjbG9zZTogY2xvc2VcbiAgICAgIH0pKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRW1wdHkgYnJhY2VzICh3ZSBjYXB0dXJlIHRoZXNlIGVhcmx5IHRvXG4gICAgICogc3BlZWQgdXAgcHJvY2Vzc2luZyBpbiB0aGUgY29tcGlsZXIpXG4gICAgICovXG5cbiAgICAuc2V0KCdtdWx0aXBsaWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNJbnNpZGUgPSB0aGlzLmlzSW5zaWRlKCdicmFjZScpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxceygoPzosfFxceywrXFx9KSspXFx9Lyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdGhpcy5tdWx0aXBsaWVyID0gdHJ1ZTtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgaWYgKGlzSW5zaWRlICYmIHByZXYudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBwcmV2LnRleHQgPSBwcmV2LnRleHQgfHwgJyc7XG4gICAgICAgIHByZXYudGV4dCArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBtdWx0aXBsaWVyOiAxLFxuICAgICAgICBtYXRjaDogbSxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGNvbmNhdE5vZGVzLmNhbGwodGhpcywgcG9zLCBub2RlLCBwcmV2LCBvcHRpb25zKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogT3BlblxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2Uub3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxceyg/ISg/OlteXFxcXH1dP3wsKylcXH0pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcblxuICAgICAgLy8gaWYgdGhlIGxhc3QgcGFyc2VkIGNoYXJhY3RlciB3YXMgYW4gZXh0Z2xvYiBjaGFyYWN0ZXJcbiAgICAgIC8vIHdlIG5lZWQgdG8gX25vdCBvcHRpbWl6ZV8gdGhlIGJyYWNlIHBhdHRlcm4gYmVjYXVzZVxuICAgICAgLy8gaXQgbWlnaHQgYmUgbWlzdGFrZW4gZm9yIGFuIGV4dGdsb2IgYnkgYSBkb3duc3RyZWFtIHBhcnNlclxuICAgICAgaWYgKGxhc3QgJiYgbGFzdC52YWwgJiYgaXNFeHRnbG9iQ2hhcihsYXN0LnZhbC5zbGljZSgtMSkpKSB7XG4gICAgICAgIGxhc3Qub3B0aW1pemUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZW4gPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAnYnJhY2Uub3BlbicsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSkpO1xuXG4gICAgICB2YXIgbm9kZSA9IHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgIG5vZGVzOiBbXVxuICAgICAgfSkpO1xuXG4gICAgICBub2RlLnB1c2gob3Blbik7XG4gICAgICBwcmV2LnB1c2gobm9kZSk7XG4gICAgICB0aGlzLnB1c2goJ2JyYWNlJywgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENsb3NlXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFjZS5jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcfS8pO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHZhciBicmFjZSA9IHRoaXMucG9wKCdicmFjZScpO1xuICAgICAgdmFyIG5vZGUgPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAnYnJhY2UuY2xvc2UnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCF0aGlzLmlzVHlwZShicmFjZSwgJ2JyYWNlJykpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlbmluZyBcIntcIicpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgbm9kZS5tdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG4gICAgICBpZiAobGFzdC50ZXh0KSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZSA9IHV0aWxzLmxhc3QobGFzdC5ub2Rlcyk7XG4gICAgICAgIGlmIChsYXN0Tm9kZS52YWwgPT09ICcpJyAmJiAvWyFAKj8rXVxcKC8udGVzdChsYXN0LnRleHQpKSB7XG4gICAgICAgICAgdmFyIG9wZW4gPSBsYXN0Lm5vZGVzWzBdO1xuICAgICAgICAgIHZhciB0ZXh0ID0gbGFzdC5ub2Rlc1sxXTtcbiAgICAgICAgICBpZiAob3Blbi50eXBlID09PSAnYnJhY2Uub3BlbicgJiYgdGV4dCAmJiB0ZXh0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGV4dC5vcHRpbWl6ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYnJhY2Uubm9kZXMubGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgZmlyc3QgPSBicmFjZS5ub2Rlc1sxXTtcbiAgICAgICAgaWYgKGZpcnN0LnR5cGUgPT09ICd0ZXh0JyAmJiBmaXJzdC52YWwgPT09ICcsJykge1xuICAgICAgICAgIGJyYWNlLm5vZGVzLnNwbGljZSgxLCAxKTtcbiAgICAgICAgICBicmFjZS5ub2Rlcy5wdXNoKGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmFjZS5wdXNoKG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIGJvdW5kYXJ5IGNoYXJhY3RlcnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JvdW5kYXJ5JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eWyReXSg/IVxceykvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIE9uZSBvciB6ZXJvLCBub24tY29tbWEgY2hhcmFjdGVycyB3cmFwcGVkIGluIGJyYWNlc1xuICAgICAqL1xuXG4gICAgLnNldCgnbm9icmFjZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzSW5zaWRlID0gdGhpcy5pc0luc2lkZSgnYnJhY2UnKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXHtbXixdP1xcfS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgaWYgKGlzSW5zaWRlICYmIHByZXYudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBwcmV2LnRleHQgPSBwcmV2LnRleHQgfHwgJyc7XG4gICAgICAgIHByZXYudGV4dCArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG11bHRpcGxpZXI6IDAsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0luc2lkZSA9IHRoaXMuaXNJbnNpZGUoJ2JyYWNlJyk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKCg/IVxcXFwpW14ke31bXFxdXSkrLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICBpZiAoaXNJbnNpZGUgJiYgcHJldi50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgIHByZXYudGV4dCA9IHByZXYudGV4dCB8fCAnJztcbiAgICAgICAgcHJldi50ZXh0ICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG11bHRpcGxpZXI6IDEsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBjb25jYXROb2Rlcy5jYWxsKHRoaXMsIHBvcywgbm9kZSwgcHJldiwgb3B0aW9ucyk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGFuIGV4dGdsb2IgY2hhcmFjdGVyLlxuICovXG5cbmZ1bmN0aW9uIGlzRXh0Z2xvYkNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAnIScgfHwgY2ggPT09ICdAJyB8fCBjaCA9PT0gJyonIHx8IGNoID09PSAnPycgfHwgY2ggPT09ICcrJztcbn1cblxuLyoqXG4gKiBDb21iaW5lIHRleHQgbm9kZXMsIGFuZCBjYWxjdWxhdGUgZW1wdHkgc2V0cyAoYHssLH1gKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYHBvc2AgRnVuY3Rpb24gdG8gY2FsY3VsYXRlIG5vZGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgQVNUIG5vZGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBjb25jYXROb2Rlcyhwb3MsIG5vZGUsIHBhcmVudCwgb3B0aW9ucykge1xuICBub2RlLm9yaWcgPSBub2RlLnZhbDtcbiAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgdmFyIGxhc3QgPSB1dGlscy5sYXN0KHByZXYubm9kZXMpO1xuICB2YXIgaXNFc2NhcGVkID0gZmFsc2U7XG5cbiAgaWYgKG5vZGUudmFsLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYSA9IG5vZGUudmFsLmNoYXJBdCgwKTtcbiAgICB2YXIgYiA9IG5vZGUudmFsLnNsaWNlKC0xKTtcblxuICAgIGlzRXNjYXBlZCA9IChhID09PSAnXCInICYmIGIgPT09ICdcIicpXG4gICAgICB8fCAoYSA9PT0gXCInXCIgJiYgYiA9PT0gXCInXCIpXG4gICAgICB8fCAoYSA9PT0gJ2AnICYmIGIgPT09ICdgJyk7XG4gIH1cblxuICBpZiAoaXNFc2NhcGVkICYmIG9wdGlvbnMudW5lc2NhcGUgIT09IGZhbHNlKSB7XG4gICAgbm9kZS52YWwgPSBub2RlLnZhbC5zbGljZSgxLCBub2RlLnZhbC5sZW5ndGggLSAxKTtcbiAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGUubWF0Y2gpIHtcbiAgICB2YXIgbWF0Y2ggPSBub2RlLm1hdGNoWzFdO1xuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXhPZignfScpID09PSAtMSkge1xuICAgICAgbWF0Y2ggPSBub2RlLm1hdGNoWzBdO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgZWFjaCBzZXQgd2l0aCBhIHNpbmdsZSBcIixcIlxuICAgIHZhciB2YWwgPSBtYXRjaC5yZXBsYWNlKC9cXHsvZywgJywnKS5yZXBsYWNlKC9cXH0vZywgJycpO1xuICAgIG5vZGUubXVsdGlwbGllciAqPSB2YWwubGVuZ3RoO1xuICAgIG5vZGUudmFsID0gJyc7XG4gIH1cblxuICB2YXIgc2ltcGxlVGV4dCA9IGxhc3QudHlwZSA9PT0gJ3RleHQnXG4gICAgJiYgbGFzdC5tdWx0aXBsaWVyID09PSAxXG4gICAgJiYgbm9kZS5tdWx0aXBsaWVyID09PSAxXG4gICAgJiYgbm9kZS52YWw7XG5cbiAgaWYgKHNpbXBsZVRleHQpIHtcbiAgICBsYXN0LnZhbCArPSBub2RlLnZhbDtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcmV2LnB1c2gobm9kZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzcGxpdFN0cmluZyA9IHJlcXVpcmUoJ3NwbGl0LXN0cmluZycpO1xudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnV0aWxzLmV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG51dGlscy5mbGF0dGVuID0gcmVxdWlyZSgnYXJyLWZsYXR0ZW4nKTtcbnV0aWxzLmlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnV0aWxzLmZpbGxSYW5nZSA9IHJlcXVpcmUoJ2ZpbGwtcmFuZ2UnKTtcbnV0aWxzLnJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1lbGVtZW50Jyk7XG51dGlscy51bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcblxudXRpbHMuZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHZhbFxuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgb25seSBlbXB0eSBicmFjZSBzZXRzLlxuICovXG5cbnV0aWxzLmlzRW1wdHlTZXRzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAvXig/OlxceyxcXH0pKyQvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgb25seSBlbXB0eSBicmFjZSBzZXRzLlxuICovXG5cbnV0aWxzLmlzUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBvcGVuID0gc3RyLmNoYXJBdCgwKTtcbiAgaWYgKG9wZW4gPT09ICdcXCcnIHx8IG9wZW4gPT09ICdcIicgfHwgb3BlbiA9PT0gJ2AnKSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgtMSkgPT09IG9wZW47XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGtleSB0byB1c2UgZm9yIG1lbW9pemF0aW9uLiBUaGUgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbnV0aWxzLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGlkID0gcGF0dGVybjtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZCArPSAnOycgKyBrZXkgKyAnPScgKyBTdHJpbmcob3B0aW9uc1trZXldKTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBvcHRpb25zXG4gKi9cblxudXRpbHMuY3JlYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgaWYgKHR5cGVvZiBvcHRzLmV4cGFuZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0cy5vcHRpbWl6ZSA9ICFvcHRzLmV4cGFuZDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdHMub3B0aW1pemUgPT09ICdib29sZWFuJykge1xuICAgIG9wdHMuZXhwYW5kID0gIW9wdHMub3B0aW1pemU7XG4gIH1cbiAgaWYgKG9wdHMub3B0aW1pemUgPT09IHRydWUpIHtcbiAgICBvcHRzLm1ha2VSZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG4vKipcbiAqIEpvaW4gcGF0dGVybnMgaW4gYGFgIHRvIHBhdHRlcm5zIGluIGBiYFxuICovXG5cbnV0aWxzLmpvaW4gPSBmdW5jdGlvbihhLCBiLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBhID0gdXRpbHMuYXJyYXlpZnkoYSk7XG4gIGIgPSB1dGlscy5hcnJheWlmeShiKTtcblxuICBpZiAoIWEubGVuZ3RoKSByZXR1cm4gYjtcbiAgaWYgKCFiLmxlbmd0aCkgcmV0dXJuIGE7XG5cbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBhcnIgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgdmFsID0gYVtpZHhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbFtpXSA9IHV0aWxzLmpvaW4odmFsW2ldLCBiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGFyci5wdXNoKHZhbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBidmFsID0gYltqXTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnZhbCkpIHtcbiAgICAgICAgYXJyLnB1c2godXRpbHMuam9pbih2YWwsIGJ2YWwsIG9wdGlvbnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci5wdXNoKHZhbCArIGJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgZ2l2ZW4gc3RyaW5nIG9uIGAsYCBpZiBub3QgZXNjYXBlZC5cbiAqL1xuXG51dGlscy5zcGxpdCA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHV0aWxzLmV4dGVuZCh7c2VwOiAnLCd9LCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRzLmtlZXBRdW90ZXMgIT09ICdib29sZWFuJykge1xuICAgIG9wdHMua2VlcFF1b3RlcyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMudW5lc2NhcGUgPT09IGZhbHNlKSB7XG4gICAgb3B0cy5rZWVwRXNjYXBpbmcgPSB0cnVlO1xuICB9XG4gIHJldHVybiBzcGxpdFN0cmluZyhzdHIsIG9wdHMsIHV0aWxzLmVzY2FwZUJyYWNrZXRzKG9wdHMpKTtcbn07XG5cbi8qKlxuICogRXhwYW5kIHJhbmdlcyBvciBzZXRzIGluIHRoZSBnaXZlbiBgcGF0dGVybmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxudXRpbHMuZXhwYW5kID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdXRpbHMuZXh0ZW5kKHtyYW5nZUxpbWl0OiAxMDAwMH0sIG9wdGlvbnMpO1xuICB2YXIgc2VncyA9IHV0aWxzLnNwbGl0KHN0ciwgb3B0cyk7XG4gIHZhciB0b2sgPSB7IHNlZ3M6IHNlZ3MgfTtcblxuICBpZiAodXRpbHMuaXNRdW90ZWRTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiB0b2s7XG4gIH1cblxuICBpZiAob3B0cy5yYW5nZUxpbWl0ID09PSB0cnVlKSB7XG4gICAgb3B0cy5yYW5nZUxpbWl0ID0gMTAwMDA7XG4gIH1cblxuICBpZiAoc2Vncy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKG9wdHMub3B0aW1pemUgPT09IGZhbHNlKSB7XG4gICAgICB0b2sudmFsID0gc2Vnc1swXTtcbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuXG4gICAgdG9rLnNlZ3MgPSB1dGlscy5zdHJpbmdpZnlBcnJheSh0b2suc2Vncyk7XG4gIH0gZWxzZSBpZiAoc2Vncy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgYXJyID0gc3RyLnNwbGl0KCcuLicpO1xuXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRvay52YWwgPSB0b2suc2Vnc1t0b2suc2Vncy5sZW5ndGggLSAxXSB8fCB0b2sudmFsIHx8IHN0cjtcbiAgICAgIHRvay5zZWdzID0gW107XG4gICAgICByZXR1cm4gdG9rO1xuICAgIH1cblxuICAgIGlmIChhcnIubGVuZ3RoID09PSAyICYmIGFyclswXSA9PT0gYXJyWzFdKSB7XG4gICAgICB0b2suZXNjYXBlZCA9IHRydWU7XG4gICAgICB0b2sudmFsID0gYXJyWzBdO1xuICAgICAgdG9rLnNlZ3MgPSBbXTtcbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuXG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAob3B0cy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3B0cy5vcHRpbWl6ZSA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBvcHRzLmV4cGFuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMub3B0aW1pemUgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKGFyclswXSwgYXJyWzFdKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGFyclswXSwgYXJyWzFdKTtcbiAgICAgICAgdmFyIHN0ZXAgPSBhcnJbMl0gfHwgMTtcblxuICAgICAgICBpZiAob3B0cy5yYW5nZUxpbWl0ICE9PSBmYWxzZSAmJiAoKG1heCAtIG1pbikgLyBzdGVwID49IG9wdHMucmFuZ2VMaW1pdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXJyLnB1c2gob3B0cyk7XG4gICAgICB0b2suc2VncyA9IHV0aWxzLmZpbGxSYW5nZS5hcHBseShudWxsLCBhcnIpO1xuXG4gICAgICBpZiAoIXRvay5zZWdzLmxlbmd0aCkge1xuICAgICAgICB0b2suZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIHRvay52YWwgPSBzdHI7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm9wdGltaXplID09PSB0cnVlKSB7XG4gICAgICAgIHRvay5zZWdzID0gdXRpbHMuc3RyaW5naWZ5QXJyYXkodG9rLnNlZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rLnNlZ3MgPT09ICcnKSB7XG4gICAgICAgIHRvay52YWwgPSBzdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2sudmFsID0gdG9rLnNlZ3NbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b2sudmFsID0gc3RyO1xuICB9XG4gIHJldHVybiB0b2s7XG59O1xuXG4vKipcbiAqIEVuc3VyZSBjb21tYXMgaW5zaWRlIGJyYWNrZXRzIGFuZCBwYXJlbnMgYXJlIG5vdCBzcGxpdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgdG9rYCBUb2tlbiBmcm9tIHRoZSBgc3BsaXQtc3RyaW5nYCBtb2R1bGVcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuXG51dGlscy5lc2NhcGVCcmFja2V0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRvaykge1xuICAgIGlmICh0b2suZXNjYXBlZCAmJiB0b2sudmFsID09PSAnYicpIHtcbiAgICAgIHRvay52YWwgPSAnXFxcXGInO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0b2sudmFsICE9PSAnKCcgJiYgdG9rLnZhbCAhPT0gJ1snKSByZXR1cm47XG4gICAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciBicmFja2V0cyA9IFtdO1xuICAgIHZhciBwYXJlbnMgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgdmFsID0gdG9rLnZhbDtcbiAgICB2YXIgc3RyID0gdG9rLnN0cjtcbiAgICB2YXIgaSA9IHRvay5pZHggLSAxO1xuXG4gICAgd2hpbGUgKCsraSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHN0cltpXTtcblxuICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFsICs9IChvcHRzLmtlZXBFc2NhcGluZyA9PT0gZmFsc2UgPyAnJyA6IGNoKSArIHN0clsrK2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgcGFyZW5zLnB1c2goY2gpO1xuICAgICAgICBzdGFjay5wdXNoKGNoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgYnJhY2tldHMucHVzaChjaCk7XG4gICAgICAgIHN0YWNrLnB1c2goY2gpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICBwYXJlbnMucG9wKCk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCArPSBjaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFsICs9IGNoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWwgKz0gY2g7XG4gICAgfVxuXG4gICAgdG9rLnNwbGl0ID0gZmFsc2U7XG4gICAgdG9rLnZhbCA9IHZhbC5zbGljZSgxKTtcbiAgICB0b2suaWR4ID0gaTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgbG9va3MgbGlrZSBhIHJlZ2V4IHF1YW50aWZpZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAvXig/OlswLTldPyxbMC05XXxbMC05XSwpJC8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHsqfSBgdmFsYFxuICovXG5cbnV0aWxzLnN0cmluZ2lmeUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBbdXRpbHMuYXJyYXlpZnkoYXJyKS5qb2luKCd8JyldO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHsqfSBgdmFsYFxuICovXG5cbnV0aWxzLmFycmF5aWZ5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIGlmICh0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAodHlwZW9mIGFyciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW2Fycl07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ciAhPSBudWxsICYmIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBmcm9tIGBhcnJheWBcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJheWBcbiAqIEByZXR1cm4geyp9XG4gKi9cblxudXRpbHMubGFzdCA9IGZ1bmN0aW9uKGFyciwgbikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAobiB8fCAxKV07XG59O1xuXG51dGlscy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFw/KFshXio/KClbXFxde30rPy9dKS9nLCAnXFxcXCQxJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpcy1leHRlbmRhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKG8vKiwgb2JqZWN0cyovKSB7XG4gIGlmICghaXNPYmplY3QobykpIHsgbyA9IHt9OyB9XG5cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgIGFzc2lnbihvLCBvYmopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbihhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhc093bihiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBga2V5YCBpcyBhbiBvd24gcHJvcGVydHkgb2YgYG9iamAuXG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb24tdmlzaXQnKTtcbnZhciB0b1BhdGggPSByZXF1aXJlKCd0by1vYmplY3QtcGF0aCcpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgndW5pb24tdmFsdWUnKTtcbnZhciBkZWwgPSByZXF1aXJlKCd1bnNldC12YWx1ZScpO1xudmFyIGdldCA9IHJlcXVpcmUoJ2dldC12YWx1ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcy12YWx1ZScpO1xudmFyIHNldCA9IHJlcXVpcmUoJ3NldC12YWx1ZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGBDYWNoZWAgY29uc3RydWN0b3IgdGhhdCB3aGVuIGluc3RhbnRpYXRlZCB3aWxsXG4gKiBzdG9yZSB2YWx1ZXMgb24gdGhlIGdpdmVuIGBwcm9wYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhY2hlID0gcmVxdWlyZSgnY2FjaGUtYmFzZScpLm5hbWVzcGFjZSgnZGF0YScpO1xuICogdmFyIGNhY2hlID0gbmV3IENhY2hlKCk7XG4gKlxuICogY2FjaGUuc2V0KCdmb28nLCAnYmFyJyk7XG4gKiAvLz0+IHtkYXRhOiB7Zm9vOiAnYmFyJ319XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcHJvcGAgVGhlIHByb3BlcnR5IG5hbWUgdG8gdXNlIGZvciBzdG9yaW5nIHZhbHVlcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY3VzdG9tIGBDYWNoZWAgY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbmFtZXNwYWNlKHByb3ApIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDYWNoZWAuIEludGVybmFsbHkgdGhlIGBDYWNoZWAgY29uc3RydWN0b3IgaXMgY3JlYXRlZCB1c2luZ1xuICAgKiB0aGUgYG5hbWVzcGFjZWAgZnVuY3Rpb24sIHdpdGggYGNhY2hlYCBkZWZpbmVkIGFzIHRoZSBzdG9yYWdlIG9iamVjdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGFwcCA9IG5ldyBDYWNoZSgpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHtPYmplY3R9IGBjYWNoZWAgT3B0aW9uYWxseSBwYXNzIGFuIG9iamVjdCB0byBpbml0aWFsaXplIHdpdGguXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBDYWNoZShjYWNoZSkge1xuICAgIGlmIChwcm9wKSB7XG4gICAgICB0aGlzW3Byb3BdID0ge307XG4gICAgfVxuICAgIGlmIChjYWNoZSkge1xuICAgICAgdGhpcy5zZXQoY2FjaGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmhlcml0IEVtaXR0ZXJcbiAgICovXG5cbiAgRW1pdHRlcihDYWNoZS5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBBc3NpZ24gYHZhbHVlYCB0byBga2V5YC4gQWxzbyBlbWl0cyBgc2V0YCB3aXRoXG4gICAqIHRoZSBrZXkgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAub24oJ3NldCcsIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAqICAgLy8gZG8gc29tZXRoaW5nIHdoZW4gYHNldGAgaXMgZW1pdHRlZFxuICAgKiB9KTtcbiAgICpcbiAgICogYXBwLnNldChrZXksIHZhbHVlKTtcbiAgICpcbiAgICogLy8gYWxzbyB0YWtlcyBhbiBvYmplY3Qgb3IgYXJyYXlcbiAgICogYXBwLnNldCh7bmFtZTogJ0hhbGxlJ30pO1xuICAgKiBhcHAuc2V0KFt7Zm9vOiAnYmFyJ30sIHtiYXo6ICdxdXV4J31dKTtcbiAgICogY29uc29sZS5sb2coYXBwKTtcbiAgICogLy89PiB7bmFtZTogJ0hhbGxlJywgZm9vOiAnYmFyJywgYmF6OiAncXV1eCd9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbmFtZSAuc2V0XG4gICAqIEBlbWl0cyBgc2V0YCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIGFzIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgXG4gICAqIEBwYXJhbSB7YW55fSBgdmFsdWVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGtleSA9IHRvUGF0aChrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoa2V5KSB8fCBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIHRoaXMudmlzaXQoJ3NldCcsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldChwcm9wID8gdGhpc1twcm9wXSA6IHRoaXMsIGtleSwgdmFsKTtcbiAgICAgIHRoaXMuZW1pdCgnc2V0Jywga2V5LCB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5pb24gYGFycmF5YCB0byBga2V5YC4gQWxzbyBlbWl0cyBgc2V0YCB3aXRoXG4gICAqIHRoZSBrZXkgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAudW5pb24oJ2EuYicsIFsnZm9vJ10pO1xuICAgKiBhcHAudW5pb24oJ2EuYicsIFsnYmFyJ10pO1xuICAgKiBjb25zb2xlLmxvZyhhcHAuZ2V0KCdhJykpO1xuICAgKiAvLz0+IHtiOiBbJ2ZvbycsICdiYXInXX1cbiAgICogYGBgXG4gICAqIEBuYW1lIC51bmlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAgICogQHBhcmFtIHthbnl9IGB2YWx1ZWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENhY2hlLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBrZXkgPSB0b1BhdGgoa2V5KTtcbiAgICB9XG4gICAgdmFyIGN0eCA9IHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcztcbiAgICB1bmlvbihjdHgsIGtleSwgYXJyYXlpZnkodmFsKSk7XG4gICAgdGhpcy5lbWl0KCd1bmlvbicsIHZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgYGtleWAuIERvdCBub3RhdGlvbiBtYXkgYmUgdXNlZFxuICAgKiB0byBnZXQgW25lc3RlZCBwcm9wZXJ0eSB2YWx1ZXNdW2dldC12YWx1ZV0uXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5zZXQoJ2EuYi5jJywgJ2QnKTtcbiAgICogYXBwLmdldCgnYS5iJyk7XG4gICAqIC8vPT4ge2M6ICdkJ31cbiAgICpcbiAgICogYXBwLmdldChbJ2EnLCAnYiddKTtcbiAgICogLy89PiB7YzogJ2QnfVxuICAgKiBgYGBcbiAgICpcbiAgICogQG5hbWUgLmdldFxuICAgKiBAZW1pdHMgYGdldGAgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBhcyBhcmd1bWVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LiBEb3Qtbm90YXRpb24gbWF5IGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge2FueX0gUmV0dXJucyB0aGUgdmFsdWUgb2YgYGtleWBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IHRvUGF0aChhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN0eCA9IHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcztcbiAgICB2YXIgdmFsID0gZ2V0KGN0eCwga2V5KTtcblxuICAgIHRoaXMuZW1pdCgnZ2V0Jywga2V5LCB2YWwpO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGFwcCBoYXMgYSBzdG9yZWQgdmFsdWUgZm9yIGBrZXlgLFxuICAgKiBmYWxzZSBvbmx5IGlmIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAuc2V0KCdmb28nLCAnYmFyJyk7XG4gICAqIGFwcC5oYXMoJ2ZvbycpO1xuICAgKiAvLz0+IHRydWVcbiAgICogYGBgXG4gICAqXG4gICAqIEBuYW1lIC5oYXNcbiAgICogQGVtaXRzIGBoYXNgIHdpdGggYGtleWAgYW5kIHRydWUgb3IgZmFsc2UgYXMgYXJndW1lbnRzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IHRvUGF0aChhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN0eCA9IHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcztcbiAgICB2YXIgdmFsID0gZ2V0KGN0eCwga2V5KTtcblxuICAgIHZhciBoYXMgPSB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcbiAgICB0aGlzLmVtaXQoJ2hhcycsIGtleSwgaGFzKTtcbiAgICByZXR1cm4gaGFzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgb25lIG9yIG1vcmUgcHJvcGVydGllcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogYGBganNcbiAgICogYXBwLmRlbCgpOyAvLyBkZWxldGUgYWxsXG4gICAqIC8vIG9yXG4gICAqIGFwcC5kZWwoJ2ZvbycpO1xuICAgKiAvLyBvclxuICAgKiBhcHAuZGVsKFsnZm9vJywgJ2JhciddKTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5kZWxcbiAgICogQGVtaXRzIGBkZWxgIHdpdGggdGhlIGBrZXlgIGFzIHRoZSBvbmx5IGFyZ3VtZW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYGtleWAgUHJvcGVydHkgbmFtZSBvciBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICB0aGlzLnZpc2l0KCdkZWwnLCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWwocHJvcCA/IHRoaXNbcHJvcF0gOiB0aGlzLCBrZXkpO1xuICAgICAgdGhpcy5lbWl0KCdkZWwnLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIGVudGlyZSBjYWNoZSB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5jbGVhcigpO1xuICAgKiBgYGBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHRoaXNbcHJvcF0gPSB7fTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFZpc2l0IGBtZXRob2RgIG92ZXIgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIG9iamVjdCwgb3IgbWFwXG4gICAqIHZpc2l0IG92ZXIgdGhlIG9iamVjdC1lbGVtZW50cyBpbiBhbiBhcnJheS5cbiAgICpcbiAgICogQG5hbWUgLnZpc2l0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbWV0aG9kYCBUaGUgbmFtZSBvZiB0aGUgYGJhc2VgIG1ldGhvZCB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYHZhbGAgVGhlIG9iamVjdCBvciBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihtZXRob2QsIHZhbCkge1xuICAgIHZpc2l0KHRoaXMsIG1ldGhvZCwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQ2FjaGU7XG59XG5cbi8qKlxuICogQ2FzdCB2YWwgdG8gYW4gYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYENhY2hlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbmFtZXNwYWNlKCk7XG5cbi8qKlxuICogRXhwb3NlIGBDYWNoZS5uYW1lc3BhY2VgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgc3lzUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBhc3luY0VhY2ggPSByZXF1aXJlKCdhc3luYy1lYWNoJyk7XG52YXIgYW55bWF0Y2ggPSByZXF1aXJlKCdhbnltYXRjaCcpO1xudmFyIGdsb2JQYXJlbnQgPSByZXF1aXJlKCdnbG9iLXBhcmVudCcpO1xudmFyIGlzR2xvYiA9IHJlcXVpcmUoJ2lzLWdsb2InKTtcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbnZhciBub3JtYWxpemVQYXRoID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgnKTtcbnZhciB1cGF0aCA9IHJlcXVpcmUoJ3VwYXRoJyk7XG5cbnZhciBOb2RlRnNIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvbm9kZWZzLWhhbmRsZXInKTtcbnZhciBGc0V2ZW50c0hhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9mc2V2ZW50cy1oYW5kbGVyJyk7XG5cbnZhciBhcnJpZnkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59O1xuXG52YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGxpc3QsIHJlc3VsdCkge1xuICBpZiAocmVzdWx0ID09IG51bGwpIHJlc3VsdCA9IFtdO1xuICBsaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBmbGF0dGVuKGl0ZW0sIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBMaXR0bGUgaXNTdHJpbmcgdXRpbCBmb3IgdXNlIGluIEFycmF5I2V2ZXJ5LlxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ3N0cmluZyc7XG59O1xuXG4vLyBQdWJsaWM6IE1haW4gY2xhc3MuXG4vLyBXYXRjaGVzIGZpbGVzICYgZGlyZWN0b3JpZXMgZm9yIGNoYW5nZXMuXG4vL1xuLy8gKiBfb3B0cyAtIG9iamVjdCwgY2hva2lkYXIgb3B0aW9ucyBoYXNoXG4vL1xuLy8gRW1pdHRlZCBldmVudHM6XG4vLyBgYWRkYCwgYGFkZERpcmAsIGBjaGFuZ2VgLCBgdW5saW5rYCwgYHVubGlua0RpcmAsIGBhbGxgLCBgZXJyb3JgXG4vL1xuLy8gRXhhbXBsZXNcbi8vXG4vLyAgdmFyIHdhdGNoZXIgPSBuZXcgRlNXYXRjaGVyKClcbi8vICAgIC5hZGQoZGlyZWN0b3JpZXMpXG4vLyAgICAub24oJ2FkZCcsIHBhdGggPT4gY29uc29sZS5sb2coJ0ZpbGUnLCBwYXRoLCAnd2FzIGFkZGVkJykpXG4vLyAgICAub24oJ2NoYW5nZScsIHBhdGggPT4gY29uc29sZS5sb2coJ0ZpbGUnLCBwYXRoLCAnd2FzIGNoYW5nZWQnKSlcbi8vICAgIC5vbigndW5saW5rJywgcGF0aCA9PiBjb25zb2xlLmxvZygnRmlsZScsIHBhdGgsICd3YXMgcmVtb3ZlZCcpKVxuLy8gICAgLm9uKCdhbGwnLCAoZXZlbnQsIHBhdGgpID0+IGNvbnNvbGUubG9nKHBhdGgsICcgZW1pdHRlZCAnLCBldmVudCkpXG4vL1xuZnVuY3Rpb24gRlNXYXRjaGVyKF9vcHRzKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgb3B0cyA9IHt9O1xuICAvLyBpbiBjYXNlIF9vcHRzIHRoYXQgaXMgcGFzc2VkIGluIGlzIGEgZnJvemVuIG9iamVjdFxuICBpZiAoX29wdHMpIGZvciAodmFyIG9wdCBpbiBfb3B0cykgb3B0c1tvcHRdID0gX29wdHNbb3B0XTtcbiAgdGhpcy5fd2F0Y2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2Nsb3NlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9pZ25vcmVkUGF0aHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19nbG9iSWdub3JlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faWdub3JlZFBhdGhzKTsgfVxuICB9KTtcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgdGhpcy5fdGhyb3R0bGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fc3ltbGlua1BhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiB1bmRlZihrZXkpIHtcbiAgICByZXR1cm4gb3B0c1trZXldID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBTZXQgdXAgZGVmYXVsdCBvcHRpb25zLlxuICBpZiAodW5kZWYoJ3BlcnNpc3RlbnQnKSkgb3B0cy5wZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgaWYgKHVuZGVmKCdpZ25vcmVJbml0aWFsJykpIG9wdHMuaWdub3JlSW5pdGlhbCA9IGZhbHNlO1xuICBpZiAodW5kZWYoJ2lnbm9yZVBlcm1pc3Npb25FcnJvcnMnKSkgb3B0cy5pZ25vcmVQZXJtaXNzaW9uRXJyb3JzID0gZmFsc2U7XG4gIGlmICh1bmRlZignaW50ZXJ2YWwnKSkgb3B0cy5pbnRlcnZhbCA9IDEwMDtcbiAgaWYgKHVuZGVmKCdiaW5hcnlJbnRlcnZhbCcpKSBvcHRzLmJpbmFyeUludGVydmFsID0gMzAwO1xuICBpZiAodW5kZWYoJ2Rpc2FibGVHbG9iYmluZycpKSBvcHRzLmRpc2FibGVHbG9iYmluZyA9IGZhbHNlO1xuICB0aGlzLmVuYWJsZUJpbmFyeUludGVydmFsID0gb3B0cy5iaW5hcnlJbnRlcnZhbCAhPT0gb3B0cy5pbnRlcnZhbDtcblxuICAvLyBFbmFibGUgZnNldmVudHMgb24gT1MgWCB3aGVuIHBvbGxpbmcgaXNuJ3QgZXhwbGljaXRseSBlbmFibGVkLlxuICBpZiAodW5kZWYoJ3VzZUZzRXZlbnRzJykpIG9wdHMudXNlRnNFdmVudHMgPSAhb3B0cy51c2VQb2xsaW5nO1xuXG4gIC8vIElmIHdlIGNhbid0IHVzZSBmc2V2ZW50cywgZW5zdXJlIHRoZSBvcHRpb25zIHJlZmxlY3QgaXQncyBkaXNhYmxlZC5cbiAgaWYgKCFGc0V2ZW50c0hhbmRsZXIuY2FuVXNlKCkpIG9wdHMudXNlRnNFdmVudHMgPSBmYWxzZTtcblxuICAvLyBVc2UgcG9sbGluZyBvbiBNYWMgaWYgbm90IHVzaW5nIGZzZXZlbnRzLlxuICAvLyBPdGhlciBwbGF0Zm9ybXMgdXNlIG5vbi1wb2xsaW5nIGZzLndhdGNoLlxuICBpZiAodW5kZWYoJ3VzZVBvbGxpbmcnKSAmJiAhb3B0cy51c2VGc0V2ZW50cykge1xuICAgIG9wdHMudXNlUG9sbGluZyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nO1xuICB9XG5cbiAgLy8gR2xvYmFsIG92ZXJyaWRlICh1c2VmdWwgZm9yIGVuZC1kZXZlbG9wZXJzIHRoYXQgbmVlZCB0byBmb3JjZSBwb2xsaW5nIGZvciBhbGxcbiAgLy8gaW5zdGFuY2VzIG9mIGNob2tpZGFyLCByZWdhcmRsZXNzIG9mIHVzYWdlL2RlcGVuZGVuY3kgZGVwdGgpXG4gIHZhciBlbnZQb2xsID0gcHJvY2Vzcy5lbnYuQ0hPS0lEQVJfVVNFUE9MTElORztcbiAgaWYgKGVudlBvbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlbnZMb3dlciA9IGVudlBvbGwudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbnZMb3dlciA9PT0gJ2ZhbHNlJyB8fCBlbnZMb3dlciA9PT0gJzAnKSB7XG4gICAgICBvcHRzLnVzZVBvbGxpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGVudkxvd2VyID09PSAndHJ1ZScgfHwgZW52TG93ZXIgPT09ICcxJykge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gISFlbnZMb3dlclxuICAgIH1cbiAgfVxuICB2YXIgZW52SW50ZXJ2YWwgPSBwcm9jZXNzLmVudi5DSE9LSURBUl9JTlRFUlZBTDtcbiAgaWYgKGVudkludGVydmFsKSB7XG4gICAgb3B0cy5pbnRlcnZhbCA9IHBhcnNlSW50KGVudkludGVydmFsKTtcbiAgfVxuXG4gIC8vIEVkaXRvciBhdG9taWMgd3JpdGUgbm9ybWFsaXphdGlvbiBlbmFibGVkIGJ5IGRlZmF1bHQgd2l0aCBmcy53YXRjaFxuICBpZiAodW5kZWYoJ2F0b21pYycpKSBvcHRzLmF0b21pYyA9ICFvcHRzLnVzZVBvbGxpbmcgJiYgIW9wdHMudXNlRnNFdmVudHM7XG4gIGlmIChvcHRzLmF0b21pYykgdGhpcy5fcGVuZGluZ1VubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGlmICh1bmRlZignZm9sbG93U3ltbGlua3MnKSkgb3B0cy5mb2xsb3dTeW1saW5rcyA9IHRydWU7XG5cbiAgaWYgKHVuZGVmKCdhd2FpdFdyaXRlRmluaXNoJykpIG9wdHMuYXdhaXRXcml0ZUZpbmlzaCA9IGZhbHNlO1xuICBpZiAob3B0cy5hd2FpdFdyaXRlRmluaXNoID09PSB0cnVlKSBvcHRzLmF3YWl0V3JpdGVGaW5pc2ggPSB7fTtcbiAgdmFyIGF3ZiA9IG9wdHMuYXdhaXRXcml0ZUZpbmlzaDtcbiAgaWYgKGF3Zikge1xuICAgIGlmICghYXdmLnN0YWJpbGl0eVRocmVzaG9sZCkgYXdmLnN0YWJpbGl0eVRocmVzaG9sZCA9IDIwMDA7XG4gICAgaWYgKCFhd2YucG9sbEludGVydmFsKSBhd2YucG9sbEludGVydmFsID0gMTAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1dyaXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaWYgKG9wdHMuaWdub3JlZCkgb3B0cy5pZ25vcmVkID0gYXJyaWZ5KG9wdHMuaWdub3JlZCk7XG5cbiAgdGhpcy5faXNudElnbm9yZWQgPSBmdW5jdGlvbihwYXRoLCBzdGF0KSB7XG4gICAgcmV0dXJuICF0aGlzLl9pc0lnbm9yZWQocGF0aCwgc3RhdCk7XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgcmVhZHlDYWxscyA9IDA7XG4gIHRoaXMuX2VtaXRSZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgrK3JlYWR5Q2FsbHMgPj0gdGhpcy5fcmVhZHlDb3VudCkge1xuICAgICAgdGhpcy5fZW1pdFJlYWR5ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgICAgdGhpcy5fcmVhZHlFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIC8vIHVzZSBwcm9jZXNzLm5leHRUaWNrIHRvIGFsbG93IHRpbWUgZm9yIGxpc3RlbmVyIHRvIGJlIGJvdW5kXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW1pdC5iaW5kKHRoaXMsICdyZWFkeScpKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuXG4gIC8vIFlvdeKAmXJlIGZyb3plbiB3aGVuIHlvdXIgaGVhcnTigJlzIG5vdCBvcGVuLlxuICBPYmplY3QuZnJlZXplKG9wdHMpO1xufVxuXG5pbmhlcml0cyhGU1dhdGNoZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIENvbW1vbiBoZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS0tLVxuXG4vLyBQcml2YXRlIG1ldGhvZDogTm9ybWFsaXplIGFuZCBlbWl0IGV2ZW50c1xuLy9cbi8vICogZXZlbnQgICAgIC0gc3RyaW5nLCB0eXBlIG9mIGV2ZW50XG4vLyAqIHBhdGggICAgICAtIHN0cmluZywgZmlsZSBvciBkaXJlY3RvcnkgcGF0aFxuLy8gKiB2YWxbMS4uM10gLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHdpdGggZXZlbnRcbi8vXG4vLyBSZXR1cm5zIHRoZSBlcnJvciBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdGhlIHZhbHVlIG9mIHRoZVxuLy8gRlNXYXRjaGVyIGluc3RhbmNlJ3MgYGNsb3NlZGAgZmxhZ1xuRlNXYXRjaGVyLnByb3RvdHlwZS5fZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCBwYXRoLCB2YWwxLCB2YWwyLCB2YWwzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuY3dkKSBwYXRoID0gc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgdmFyIGFyZ3MgPSBbZXZlbnQsIHBhdGhdO1xuICBpZiAodmFsMyAhPT0gdW5kZWZpbmVkKSBhcmdzLnB1c2godmFsMSwgdmFsMiwgdmFsMyk7XG4gIGVsc2UgaWYgKHZhbDIgIT09IHVuZGVmaW5lZCkgYXJncy5wdXNoKHZhbDEsIHZhbDIpO1xuICBlbHNlIGlmICh2YWwxICE9PSB1bmRlZmluZWQpIGFyZ3MucHVzaCh2YWwxKTtcblxuICB2YXIgYXdmID0gdGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2g7XG4gIGlmIChhd2YgJiYgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXSkge1xuICAgIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0ubGFzdENoYW5nZSA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmF0b21pYykge1xuICAgIGlmIChldmVudCA9PT0gJ3VubGluaycpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdID0gYXJncztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdVbmxpbmtzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgdGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF0pO1xuICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBbJ2FsbCddLmNvbmNhdCh0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXSkpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdHlwZW9mIHRoaXMub3B0aW9ucy5hdG9taWMgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuYXRvbWljXG4gICAgICAgIDogMTAwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdhZGQnICYmIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdKSB7XG4gICAgICBldmVudCA9IGFyZ3NbMF0gPSAnY2hhbmdlJztcbiAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZW1pdEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJykgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIFsnYWxsJ10uY29uY2F0KGFyZ3MpKTtcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIGlmIChhd2YgJiYgKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ2NoYW5nZScpICYmIHRoaXMuX3JlYWR5RW1pdHRlZCkge1xuICAgIHZhciBhd2ZFbWl0ID0gZnVuY3Rpb24oZXJyLCBzdGF0cykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBldmVudCA9IGFyZ3NbMF0gPSAnZXJyb3InO1xuICAgICAgICBhcmdzWzFdID0gZXJyO1xuICAgICAgICBlbWl0RXZlbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHMpIHtcbiAgICAgICAgLy8gaWYgc3RhdHMgZG9lc24ndCBleGlzdCB0aGUgZmlsZSBtdXN0IGhhdmUgYmVlbiBkZWxldGVkXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBhcmdzWzJdID0gc3RhdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJncy5wdXNoKHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbWl0RXZlbnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fYXdhaXRXcml0ZUZpbmlzaChwYXRoLCBhd2Yuc3RhYmlsaXR5VGhyZXNob2xkLCBldmVudCwgYXdmRW1pdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgaWYgKCF0aGlzLl90aHJvdHRsZSgnY2hhbmdlJywgcGF0aCwgNTApKSByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChcbiAgICB0aGlzLm9wdGlvbnMuYWx3YXlzU3RhdCAmJiB2YWwxID09PSB1bmRlZmluZWQgJiZcbiAgICAoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAnYWRkRGlyJyB8fCBldmVudCA9PT0gJ2NoYW5nZScpXG4gICkge1xuICAgIHZhciBmdWxsUGF0aCA9IHRoaXMub3B0aW9ucy5jd2QgPyBzeXNQYXRoLmpvaW4odGhpcy5vcHRpb25zLmN3ZCwgcGF0aCkgOiBwYXRoO1xuICAgIGZzLnN0YXQoZnVsbFBhdGgsIGZ1bmN0aW9uKGVycm9yLCBzdGF0cykge1xuICAgICAgLy8gU3VwcHJlc3MgZXZlbnQgd2hlbiBmcy5zdGF0IGZhaWxzLCB0byBhdm9pZCBzZW5kaW5nIHVuZGVmaW5lZCAnc3RhdCdcbiAgICAgIGlmIChlcnJvciB8fCAhc3RhdHMpIHJldHVybjtcblxuICAgICAgYXJncy5wdXNoKHN0YXRzKTtcbiAgICAgIGVtaXRFdmVudCgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGVtaXRFdmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogQ29tbW9uIGhhbmRsZXIgZm9yIGVycm9yc1xuLy9cbi8vICogZXJyb3IgIC0gb2JqZWN0LCBFcnJvciBpbnN0YW5jZVxuLy9cbi8vIFJldHVybnMgdGhlIGVycm9yIGlmIGRlZmluZWQsIG90aGVyd2lzZSB0aGUgdmFsdWUgb2YgdGhlXG4vLyBGU1dhdGNoZXIgaW5zdGFuY2UncyBgY2xvc2VkYCBmbGFnXG5GU1dhdGNoZXIucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHZhciBjb2RlID0gZXJyb3IgJiYgZXJyb3IuY29kZTtcbiAgdmFyIGlwZSA9IHRoaXMub3B0aW9ucy5pZ25vcmVQZXJtaXNzaW9uRXJyb3JzO1xuICBpZiAoZXJyb3IgJiZcbiAgICBjb2RlICE9PSAnRU5PRU5UJyAmJlxuICAgIGNvZGUgIT09ICdFTk9URElSJyAmJlxuICAgICghaXBlIHx8IChjb2RlICE9PSAnRVBFUk0nICYmIGNvZGUgIT09ICdFQUNDRVMnKSlcbiAgKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICByZXR1cm4gZXJyb3IgfHwgdGhpcy5jbG9zZWQ7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGVscGVyIHV0aWxpdHkgZm9yIHRocm90dGxpbmdcbi8vXG4vLyAqIGFjdGlvbiAgLSBzdHJpbmcsIHR5cGUgb2YgYWN0aW9uIGJlaW5nIHRocm90dGxlZFxuLy8gKiBwYXRoICAgIC0gc3RyaW5nLCBwYXRoIGJlaW5nIGFjdGVkIHVwb25cbi8vICogdGltZW91dCAtIGludCwgZHVyYXRpb24gb2YgdGltZSB0byBzdXBwcmVzcyBkdXBsaWNhdGUgYWN0aW9uc1xuLy9cbi8vIFJldHVybnMgdGhyb3R0bGUgdHJhY2tpbmcgb2JqZWN0IG9yIGZhbHNlIGlmIGFjdGlvbiBzaG91bGQgYmUgc3VwcHJlc3NlZFxuRlNXYXRjaGVyLnByb3RvdHlwZS5fdGhyb3R0bGUgPSBmdW5jdGlvbihhY3Rpb24sIHBhdGgsIHRpbWVvdXQpIHtcbiAgaWYgKCEoYWN0aW9uIGluIHRoaXMuX3Rocm90dGxlZCkpIHtcbiAgICB0aGlzLl90aHJvdHRsZWRbYWN0aW9uXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdmFyIHRocm90dGxlZCA9IHRoaXMuX3Rocm90dGxlZFthY3Rpb25dO1xuICBpZiAocGF0aCBpbiB0aHJvdHRsZWQpIHtcbiAgICB0aHJvdHRsZWRbcGF0aF0uY291bnQrKztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIGNvdW50ID0gdGhyb3R0bGVkW3BhdGhdID8gdGhyb3R0bGVkW3BhdGhdLmNvdW50IDogMDtcbiAgICBkZWxldGUgdGhyb3R0bGVkW3BhdGhdO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0T2JqZWN0KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgdmFyIHRpbWVvdXRPYmplY3QgPSBzZXRUaW1lb3V0KGNsZWFyLCB0aW1lb3V0KTtcbiAgdGhyb3R0bGVkW3BhdGhdID0ge3RpbWVvdXRPYmplY3Q6IHRpbWVvdXRPYmplY3QsIGNsZWFyOiBjbGVhciwgY291bnQ6IDB9O1xuICByZXR1cm4gdGhyb3R0bGVkW3BhdGhdO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEF3YWl0cyB3cml0ZSBvcGVyYXRpb24gdG8gZmluaXNoXG4vL1xuLy8gKiBwYXRoICAgIC0gc3RyaW5nLCBwYXRoIGJlaW5nIGFjdGVkIHVwb25cbi8vICogdGhyZXNob2xkIC0gaW50LCB0aW1lIGluIG1pbGxpc2Vjb25kcyBhIGZpbGUgc2l6ZSBtdXN0IGJlIGZpeGVkIGJlZm9yZVxuLy8gICAgICAgICAgICAgICAgICAgIGFja25vd2xlZGdpbmcgd3JpdGUgb3BlcmF0aW9uIGlzIGZpbmlzaGVkXG4vLyAqIGF3ZkVtaXQgLSBmdW5jdGlvbiwgdG8gYmUgY2FsbGVkIHdoZW4gcmVhZHkgZm9yIGV2ZW50IHRvIGJlIGVtaXR0ZWRcbi8vIFBvbGxzIGEgbmV3bHkgY3JlYXRlZCBmaWxlIGZvciBzaXplIHZhcmlhdGlvbnMuIFdoZW4gZmlsZXMgc2l6ZSBkb2VzIG5vdFxuLy8gY2hhbmdlIGZvciAndGhyZXNob2xkJyBtaWxsaXNlY29uZHMgY2FsbHMgY2FsbGJhY2suXG5GU1dhdGNoZXIucHJvdG90eXBlLl9hd2FpdFdyaXRlRmluaXNoID0gZnVuY3Rpb24ocGF0aCwgdGhyZXNob2xkLCBldmVudCwgYXdmRW1pdCkge1xuICB2YXIgdGltZW91dEhhbmRsZXI7XG5cbiAgdmFyIGZ1bGxQYXRoID0gcGF0aDtcbiAgaWYgKHRoaXMub3B0aW9ucy5jd2QgJiYgIWlzQWJzb2x1dGUocGF0aCkpIHtcbiAgICBmdWxsUGF0aCA9IHN5c1BhdGguam9pbih0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgfVxuXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBhd2FpdFdyaXRlRmluaXNoID0gKGZ1bmN0aW9uIChwcmV2U3RhdCkge1xuICAgIGZzLnN0YXQoZnVsbFBhdGgsIGZ1bmN0aW9uKGVyciwgY3VyU3RhdCkge1xuICAgICAgaWYgKGVyciB8fCAhKHBhdGggaW4gdGhpcy5fcGVuZGluZ1dyaXRlcykpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIGF3ZkVtaXQoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcblxuICAgICAgaWYgKHByZXZTdGF0ICYmIGN1clN0YXQuc2l6ZSAhPSBwcmV2U3RhdC5zaXplKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0ubGFzdENoYW5nZSA9IG5vdztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdyAtIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0ubGFzdENoYW5nZSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF07XG4gICAgICAgIGF3ZkVtaXQobnVsbCwgY3VyU3RhdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0SGFuZGxlciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgYXdhaXRXcml0ZUZpbmlzaC5iaW5kKHRoaXMsIGN1clN0YXQpLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hd2FpdFdyaXRlRmluaXNoLnBvbGxJbnRlcnZhbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgaWYgKCEocGF0aCBpbiB0aGlzLl9wZW5kaW5nV3JpdGVzKSkge1xuICAgIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0gPSB7XG4gICAgICBsYXN0Q2hhbmdlOiBub3csXG4gICAgICBjYW5jZWxXYWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF07XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlcik7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0uYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGltZW91dEhhbmRsZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgYXdhaXRXcml0ZUZpbmlzaC5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2gucG9sbEludGVydmFsXG4gICAgKTtcbiAgfVxufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IERldGVybWluZXMgd2hldGhlciB1c2VyIGhhcyBhc2tlZCB0byBpZ25vcmUgdGhpcyBwYXRoXG4vL1xuLy8gKiBwYXRoICAtIHN0cmluZywgcGF0aCB0byBmaWxlIG9yIGRpcmVjdG9yeVxuLy8gKiBzdGF0cyAtIG9iamVjdCwgcmVzdWx0IG9mIGZzLnN0YXRcbi8vXG4vLyBSZXR1cm5zIGJvb2xlYW5cbnZhciBkb3RSZSA9IC9cXC4uKlxcLihzd1tweF0pJHxcXH4kfFxcLnN1YmwuKlxcLnRtcC87XG5GU1dhdGNoZXIucHJvdG90eXBlLl9pc0lnbm9yZWQgPSBmdW5jdGlvbihwYXRoLCBzdGF0cykge1xuICBpZiAodGhpcy5vcHRpb25zLmF0b21pYyAmJiBkb3RSZS50ZXN0KHBhdGgpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoIXRoaXMuX3VzZXJJZ25vcmVkKSB7XG4gICAgdmFyIGN3ZCA9IHRoaXMub3B0aW9ucy5jd2Q7XG4gICAgdmFyIGlnbm9yZWQgPSB0aGlzLm9wdGlvbnMuaWdub3JlZDtcbiAgICBpZiAoY3dkICYmIGlnbm9yZWQpIHtcbiAgICAgIGlnbm9yZWQgPSBpZ25vcmVkLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSByZXR1cm4gcGF0aDtcbiAgICAgICAgcmV0dXJuIHVwYXRoLm5vcm1hbGl6ZShpc0Fic29sdXRlKHBhdGgpID8gcGF0aCA6IHN5c1BhdGguam9pbihjd2QsIHBhdGgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcGF0aHMgPSBhcnJpZnkoaWdub3JlZClcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmICFpc0dsb2IocGF0aCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvKionO1xuICAgICAgfSk7XG4gICAgdGhpcy5fdXNlcklnbm9yZWQgPSBhbnltYXRjaChcbiAgICAgIHRoaXMuX2dsb2JJZ25vcmVkLmNvbmNhdChpZ25vcmVkKS5jb25jYXQocGF0aHMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl91c2VySWdub3JlZChbcGF0aCwgc3RhdHNdKTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBQcm92aWRlcyBhIHNldCBvZiBjb21tb24gaGVscGVycyBhbmQgcHJvcGVydGllcyByZWxhdGluZyB0b1xuLy8gc3ltbGluayBhbmQgZ2xvYiBoYW5kbGluZ1xuLy9cbi8vICogcGF0aCAtIHN0cmluZywgZmlsZSwgZGlyZWN0b3J5LCBvciBnbG9iIHBhdHRlcm4gYmVpbmcgd2F0Y2hlZFxuLy8gKiBkZXB0aCAtIGludCwgYXQgYW55IGRlcHRoID4gMCwgdGhpcyBpc24ndCBhIGdsb2Jcbi8vXG4vLyBSZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGhlbHBlcnMgZm9yIHRoaXMgcGF0aFxudmFyIHJlcGxhY2VyUmUgPSAvXlxcLltcXC9cXFxcXS87XG5GU1dhdGNoZXIucHJvdG90eXBlLl9nZXRXYXRjaEhlbHBlcnMgPSBmdW5jdGlvbihwYXRoLCBkZXB0aCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKHJlcGxhY2VyUmUsICcnKTtcbiAgdmFyIHdhdGNoUGF0aCA9IGRlcHRoIHx8IHRoaXMub3B0aW9ucy5kaXNhYmxlR2xvYmJpbmcgfHwgIWlzR2xvYihwYXRoKSA/IHBhdGggOiBnbG9iUGFyZW50KHBhdGgpO1xuICB2YXIgZnVsbFdhdGNoUGF0aCA9IHN5c1BhdGgucmVzb2x2ZSh3YXRjaFBhdGgpO1xuICB2YXIgaGFzR2xvYiA9IHdhdGNoUGF0aCAhPT0gcGF0aDtcbiAgdmFyIGdsb2JGaWx0ZXIgPSBoYXNHbG9iID8gYW55bWF0Y2gocGF0aCkgOiBmYWxzZTtcbiAgdmFyIGZvbGxvdyA9IHRoaXMub3B0aW9ucy5mb2xsb3dTeW1saW5rcztcbiAgdmFyIGdsb2JTeW1saW5rID0gaGFzR2xvYiAmJiBmb2xsb3cgPyBudWxsIDogZmFsc2U7XG5cbiAgdmFyIGNoZWNrR2xvYlN5bWxpbmsgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIC8vIG9ubHkgbmVlZCB0byByZXNvbHZlIG9uY2VcbiAgICAvLyBmaXJzdCBlbnRyeSBzaG91bGQgYWx3YXlzIGhhdmUgZW50cnkucGFyZW50RGlyID09PSAnJ1xuICAgIGlmIChnbG9iU3ltbGluayA9PSBudWxsKSB7XG4gICAgICBnbG9iU3ltbGluayA9IGVudHJ5LmZ1bGxQYXJlbnREaXIgPT09IGZ1bGxXYXRjaFBhdGggPyBmYWxzZSA6IHtcbiAgICAgICAgcmVhbFBhdGg6IGVudHJ5LmZ1bGxQYXJlbnREaXIsXG4gICAgICAgIGxpbmtQYXRoOiBmdWxsV2F0Y2hQYXRoXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChnbG9iU3ltbGluaykge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1bGxQYXRoLnJlcGxhY2UoZ2xvYlN5bWxpbmsucmVhbFBhdGgsIGdsb2JTeW1saW5rLmxpbmtQYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZnVsbFBhdGg7XG4gIH07XG5cbiAgdmFyIGVudHJ5UGF0aCA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIHN5c1BhdGguam9pbih3YXRjaFBhdGgsXG4gICAgICBzeXNQYXRoLnJlbGF0aXZlKHdhdGNoUGF0aCwgY2hlY2tHbG9iU3ltbGluayhlbnRyeSkpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZmlsdGVyUGF0aCA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5LnN0YXQgJiYgZW50cnkuc3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gZmlsdGVyRGlyKGVudHJ5KTtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZW50cnlQYXRoKGVudHJ5KTtcbiAgICByZXR1cm4gKCFoYXNHbG9iIHx8IGdsb2JGaWx0ZXIocmVzb2x2ZWRQYXRoKSkgJiZcbiAgICAgIHRoaXMuX2lzbnRJZ25vcmVkKHJlc29sdmVkUGF0aCwgZW50cnkuc3RhdCkgJiZcbiAgICAgICh0aGlzLm9wdGlvbnMuaWdub3JlUGVybWlzc2lvbkVycm9ycyB8fFxuICAgICAgICB0aGlzLl9oYXNSZWFkUGVybWlzc2lvbnMoZW50cnkuc3RhdCkpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdmFyIGdldERpclBhcnRzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICghaGFzR2xvYikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBleHBhbmRlZFBhdGggPSBicmFjZXMuZXhwYW5kKHBhdGgpO1xuICAgIGV4cGFuZGVkUGF0aC5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHBhcnRzLnB1c2goc3lzUGF0aC5yZWxhdGl2ZSh3YXRjaFBhdGgsIHBhdGgpLnNwbGl0KC9bXFwvXFxcXF0vKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9O1xuXG4gIHZhciBkaXJQYXJ0cyA9IGdldERpclBhcnRzKHBhdGgpO1xuICBpZiAoZGlyUGFydHMpIHtcbiAgICBkaXJQYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkgcGFydHMucG9wKCk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIHVubWF0Y2hlZEdsb2I7XG5cbiAgdmFyIGZpbHRlckRpciA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGhhc0dsb2IpIHtcbiAgICAgIHZhciBlbnRyeVBhcnRzID0gZ2V0RGlyUGFydHMoY2hlY2tHbG9iU3ltbGluayhlbnRyeSkpO1xuICAgICAgdmFyIGdsb2JzdGFyID0gZmFsc2U7XG4gICAgICB1bm1hdGNoZWRHbG9iID0gIWRpclBhcnRzLnNvbWUoZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmV2ZXJ5KGZ1bmN0aW9uKHBhcnQsIGkpIHtcbiAgICAgICAgICBpZiAocGFydCA9PT0gJyoqJykgZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBnbG9ic3RhciB8fCAhZW50cnlQYXJ0c1swXVtpXSB8fCBhbnltYXRjaChwYXJ0LCBlbnRyeVBhcnRzWzBdW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICF1bm1hdGNoZWRHbG9iICYmIHRoaXMuX2lzbnRJZ25vcmVkKGVudHJ5UGF0aChlbnRyeSksIGVudHJ5LnN0YXQpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmb2xsb3dTeW1saW5rczogZm9sbG93LFxuICAgIHN0YXRNZXRob2Q6IGZvbGxvdyA/ICdzdGF0JyA6ICdsc3RhdCcsXG4gICAgcGF0aDogcGF0aCxcbiAgICB3YXRjaFBhdGg6IHdhdGNoUGF0aCxcbiAgICBlbnRyeVBhdGg6IGVudHJ5UGF0aCxcbiAgICBoYXNHbG9iOiBoYXNHbG9iLFxuICAgIGdsb2JGaWx0ZXI6IGdsb2JGaWx0ZXIsXG4gICAgZmlsdGVyUGF0aDogZmlsdGVyUGF0aCxcbiAgICBmaWx0ZXJEaXI6IGZpbHRlckRpclxuICB9O1xufTtcblxuLy8gRGlyZWN0b3J5IGhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFByaXZhdGUgbWV0aG9kOiBQcm92aWRlcyBkaXJlY3RvcnkgdHJhY2tpbmcgb2JqZWN0c1xuLy9cbi8vICogZGlyZWN0b3J5IC0gc3RyaW5nLCBwYXRoIG9mIHRoZSBkaXJlY3Rvcnlcbi8vXG4vLyBSZXR1cm5zIHRoZSBkaXJlY3RvcnkncyB0cmFja2luZyBvYmplY3RcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2dldFdhdGNoZWREaXIgPSBmdW5jdGlvbihkaXJlY3RvcnkpIHtcbiAgdmFyIGRpciA9IHN5c1BhdGgucmVzb2x2ZShkaXJlY3RvcnkpO1xuICB2YXIgd2F0Y2hlclJlbW92ZSA9IHRoaXMuX3JlbW92ZS5iaW5kKHRoaXMpO1xuICBpZiAoIShkaXIgaW4gdGhpcy5fd2F0Y2hlZCkpIHRoaXMuX3dhdGNoZWRbZGlyXSA9IHtcbiAgICBfaXRlbXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgYWRkOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbSAhPT0gJy4nICYmIGl0ZW0gIT09ICcuLicpIHRoaXMuX2l0ZW1zW2l0ZW1dID0gdHJ1ZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2l0ZW1zW2l0ZW1dO1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgIGZzLnJlYWRkaXIoZGlyLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB3YXRjaGVyUmVtb3ZlKHN5c1BhdGguZGlybmFtZShkaXIpLCBzeXNQYXRoLmJhc2VuYW1lKGRpcikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtIGluIHRoaXMuX2l0ZW1zO30sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKCkge3JldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pdGVtcyk7fVxuICB9O1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlZFtkaXJdO1xufTtcblxuLy8gRmlsZSBoZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS1cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IENoZWNrIGZvciByZWFkIHBlcm1pc3Npb25zXG4vLyBCYXNlZCBvbiB0aGlzIGFuc3dlciBvbiBTTzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE3ODE0MDQvMTM1ODQwNVxuLy9cbi8vICogc3RhdHMgLSBvYmplY3QsIHJlc3VsdCBvZiBmcy5zdGF0XG4vL1xuLy8gUmV0dXJucyBib29sZWFuXG5GU1dhdGNoZXIucHJvdG90eXBlLl9oYXNSZWFkUGVybWlzc2lvbnMgPSBmdW5jdGlvbihzdGF0cykge1xuICByZXR1cm4gQm9vbGVhbig0ICYgcGFyc2VJbnQoKChzdGF0cyAmJiBzdGF0cy5tb2RlKSAmIDB4MWZmKS50b1N0cmluZyg4KVswXSwgMTApKTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGVzIGVtaXR0aW5nIHVubGluayBldmVudHMgZm9yXG4vLyBmaWxlcyBhbmQgZGlyZWN0b3JpZXMsIGFuZCB2aWEgcmVjdXJzaW9uLCBmb3Jcbi8vIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB3aXRoaW4gZGlyZWN0b3JpZXMgdGhhdCBhcmUgdW5saW5rZWRcbi8vXG4vLyAqIGRpcmVjdG9yeSAtIHN0cmluZywgZGlyZWN0b3J5IHdpdGhpbiB3aGljaCB0aGUgZm9sbG93aW5nIGl0ZW0gaXMgbG9jYXRlZFxuLy8gKiBpdGVtICAgICAgLSBzdHJpbmcsIGJhc2UgcGF0aCBvZiBpdGVtL2RpcmVjdG9yeVxuLy9cbi8vIFJldHVybnMgbm90aGluZ1xuRlNXYXRjaGVyLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24oZGlyZWN0b3J5LCBpdGVtKSB7XG4gIC8vIGlmIHdoYXQgaXMgYmVpbmcgZGVsZXRlZCBpcyBhIGRpcmVjdG9yeSwgZ2V0IHRoYXQgZGlyZWN0b3J5J3MgcGF0aHNcbiAgLy8gZm9yIHJlY3Vyc2l2ZSBkZWxldGluZyBhbmQgY2xlYW5pbmcgb2Ygd2F0Y2hlZCBvYmplY3RcbiAgLy8gaWYgaXQgaXMgbm90IGEgZGlyZWN0b3J5LCBuZXN0ZWREaXJlY3RvcnlDaGlsZHJlbiB3aWxsIGJlIGVtcHR5IGFycmF5XG4gIHZhciBwYXRoID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgaXRlbSk7XG4gIHZhciBmdWxsUGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgdmFyIGlzRGlyZWN0b3J5ID0gdGhpcy5fd2F0Y2hlZFtwYXRoXSB8fCB0aGlzLl93YXRjaGVkW2Z1bGxQYXRoXTtcblxuICAvLyBwcmV2ZW50IGR1cGxpY2F0ZSBoYW5kbGluZyBpbiBjYXNlIG9mIGFycml2aW5nIGhlcmUgbmVhcmx5IHNpbXVsdGFuZW91c2x5XG4gIC8vIHZpYSBtdWx0aXBsZSBwYXRocyAoc3VjaCBhcyBfaGFuZGxlRmlsZSBhbmQgX2hhbmRsZURpcilcbiAgaWYgKCF0aGlzLl90aHJvdHRsZSgncmVtb3ZlJywgcGF0aCwgMTAwKSkgcmV0dXJuO1xuXG4gIC8vIGlmIHRoZSBvbmx5IHdhdGNoZWQgZmlsZSBpcyByZW1vdmVkLCB3YXRjaCBmb3IgaXRzIHJldHVyblxuICB2YXIgd2F0Y2hlZERpcnMgPSBPYmplY3Qua2V5cyh0aGlzLl93YXRjaGVkKTtcbiAgaWYgKCFpc0RpcmVjdG9yeSAmJiAhdGhpcy5vcHRpb25zLnVzZUZzRXZlbnRzICYmIHdhdGNoZWREaXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuYWRkKGRpcmVjdG9yeSwgaXRlbSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IGVudHJ5IGluIHRoZSB3YXRjaGVkIG9iamVjdCBpbiBlaXRoZXIgY2FzZVxuICAvLyBzbyB3ZSBnb3QgdG8gZG8gdGhlIGRpcmVjdG9yeSBjaGVjayBiZWZvcmVoYW5kXG4gIHZhciBuZXN0ZWREaXJlY3RvcnlDaGlsZHJlbiA9IHRoaXMuX2dldFdhdGNoZWREaXIocGF0aCkuY2hpbGRyZW4oKTtcblxuICAvLyBSZWN1cnNpdmVseSByZW1vdmUgY2hpbGRyZW4gZGlyZWN0b3JpZXMgLyBmaWxlcy5cbiAgbmVzdGVkRGlyZWN0b3J5Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihuZXN0ZWRJdGVtKSB7XG4gICAgdGhpcy5fcmVtb3ZlKHBhdGgsIG5lc3RlZEl0ZW0pO1xuICB9LCB0aGlzKTtcblxuICAvLyBDaGVjayBpZiBpdGVtIHdhcyBvbiB0aGUgd2F0Y2hlZCBsaXN0IGFuZCByZW1vdmUgaXRcbiAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcbiAgdmFyIHdhc1RyYWNrZWQgPSBwYXJlbnQuaGFzKGl0ZW0pO1xuICBwYXJlbnQucmVtb3ZlKGl0ZW0pO1xuXG4gIC8vIElmIHdlIHdhaXQgZm9yIHRoaXMgZmlsZSB0byBiZSBmdWxseSB3cml0dGVuLCBjYW5jZWwgdGhlIHdhaXQuXG4gIHZhciByZWxQYXRoID0gcGF0aDtcbiAgaWYgKHRoaXMub3B0aW9ucy5jd2QpIHJlbFBhdGggPSBzeXNQYXRoLnJlbGF0aXZlKHRoaXMub3B0aW9ucy5jd2QsIHBhdGgpO1xuICBpZiAodGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2ggJiYgdGhpcy5fcGVuZGluZ1dyaXRlc1tyZWxQYXRoXSkge1xuICAgIHZhciBldmVudCA9IHRoaXMuX3BlbmRpbmdXcml0ZXNbcmVsUGF0aF0uY2FuY2VsV2FpdCgpO1xuICAgIGlmIChldmVudCA9PT0gJ2FkZCcpIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSBFbnRyeSB3aWxsIGVpdGhlciBiZSBhIGRpcmVjdG9yeSB0aGF0IGp1c3QgZ290IHJlbW92ZWRcbiAgLy8gb3IgYSBib2d1cyBlbnRyeSB0byBhIGZpbGUsIGluIGVpdGhlciBjYXNlIHdlIGhhdmUgdG8gcmVtb3ZlIGl0XG4gIGRlbGV0ZSB0aGlzLl93YXRjaGVkW3BhdGhdO1xuICBkZWxldGUgdGhpcy5fd2F0Y2hlZFtmdWxsUGF0aF07XG4gIHZhciBldmVudE5hbWUgPSBpc0RpcmVjdG9yeSA/ICd1bmxpbmtEaXInIDogJ3VubGluayc7XG4gIGlmICh3YXNUcmFja2VkICYmICF0aGlzLl9pc0lnbm9yZWQocGF0aCkpIHRoaXMuX2VtaXQoZXZlbnROYW1lLCBwYXRoKTtcblxuICAvLyBBdm9pZCBjb25mbGljdHMgaWYgd2UgbGF0ZXIgY3JlYXRlIGFub3RoZXIgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgaWYgKCF0aGlzLm9wdGlvbnMudXNlRnNFdmVudHMpIHtcbiAgICB0aGlzLl9jbG9zZVBhdGgocGF0aCk7XG4gIH1cbn07XG5cbkZTV2F0Y2hlci5wcm90b3R5cGUuX2Nsb3NlUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKCF0aGlzLl9jbG9zZXJzW3BhdGhdKSByZXR1cm47XG4gIHRoaXMuX2Nsb3NlcnNbcGF0aF0uZm9yRWFjaChmdW5jdGlvbihjbG9zZXIpIHtcbiAgICBjbG9zZXIoKTtcbiAgfSk7XG4gIGRlbGV0ZSB0aGlzLl9jbG9zZXJzW3BhdGhdO1xuICB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwYXRoKSkucmVtb3ZlKHN5c1BhdGguYmFzZW5hbWUocGF0aCkpO1xufVxuXG4vLyBQdWJsaWMgbWV0aG9kOiBBZGRzIHBhdGhzIHRvIGJlIHdhdGNoZWQgb24gYW4gZXhpc3RpbmcgRlNXYXRjaGVyIGluc3RhbmNlXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuLy8gKiBfb3JpZ0FkZCAgLSBwcml2YXRlIGJvb2xlYW4sIGZvciBoYW5kbGluZyBub24tZXhpc3RlbnQgcGF0aHMgdG8gYmUgd2F0Y2hlZFxuLy8gKiBfaW50ZXJuYWwgLSBwcml2YXRlIGJvb2xlYW4sIGluZGljYXRlcyBhIG5vbi11c2VyIGFkZFxuXG4vLyBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhdGhzLCBfb3JpZ0FkZCwgX2ludGVybmFsKSB7XG4gIHZhciBkaXNhYmxlR2xvYmJpbmcgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZUdsb2JiaW5nO1xuICB2YXIgY3dkID0gdGhpcy5vcHRpb25zLmN3ZDtcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgcGF0aHMgPSBmbGF0dGVuKGFycmlmeShwYXRocykpO1xuXG4gIGlmICghcGF0aHMuZXZlcnkoaXNTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uLXN0cmluZyBwcm92aWRlZCBhcyB3YXRjaCBwYXRoOiAnICsgcGF0aHMpO1xuICB9XG5cbiAgaWYgKGN3ZCkgcGF0aHMgPSBwYXRocy5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBhYnNQYXRoO1xuICAgIGlmIChpc0Fic29sdXRlKHBhdGgpKSB7XG4gICAgICBhYnNQYXRoID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKHBhdGhbMF0gPT09ICchJykge1xuICAgICAgYWJzUGF0aCA9ICchJyArIHN5c1BhdGguam9pbihjd2QsIHBhdGguc3Vic3RyaW5nKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWJzUGF0aCA9IHN5c1BhdGguam9pbihjd2QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGBwYXRoYCBpbnN0ZWFkIG9mIGBhYnNQYXRoYCBiZWNhdXNlIHRoZSBjd2QgcG9ydGlvbiBjYW4ndCBiZSBhIGdsb2JcbiAgICBpZiAoZGlzYWJsZUdsb2JiaW5nIHx8ICFpc0dsb2IocGF0aCkpIHtcbiAgICAgIHJldHVybiBhYnNQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChhYnNQYXRoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHNldCBhc2lkZSBuZWdhdGVkIGdsb2Igc3RyaW5nc1xuICBwYXRocyA9IHBhdGhzLmZpbHRlcihmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGhbMF0gPT09ICchJykge1xuICAgICAgdGhpcy5faWdub3JlZFBhdGhzW3BhdGguc3Vic3RyaW5nKDEpXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGEgcGF0aCBpcyBiZWluZyBhZGRlZCB0aGF0IHdhcyBwcmV2aW91c2x5IGlnbm9yZWQsIHN0b3AgaWdub3JpbmcgaXRcbiAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aF07XG4gICAgICBkZWxldGUgdGhpcy5faWdub3JlZFBhdGhzW3BhdGggKyAnLyoqJ107XG5cbiAgICAgIC8vIHJlc2V0IHRoZSBjYWNoZWQgdXNlcklnbm9yZWQgYW55bWF0Y2ggZm5cbiAgICAgIC8vIHRvIG1ha2UgaWdub3JlZFBhdGhzIGNoYW5nZXMgZWZmZWN0aXZlXG4gICAgICB0aGlzLl91c2VySWdub3JlZCA9IG51bGw7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy51c2VGc0V2ZW50cyAmJiBGc0V2ZW50c0hhbmRsZXIuY2FuVXNlKCkpIHtcbiAgICBpZiAoIXRoaXMuX3JlYWR5Q291bnQpIHRoaXMuX3JlYWR5Q291bnQgPSBwYXRocy5sZW5ndGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50KSB0aGlzLl9yZWFkeUNvdW50ICo9IDI7XG4gICAgcGF0aHMuZm9yRWFjaCh0aGlzLl9hZGRUb0ZzRXZlbnRzLCB0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX3JlYWR5Q291bnQpIHRoaXMuX3JlYWR5Q291bnQgPSAwO1xuICAgIHRoaXMuX3JlYWR5Q291bnQgKz0gcGF0aHMubGVuZ3RoO1xuICAgIGFzeW5jRWFjaChwYXRocywgZnVuY3Rpb24ocGF0aCwgbmV4dCkge1xuICAgICAgdGhpcy5fYWRkVG9Ob2RlRnMocGF0aCwgIV9pbnRlcm5hbCwgMCwgMCwgX29yaWdBZGQsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChyZXMpIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgICAgICBuZXh0KGVyciwgcmVzKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0cykge1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtIHx8IHRoaXMuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkKHN5c1BhdGguZGlybmFtZShpdGVtKSwgc3lzUGF0aC5iYXNlbmFtZShfb3JpZ0FkZCB8fCBpdGVtKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQdWJsaWMgbWV0aG9kOiBDbG9zZSB3YXRjaGVycyBvciBzdGFydCBpZ25vcmluZyBldmVudHMgZnJvbSBzcGVjaWZpZWQgcGF0aHMuXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuXG4vLyBSZXR1cm5zIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLnVud2F0Y2ggPSBmdW5jdGlvbihwYXRocykge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiB0aGlzO1xuICBwYXRocyA9IGZsYXR0ZW4oYXJyaWZ5KHBhdGhzKSk7XG5cbiAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XG4gICAgLy8gY29udmVydCB0byBhYnNvbHV0ZSBwYXRoIHVubGVzcyByZWxhdGl2ZSBwYXRoIGFscmVhZHkgbWF0Y2hlc1xuICAgIGlmICghaXNBYnNvbHV0ZShwYXRoKSAmJiAhdGhpcy5fY2xvc2Vyc1twYXRoXSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jd2QpIHBhdGggPSBzeXNQYXRoLmpvaW4odGhpcy5vcHRpb25zLmN3ZCwgcGF0aCk7XG4gICAgICBwYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlUGF0aChwYXRoKTtcblxuICAgIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoXSA9IHRydWU7XG4gICAgaWYgKHBhdGggaW4gdGhpcy5fd2F0Y2hlZCkge1xuICAgICAgdGhpcy5faWdub3JlZFBhdGhzW3BhdGggKyAnLyoqJ10gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IHRoZSBjYWNoZWQgdXNlcklnbm9yZWQgYW55bWF0Y2ggZm5cbiAgICAvLyB0byBtYWtlIGlnbm9yZWRQYXRocyBjaGFuZ2VzIGVmZmVjdGl2ZVxuICAgIHRoaXMuX3VzZXJJZ25vcmVkID0gbnVsbDtcbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQdWJsaWMgbWV0aG9kOiBDbG9zZSB3YXRjaGVycyBhbmQgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB3YXRjaGVkIHBhdGhzLlxuXG4vLyBSZXR1cm5zIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICBPYmplY3Qua2V5cyh0aGlzLl9jbG9zZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHdhdGNoUGF0aCkge1xuICAgIHRoaXMuX2Nsb3NlcnNbd2F0Y2hQYXRoXS5mb3JFYWNoKGZ1bmN0aW9uKGNsb3Nlcikge1xuICAgICAgY2xvc2VyKCk7XG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuX2Nsb3NlcnNbd2F0Y2hQYXRoXTtcbiAgfSwgdGhpcyk7XG4gIHRoaXMuX3dhdGNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUHVibGljIG1ldGhvZDogRXhwb3NlIGxpc3Qgb2Ygd2F0Y2hlZCBwYXRoc1xuXG4vLyBSZXR1cm5zIG9iamVjdCB3LyBkaXIgcGF0aHMgYXMga2V5cyBhbmQgYXJyYXlzIG9mIGNvbnRhaW5lZCBwYXRocyBhcyB2YWx1ZXMuXG5GU1dhdGNoZXIucHJvdG90eXBlLmdldFdhdGNoZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdhdGNoTGlzdCA9IHt9O1xuICBPYmplY3Qua2V5cyh0aGlzLl93YXRjaGVkKS5mb3JFYWNoKGZ1bmN0aW9uKGRpcikge1xuICAgIHZhciBrZXkgPSB0aGlzLm9wdGlvbnMuY3dkID8gc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLm9wdGlvbnMuY3dkLCBkaXIpIDogZGlyO1xuICAgIHdhdGNoTGlzdFtrZXkgfHwgJy4nXSA9IE9iamVjdC5rZXlzKHRoaXMuX3dhdGNoZWRbZGlyXS5faXRlbXMpLnNvcnQoKTtcbiAgfS5iaW5kKHRoaXMpKTtcbiAgcmV0dXJuIHdhdGNoTGlzdDtcbn07XG5cbi8vIEF0dGFjaCB3YXRjaCBoYW5kbGVyIHByb3RvdHlwZSBtZXRob2RzXG5mdW5jdGlvbiBpbXBvcnRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgT2JqZWN0LmtleXMoaGFuZGxlci5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgRlNXYXRjaGVyLnByb3RvdHlwZVttZXRob2RdID0gaGFuZGxlci5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfSk7XG59XG5pbXBvcnRIYW5kbGVyKE5vZGVGc0hhbmRsZXIpO1xuaWYgKEZzRXZlbnRzSGFuZGxlci5jYW5Vc2UoKSkgaW1wb3J0SGFuZGxlcihGc0V2ZW50c0hhbmRsZXIpO1xuXG4vLyBFeHBvcnQgRlNXYXRjaGVyIGNsYXNzXG5leHBvcnRzLkZTV2F0Y2hlciA9IEZTV2F0Y2hlcjtcblxuLy8gUHVibGljIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgd2F0Y2hlciB3aXRoIHBhdGhzIHRvIGJlIHRyYWNrZWQuXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuLy8gKiBvcHRpb25zICAgLSBvYmplY3QsIGNob2tpZGFyIG9wdGlvbnNcblxuLy8gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBGU1dhdGNoZXIgZm9yIGNoYWluaW5nLlxuZXhwb3J0cy53YXRjaCA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRlNXYXRjaGVyKG9wdGlvbnMpLmFkZChwYXRocyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcmVhZGRpcnAgPSByZXF1aXJlKCdyZWFkZGlycCcpO1xudmFyIGZzZXZlbnRzO1xuLy8gdHJ5IHsgZnNldmVudHMgPSByZXF1aXJlKCdmc2V2ZW50cycpOyB9IGNhdGNoIChlcnJvcikge1xuLy8gICBpZiAocHJvY2Vzcy5lbnYuQ0hPS0lEQVJfUFJJTlRfRlNFVkVOVFNfUkVRVUlSRV9FUlJPUikgY29uc29sZS5lcnJvcihlcnJvcilcbi8vIH1cblxuLy8gZnNldmVudHMgaW5zdGFuY2UgaGVscGVyIGZ1bmN0aW9uc1xuXG4vLyBvYmplY3QgdG8gaG9sZCBwZXItcHJvY2VzcyBmc2V2ZW50cyBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxudmFyIEZTRXZlbnRzV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vLyBUaHJlc2hvbGQgb2YgZHVwbGljYXRlIHBhdGggcHJlZml4ZXMgYXQgd2hpY2ggdG8gc3RhcnRcbi8vIGNvbnNvbGlkYXRpbmcgZ29pbmcgZm9yd2FyZFxudmFyIGNvbnNvbGlkYXRlVGhyZXNoaG9sZCA9IDEwO1xuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzZXZlbnRzIGludGVyZmFjZVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBjYWxsYmFjayAgIC0gZnVuY3Rpb24sIGNhbGxlZCB3aGVuIGZzZXZlbnRzIGlzIGJvdW5kIGFuZCByZWFkeVxuXG4vLyBSZXR1cm5zIG5ldyBmc2V2ZW50cyBpbnN0YW5jZVxuZnVuY3Rpb24gY3JlYXRlRlNFdmVudHNJbnN0YW5jZShwYXRoLCBjYWxsYmFjaykge1xuICByZXR1cm4gKG5ldyBmc2V2ZW50cyhwYXRoKSkub24oJ2ZzZXZlbnQnLCBjYWxsYmFjaykuc3RhcnQoKTtcbn1cblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSW5zdGFudGlhdGVzIHRoZSBmc2V2ZW50cyBpbnRlcmZhY2Ugb3IgYmluZHMgbGlzdGVuZXJzXG4vLyB0byBhbiBleGlzdGluZyBvbmUgY292ZXJpbmcgdGhlIHNhbWUgZmlsZSB0cmVlXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIHJlYWxQYXRoICAgLSBzdHJpbmcsIHJlYWwgcGF0aCAoaW4gY2FzZSBvZiBzeW1saW5rcylcbi8vICogbGlzdGVuZXIgICAtIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiBmc2V2ZW50cyBlbWl0cyBldmVudHNcbi8vICogcmF3RW1pdHRlciAtIGZ1bmN0aW9uLCBwYXNzZXMgZGF0YSB0byBsaXN0ZW5lcnMgb2YgdGhlICdyYXcnIGV2ZW50XG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZTRXZlbnRzTGlzdGVuZXIocGF0aCwgcmVhbFBhdGgsIGxpc3RlbmVyLCByYXdFbWl0dGVyKSB7XG4gIHZhciB3YXRjaFBhdGggPSBzeXNQYXRoLmV4dG5hbWUocGF0aCkgPyBzeXNQYXRoLmRpcm5hbWUocGF0aCkgOiBwYXRoO1xuICB2YXIgd2F0Y2hDb250YWluZXI7XG4gIHZhciBwYXJlbnRQYXRoID0gc3lzUGF0aC5kaXJuYW1lKHdhdGNoUGF0aCk7XG5cbiAgLy8gSWYgd2UndmUgYWNjdW11bGF0ZWQgYSBzdWJzdGFudGlhbCBudW1iZXIgb2YgcGF0aHMgdGhhdFxuICAvLyBjb3VsZCBoYXZlIGJlZW4gY29uc29saWRhdGVkIGJ5IHdhdGNoaW5nIG9uZSBkaXJlY3RvcnlcbiAgLy8gYWJvdmUgdGhlIGN1cnJlbnQgb25lLCBjcmVhdGUgYSB3YXRjaGVyIG9uIHRoZSBwYXJlbnRcbiAgLy8gcGF0aCBpbnN0ZWFkLCBzbyB0aGF0IHdlIGRvIGNvbnNvbGlkYXRlIGdvaW5nIGZvcndhcmQuXG4gIGlmIChjb3VsZENvbnNvbGlkYXRlKHBhcmVudFBhdGgpKSB7XG4gICAgd2F0Y2hQYXRoID0gcGFyZW50UGF0aDtcbiAgfVxuXG4gIHZhciByZXNvbHZlZFBhdGggPSBzeXNQYXRoLnJlc29sdmUocGF0aCk7XG4gIHZhciBoYXNTeW1saW5rID0gcmVzb2x2ZWRQYXRoICE9PSByZWFsUGF0aDtcbiAgZnVuY3Rpb24gZmlsdGVyZWRMaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pIHtcbiAgICBpZiAoaGFzU3ltbGluaykgZnVsbFBhdGggPSBmdWxsUGF0aC5yZXBsYWNlKHJlYWxQYXRoLCByZXNvbHZlZFBhdGgpO1xuICAgIGlmIChcbiAgICAgIGZ1bGxQYXRoID09PSByZXNvbHZlZFBhdGggfHxcbiAgICAgICFmdWxsUGF0aC5pbmRleE9mKHJlc29sdmVkUGF0aCArIHN5c1BhdGguc2VwKVxuICAgICkgbGlzdGVuZXIoZnVsbFBhdGgsIGZsYWdzLCBpbmZvKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB3YXRjaGVyIG9uIGEgcGFyZW50IHBhdGhcbiAgLy8gbW9kaWZpZXMgYHdhdGNoUGF0aGAgdG8gdGhlIHBhcmVudCBwYXRoIHdoZW4gaXQgZmluZHMgYSBtYXRjaFxuICBmdW5jdGlvbiB3YXRjaGVkUGFyZW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhGU0V2ZW50c1dhdGNoZXJzKS5zb21lKGZ1bmN0aW9uICh3YXRjaGVkUGF0aCkge1xuICAgICAgLy8gY29uZGl0aW9uIGlzIG1ldCB3aGVuIGluZGV4T2YgcmV0dXJucyAwXG4gICAgICBpZiAoIXJlYWxQYXRoLmluZGV4T2Yoc3lzUGF0aC5yZXNvbHZlKHdhdGNoZWRQYXRoKSArIHN5c1BhdGguc2VwKSkge1xuICAgICAgICB3YXRjaFBhdGggPSB3YXRjaGVkUGF0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAod2F0Y2hQYXRoIGluIEZTRXZlbnRzV2F0Y2hlcnMgfHwgd2F0Y2hlZFBhcmVudCgpKSB7XG4gICAgd2F0Y2hDb250YWluZXIgPSBGU0V2ZW50c1dhdGNoZXJzW3dhdGNoUGF0aF07XG4gICAgd2F0Y2hDb250YWluZXIubGlzdGVuZXJzLnB1c2goZmlsdGVyZWRMaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgd2F0Y2hDb250YWluZXIgPSBGU0V2ZW50c1dhdGNoZXJzW3dhdGNoUGF0aF0gPSB7XG4gICAgICBsaXN0ZW5lcnM6IFtmaWx0ZXJlZExpc3RlbmVyXSxcbiAgICAgIHJhd0VtaXR0ZXJzOiBbcmF3RW1pdHRlcl0sXG4gICAgICB3YXRjaGVyOiBjcmVhdGVGU0V2ZW50c0luc3RhbmNlKHdhdGNoUGF0aCwgZnVuY3Rpb24gKGZ1bGxQYXRoLCBmbGFncykge1xuICAgICAgICB2YXIgaW5mbyA9IGZzZXZlbnRzLmdldEluZm8oZnVsbFBhdGgsIGZsYWdzKTtcbiAgICAgICAgd2F0Y2hDb250YWluZXIubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIoZnVsbFBhdGgsIGZsYWdzLCBpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdhdGNoQ29udGFpbmVyLnJhd0VtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICAgICAgICBlbWl0dGVyKGluZm8uZXZlbnQsIGZ1bGxQYXRoLCBpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdmFyIGxpc3RlbmVySW5kZXggPSB3YXRjaENvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmc2V2ZW50c1xuICAvLyBpbnN0YW5jZSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgbGVmdFxuICByZXR1cm4gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgZGVsZXRlIHdhdGNoQ29udGFpbmVyLmxpc3RlbmVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBkZWxldGUgd2F0Y2hDb250YWluZXIucmF3RW1pdHRlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh3YXRjaENvbnRhaW5lci5saXN0ZW5lcnMpLmxlbmd0aCkge1xuICAgICAgd2F0Y2hDb250YWluZXIud2F0Y2hlci5zdG9wKCk7XG4gICAgICBkZWxldGUgRlNFdmVudHNXYXRjaGVyc1t3YXRjaFBhdGhdO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gRGVjaWRlIHdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBzdGFydCBhIG5ldyBoaWdoZXItbGV2ZWxcbi8vIHBhcmVudCB3YXRjaGVyXG5mdW5jdGlvbiBjb3VsZENvbnNvbGlkYXRlKHBhdGgpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhGU0V2ZW50c1dhdGNoZXJzKTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB3YXRjaFBhdGggPSBrZXlzW2ldO1xuICAgIGlmICh3YXRjaFBhdGguaW5kZXhPZihwYXRoKSA9PT0gMCkge1xuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA+PSBjb25zb2xpZGF0ZVRocmVzaGhvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbnN0cnVjdG9yKG9iaikge1xuICByZXR1cm4gb2JqLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBmc2V2ZW50cyBjYW4gYmUgdXNlZFxuZnVuY3Rpb24gY2FuVXNlKCkge1xuICByZXR1cm4gZnNldmVudHMgJiYgT2JqZWN0LmtleXMoRlNFdmVudHNXYXRjaGVycykubGVuZ3RoIDwgMTI4ICYmIGlzQ29uc3RydWN0b3IoZnNldmVudHMpO1xufVxuXG4vLyBkZXRlcm1pbmVzIHN1YmRpcmVjdG9yeSB0cmF2ZXJzYWwgbGV2ZWxzIGZyb20gcm9vdCB0byBwYXRoXG5mdW5jdGlvbiBkZXB0aChwYXRoLCByb290KSB7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCFwYXRoLmluZGV4T2Yocm9vdCkgJiYgKHBhdGggPSBzeXNQYXRoLmRpcm5hbWUocGF0aCkpICE9PSByb290KSBpKys7XG4gIHJldHVybiBpO1xufVxuXG4vLyBmYWtlIGNvbnN0cnVjdG9yIGZvciBhdHRhY2hpbmcgZnNldmVudHMtc3BlY2lmaWMgcHJvdG90eXBlIG1ldGhvZHMgdGhhdFxuLy8gd2lsbCBiZSBjb3BpZWQgdG8gRlNXYXRjaGVyJ3MgcHJvdG90eXBlXG5mdW5jdGlvbiBGc0V2ZW50c0hhbmRsZXIoKSB7IH1cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZSBzeW1saW5rcyBlbmNvdW50ZXJlZCBkdXJpbmcgZGlyZWN0b3J5IHNjYW5cblxuLy8gKiB3YXRjaFBhdGggIC0gc3RyaW5nLCBmaWxlL2RpciBwYXRoIHRvIGJlIHdhdGNoZWQgd2l0aCBmc2V2ZW50c1xuLy8gKiByZWFsUGF0aCAgIC0gc3RyaW5nLCByZWFsIHBhdGggKGluIGNhc2Ugb2Ygc3ltbGlua3MpXG4vLyAqIHRyYW5zZm9ybSAgLSBmdW5jdGlvbiwgcGF0aCB0cmFuc2Zvcm1lclxuLy8gKiBnbG9iRmlsdGVyIC0gZnVuY3Rpb24sIHBhdGggZmlsdGVyIGluIGNhc2UgYSBnbG9iIHBhdHRlcm4gd2FzIHByb3ZpZGVkXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Gc0V2ZW50c0hhbmRsZXIucHJvdG90eXBlLl93YXRjaFdpdGhGc0V2ZW50cyA9XG4gIGZ1bmN0aW9uICh3YXRjaFBhdGgsIHJlYWxQYXRoLCB0cmFuc2Zvcm0sIGdsb2JGaWx0ZXIpIHtcbiAgICBpZiAodGhpcy5faXNJZ25vcmVkKHdhdGNoUGF0aCkpIHJldHVybjtcbiAgICB2YXIgd2F0Y2hDYWxsYmFjayA9IGZ1bmN0aW9uIChmdWxsUGF0aCwgZmxhZ3MsIGluZm8pIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmRlcHRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZGVwdGgoZnVsbFBhdGgsIHJlYWxQYXRoKSA+IHRoaXMub3B0aW9ucy5kZXB0aFxuICAgICAgKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IHRyYW5zZm9ybShzeXNQYXRoLmpvaW4oXG4gICAgICAgIHdhdGNoUGF0aCwgc3lzUGF0aC5yZWxhdGl2ZSh3YXRjaFBhdGgsIGZ1bGxQYXRoKVxuICAgICAgKSk7XG4gICAgICBpZiAoZ2xvYkZpbHRlciAmJiAhZ2xvYkZpbHRlcihwYXRoKSkgcmV0dXJuO1xuICAgICAgLy8gZW5zdXJlIGRpcmVjdG9yaWVzIGFyZSB0cmFja2VkXG4gICAgICB2YXIgcGFyZW50ID0gc3lzUGF0aC5kaXJuYW1lKHBhdGgpO1xuICAgICAgdmFyIGl0ZW0gPSBzeXNQYXRoLmJhc2VuYW1lKHBhdGgpO1xuICAgICAgdmFyIHdhdGNoZWREaXIgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKFxuICAgICAgICBpbmZvLnR5cGUgPT09ICdkaXJlY3RvcnknID8gcGF0aCA6IHBhcmVudFxuICAgICAgKTtcbiAgICAgIHZhciBjaGVja0lnbm9yZWQgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSWdub3JlZChwYXRoLCBzdGF0cykpIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aF0gPSB0cnVlO1xuICAgICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKiovKiddID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlZFBhdGhzW3BhdGggKyAnLyoqLyonXTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGNoZWNrSWdub3JlZCgpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGV2ZW50ID09PSAndW5saW5rJykge1xuICAgICAgICAgIC8vIHN1cHByZXNzIHVubGluayBldmVudHMgb24gbmV2ZXIgYmVmb3JlIHNlZW4gZmlsZXNcbiAgICAgICAgICBpZiAoaW5mby50eXBlID09PSAnZGlyZWN0b3J5JyB8fCB3YXRjaGVkRGlyLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHBhcmVudCwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChldmVudCA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIC8vIHRyYWNrIG5ldyBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgaWYgKGluZm8udHlwZSA9PT0gJ2RpcmVjdG9yeScpIHRoaXMuX2dldFdhdGNoZWREaXIocGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgPT09ICdzeW1saW5rJyAmJiB0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAgICAgICAgICAgLy8gcHVzaCBzeW1saW5rcyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHRvIGdldCBoYW5kbGVkXG4gICAgICAgICAgICAgIHZhciBjdXJEZXB0aCA9IHRoaXMub3B0aW9ucy5kZXB0aCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiBkZXB0aChmdWxsUGF0aCwgcmVhbFBhdGgpICsgMTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvRnNFdmVudHMocGF0aCwgZmFsc2UsIHRydWUsIGN1ckRlcHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyYWNrIG5ldyBwYXRoc1xuICAgICAgICAgICAgICAvLyAob3RoZXIgdGhhbiBzeW1saW5rcyBiZWluZyBmb2xsb3dlZCwgd2hpY2ggd2lsbCBiZSB0cmFja2VkIHNvb24pXG4gICAgICAgICAgICAgIHRoaXMuX2dldFdhdGNoZWREaXIocGFyZW50KS5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBpbmZvLnR5cGUgPT09ICdkaXJlY3RvcnknID8gZXZlbnQgKyAnRGlyJyA6IGV2ZW50O1xuICAgICAgICAgIHRoaXMuX2VtaXQoZXZlbnROYW1lLCBwYXRoKTtcbiAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnYWRkRGlyJykgdGhpcy5fYWRkVG9Gc0V2ZW50cyhwYXRoLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgZnVuY3Rpb24gYWRkT3JDaGFuZ2UoKSB7XG4gICAgICAgIGhhbmRsZUV2ZW50KHdhdGNoZWREaXIuaGFzKGl0ZW0pID8gJ2NoYW5nZScgOiAnYWRkJyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjaGVja0ZkKCkge1xuICAgICAgICBmcy5vcGVuKHBhdGgsICdyJywgZnVuY3Rpb24gKGVycm9yLCBmZCkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuY29kZSAhPT0gJ0VBQ0NFUycgP1xuICAgICAgICAgICAgICBoYW5kbGVFdmVudCgndW5saW5rJykgOiBhZGRPckNoYW5nZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBlcnIgJiYgZXJyLmNvZGUgIT09ICdFQUNDRVMnID9cbiAgICAgICAgICAgICAgICBoYW5kbGVFdmVudCgndW5saW5rJykgOiBhZGRPckNoYW5nZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcnJlY3QgZm9yIHdyb25nIGV2ZW50cyBlbWl0dGVkXG4gICAgICB2YXIgd3JvbmdFdmVudEZsYWdzID0gW1xuICAgICAgICA2OTg4OCwgNzA0MDAsIDcxNDI0LCA3MjcwNCwgNzM0NzIsIDEzMTMyOCwgMTMxODQwLCAyNjI5MTJcbiAgICAgIF07XG4gICAgICBpZiAod3JvbmdFdmVudEZsYWdzLmluZGV4T2YoZmxhZ3MpICE9PSAtMSB8fCBpbmZvLmV2ZW50ID09PSAndW5rbm93bicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZzLnN0YXQocGF0aCwgZnVuY3Rpb24gKGVycm9yLCBzdGF0cykge1xuICAgICAgICAgICAgaWYgKGNoZWNrSWdub3JlZChzdGF0cykpIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRzID8gYWRkT3JDaGFuZ2UoKSA6IGhhbmRsZUV2ZW50KCd1bmxpbmsnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0ZkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoaW5mby5ldmVudCkge1xuICAgICAgICAgIGNhc2UgJ2NyZWF0ZWQnOlxuICAgICAgICAgIGNhc2UgJ21vZGlmaWVkJzpcbiAgICAgICAgICAgIHJldHVybiBhZGRPckNoYW5nZSgpO1xuICAgICAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgICAgIGNhc2UgJ21vdmVkJzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0ZkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgY2xvc2VyID0gc2V0RlNFdmVudHNMaXN0ZW5lcihcbiAgICAgIHdhdGNoUGF0aCxcbiAgICAgIHJlYWxQYXRoLFxuICAgICAgd2F0Y2hDYWxsYmFjayxcbiAgICAgIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdyYXcnKVxuICAgICk7XG5cbiAgICB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICByZXR1cm4gY2xvc2VyO1xuICB9O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIHN5bWxpbmtzIGVuY291bnRlcmVkIGR1cmluZyBkaXJlY3Rvcnkgc2NhblxuXG4vLyAqIGxpbmtQYXRoICAgLSBzdHJpbmcsIHBhdGggdG8gc3ltbGlua1xuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBzeW1saW5rXG4vLyAqIHRyYW5zZm9ybSAgLSBmdW5jdGlvbiwgcHJlLWV4aXN0aW5nIHBhdGggdHJhbnNmb3JtZXJcbi8vICogY3VyRGVwdGggICAtIGludCwgbGV2ZWwgb2Ygc3ViZGlyZWN0b3JpZXMgdHJhdmVyc2VkIHRvIHdoZXJlIHN5bWxpbmsgaXNcblxuLy8gUmV0dXJucyBub3RoaW5nXG5Gc0V2ZW50c0hhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVGc0V2ZW50c1N5bWxpbmsgPVxuICBmdW5jdGlvbiAobGlua1BhdGgsIGZ1bGxQYXRoLCB0cmFuc2Zvcm0sIGN1ckRlcHRoKSB7XG4gICAgLy8gZG9uJ3QgZm9sbG93IHRoZSBzYW1lIHN5bWxpbmsgbW9yZSB0aGFuIG9uY2VcbiAgICBpZiAodGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxQYXRoXSkgcmV0dXJuO1xuICAgIGVsc2UgdGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxQYXRoXSA9IHRydWU7XG5cbiAgICB0aGlzLl9yZWFkeUNvdW50Kys7XG5cbiAgICBmcy5yZWFscGF0aChsaW5rUGF0aCwgZnVuY3Rpb24gKGVycm9yLCBsaW5rVGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpIHx8IHRoaXMuX2lzSWdub3JlZChsaW5rVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlYWR5Q291bnQrKztcblxuICAgICAgLy8gYWRkIHRoZSBsaW5rVGFyZ2V0IGZvciB3YXRjaGluZyB3aXRoIGEgd3JhcHBlciBmb3IgdHJhbnNmb3JtXG4gICAgICAvLyB0aGF0IGNhdXNlcyBlbWl0dGVkIHBhdGhzIHRvIGluY29ycG9yYXRlIHRoZSBsaW5rJ3MgcGF0aFxuICAgICAgdGhpcy5fYWRkVG9Gc0V2ZW50cyhsaW5rVGFyZ2V0IHx8IGxpbmtQYXRoLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgZG90U2xhc2ggPSAnLicgKyBzeXNQYXRoLnNlcDtcbiAgICAgICAgdmFyIGFsaWFzZWRQYXRoID0gbGlua1BhdGg7XG4gICAgICAgIGlmIChsaW5rVGFyZ2V0ICYmIGxpbmtUYXJnZXQgIT09IGRvdFNsYXNoKSB7XG4gICAgICAgICAgYWxpYXNlZFBhdGggPSBwYXRoLnJlcGxhY2UobGlua1RhcmdldCwgbGlua1BhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGggIT09IGRvdFNsYXNoKSB7XG4gICAgICAgICAgYWxpYXNlZFBhdGggPSBzeXNQYXRoLmpvaW4obGlua1BhdGgsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0oYWxpYXNlZFBhdGgpO1xuICAgICAgfSwgZmFsc2UsIGN1ckRlcHRoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIGFkZGVkIHBhdGggd2l0aCBmc2V2ZW50c1xuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIGZpbGUvZGlyZWN0b3J5IHBhdGggb3IgZ2xvYiBwYXR0ZXJuXG4vLyAqIHRyYW5zZm9ybSAgLSBmdW5jdGlvbiwgY29udmVydHMgd29ya2luZyBwYXRoIHRvIHdoYXQgdGhlIHVzZXIgZXhwZWN0c1xuLy8gKiBmb3JjZUFkZCAgIC0gYm9vbGVhbiwgZW5zdXJlIGFkZCBpcyBlbWl0dGVkXG4vLyAqIHByaW9yRGVwdGggLSBpbnQsIGxldmVsIG9mIHN1YmRpcmVjdG9yaWVzIGFscmVhZHkgdHJhdmVyc2VkXG5cbi8vIFJldHVybnMgbm90aGluZ1xuRnNFdmVudHNIYW5kbGVyLnByb3RvdHlwZS5fYWRkVG9Gc0V2ZW50cyA9XG4gIGZ1bmN0aW9uIChwYXRoLCB0cmFuc2Zvcm0sIGZvcmNlQWRkLCBwcmlvckRlcHRoKSB7XG5cbiAgICAvLyBhcHBsaWVzIHRyYW5zZm9ybSBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHJldHVybnMgc2FtZSB2YWx1ZVxuICAgIHZhciBwcm9jZXNzUGF0aCA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgP1xuICAgICAgdHJhbnNmb3JtIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsOyB9O1xuXG4gICAgdmFyIGVtaXRBZGQgPSBmdW5jdGlvbiAobmV3UGF0aCwgc3RhdHMpIHtcbiAgICAgIHZhciBwcCA9IHByb2Nlc3NQYXRoKG5ld1BhdGgpO1xuICAgICAgdmFyIGlzRGlyID0gc3RhdHMuaXNEaXJlY3RvcnkoKTtcbiAgICAgIHZhciBkaXJPYmogPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwcCkpO1xuICAgICAgdmFyIGJhc2UgPSBzeXNQYXRoLmJhc2VuYW1lKHBwKTtcblxuICAgICAgLy8gZW5zdXJlIGVtcHR5IGRpcnMgZ2V0IHRyYWNrZWRcbiAgICAgIGlmIChpc0RpcikgdGhpcy5fZ2V0V2F0Y2hlZERpcihwcCk7XG5cbiAgICAgIGlmIChkaXJPYmouaGFzKGJhc2UpKSByZXR1cm47XG4gICAgICBkaXJPYmouYWRkKGJhc2UpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVJbml0aWFsIHx8IGZvcmNlQWRkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoaXNEaXIgPyAnYWRkRGlyJyA6ICdhZGQnLCBwcCwgc3RhdHMpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciB3aCA9IHRoaXMuX2dldFdhdGNoSGVscGVycyhwYXRoKTtcblxuICAgIC8vIGV2YWx1YXRlIHdoYXQgaXMgYXQgdGhlIHBhdGggd2UncmUgYmVpbmcgYXNrZWQgdG8gd2F0Y2hcbiAgICBmc1t3aC5zdGF0TWV0aG9kXSh3aC53YXRjaFBhdGgsIGZ1bmN0aW9uIChlcnJvciwgc3RhdHMpIHtcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcihlcnJvcikgfHwgdGhpcy5faXNJZ25vcmVkKHdoLndhdGNoUGF0aCwgc3RhdHMpKSB7XG4gICAgICAgIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIGVtaXQgYWRkRGlyIHVubGVzcyB0aGlzIGlzIGEgZ2xvYiBwYXJlbnRcbiAgICAgICAgaWYgKCF3aC5nbG9iRmlsdGVyKSBlbWl0QWRkKHByb2Nlc3NQYXRoKHBhdGgpLCBzdGF0cyk7XG5cbiAgICAgICAgLy8gZG9uJ3QgcmVjdXJzZSBmdXJ0aGVyIGlmIGl0IHdvdWxkIGV4Y2VlZCBkZXB0aCBzZXR0aW5nXG4gICAgICAgIGlmIChwcmlvckRlcHRoICYmIHByaW9yRGVwdGggPiB0aGlzLm9wdGlvbnMuZGVwdGgpIHJldHVybjtcblxuICAgICAgICAvLyBzY2FuIHRoZSBjb250ZW50cyBvZiB0aGUgZGlyXG4gICAgICAgIHJlYWRkaXJwKHtcbiAgICAgICAgICByb290OiB3aC53YXRjaFBhdGgsXG4gICAgICAgICAgZW50cnlUeXBlOiAnYWxsJyxcbiAgICAgICAgICBmaWxlRmlsdGVyOiB3aC5maWx0ZXJQYXRoLFxuICAgICAgICAgIGRpcmVjdG9yeUZpbHRlcjogd2guZmlsdGVyRGlyLFxuICAgICAgICAgIGxzdGF0OiB0cnVlLFxuICAgICAgICAgIGRlcHRoOiB0aGlzLm9wdGlvbnMuZGVwdGggLSAocHJpb3JEZXB0aCB8fCAwKVxuICAgICAgICB9KS5vbignZGF0YScsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgZmlsdGVyUGF0aCBvbiBkaXJzIGIvYyBmaWx0ZXJEaXIgaXMgbGVzcyByZXN0cmljdGl2ZVxuICAgICAgICAgIGlmIChlbnRyeS5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgIXdoLmZpbHRlclBhdGgoZW50cnkpKSByZXR1cm47XG5cbiAgICAgICAgICB2YXIgam9pbmVkUGF0aCA9IHN5c1BhdGguam9pbih3aC53YXRjaFBhdGgsIGVudHJ5LnBhdGgpO1xuICAgICAgICAgIHZhciBmdWxsUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuXG4gICAgICAgICAgaWYgKHdoLmZvbGxvd1N5bWxpbmtzICYmIGVudHJ5LnN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgdGhlIGN1cnJlbnQgZGVwdGggaGVyZSBzaW5jZSBpdCBjYW4ndCBiZSBkZXJpdmVkIGZyb21cbiAgICAgICAgICAgIC8vIHJlYWwgcGF0aHMgcGFzdCB0aGUgc3ltbGlua1xuICAgICAgICAgICAgdmFyIGN1ckRlcHRoID0gdGhpcy5vcHRpb25zLmRlcHRoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICB1bmRlZmluZWQgOiBkZXB0aChqb2luZWRQYXRoLCBzeXNQYXRoLnJlc29sdmUod2gud2F0Y2hQYXRoKSkgKyAxO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVGc0V2ZW50c1N5bWxpbmsoam9pbmVkUGF0aCwgZnVsbFBhdGgsIHByb2Nlc3NQYXRoLCBjdXJEZXB0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXRBZGQoam9pbmVkUGF0aCwgZW50cnkuc3RhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgcmVhZGRpcnAgZXJyb3JzXG4gICAgICAgIH0pLm9uKCdlbmQnLCB0aGlzLl9lbWl0UmVhZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdEFkZCh3aC53YXRjaFBhdGgsIHN0YXRzKTtcbiAgICAgICAgdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCAmJiBmb3JjZUFkZCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIGluaXRXYXRjaCA9IGZ1bmN0aW9uIChlcnJvciwgcmVhbFBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIHZhciBjbG9zZXIgPSB0aGlzLl93YXRjaFdpdGhGc0V2ZW50cyhcbiAgICAgICAgICB3aC53YXRjaFBhdGgsXG4gICAgICAgICAgc3lzUGF0aC5yZXNvbHZlKHJlYWxQYXRoIHx8IHdoLndhdGNoUGF0aCksXG4gICAgICAgICAgcHJvY2Vzc1BhdGgsXG4gICAgICAgICAgd2guZ2xvYkZpbHRlclxuICAgICAgICApO1xuICAgICAgICBpZiAoY2xvc2VyKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2Vyc1twYXRoXSA9IHRoaXMuX2Nsb3NlcnNbcGF0aF0gfHwgW107XG4gICAgICAgICAgdGhpcy5fY2xvc2Vyc1twYXRoXS5wdXNoKGNsb3Nlcik7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gcmVhbHBhdGggaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZFxuICAgICAgICBpbml0V2F0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZzLnJlYWxwYXRoKHdoLndhdGNoUGF0aCwgaW5pdFdhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gRnNFdmVudHNIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMuY2FuVXNlID0gY2FuVXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcmVhZGRpcnAgPSByZXF1aXJlKCdyZWFkZGlycCcpO1xudmFyIGlzQmluYXJ5UGF0aCA9IHJlcXVpcmUoJ2lzLWJpbmFyeS1wYXRoJyk7XG5cbi8vIGZzLndhdGNoIGhlbHBlcnNcblxuLy8gb2JqZWN0IHRvIGhvbGQgcGVyLXByb2Nlc3MgZnMud2F0Y2ggaW5zdGFuY2VzXG4vLyAobWF5IGJlIHNoYXJlZCBhY3Jvc3MgY2hva2lkYXIgRlNXYXRjaGVyIGluc3RhbmNlcylcbnZhciBGc1dhdGNoSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzLndhdGNoIGludGVyZmFjZVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBvcHRpb25zICAgIC0gb2JqZWN0LCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBmcy53YXRjaFxuLy8gKiBsaXN0ZW5lciAgIC0gZnVuY3Rpb24sIG1haW4gZXZlbnQgaGFuZGxlclxuLy8gKiBlcnJIYW5kbGVyIC0gZnVuY3Rpb24sIGhhbmRsZXIgd2hpY2ggZW1pdHMgaW5mbyBhYm91dCBlcnJvcnNcbi8vICogZW1pdFJhdyAgICAtIGZ1bmN0aW9uLCBoYW5kbGVyIHdoaWNoIGVtaXRzIHJhdyBldmVudCBkYXRhXG5cbi8vIFJldHVybnMgbmV3IGZzZXZlbnRzIGluc3RhbmNlXG5mdW5jdGlvbiBjcmVhdGVGc1dhdGNoSW5zdGFuY2UocGF0aCwgb3B0aW9ucywgbGlzdGVuZXIsIGVyckhhbmRsZXIsIGVtaXRSYXcpIHtcbiAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24ocmF3RXZlbnQsIGV2UGF0aCkge1xuICAgIGxpc3RlbmVyKHBhdGgpO1xuICAgIGVtaXRSYXcocmF3RXZlbnQsIGV2UGF0aCwge3dhdGNoZWRQYXRoOiBwYXRofSk7XG5cbiAgICAvLyBlbWl0IGJhc2VkIG9uIGV2ZW50cyBvY2N1cnJpbmcgZm9yIGZpbGVzIGZyb20gYSBkaXJlY3RvcnkncyB3YXRjaGVyIGluXG4gICAgLy8gY2FzZSB0aGUgZmlsZSdzIHdhdGNoZXIgbWlzc2VzIGl0IChhbmQgcmVseSBvbiB0aHJvdHRsaW5nIHRvIGRlLWR1cGUpXG4gICAgaWYgKGV2UGF0aCAmJiBwYXRoICE9PSBldlBhdGgpIHtcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QoXG4gICAgICAgIHN5c1BhdGgucmVzb2x2ZShwYXRoLCBldlBhdGgpLCAnbGlzdGVuZXJzJywgc3lzUGF0aC5qb2luKHBhdGgsIGV2UGF0aClcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICB0cnkge1xuICAgIHJldHVybiBmcy53YXRjaChwYXRoLCBvcHRpb25zLCBoYW5kbGVFdmVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJySGFuZGxlcihlcnJvcik7XG4gIH1cbn1cblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSGVscGVyIGZvciBwYXNzaW5nIGZzLndhdGNoIGV2ZW50IGRhdGEgdG8gYVxuLy8gY29sbGVjdGlvbiBvZiBsaXN0ZW5lcnNcblxuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoIGJvdW5kIHRvIHRoZSBmcy53YXRjaCBpbnN0YW5jZVxuLy8gKiB0eXBlICAgICAgIC0gc3RyaW5nLCBsaXN0ZW5lciB0eXBlXG4vLyAqIHZhbFsxLi4zXSAgLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGxpc3RlbmVyc1xuXG4vLyBSZXR1cm5zIG5vdGhpbmdcbmZ1bmN0aW9uIGZzV2F0Y2hCcm9hZGNhc3QoZnVsbFBhdGgsIHR5cGUsIHZhbDEsIHZhbDIsIHZhbDMpIHtcbiAgaWYgKCFGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXSkgcmV0dXJuO1xuICBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXVt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIodmFsMSwgdmFsMiwgdmFsMyk7XG4gIH0pO1xufVxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzLndhdGNoIGludGVyZmFjZSBvciBiaW5kcyBsaXN0ZW5lcnNcbi8vIHRvIGFuIGV4aXN0aW5nIG9uZSBjb3ZlcmluZyB0aGUgc2FtZSBmaWxlIHN5c3RlbSBlbnRyeVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoXG4vLyAqIG9wdGlvbnMgICAgLSBvYmplY3QsIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGZzLndhdGNoXG4vLyAqIGhhbmRsZXJzICAgLSBvYmplY3QsIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZzV2F0Y2hMaXN0ZW5lcihwYXRoLCBmdWxsUGF0aCwgb3B0aW9ucywgaGFuZGxlcnMpIHtcbiAgdmFyIGxpc3RlbmVyID0gaGFuZGxlcnMubGlzdGVuZXI7XG4gIHZhciBlcnJIYW5kbGVyID0gaGFuZGxlcnMuZXJySGFuZGxlcjtcbiAgdmFyIHJhd0VtaXR0ZXIgPSBoYW5kbGVycy5yYXdFbWl0dGVyO1xuICB2YXIgY29udGFpbmVyID0gRnNXYXRjaEluc3RhbmNlc1tmdWxsUGF0aF07XG4gIHZhciB3YXRjaGVyO1xuICBpZiAoIW9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLCBvcHRpb25zLCBsaXN0ZW5lciwgZXJySGFuZGxlciwgcmF3RW1pdHRlclxuICAgICk7XG4gICAgcmV0dXJuIHdhdGNoZXIuY2xvc2UuYmluZCh3YXRjaGVyKTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ2xpc3RlbmVycycpLFxuICAgICAgZXJySGFuZGxlciwgLy8gbm8gbmVlZCB0byB1c2UgYnJvYWRjYXN0IGhlcmVcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ3Jhd0VtaXR0ZXJzJylcbiAgICApO1xuICAgIGlmICghd2F0Y2hlcikgcmV0dXJuO1xuICAgIHZhciBicm9hZGNhc3RFcnIgPSBmc1dhdGNoQnJvYWRjYXN0LmJpbmQobnVsbCwgZnVsbFBhdGgsICdlcnJIYW5kbGVycycpO1xuICAgIHdhdGNoZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnRhaW5lci53YXRjaGVyVW51c2FibGUgPSB0cnVlOyAvLyBkb2N1bWVudGVkIHNpbmNlIE5vZGUgMTAuNC4xXG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzQzMzdcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIGVycm9yLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCAncicsIGZ1bmN0aW9uKGVyciwgZmQpIHtcbiAgICAgICAgICBpZiAoIWVycikgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKCFlcnIpIGJyb2FkY2FzdEVycihlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJvYWRjYXN0RXJyKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250YWluZXIgPSBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXSA9IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXSxcbiAgICAgIGVyckhhbmRsZXJzOiBbZXJySGFuZGxlcl0sXG4gICAgICByYXdFbWl0dGVyczogW3Jhd0VtaXR0ZXJdLFxuICAgICAgd2F0Y2hlcjogd2F0Y2hlclxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBjb250YWluZXIuZXJySGFuZGxlcnMucHVzaChlcnJIYW5kbGVyKTtcbiAgICBjb250YWluZXIucmF3RW1pdHRlcnMucHVzaChyYXdFbWl0dGVyKTtcbiAgfVxuICB2YXIgbGlzdGVuZXJJbmRleCA9IGNvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmcy53YXRjaFxuICAvLyBpbnN0YW5jZSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgbGVmdFxuICByZXR1cm4gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgZGVsZXRlIGNvbnRhaW5lci5saXN0ZW5lcnNbbGlzdGVuZXJJbmRleF07XG4gICAgZGVsZXRlIGNvbnRhaW5lci5lcnJIYW5kbGVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBkZWxldGUgY29udGFpbmVyLnJhd0VtaXR0ZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGlmICghT2JqZWN0LmtleXMoY29udGFpbmVyLmxpc3RlbmVycykubGVuZ3RoKSB7XG4gICAgICBpZiAoIWNvbnRhaW5lci53YXRjaGVyVW51c2FibGUpIHsgLy8gY2hlY2sgdG8gcHJvdGVjdCBhZ2FpbnN0IGlzc3VlICM3MzBcbiAgICAgICAgY29udGFpbmVyLndhdGNoZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGZzLndhdGNoRmlsZSBoZWxwZXJzXG5cbi8vIG9iamVjdCB0byBob2xkIHBlci1wcm9jZXNzIGZzLndhdGNoRmlsZSBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxudmFyIEZzV2F0Y2hGaWxlSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSW5zdGFudGlhdGVzIHRoZSBmcy53YXRjaEZpbGUgaW50ZXJmYWNlIG9yIGJpbmRzIGxpc3RlbmVyc1xuLy8gdG8gYW4gZXhpc3Rpbmcgb25lIGNvdmVyaW5nIHRoZSBzYW1lIGZpbGUgc3lzdGVtIGVudHJ5XG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIGZ1bGxQYXRoICAgLSBzdHJpbmcsIGFic29sdXRlIHBhdGhcbi8vICogb3B0aW9ucyAgICAtIG9iamVjdCwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gZnMud2F0Y2hGaWxlXG4vLyAqIGhhbmRsZXJzICAgLSBvYmplY3QsIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgZnVsbFBhdGgsIG9wdGlvbnMsIGhhbmRsZXJzKSB7XG4gIHZhciBsaXN0ZW5lciA9IGhhbmRsZXJzLmxpc3RlbmVyO1xuICB2YXIgcmF3RW1pdHRlciA9IGhhbmRsZXJzLnJhd0VtaXR0ZXI7XG4gIHZhciBjb250YWluZXIgPSBGc1dhdGNoRmlsZUluc3RhbmNlc1tmdWxsUGF0aF07XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHJhd0VtaXR0ZXJzID0gW107XG4gIGlmIChcbiAgICBjb250YWluZXIgJiYgKFxuICAgICAgY29udGFpbmVyLm9wdGlvbnMucGVyc2lzdGVudCA8IG9wdGlvbnMucGVyc2lzdGVudCB8fFxuICAgICAgY29udGFpbmVyLm9wdGlvbnMuaW50ZXJ2YWwgPiBvcHRpb25zLmludGVydmFsXG4gICAgKVxuICApIHtcbiAgICAvLyBcIlVwZ3JhZGVcIiB0aGUgd2F0Y2hlciB0byBwZXJzaXN0ZW5jZSBvciBhIHF1aWNrZXIgaW50ZXJ2YWwuXG4gICAgLy8gVGhpcyBjcmVhdGVzIHNvbWUgdW5saWtlbHkgZWRnZSBjYXNlIGlzc3VlcyBpZiB0aGUgdXNlciBtaXhlc1xuICAgIC8vIHNldHRpbmdzIGluIGEgdmVyeSB3ZWlyZCB3YXksIGJ1dCBzb2x2aW5nIGZvciB0aG9zZSBjYXNlc1xuICAgIC8vIGRvZXNuJ3Qgc2VlbSB3b3J0aHdoaWxlIGZvciB0aGUgYWRkZWQgY29tcGxleGl0eS5cbiAgICBsaXN0ZW5lcnMgPSBjb250YWluZXIubGlzdGVuZXJzO1xuICAgIHJhd0VtaXR0ZXJzID0gY29udGFpbmVyLnJhd0VtaXR0ZXJzO1xuICAgIGZzLnVud2F0Y2hGaWxlKGZ1bGxQYXRoKTtcbiAgICBjb250YWluZXIgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByYXdFbWl0dGVycy5wdXNoKHJhd0VtaXR0ZXIpO1xuICAgIGNvbnRhaW5lciA9IEZzV2F0Y2hGaWxlSW5zdGFuY2VzW2Z1bGxQYXRoXSA9IHtcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgcmF3RW1pdHRlcnM6IHJhd0VtaXR0ZXJzLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIHdhdGNoZXI6IGZzLndhdGNoRmlsZShmdWxsUGF0aCwgb3B0aW9ucywgZnVuY3Rpb24oY3VyciwgcHJldikge1xuICAgICAgICBjb250YWluZXIucmF3RW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbihyYXdFbWl0dGVyKSB7XG4gICAgICAgICAgcmF3RW1pdHRlcignY2hhbmdlJywgZnVsbFBhdGgsIHtjdXJyOiBjdXJyLCBwcmV2OiBwcmV2fSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3Vycm10aW1lID0gY3Vyci5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChjdXJyLnNpemUgIT09IHByZXYuc2l6ZSB8fCBjdXJybXRpbWUgPiBwcmV2Lm10aW1lLmdldFRpbWUoKSB8fCBjdXJybXRpbWUgPT09IDApIHtcbiAgICAgICAgICBjb250YWluZXIubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHBhdGgsIGN1cnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBjb250YWluZXIucmF3RW1pdHRlcnMucHVzaChyYXdFbWl0dGVyKTtcbiAgfVxuICB2YXIgbGlzdGVuZXJJbmRleCA9IGNvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmcy53YXRjaEZpbGVcbiAgLy8gaW5zdGFuY2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGxlZnRcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGRlbGV0ZSBjb250YWluZXIubGlzdGVuZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGRlbGV0ZSBjb250YWluZXIucmF3RW1pdHRlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyhjb250YWluZXIubGlzdGVuZXJzKS5sZW5ndGgpIHtcbiAgICAgIGZzLnVud2F0Y2hGaWxlKGZ1bGxQYXRoKTtcbiAgICAgIGRlbGV0ZSBGc1dhdGNoRmlsZUluc3RhbmNlc1tmdWxsUGF0aF07XG4gICAgfVxuICB9O1xufVxuXG4vLyBmYWtlIGNvbnN0cnVjdG9yIGZvciBhdHRhY2hpbmcgbm9kZWZzLXNwZWNpZmljIHByb3RvdHlwZSBtZXRob2RzIHRoYXRcbi8vIHdpbGwgYmUgY29waWVkIHRvIEZTV2F0Y2hlcidzIHByb3RvdHlwZVxuZnVuY3Rpb24gTm9kZUZzSGFuZGxlcigpIHt9XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBXYXRjaCBmaWxlIGZvciBjaGFuZ2VzIHdpdGggZnMud2F0Y2hGaWxlIG9yIGZzLndhdGNoLlxuXG4vLyAqIHBhdGggICAgIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5LlxuLy8gKiBsaXN0ZW5lciAtIGZ1bmN0aW9uLCB0byBiZSBleGVjdXRlZCBvbiBmcyBjaGFuZ2UuXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5fd2F0Y2hXaXRoTm9kZUZzID1cbmZ1bmN0aW9uKHBhdGgsIGxpc3RlbmVyKSB7XG4gIHZhciBkaXJlY3RvcnkgPSBzeXNQYXRoLmRpcm5hbWUocGF0aCk7XG4gIHZhciBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUocGF0aCk7XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSk7XG4gIHBhcmVudC5hZGQoYmFzZW5hbWUpO1xuICB2YXIgYWJzb2x1dGVQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICB2YXIgb3B0aW9ucyA9IHtwZXJzaXN0ZW50OiB0aGlzLm9wdGlvbnMucGVyc2lzdGVudH07XG4gIGlmICghbGlzdGVuZXIpIGxpc3RlbmVyID0gRnVuY3Rpb24ucHJvdG90eXBlOyAvLyBlbXB0eSBmdW5jdGlvblxuXG4gIHZhciBjbG9zZXI7XG4gIGlmICh0aGlzLm9wdGlvbnMudXNlUG9sbGluZykge1xuICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSB0aGlzLmVuYWJsZUJpbmFyeUludGVydmFsICYmIGlzQmluYXJ5UGF0aChiYXNlbmFtZSkgP1xuICAgICAgdGhpcy5vcHRpb25zLmJpbmFyeUludGVydmFsIDogdGhpcy5vcHRpb25zLmludGVydmFsO1xuICAgIGNsb3NlciA9IHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICByYXdFbWl0dGVyOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAncmF3JylcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjbG9zZXIgPSBzZXRGc1dhdGNoTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICBlcnJIYW5kbGVyOiB0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpLFxuICAgICAgcmF3RW1pdHRlcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ3JhdycpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBXYXRjaCBhIGZpbGUgYW5kIGVtaXQgYWRkIGV2ZW50IGlmIHdhcnJhbnRlZFxuXG4vLyAqIGZpbGUgICAgICAgLSBzdHJpbmcsIHRoZSBmaWxlJ3MgcGF0aFxuLy8gKiBzdGF0cyAgICAgIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy8gKiBpbml0aWFsQWRkIC0gYm9vbGVhbiwgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgY2FsbGVkIHdoZW4gZG9uZSBwcm9jZXNzaW5nIGFzIGEgbmV3bHkgc2VlbiBmaWxlXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlRmlsZSA9XG5mdW5jdGlvbihmaWxlLCBzdGF0cywgaW5pdGlhbEFkZCwgY2FsbGJhY2spIHtcbiAgdmFyIGRpcm5hbWUgPSBzeXNQYXRoLmRpcm5hbWUoZmlsZSk7XG4gIHZhciBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUoZmlsZSk7XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcm5hbWUpO1xuICAvLyBzdGF0cyBpcyBhbHdheXMgcHJlc2VudFxuICB2YXIgcHJldlN0YXRzID0gc3RhdHM7XG5cbiAgLy8gaWYgdGhlIGZpbGUgaXMgYWxyZWFkeSBiZWluZyB3YXRjaGVkLCBkbyBub3RoaW5nXG4gIGlmIChwYXJlbnQuaGFzKGJhc2VuYW1lKSkgcmV0dXJuIGNhbGxiYWNrKCk7XG5cbiAgLy8ga2ljayBvZmYgdGhlIHdhdGNoZXJcbiAgdmFyIGNsb3NlciA9IHRoaXMuX3dhdGNoV2l0aE5vZGVGcyhmaWxlLCBmdW5jdGlvbihwYXRoLCBuZXdTdGF0cykge1xuICAgIGlmICghdGhpcy5fdGhyb3R0bGUoJ3dhdGNoJywgZmlsZSwgNSkpIHJldHVybjtcbiAgICBpZiAoIW5ld1N0YXRzIHx8IG5ld1N0YXRzICYmIG5ld1N0YXRzLm10aW1lLmdldFRpbWUoKSA9PT0gMCkge1xuICAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnJvciwgbmV3U3RhdHMpIHtcbiAgICAgICAgLy8gRml4IGlzc3VlcyB3aGVyZSBtdGltZSBpcyBudWxsIGJ1dCBmaWxlIGlzIHN0aWxsIHByZXNlbnRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlKGRpcm5hbWUsIGJhc2VuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDaGVjayB0aGF0IGNoYW5nZSBldmVudCB3YXMgbm90IGZpcmVkIGJlY2F1c2Ugb2YgY2hhbmdlZCBvbmx5IGFjY2Vzc1RpbWUuXG4gICAgICAgICAgdmFyIGF0ID0gbmV3U3RhdHMuYXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICAgIHZhciBtdCA9IG5ld1N0YXRzLm10aW1lLmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoIWF0IHx8IGF0IDw9IG10IHx8IG10ICE9PSBwcmV2U3RhdHMubXRpbWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdjaGFuZ2UnLCBmaWxlLCBuZXdTdGF0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZTdGF0cyA9IG5ld1N0YXRzO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIC8vIGFkZCBpcyBhYm91dCB0byBiZSBlbWl0dGVkIGlmIGZpbGUgbm90IGFscmVhZHkgdHJhY2tlZCBpbiBwYXJlbnRcbiAgICB9IGVsc2UgaWYgKHBhcmVudC5oYXMoYmFzZW5hbWUpKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IGNoYW5nZSBldmVudCB3YXMgbm90IGZpcmVkIGJlY2F1c2Ugb2YgY2hhbmdlZCBvbmx5IGFjY2Vzc1RpbWUuXG4gICAgICB2YXIgYXQgPSBuZXdTdGF0cy5hdGltZS5nZXRUaW1lKCk7XG4gICAgICB2YXIgbXQgPSBuZXdTdGF0cy5tdGltZS5nZXRUaW1lKCk7XG4gICAgICBpZiAoIWF0IHx8IGF0IDw9IG10IHx8ICBtdCAhPT0gcHJldlN0YXRzLm10aW1lLmdldFRpbWUoKSkge1xuICAgICAgICB0aGlzLl9lbWl0KCdjaGFuZ2UnLCBmaWxlLCBuZXdTdGF0cyk7XG4gICAgICB9XG4gICAgICBwcmV2U3RhdHMgPSBuZXdTdGF0cztcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLy8gZW1pdCBhbiBhZGQgZXZlbnQgaWYgd2UncmUgc3VwcG9zZWQgdG9cbiAgaWYgKCEoaW5pdGlhbEFkZCAmJiB0aGlzLm9wdGlvbnMuaWdub3JlSW5pdGlhbCkpIHtcbiAgICBpZiAoIXRoaXMuX3Rocm90dGxlKCdhZGQnLCBmaWxlLCAwKSkgcmV0dXJuO1xuICAgIHRoaXMuX2VtaXQoJ2FkZCcsIGZpbGUsIHN0YXRzKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgcmV0dXJuIGNsb3Nlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGUgc3ltbGlua3MgZW5jb3VudGVyZWQgd2hpbGUgcmVhZGluZyBhIGRpclxuXG4vLyAqIGVudHJ5ICAgICAgLSBvYmplY3QsIGVudHJ5IG9iamVjdCByZXR1cm5lZCBieSByZWFkZGlycFxuLy8gKiBkaXJlY3RvcnkgIC0gc3RyaW5nLCBwYXRoIG9mIHRoZSBkaXJlY3RvcnkgYmVpbmcgcmVhZFxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIG9mIHRoaXMgaXRlbVxuLy8gKiBpdGVtICAgICAgIC0gc3RyaW5nLCBiYXNlbmFtZSBvZiB0aGlzIGl0ZW1cblxuLy8gUmV0dXJucyB0cnVlIGlmIG5vIG1vcmUgcHJvY2Vzc2luZyBpcyBuZWVkZWQgZm9yIHRoaXMgZW50cnkuXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlU3ltbGluayA9XG5mdW5jdGlvbihlbnRyeSwgZGlyZWN0b3J5LCBwYXRoLCBpdGVtKSB7XG4gIHZhciBmdWxsID0gZW50cnkuZnVsbFBhdGg7XG4gIHZhciBkaXIgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSk7XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAvLyB3YXRjaCBzeW1saW5rIGRpcmVjdGx5IChkb24ndCBmb2xsb3cpIGFuZCBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMuX3JlYWR5Q291bnQrKztcbiAgICBmcy5yZWFscGF0aChwYXRoLCBmdW5jdGlvbihlcnJvciwgbGlua1BhdGgpIHtcbiAgICAgIGlmIChkaXIuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGlmICh0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0gIT09IGxpbmtQYXRoKSB7XG4gICAgICAgICAgdGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdID0gbGlua1BhdGg7XG4gICAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgcGF0aCwgZW50cnkuc3RhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpci5hZGQoaXRlbSk7XG4gICAgICAgIHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsXSA9IGxpbmtQYXRoO1xuICAgICAgICB0aGlzLl9lbWl0KCdhZGQnLCBwYXRoLCBlbnRyeS5zdGF0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBkb24ndCBmb2xsb3cgdGhlIHNhbWUgc3ltbGluayBtb3JlIHRoYW4gb25jZVxuICBpZiAodGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdKSByZXR1cm4gdHJ1ZTtcbiAgZWxzZSB0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0gPSB0cnVlO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IFJlYWQgZGlyZWN0b3J5IHRvIGFkZCAvIHJlbW92ZSBmaWxlcyBmcm9tIGBAd2F0Y2hlZGAgbGlzdFxuLy8gYW5kIHJlLXJlYWQgaXQgb24gY2hhbmdlLlxuXG4vLyAqIGRpciAgICAgICAgLSBzdHJpbmcsIGZzIHBhdGguXG4vLyAqIHN0YXRzICAgICAgLSBvYmplY3QsIHJlc3VsdCBvZiBmcy5zdGF0XG4vLyAqIGluaXRpYWxBZGQgLSBib29sZWFuLCB3YXMgdGhlIGZpbGUgYWRkZWQgYXQgd2F0Y2ggaW5zdGFudGlhdGlvbj9cbi8vICogZGVwdGggICAgICAtIGludCwgZGVwdGggcmVsYXRpdmUgdG8gdXNlci1zdXBwbGllZCBwYXRoXG4vLyAqIHRhcmdldCAgICAgLSBzdHJpbmcsIGNoaWxkIHBhdGggYWN0dWFsbHkgdGFyZ2V0ZWQgZm9yIHdhdGNoXG4vLyAqIHdoICAgICAgICAgLSBvYmplY3QsIGNvbW1vbiB3YXRjaCBoZWxwZXJzIGZvciB0aGlzIHBhdGhcbi8vICogY2FsbGJhY2sgICAtIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiBkaXIgc2NhbiBpcyBjb21wbGV0ZVxuXG4vLyBSZXR1cm5zIGNsb3NlIGZ1bmN0aW9uIGZvciB0aGUgd2F0Y2hlciBpbnN0YW5jZVxuTm9kZUZzSGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZURpciA9XG5mdW5jdGlvbihkaXIsIHN0YXRzLCBpbml0aWFsQWRkLCBkZXB0aCwgdGFyZ2V0LCB3aCwgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudERpciA9IHRoaXMuX2dldFdhdGNoZWREaXIoc3lzUGF0aC5kaXJuYW1lKGRpcikpO1xuICB2YXIgdHJhY2tlZCA9IHBhcmVudERpci5oYXMoc3lzUGF0aC5iYXNlbmFtZShkaXIpKTtcbiAgaWYgKCEoaW5pdGlhbEFkZCAmJiB0aGlzLm9wdGlvbnMuaWdub3JlSW5pdGlhbCkgJiYgIXRhcmdldCAmJiAhdHJhY2tlZCkge1xuICAgIGlmICghd2guaGFzR2xvYiB8fCB3aC5nbG9iRmlsdGVyKGRpcikpIHRoaXMuX2VtaXQoJ2FkZERpcicsIGRpciwgc3RhdHMpO1xuICB9XG5cbiAgLy8gZW5zdXJlIGRpciBpcyB0cmFja2VkIChoYXJtbGVzcyBpZiByZWR1bmRhbnQpXG4gIHBhcmVudERpci5hZGQoc3lzUGF0aC5iYXNlbmFtZShkaXIpKTtcbiAgdGhpcy5fZ2V0V2F0Y2hlZERpcihkaXIpO1xuXG4gIHZhciByZWFkID0gZnVuY3Rpb24oZGlyZWN0b3J5LCBpbml0aWFsQWRkLCBkb25lKSB7XG4gICAgLy8gTm9ybWFsaXplIHRoZSBkaXJlY3RvcnkgbmFtZSBvbiBXaW5kb3dzXG4gICAgZGlyZWN0b3J5ID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgJycpO1xuXG4gICAgaWYgKCF3aC5oYXNHbG9iKSB7XG4gICAgICB2YXIgdGhyb3R0bGVyID0gdGhpcy5fdGhyb3R0bGUoJ3JlYWRkaXInLCBkaXJlY3RvcnksIDEwMDApO1xuICAgICAgaWYgKCF0aHJvdHRsZXIpIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHdoLnBhdGgpO1xuICAgIHZhciBjdXJyZW50ID0gW107XG5cbiAgICByZWFkZGlycCh7XG4gICAgICByb290OiBkaXJlY3RvcnksXG4gICAgICBlbnRyeVR5cGU6ICdhbGwnLFxuICAgICAgZmlsZUZpbHRlcjogd2guZmlsdGVyUGF0aCxcbiAgICAgIGRpcmVjdG9yeUZpbHRlcjogd2guZmlsdGVyRGlyLFxuICAgICAgZGVwdGg6IDAsXG4gICAgICBsc3RhdDogdHJ1ZVxuICAgIH0pLm9uKCdkYXRhJywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHZhciBpdGVtID0gZW50cnkucGF0aDtcbiAgICAgIHZhciBwYXRoID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgaXRlbSk7XG4gICAgICBjdXJyZW50LnB1c2goaXRlbSk7XG5cbiAgICAgIGlmIChlbnRyeS5zdGF0LmlzU3ltYm9saWNMaW5rKCkgJiZcbiAgICAgICAgdGhpcy5faGFuZGxlU3ltbGluayhlbnRyeSwgZGlyZWN0b3J5LCBwYXRoLCBpdGVtKSkgcmV0dXJuO1xuXG4gICAgICAvLyBGaWxlcyB0aGF0IHByZXNlbnQgaW4gY3VycmVudCBkaXJlY3Rvcnkgc25hcHNob3RcbiAgICAgIC8vIGJ1dCBhYnNlbnQgaW4gcHJldmlvdXMgYXJlIGFkZGVkIHRvIHdhdGNoIGxpc3QgYW5kXG4gICAgICAvLyBlbWl0IGBhZGRgIGV2ZW50LlxuICAgICAgaWYgKGl0ZW0gPT09IHRhcmdldCB8fCAhdGFyZ2V0ICYmICFwcmV2aW91cy5oYXMoaXRlbSkpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlDb3VudCsrO1xuXG4gICAgICAgIC8vIGVuc3VyZSByZWxhdGl2ZW5lc3Mgb2YgcGF0aCBpcyBwcmVzZXJ2ZWQgaW4gY2FzZSBvZiB3YXRjaGVyIHJldXNlXG4gICAgICAgIHBhdGggPSBzeXNQYXRoLmpvaW4oZGlyLCBzeXNQYXRoLnJlbGF0aXZlKGRpciwgcGF0aCkpO1xuXG4gICAgICAgIHRoaXMuX2FkZFRvTm9kZUZzKHBhdGgsIGluaXRpYWxBZGQsIHdoLCBkZXB0aCArIDEpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdhc1Rocm90dGxlZCA9IHRocm90dGxlciA/IHRocm90dGxlci5jbGVhcigpIDogZmFsc2U7XG4gICAgICBpZiAoZG9uZSkgZG9uZSgpO1xuXG4gICAgICAvLyBGaWxlcyB0aGF0IGFic2VudCBpbiBjdXJyZW50IGRpcmVjdG9yeSBzbmFwc2hvdFxuICAgICAgLy8gYnV0IHByZXNlbnQgaW4gcHJldmlvdXMgZW1pdCBgcmVtb3ZlYCBldmVudFxuICAgICAgLy8gYW5kIGFyZSByZW1vdmVkIGZyb20gQHdhdGNoZWRbZGlyZWN0b3J5XS5cbiAgICAgIHByZXZpb3VzLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGRpcmVjdG9yeSAmJlxuICAgICAgICAgIGN1cnJlbnQuaW5kZXhPZihpdGVtKSA9PT0gLTEgJiZcbiAgICAgICAgICAvLyBpbiBjYXNlIG9mIGludGVyc2VjdGluZyBnbG9icztcbiAgICAgICAgICAvLyBhIHBhdGggbWF5IGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQgb2YgdGhpcyByZWFkZGlyLCBidXRcbiAgICAgICAgICAvLyBzaG91bGRuJ3QgYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IG1hdGNoZXMgYSBkaWZmZXJlbnQgZ2xvYlxuICAgICAgICAgICghd2guaGFzR2xvYiB8fCB3aC5maWx0ZXJQYXRoKHtcbiAgICAgICAgICAgIGZ1bGxQYXRoOiBzeXNQYXRoLnJlc29sdmUoZGlyZWN0b3J5LCBpdGVtKVxuICAgICAgICAgIH0pKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB0aGlzLl9yZW1vdmUoZGlyZWN0b3J5LCBpdGVtKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAvLyBvbmUgbW9yZSB0aW1lIGZvciBhbnkgbWlzc2VkIGluIGNhc2UgY2hhbmdlcyBjYW1lIGluIGV4dHJlbWVseSBxdWlja2x5XG4gICAgICBpZiAod2FzVGhyb3R0bGVkKSByZWFkKGRpcmVjdG9yeSwgZmFsc2UpO1xuICAgIH0uYmluZCh0aGlzKSkub24oJ2Vycm9yJywgdGhpcy5faGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgY2xvc2VyO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuZGVwdGggPT0gbnVsbCB8fCBkZXB0aCA8PSB0aGlzLm9wdGlvbnMuZGVwdGgpIHtcbiAgICBpZiAoIXRhcmdldCkgcmVhZChkaXIsIGluaXRpYWxBZGQsIGNhbGxiYWNrKTtcbiAgICBjbG9zZXIgPSB0aGlzLl93YXRjaFdpdGhOb2RlRnMoZGlyLCBmdW5jdGlvbihkaXJQYXRoLCBzdGF0cykge1xuICAgICAgLy8gaWYgY3VycmVudCBkaXJlY3RvcnkgaXMgcmVtb3ZlZCwgZG8gbm90aGluZ1xuICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLm10aW1lLmdldFRpbWUoKSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICByZWFkKGRpclBhdGgsIGZhbHNlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG4gIHJldHVybiBjbG9zZXI7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIGFkZGVkIGZpbGUsIGRpcmVjdG9yeSwgb3IgZ2xvYiBwYXR0ZXJuLlxuLy8gRGVsZWdhdGVzIGNhbGwgdG8gX2hhbmRsZUZpbGUgLyBfaGFuZGxlRGlyIGFmdGVyIGNoZWNrcy5cblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5LlxuLy8gKiBpbml0aWFsQWRkIC0gYm9vbGVhbiwgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4vLyAqIGRlcHRoICAgICAgLSBpbnQsIGRlcHRoIHJlbGF0aXZlIHRvIHVzZXItc3VwcGxpZWQgcGF0aFxuLy8gKiB0YXJnZXQgICAgIC0gc3RyaW5nLCBjaGlsZCBwYXRoIGFjdHVhbGx5IHRhcmdldGVkIGZvciB3YXRjaFxuLy8gKiBjYWxsYmFjayAgIC0gZnVuY3Rpb24sIGluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXRoIHdhcyBmb3VuZCBvciBub3RcblxuLy8gUmV0dXJucyBub3RoaW5nXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5fYWRkVG9Ob2RlRnMgPVxuZnVuY3Rpb24ocGF0aCwgaW5pdGlhbEFkZCwgcHJpb3JXaCwgZGVwdGgsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciByZWFkeSA9IHRoaXMuX2VtaXRSZWFkeTtcbiAgaWYgKHRoaXMuX2lzSWdub3JlZChwYXRoKSB8fCB0aGlzLmNsb3NlZCkge1xuICAgIHJlYWR5KCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZhbHNlKTtcbiAgfVxuXG4gIHZhciB3aCA9IHRoaXMuX2dldFdhdGNoSGVscGVycyhwYXRoLCBkZXB0aCk7XG4gIGlmICghd2guaGFzR2xvYiAmJiBwcmlvcldoKSB7XG4gICAgd2guaGFzR2xvYiA9IHByaW9yV2guaGFzR2xvYjtcbiAgICB3aC5nbG9iRmlsdGVyID0gcHJpb3JXaC5nbG9iRmlsdGVyO1xuICAgIHdoLmZpbHRlclBhdGggPSBwcmlvcldoLmZpbHRlclBhdGg7XG4gICAgd2guZmlsdGVyRGlyID0gcHJpb3JXaC5maWx0ZXJEaXI7XG4gIH1cblxuICAvLyBldmFsdWF0ZSB3aGF0IGlzIGF0IHRoZSBwYXRoIHdlJ3JlIGJlaW5nIGFza2VkIHRvIHdhdGNoXG4gIGZzW3doLnN0YXRNZXRob2RdKHdoLndhdGNoUGF0aCwgZnVuY3Rpb24oZXJyb3IsIHN0YXRzKSB7XG4gICAgaWYgKHRoaXMuX2hhbmRsZUVycm9yKGVycm9yKSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHBhdGgpO1xuICAgIGlmICh0aGlzLl9pc0lnbm9yZWQod2gud2F0Y2hQYXRoLCBzdGF0cykpIHtcbiAgICAgIHJlYWR5KCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBpbml0RGlyID0gZnVuY3Rpb24oZGlyLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVEaXIoZGlyLCBzdGF0cywgaW5pdGlhbEFkZCwgZGVwdGgsIHRhcmdldCwgd2gsIHJlYWR5KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgY2xvc2VyO1xuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBjbG9zZXIgPSBpbml0RGlyKHdoLndhdGNoUGF0aCwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBzeXNQYXRoLmRpcm5hbWUod2gud2F0Y2hQYXRoKTtcbiAgICAgIHRoaXMuX2dldFdhdGNoZWREaXIocGFyZW50KS5hZGQod2gud2F0Y2hQYXRoKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2FkZCcsIHdoLndhdGNoUGF0aCwgc3RhdHMpO1xuICAgICAgY2xvc2VyID0gaW5pdERpcihwYXJlbnQsIHBhdGgpO1xuXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGlzIHN5bWxpbmsncyB0YXJnZXQgcGF0aFxuICAgICAgZnMucmVhbHBhdGgocGF0aCwgZnVuY3Rpb24oZXJyb3IsIHRhcmdldFBhdGgpIHtcbiAgICAgICAgdGhpcy5fc3ltbGlua1BhdGhzW3N5c1BhdGgucmVzb2x2ZShwYXRoKV0gPSB0YXJnZXRQYXRoO1xuICAgICAgICByZWFkeSgpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VyID0gdGhpcy5faGFuZGxlRmlsZSh3aC53YXRjaFBhdGgsIHN0YXRzLCBpbml0aWFsQWRkLCByZWFkeSk7XG4gICAgfVxuXG4gICAgaWYgKGNsb3Nlcikge1xuICAgICAgdGhpcy5fY2xvc2Vyc1twYXRoXSA9IHRoaXMuX2Nsb3NlcnNbcGF0aF0gfHwgW107XG4gICAgICB0aGlzLl9jbG9zZXJzW3BhdGhdLnB1c2goY2xvc2VyKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlRnNIYW5kbGVyO1xuIiwiLyohXG4gKiBub3JtYWxpemUtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbm9ybWFsaXplLXBhdGg+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0aCwgc3RyaXBUcmFpbGluZykge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0aCB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdGggPT09ICdcXFxcJyB8fCBwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG5cbiAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICBpZiAobGVuIDw9IDEpIHJldHVybiBwYXRoO1xuXG4gIC8vIGVuc3VyZSB0aGF0IHdpbjMyIG5hbWVzcGFjZXMgaGFzIHR3byBsZWFkaW5nIHNsYXNoZXMsIHNvIHRoYXQgdGhlIHBhdGggaXNcbiAgLy8gaGFuZGxlZCBwcm9wZXJseSBieSB0aGUgd2luMzIgdmVyc2lvbiBvZiBwYXRoLnBhcnNlKCkgYWZ0ZXIgYmVpbmcgbm9ybWFsaXplZFxuICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM2NTI0Nyh2PXZzLjg1KS5hc3B4I25hbWVzcGFjZXNcbiAgdmFyIHByZWZpeCA9ICcnO1xuICBpZiAobGVuID4gNCAmJiBwYXRoWzNdID09PSAnXFxcXCcpIHtcbiAgICB2YXIgY2ggPSBwYXRoWzJdO1xuICAgIGlmICgoY2ggPT09ICc/JyB8fCBjaCA9PT0gJy4nKSAmJiBwYXRoLnNsaWNlKDAsIDIpID09PSAnXFxcXFxcXFwnKSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICAgIHByZWZpeCA9ICcvLyc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlZ3MgPSBwYXRoLnNwbGl0KC9bL1xcXFxdKy8pO1xuICBpZiAoc3RyaXBUcmFpbGluZyAhPT0gZmFsc2UgJiYgc2Vnc1tzZWdzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgIHNlZ3MucG9wKCk7XG4gIH1cbiAgcmV0dXJuIHByZWZpeCArIHNlZ3Muam9pbignLycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCdhcnItdW5pb24nKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBzdGF0aWNFeHRlbmQgPSByZXF1aXJlKCdzdGF0aWMtZXh0ZW5kJyk7XG52YXIgaXNPYmogPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBjbGFzcyB1dGlsc1xuICovXG5cbnZhciBjdSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIEV4cG9zZSBjbGFzcyB1dGlsczogYGN1YFxuICovXG5cbmN1LmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBpc09iaih2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhcnJheSBoYXMgYW55IG9mIHRoZSBnaXZlbiBlbGVtZW50cywgb3IgYW5cbiAqIG9iamVjdCBoYXMgYW55IG9mIHRoZSBnaXZlIGtleXMuXG4gKlxuICogYGBganNcbiAqIGN1LmhhcyhbJ2EnLCAnYicsICdjJ10sICdjJyk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBjdS5oYXMoWydhJywgJ2InLCAnYyddLCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1Lmhhcyh7YTogJ2InLCBjOiAnZCd9LCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgdmFsYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuaGFzID0gZnVuY3Rpb24gaGFzKG9iaiwgdmFsKSB7XG4gIHZhbCA9IGN1LmFycmF5aWZ5KHZhbCk7XG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChjdS5pc09iamVjdChvYmopKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHZhbC5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGN1Lm5hdGl2ZUtleXMob2JqKTtcbiAgICByZXR1cm4gY3UuaGFzKGtleXMsIHZhbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgdmFyIGFyciA9IG9iajtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih2YWxbbGVuXSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gYXJyYXkgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gYXJyYXkgb3Igb2JqZWN0IGhhcyBhbGwgb2YgdGhlIGdpdmVuIHZhbHVlcy5cbiAqXG4gKiBgYGBqc1xuICogY3UuaGFzQWxsKFsnYScsICdiJywgJ2MnXSwgJ2MnKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1Lmhhc0FsbChbJ2EnLCAnYicsICdjJ10sIFsnYycsICd6J10pO1xuICogLy89PiBmYWxzZVxuICpcbiAqIGN1Lmhhc0FsbCh7YTogJ2InLCBjOiAnZCd9LCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGB2YWxgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHZhbHVlc2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1Lmhhc0FsbCA9IGZ1bmN0aW9uIGhhc0FsbCh2YWwsIHZhbHVlcykge1xuICB2YWx1ZXMgPSBjdS5hcnJheWlmeSh2YWx1ZXMpO1xuICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaWYgKCFjdS5oYXModmFsLCB2YWx1ZXNbbGVuXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIHZhbHVlIHRvIGFuIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBjdS5hcnJheWlmeSgnZm9vJyk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqXG4gKiBjdS5hcnJheWlmeShbJ2ZvbyddKTtcbiAqIC8vPT4gWydmb28nXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGB2YWxgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuYXJyYXlpZnkgPSBmdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn07XG5cbi8qKlxuICogTm9vcFxuICovXG5cbmN1Lm5vb3AgPSBmdW5jdGlvbiBub29wKCkge1xuICByZXR1cm47XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gKi9cblxuY3UuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eSh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgdmFsdWUgaGFzIGEgYGNvbnRydWN0b3JgXG4gKlxuICogYGBganNcbiAqIGN1Lmhhc0NvbnN0cnVjdG9yKHt9KTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1Lmhhc0NvbnN0cnVjdG9yKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGB2YWx1ZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1Lmhhc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsKSB7XG4gIHJldHVybiBjdS5pc09iamVjdCh2YWwpICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgIT09ICd1bmRlZmluZWQnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgb3duUHJvcGVydHlOYW1lc2AgZnJvbSB0aGUgY29uc3RydWN0b3Igb2YgdGhlXG4gKiBnaXZlbiBgb2JqZWN0YC4gQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlIG9iamVjdCBkb2VzXG4gKiBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBgYGpzXG4gKiBjdS5uYXRpdmVLZXlzKHthOiAnYicsIGI6ICdjJywgYzogJ2QnfSlcbiAqIC8vPT4gWydhJywgJ2InLCAnYyddXG4gKlxuICogY3UubmF0aXZlS2V5cyhmdW5jdGlvbigpe30pXG4gKiAvLz0+IFsnbGVuZ3RoJywgJ2NhbGxlciddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvYmpgIE9iamVjdCB0aGF0IGhhcyBhIGBjb25zdHJ1Y3RvcmAuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2Yga2V5cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UubmF0aXZlS2V5cyA9IGZ1bmN0aW9uIG5hdGl2ZUtleXModmFsKSB7XG4gIGlmICghY3UuaGFzQ29uc3RydWN0b3IodmFsKSkgcmV0dXJuIFtdO1xuICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbCk7XG4gIGlmICgnY2FsbGVyJyBpbiB2YWwpIGtleXMucHVzaCgnY2FsbGVyJyk7XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHByb3BlcnR5IGRlc2NyaXB0b3IgYGtleWAgaWYgaXQncyBhbiBcIm93blwiIHByb3BlcnR5XG4gKiBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBBcHAoKSB7fVxuICogT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcC5wcm90b3R5cGUsICdjb3VudCcsIHtcbiAqICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAqICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykubGVuZ3RoO1xuICogICB9XG4gKiB9KTtcbiAqIGN1LmdldERlc2NyaXB0b3IoQXBwLnByb3RvdHlwZSwgJ2NvdW50Jyk7XG4gKiAvLyByZXR1cm5zOlxuICogLy8ge1xuICogLy8gICBnZXQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgIHNldDogdW5kZWZpbmVkLFxuICogLy8gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAqIC8vICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBvYmpgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBkZXNjcmlwdG9yIGBrZXlgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1LmdldERlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXREZXNjcmlwdG9yKG9iaiwga2V5KSB7XG4gIGlmICghY3UuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBrZXkgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xufTtcblxuLyoqXG4gKiBDb3B5IGEgZGVzY3JpcHRvciBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlci5cbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gQXBwKCkge31cbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHAucHJvdG90eXBlLCAnY291bnQnLCB7XG4gKiAgIGdldDogZnVuY3Rpb24oKSB7XG4gKiAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmxlbmd0aDtcbiAqICAgfVxuICogfSk7XG4gKiB2YXIgb2JqID0ge307XG4gKiBjdS5jb3B5RGVzY3JpcHRvcihvYmosIEFwcC5wcm90b3R5cGUsICdjb3VudCcpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHJlY2VpdmVyYFxuICogQHBhcmFtIHtPYmplY3R9IGBwcm92aWRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuY29weURlc2NyaXB0b3IgPSBmdW5jdGlvbiBjb3B5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvdmlkZXIsIG5hbWUpIHtcbiAgaWYgKCFjdS5pc09iamVjdChyZWNlaXZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCByZWNlaXZpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAoIWN1LmlzT2JqZWN0KHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHByb3ZpZGluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBuYW1lIHRvIGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIHZhbCA9IGN1LmdldERlc2NyaXB0b3IocHJvdmlkZXIsIG5hbWUpO1xuICBpZiAodmFsKSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIG5hbWUsIHZhbCk7XG59O1xuXG4vKipcbiAqIENvcHkgc3RhdGljIHByb3BlcnRpZXMsIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnNcbiAqIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcmVjZWl2ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBvbWl0YCBPbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIHRvIG9taXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuY29weSA9IGZ1bmN0aW9uIGNvcHkocmVjZWl2ZXIsIHByb3ZpZGVyLCBvbWl0KSB7XG4gIGlmICghY3UuaXNPYmplY3QocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcmVjZWl2aW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKCFjdS5pc09iamVjdChwcm92aWRlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwcm92aWRpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm92aWRlcik7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdmlkZXIpO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoLFxuICAgIGtleTtcbiAgb21pdCA9IGN1LmFycmF5aWZ5KG9taXQpO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGtleSA9IHByb3BzW2xlbl07XG5cbiAgICBpZiAoY3UuaGFzKGtleXMsIGtleSkpIHtcbiAgICAgIGRlZmluZShyZWNlaXZlciwga2V5LCBwcm92aWRlcltrZXldKTtcbiAgICB9IGVsc2UgaWYgKCEoa2V5IGluIHJlY2VpdmVyKSAmJiAhY3UuaGFzKG9taXQsIGtleSkpIHtcbiAgICAgIGN1LmNvcHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm92aWRlciwga2V5KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgc3RhdGljIHByb3BlcnRpZXMsIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnNcbiAqIGZyb20gb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcmVjZWl2ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBvbWl0YCBPbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIHRvIG9taXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuaW5oZXJpdCA9IGZ1bmN0aW9uIGluaGVyaXQocmVjZWl2ZXIsIHByb3ZpZGVyLCBvbWl0KSB7XG4gIGlmICghY3UuaXNPYmplY3QocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcmVjZWl2aW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKCFjdS5pc09iamVjdChwcm92aWRlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwcm92aWRpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm92aWRlcikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHJlY2VpdmVyW2tleV0gPSBwcm92aWRlcltrZXldO1xuICB9XG5cbiAga2V5cyA9IGtleXMuY29uY2F0KGN1LmFycmF5aWZ5KG9taXQpKTtcblxuICB2YXIgYSA9IHByb3ZpZGVyLnByb3RvdHlwZSB8fCBwcm92aWRlcjtcbiAgdmFyIGIgPSByZWNlaXZlci5wcm90b3R5cGUgfHwgcmVjZWl2ZXI7XG4gIGN1LmNvcHkoYiwgYSwga2V5cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIHRoZSBzdGF0aWMgcHJvcGVydGllcyxcbiAqIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnMgZnJvbSB0aGUgYFBhcmVudGBcbiAqIGNvbnN0cnVjdG9yIG9udG8gYENoaWxkYCBjb25zdHJ1Y3RvcnMuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRlbmQgPSBjdS5leHRlbmQoUGFyZW50KTtcbiAqIFBhcmVudC5leHRlbmQoQ2hpbGQpO1xuICpcbiAqIC8vIG9wdGlvbmFsIG1ldGhvZHNcbiAqIFBhcmVudC5leHRlbmQoQ2hpbGQsIHtcbiAqICAgZm9vOiBmdW5jdGlvbigpIHt9LFxuICogICBiYXI6IGZ1bmN0aW9uKCkge31cbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgUGFyZW50YCBQYXJlbnQgY3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGV4dGVuZGAgT3B0aW9uYWwgZXh0ZW5kIGZ1bmN0aW9uIHRvIGhhbmRsZSBjdXN0b20gZXh0ZW5zaW9ucy4gVXNlZnVsIHdoZW4gdXBkYXRpbmcgbWV0aG9kcyB0aGF0IHJlcXVpcmUgYSBzcGVjaWZpYyBwcm90b3R5cGUuXG4gKiAgIEBwYXJhbSB7RnVuY3Rpb259IGBDaGlsZGAgQ2hpbGQgY3RvclxuICogICBAcGFyYW0ge09iamVjdH0gYHByb3RvYCBPcHRpb25hbGx5IHBhc3MgYWRkaXRpb25hbCBwcm90b3R5cGUgcHJvcGVydGllcyB0byBpbmhlcml0LlxuICogICBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1LmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAvLyBrZWVwIGl0IGxhenksIGluc3RlYWQgb2YgYXNzaWduaW5nIHRvIGBjdS5leHRlbmRgXG4gIHJldHVybiBzdGF0aWNFeHRlbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQnViYmxlIHVwIGV2ZW50cyBlbWl0dGVkIGZyb20gc3RhdGljIG1ldGhvZHMgb24gdGhlIFBhcmVudCBjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgUGFyZW50YFxuICogQHBhcmFtIHtBcnJheX0gYGV2ZW50c2AgRXZlbnQgbmFtZXMgdG8gYnViYmxlIHVwXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1LmJ1YmJsZSA9IGZ1bmN0aW9uKFBhcmVudCwgZXZlbnRzKSB7XG4gIGV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcbiAgUGFyZW50LmJ1YmJsZSA9IGZ1bmN0aW9uKENoaWxkLCBhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBldmVudHMgPSB1bmlvbihbXSwgZXZlbnRzLCBhcnIpO1xuICAgIH1cbiAgICB2YXIgbGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICB2YXIgbmFtZSA9IGV2ZW50c1tpZHhdO1xuICAgICAgUGFyZW50Lm9uKG5hbWUsIENoaWxkLmVtaXQuYmluZChDaGlsZCwgbmFtZSkpO1xuICAgIH1cbiAgICBjdS5idWJibGUoQ2hpbGQsIGV2ZW50cyk7XG4gIH07XG59O1xuIiwiLyohXG4gKiBkZWZpbmUtcHJvcGVydHkgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2RlZmluZS1wcm9wZXJ0eT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRGVzY3JpcHRvciA9IHJlcXVpcmUoJ2lzLWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHZhbCkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdCBvciBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBgcHJvcGAgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAoaXNEZXNjcmlwdG9yKHZhbCkgJiYgKCdzZXQnIGluIHZhbCB8fCAnZ2V0JyBpbiB2YWwpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHZhbCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JzsoZnVuY3Rpb24oayl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/ayhyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sayk6ayhDb2RlTWlycm9yKX0pKGZ1bmN0aW9uKGspe2Z1bmN0aW9uIHUoYSxkLGIpe3ZhciBlPWEuZ2V0TGluZUhhbmRsZShkLmxpbmUpLGM9ZC5jaC0xLGc9YiYmYi5hZnRlckN1cnNvcjtudWxsPT1nJiYoZz0vKF58ICljbS1mYXQtY3Vyc29yKCR8ICkvLnRlc3QoYS5nZXRXcmFwcGVyRWxlbWVudCgpLmNsYXNzTmFtZSkpO3ZhciBoPWImJmIuYnJhY2tldFJlZ2V4fHwvWygpe31bXFxdXS87ZT0hZyYmMDw9YyYmaC50ZXN0KGUudGV4dC5jaGFyQXQoYykpJiZ0W2UudGV4dC5jaGFyQXQoYyldfHxoLnRlc3QoZS50ZXh0LmNoYXJBdChjKzEpKSYmdFtlLnRleHQuY2hhckF0KCsrYyldO1xuaWYoIWUpcmV0dXJuIG51bGw7Zz1cIj5cIj09ZS5jaGFyQXQoMSk/MTotMTtpZihiJiZiLnN0cmljdCYmMDxnIT0oYz09ZC5jaCkpcmV0dXJuIG51bGw7aD1hLmdldFRva2VuVHlwZUF0KG4oZC5saW5lLGMrMSkpO2E9dihhLG4oZC5saW5lLGMrKDA8Zz8xOjApKSxnLGh8fG51bGwsYik7cmV0dXJuIG51bGw9PWE/bnVsbDp7ZnJvbTpuKGQubGluZSxjKSx0bzphJiZhLnBvcyxtYXRjaDphJiZhLmNoPT1lLmNoYXJBdCgwKSxmb3J3YXJkOjA8Z319ZnVuY3Rpb24gdihhLGQsYixlLGMpe3ZhciBnPWMmJmMubWF4U2NhbkxpbmVMZW5ndGh8fDFFNCxoPWMmJmMubWF4U2NhbkxpbmVzfHwxRTMsZj1bXTtjPWMmJmMuYnJhY2tldFJlZ2V4fHwvWygpe31bXFxdXS87aD0wPGI/TWF0aC5taW4oZC5saW5lK2gsYS5sYXN0TGluZSgpKzEpOk1hdGgubWF4KGEuZmlyc3RMaW5lKCktMSxkLmxpbmUtaCk7Zm9yKHZhciBsPWQubGluZTtsIT1oO2wrPWIpe3ZhciBtPWEuZ2V0TGluZShsKTtpZihtKXt2YXIgcD1cbjA8Yj8wOm0ubGVuZ3RoLTEseT0wPGI/bS5sZW5ndGg6LTE7aWYoIShtLmxlbmd0aD5nKSlmb3IobD09ZC5saW5lJiYocD1kLmNoLSgwPmI/MTowKSk7cCE9eTtwKz1iKXt2YXIgcT1tLmNoYXJBdChwKTtpZihjLnRlc3QocSkmJih2b2lkIDA9PT1lfHxhLmdldFRva2VuVHlwZUF0KG4obCxwKzEpKT09ZSkpe3ZhciB3PXRbcV07aWYodyYmXCI+XCI9PXcuY2hhckF0KDEpPT0wPGIpZi5wdXNoKHEpO2Vsc2UgaWYoZi5sZW5ndGgpZi5wb3AoKTtlbHNlIHJldHVybntwb3M6bihsLHApLGNoOnF9fX19fXJldHVybiBsLWI9PSgwPGI/YS5sYXN0TGluZSgpOmEuZmlyc3RMaW5lKCkpPyExOm51bGx9ZnVuY3Rpb24geChhLGQsYil7Zm9yKHZhciBlPWEuc3RhdGUubWF0Y2hCcmFja2V0cy5tYXhIaWdobGlnaHRMaW5lTGVuZ3RofHwxRTMsYz1bXSxnPWEubGlzdFNlbGVjdGlvbnMoKSxoPTA7aDxnLmxlbmd0aDtoKyspe3ZhciBmPWdbaF0uZW1wdHkoKSYmdShhLGdbaF0uaGVhZCxiKTtpZihmJiZhLmdldExpbmUoZi5mcm9tLmxpbmUpLmxlbmd0aDw9XG5lKXt2YXIgbD1mLm1hdGNoP1wiQ29kZU1pcnJvci1tYXRjaGluZ2JyYWNrZXRcIjpcIkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0XCI7Yy5wdXNoKGEubWFya1RleHQoZi5mcm9tLG4oZi5mcm9tLmxpbmUsZi5mcm9tLmNoKzEpLHtjbGFzc05hbWU6bH0pKTtmLnRvJiZhLmdldExpbmUoZi50by5saW5lKS5sZW5ndGg8PWUmJmMucHVzaChhLm1hcmtUZXh0KGYudG8sbihmLnRvLmxpbmUsZi50by5jaCsxKSx7Y2xhc3NOYW1lOmx9KSl9fWlmKGMubGVuZ3RoKWlmKHomJmEuc3RhdGUuZm9jdXNlZCYmYS5mb2N1cygpLGI9ZnVuY3Rpb24oKXthLm9wZXJhdGlvbihmdW5jdGlvbigpe2Zvcih2YXIgbT0wO208Yy5sZW5ndGg7bSsrKWNbbV0uY2xlYXIoKX0pfSxkKXNldFRpbWVvdXQoYiw4MDApO2Vsc2UgcmV0dXJuIGJ9ZnVuY3Rpb24gcihhKXthLm9wZXJhdGlvbihmdW5jdGlvbigpe2Euc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCYmKGEuc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCgpLFxuYS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkPW51bGwpO2Euc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZD14KGEsITEsYS5zdGF0ZS5tYXRjaEJyYWNrZXRzKX0pfXZhciB6PS9NU0lFIFxcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OD5kb2N1bWVudC5kb2N1bWVudE1vZGUpLG49ay5Qb3MsdD17XCIoXCI6XCIpPlwiLFwiKVwiOlwiKDxcIixcIltcIjpcIl0+XCIsXCJdXCI6XCJbPFwiLFwie1wiOlwifT5cIixcIn1cIjpcIns8XCIsXCI8XCI6XCI+PlwiLFwiPlwiOlwiPDxcIn07ay5kZWZpbmVPcHRpb24oXCJtYXRjaEJyYWNrZXRzXCIsITEsZnVuY3Rpb24oYSxkLGIpe2Z1bmN0aW9uIGUoYyl7Yy5zdGF0ZS5tYXRjaEJyYWNrZXRzJiZjLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQmJihjLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQoKSxjLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQ9XG5udWxsKX1iJiZiIT1rLkluaXQmJihhLm9mZihcImN1cnNvckFjdGl2aXR5XCIsciksYS5vZmYoXCJmb2N1c1wiLHIpLGEub2ZmKFwiYmx1clwiLGUpLGUoYSkpO2QmJihhLnN0YXRlLm1hdGNoQnJhY2tldHM9XCJvYmplY3RcIj09dHlwZW9mIGQ/ZDp7fSxhLm9uKFwiY3Vyc29yQWN0aXZpdHlcIixyKSxhLm9uKFwiZm9jdXNcIixyKSxhLm9uKFwiYmx1clwiLGUpKX0pO2suZGVmaW5lRXh0ZW5zaW9uKFwibWF0Y2hCcmFja2V0c1wiLGZ1bmN0aW9uKCl7eCh0aGlzLCEwKX0pO2suZGVmaW5lRXh0ZW5zaW9uKFwiZmluZE1hdGNoaW5nQnJhY2tldFwiLGZ1bmN0aW9uKGEsZCxiKXtpZihifHxcImJvb2xlYW5cIj09dHlwZW9mIGQpYj8oYi5zdHJpY3Q9ZCxkPWIpOmQ9ZD97c3RyaWN0OiEwfTpudWxsO3JldHVybiB1KHRoaXMsYSxkKX0pO2suZGVmaW5lRXh0ZW5zaW9uKFwic2NhbkZvckJyYWNrZXRcIixmdW5jdGlvbihhLGQsYixlKXtyZXR1cm4gdih0aGlzLGEsZCxiLGUpfSl9KTtcbiIsIid1c2Ugc3RyaWN0Jzt2YXIgJGpzY29tcD0kanNjb21wfHx7fTskanNjb21wLnNjb3BlPXt9OyRqc2NvbXAuZmluZEludGVybmFsPWZ1bmN0aW9uKHksRSxEKXt5IGluc3RhbmNlb2YgU3RyaW5nJiYoeT1TdHJpbmcoeSkpO2Zvcih2YXIgdj15Lmxlbmd0aCxLPTA7Szx2O0srKyl7dmFyIGthPXlbS107aWYoRS5jYWxsKEQsa2EsSyx5KSlyZXR1cm57aTpLLHY6a2F9fXJldHVybntpOi0xLHY6dm9pZCAwfX07JGpzY29tcC5BU1NVTUVfRVM1PSExOyRqc2NvbXAuQVNTVU1FX05PX05BVElWRV9NQVA9ITE7JGpzY29tcC5BU1NVTUVfTk9fTkFUSVZFX1NFVD0hMTskanNjb21wLlNJTVBMRV9GUk9VTkRfUE9MWUZJTEw9ITE7JGpzY29tcC5JU09MQVRFX1BPTFlGSUxMUz0hMTskanNjb21wLkZPUkNFX1BPTFlGSUxMX1BST01JU0U9ITE7JGpzY29tcC5FTkFCTEVfVU5IQU5ETEVEX1JFSkVDVElPTl9QT0xZRklMTD0hMDtcbiRqc2NvbXAuZGVmaW5lUHJvcGVydHk9JGpzY29tcC5BU1NVTUVfRVM1fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydGllcz9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oeSxFLEQpe2lmKHk9PUFycmF5LnByb3RvdHlwZXx8eT09T2JqZWN0LnByb3RvdHlwZSlyZXR1cm4geTt5W0VdPUQudmFsdWU7cmV0dXJuIHl9OyRqc2NvbXAuZ2V0R2xvYmFsPWZ1bmN0aW9uKHkpe3k9W1wib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzJiZnbG9iYWxUaGlzLHksXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93LFwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbF07Zm9yKHZhciBFPTA7RTx5Lmxlbmd0aDsrK0Upe3ZhciBEPXlbRV07aWYoRCYmRC5NYXRoPT1NYXRoKXJldHVybiBEfXRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgZ2xvYmFsIG9iamVjdFwiKTt9OyRqc2NvbXAuZ2xvYmFsPSRqc2NvbXAuZ2V0R2xvYmFsKHRoaXMpO1xuJGpzY29tcC5JU19TWU1CT0xfTkFUSVZFPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PT10eXBlb2YgU3ltYm9sKFwieFwiKTskanNjb21wLlRSVVNUX0VTNl9QT0xZRklMTFM9ISRqc2NvbXAuSVNPTEFURV9QT0xZRklMTFN8fCRqc2NvbXAuSVNfU1lNQk9MX05BVElWRTskanNjb21wLnBvbHlmaWxscz17fTskanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbD17fTskanNjb21wLlBPTFlGSUxMX1BSRUZJWD1cIiRqc2NwJFwiO3ZhciAkanNjb21wJGxvb2t1cFBvbHlmaWxsZWRWYWx1ZT1mdW5jdGlvbih5LEUpe3ZhciBEPSRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW0VdO2lmKG51bGw9PUQpcmV0dXJuIHlbRV07RD15W0RdO3JldHVybiB2b2lkIDAhPT1EP0Q6eVtFXX07XG4kanNjb21wLnBvbHlmaWxsPWZ1bmN0aW9uKHksRSxELHYpe0UmJigkanNjb21wLklTT0xBVEVfUE9MWUZJTExTPyRqc2NvbXAucG9seWZpbGxJc29sYXRlZCh5LEUsRCx2KTokanNjb21wLnBvbHlmaWxsVW5pc29sYXRlZCh5LEUsRCx2KSl9OyRqc2NvbXAucG9seWZpbGxVbmlzb2xhdGVkPWZ1bmN0aW9uKHksRSxELHYpe0Q9JGpzY29tcC5nbG9iYWw7eT15LnNwbGl0KFwiLlwiKTtmb3Iodj0wO3Y8eS5sZW5ndGgtMTt2Kyspe3ZhciBLPXlbdl07aWYoIShLIGluIEQpKXJldHVybjtEPURbS119eT15W3kubGVuZ3RoLTFdO3Y9RFt5XTtFPUUodik7RSE9diYmbnVsbCE9RSYmJGpzY29tcC5kZWZpbmVQcm9wZXJ0eShELHkse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpFfSl9O1xuJGpzY29tcC5wb2x5ZmlsbElzb2xhdGVkPWZ1bmN0aW9uKHksRSxELHYpe3ZhciBLPXkuc3BsaXQoXCIuXCIpO3k9MT09PUsubGVuZ3RoO3Y9S1swXTt2PSF5JiZ2IGluICRqc2NvbXAucG9seWZpbGxzPyRqc2NvbXAucG9seWZpbGxzOiRqc2NvbXAuZ2xvYmFsO2Zvcih2YXIga2E9MDtrYTxLLmxlbmd0aC0xO2thKyspe3ZhciB2YT1LW2thXTtpZighKHZhIGluIHYpKXJldHVybjt2PXZbdmFdfUs9S1tLLmxlbmd0aC0xXTtEPSRqc2NvbXAuSVNfU1lNQk9MX05BVElWRSYmXCJlczZcIj09PUQ/dltLXTpudWxsO0U9RShEKTtudWxsIT1FJiYoeT8kanNjb21wLmRlZmluZVByb3BlcnR5KCRqc2NvbXAucG9seWZpbGxzLEsse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpFfSk6RSE9PUQmJigkanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbFtLXT0kanNjb21wLklTX1NZTUJPTF9OQVRJVkU/JGpzY29tcC5nbG9iYWwuU3ltYm9sKEspOiRqc2NvbXAuUE9MWUZJTExfUFJFRklYK1xuSyxLPSRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW0tdLCRqc2NvbXAuZGVmaW5lUHJvcGVydHkodixLLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6RX0pKSl9OyRqc2NvbXAucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUuZmluZFwiLGZ1bmN0aW9uKHkpe3JldHVybiB5P3k6ZnVuY3Rpb24oRSxEKXtyZXR1cm4gJGpzY29tcC5maW5kSW50ZXJuYWwodGhpcyxFLEQpLnZ9fSxcImVzNlwiLFwiZXMzXCIpO1xuKGZ1bmN0aW9uKHksRSl7XCJvYmplY3RcIj09PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1FKCk6XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoRSk6KHk9eXx8c2VsZix5LkNvZGVNaXJyb3I9RSgpKX0pKHRoaXMsZnVuY3Rpb24oKXtmdW5jdGlvbiB5KGEpe3JldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIrYStcIig/OiR8XFxcXHMpXFxcXHMqXCIpfWZ1bmN0aW9uIEUoYSl7Zm9yKHZhciBiPWEuY2hpbGROb2Rlcy5sZW5ndGg7MDxiOy0tYilhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7cmV0dXJuIGF9ZnVuY3Rpb24gRChhLGIpe3JldHVybiBFKGEpLmFwcGVuZENoaWxkKGIpfWZ1bmN0aW9uIHYoYSxiLGQsYyl7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGEpO2QmJihhLmNsYXNzTmFtZT1kKTtjJiYoYS5zdHlsZS5jc3NUZXh0PWMpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKWEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYikpO1xuZWxzZSBpZihiKWZvcihkPTA7ZDxiLmxlbmd0aDsrK2QpYS5hcHBlbmRDaGlsZChiW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiBLKGEsYixkLGMpe2E9dihhLGIsZCxjKTthLnNldEF0dHJpYnV0ZShcInJvbGVcIixcInByZXNlbnRhdGlvblwiKTtyZXR1cm4gYX1mdW5jdGlvbiBrYShhLGIpezM9PWIubm9kZVR5cGUmJihiPWIucGFyZW50Tm9kZSk7aWYoYS5jb250YWlucylyZXR1cm4gYS5jb250YWlucyhiKTtkbyBpZigxMT09Yi5ub2RlVHlwZSYmKGI9Yi5ob3N0KSxiPT1hKXJldHVybiEwO3doaWxlKGI9Yi5wYXJlbnROb2RlKX1mdW5jdGlvbiB2YSgpe3RyeXt2YXIgYT1kb2N1bWVudC5hY3RpdmVFbGVtZW50fWNhdGNoKGIpe2E9ZG9jdW1lbnQuYm9keXx8bnVsbH1mb3IoO2EmJmEuc2hhZG93Um9vdCYmYS5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7KWE9YS5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7cmV0dXJuIGF9ZnVuY3Rpb24gV2EoYSxiKXt2YXIgZD1hLmNsYXNzTmFtZTt5KGIpLnRlc3QoZCl8fFxuKGEuY2xhc3NOYW1lKz0oZD9cIiBcIjpcIlwiKStiKX1mdW5jdGlvbiBjZChhLGIpe2E9YS5zcGxpdChcIiBcIik7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXSYmIXkoYVtkXSkudGVzdChiKSYmKGIrPVwiIFwiK2FbZF0pO3JldHVybiBifWZ1bmN0aW9uIGRkKGEpe3ZhciBiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShudWxsLGIpfX1mdW5jdGlvbiBYYShhLGIsZCl7Ynx8KGI9e30pO2Zvcih2YXIgYyBpbiBhKSFhLmhhc093blByb3BlcnR5KGMpfHwhMT09PWQmJmIuaGFzT3duUHJvcGVydHkoYyl8fChiW2NdPWFbY10pO3JldHVybiBifWZ1bmN0aW9uIHdhKGEsYixkLGMsZSl7bnVsbD09YiYmKGI9YS5zZWFyY2goL1teXFxzXFx1MDBhMF0vKSwtMT09YiYmKGI9YS5sZW5ndGgpKTtjPWN8fDA7Zm9yKGU9ZXx8MDs7KXt2YXIgZj1hLmluZGV4T2YoXCJcXHRcIixjKTtpZigwPmZ8fGY+PWIpcmV0dXJuIGUrKGItXG5jKTtlKz1mLWM7ZSs9ZC1lJWQ7Yz1mKzF9fWZ1bmN0aW9uIGVhKGEsYil7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDsrK2QpaWYoYVtkXT09YilyZXR1cm4gZDtyZXR1cm4tMX1mdW5jdGlvbiBlZChhLGIsZCl7Zm9yKHZhciBjPTAsZT0wOzspe3ZhciBmPWEuaW5kZXhPZihcIlxcdFwiLGMpOy0xPT1mJiYoZj1hLmxlbmd0aCk7dmFyIGc9Zi1jO2lmKGY9PWEubGVuZ3RofHxlK2c+PWIpcmV0dXJuIGMrTWF0aC5taW4oZyxiLWUpO2UrPWYtYztlKz1kLWUlZDtjPWYrMTtpZihlPj1iKXJldHVybiBjfX1mdW5jdGlvbiBmZChhKXtmb3IoO3VjLmxlbmd0aDw9YTspdWMucHVzaChMKHVjKStcIiBcIik7cmV0dXJuIHVjW2FdfWZ1bmN0aW9uIEwoYSl7cmV0dXJuIGFbYS5sZW5ndGgtMV19ZnVuY3Rpb24gdmMoYSxiKXtmb3IodmFyIGQ9W10sYz0wO2M8YS5sZW5ndGg7YysrKWRbY109YihhW2NdLGMpO3JldHVybiBkfWZ1bmN0aW9uIHdnKGEsYixkKXtmb3IodmFyIGM9MCxlPWQoYik7YzxhLmxlbmd0aCYmXG5kKGFbY10pPD1lOyljKys7YS5zcGxpY2UoYywwLGIpfWZ1bmN0aW9uIG1lKCl7fWZ1bmN0aW9uIG5lKGEsYil7T2JqZWN0LmNyZWF0ZT9hPU9iamVjdC5jcmVhdGUoYSk6KG1lLnByb3RvdHlwZT1hLGE9bmV3IG1lKTtiJiZYYShiLGEpO3JldHVybiBhfWZ1bmN0aW9uIGdkKGEpe3JldHVybi9cXHcvLnRlc3QoYSl8fFwiXFx1MDA4MFwiPGEmJihhLnRvVXBwZXJDYXNlKCkhPWEudG9Mb3dlckNhc2UoKXx8eGcudGVzdChhKSl9ZnVuY3Rpb24gd2MoYSxiKXtyZXR1cm4gYj8tMTxiLnNvdXJjZS5pbmRleE9mKFwiXFxcXHdcIikmJmdkKGEpPyEwOmIudGVzdChhKTpnZChhKX1mdW5jdGlvbiBvZShhKXtmb3IodmFyIGIgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGIpJiZhW2JdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGhkKGEpe3JldHVybiA3Njg8PWEuY2hhckNvZGVBdCgwKSYmeWcudGVzdChhKX1mdW5jdGlvbiBwZShhLGIsZCl7Zm9yKDsoMD5kPzA8YjpiPGEubGVuZ3RoKSYmaGQoYS5jaGFyQXQoYikpOyliKz1cbmQ7cmV0dXJuIGJ9ZnVuY3Rpb24gSGIoYSxiLGQpe2Zvcih2YXIgYz1iPmQ/LTE6MTs7KXtpZihiPT1kKXJldHVybiBiO3ZhciBlPShiK2QpLzI7ZT0wPmM/TWF0aC5jZWlsKGUpOk1hdGguZmxvb3IoZSk7aWYoZT09YilyZXR1cm4gYShlKT9iOmQ7YShlKT9kPWU6Yj1lK2N9fWZ1bmN0aW9uIHpnKGEsYixkLGMpe2lmKCFhKXJldHVybiBjKGIsZCxcImx0clwiLDApO2Zvcih2YXIgZT0hMSxmPTA7ZjxhLmxlbmd0aDsrK2Ype3ZhciBnPWFbZl07aWYoZy5mcm9tPGQmJmcudG8+Ynx8Yj09ZCYmZy50bz09YiljKE1hdGgubWF4KGcuZnJvbSxiKSxNYXRoLm1pbihnLnRvLGQpLDE9PWcubGV2ZWw/XCJydGxcIjpcImx0clwiLGYpLGU9ITB9ZXx8YyhiLGQsXCJsdHJcIil9ZnVuY3Rpb24gSWIoYSxiLGQpe3ZhciBjO0piPW51bGw7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoZi5mcm9tPGImJmYudG8+YilyZXR1cm4gZTtmLnRvPT1iJiYoZi5mcm9tIT1mLnRvJiZcImJlZm9yZVwiPT1cbmQ/Yz1lOkpiPWUpO2YuZnJvbT09YiYmKGYuZnJvbSE9Zi50byYmXCJiZWZvcmVcIiE9ZD9jPWU6SmI9ZSl9cmV0dXJuIG51bGwhPWM/YzpKYn1mdW5jdGlvbiBKYShhLGIpe3ZhciBkPWEub3JkZXI7bnVsbD09ZCYmKGQ9YS5vcmRlcj1BZyhhLnRleHQsYikpO3JldHVybiBkfWZ1bmN0aW9uIHJhKGEsYixkKXtpZihhLnJlbW92ZUV2ZW50TGlzdGVuZXIpYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsZCwhMSk7ZWxzZSBpZihhLmRldGFjaEV2ZW50KWEuZGV0YWNoRXZlbnQoXCJvblwiK2IsZCk7ZWxzZXt2YXIgYz0oYT1hLl9oYW5kbGVycykmJmFbYl07YyYmKGQ9ZWEoYyxkKSwtMTxkJiYoYVtiXT1jLnNsaWNlKDAsZCkuY29uY2F0KGMuc2xpY2UoZCsxKSkpKX19ZnVuY3Rpb24gWChhLGIpe3ZhciBkPWEuX2hhbmRsZXJzJiZhLl9oYW5kbGVyc1tiXXx8eGM7aWYoZC5sZW5ndGgpZm9yKHZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxlPTA7ZTxkLmxlbmd0aDsrK2UpZFtlXS5hcHBseShudWxsLFxuYyl9ZnVuY3Rpb24gWihhLGIsZCl7XCJzdHJpbmdcIj09dHlwZW9mIGImJihiPXt0eXBlOmIscHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITB9fSk7WChhLGR8fGIudHlwZSxhLGIpO3JldHVybiBpZChiKXx8Yi5jb2RlbWlycm9ySWdub3JlfWZ1bmN0aW9uIHFlKGEpe3ZhciBiPWEuX2hhbmRsZXJzJiZhLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtpZihiKXthPWEuY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc3x8KGEuY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycz1bXSk7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDsrK2QpLTE9PWVhKGEsYltkXSkmJmEucHVzaChiW2RdKX19ZnVuY3Rpb24geGEoYSxiKXtyZXR1cm4gMDwoYS5faGFuZGxlcnMmJmEuX2hhbmRsZXJzW2JdfHx4YykubGVuZ3RofWZ1bmN0aW9uIG5iKGEpe2EucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGIsZCl7eih0aGlzLGIsZCl9O2EucHJvdG90eXBlLm9mZj1mdW5jdGlvbihiLFxuZCl7cmEodGhpcyxiLGQpfX1mdW5jdGlvbiBsYShhKXthLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTphLnJldHVyblZhbHVlPSExfWZ1bmN0aW9uIHJlKGEpe2Euc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6YS5jYW5jZWxCdWJibGU9ITB9ZnVuY3Rpb24gaWQoYSl7cmV0dXJuIG51bGwhPWEuZGVmYXVsdFByZXZlbnRlZD9hLmRlZmF1bHRQcmV2ZW50ZWQ6MD09YS5yZXR1cm5WYWx1ZX1mdW5jdGlvbiBLYihhKXtsYShhKTtyZShhKX1mdW5jdGlvbiBzZShhKXt2YXIgYj1hLndoaWNoO251bGw9PWImJihhLmJ1dHRvbiYxP2I9MTphLmJ1dHRvbiYyP2I9MzphLmJ1dHRvbiY0JiYoYj0yKSk7eWEmJmEuY3RybEtleSYmMT09YiYmKGI9Myk7cmV0dXJuIGJ9ZnVuY3Rpb24gQmcoYSl7aWYobnVsbD09amQpe3ZhciBiPXYoXCJzcGFuXCIsXCJcXHUyMDBiXCIpO0QoYSx2KFwic3BhblwiLFtiLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTswIT1hLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0JiZcbihqZD0xPj1iLm9mZnNldFdpZHRoJiYyPGIub2Zmc2V0SGVpZ2h0JiYhKEcmJjg+VSkpfWE9amQ/dihcInNwYW5cIixcIlxcdTIwMGJcIik6dihcInNwYW5cIixcIlxcdTAwYTBcIixudWxsLFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcIik7YS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsXCJcIik7cmV0dXJuIGF9ZnVuY3Rpb24gQ2coYSxiKXsyPGFyZ3VtZW50cy5sZW5ndGgmJihiLmRlcGVuZGVuY2llcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpO2tkW2FdPWJ9ZnVuY3Rpb24geWMoYSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEmJm9iLmhhc093blByb3BlcnR5KGEpKWE9b2JbYV07ZWxzZSBpZihhJiZcInN0cmluZ1wiPT10eXBlb2YgYS5uYW1lJiZvYi5oYXNPd25Qcm9wZXJ0eShhLm5hbWUpKXt2YXIgYj1vYlthLm5hbWVdO1wic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj17bmFtZTpifSk7YT1uZShiLGEpO2EubmFtZT1iLm5hbWV9ZWxzZXtpZihcInN0cmluZ1wiPT1cbnR5cGVvZiBhJiYvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK3htbCQvLnRlc3QoYSkpcmV0dXJuIHljKFwiYXBwbGljYXRpb24veG1sXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiYvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK2pzb24kLy50ZXN0KGEpKXJldHVybiB5YyhcImFwcGxpY2F0aW9uL2pzb25cIil9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGE/e25hbWU6YX06YXx8e25hbWU6XCJudWxsXCJ9fWZ1bmN0aW9uIGxkKGEsYil7Yj15YyhiKTt2YXIgZD1rZFtiLm5hbWVdO2lmKCFkKXJldHVybiBsZChhLFwidGV4dC9wbGFpblwiKTthPWQoYSxiKTtpZihwYi5oYXNPd25Qcm9wZXJ0eShiLm5hbWUpKXtkPXBiW2IubmFtZV07Zm9yKHZhciBjIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShjKSYmKGEuaGFzT3duUHJvcGVydHkoYykmJihhW1wiX1wiK2NdPWFbY10pLGFbY109ZFtjXSl9YS5uYW1lPWIubmFtZTtiLmhlbHBlclR5cGUmJihhLmhlbHBlclR5cGU9Yi5oZWxwZXJUeXBlKTtpZihiLm1vZGVQcm9wcylmb3IodmFyIGUgaW4gYi5tb2RlUHJvcHMpYVtlXT1cbmIubW9kZVByb3BzW2VdO3JldHVybiBhfWZ1bmN0aW9uIERnKGEsYil7YT1wYi5oYXNPd25Qcm9wZXJ0eShhKT9wYlthXTpwYlthXT17fTtYYShiLGEpfWZ1bmN0aW9uIFlhKGEsYil7aWYoITA9PT1iKXJldHVybiBiO2lmKGEuY29weVN0YXRlKXJldHVybiBhLmNvcHlTdGF0ZShiKTthPXt9O2Zvcih2YXIgZCBpbiBiKXt2YXIgYz1iW2RdO2MgaW5zdGFuY2VvZiBBcnJheSYmKGM9Yy5jb25jYXQoW10pKTthW2RdPWN9cmV0dXJuIGF9ZnVuY3Rpb24gbWQoYSxiKXtmb3IodmFyIGQ7YS5pbm5lck1vZGU7KXtkPWEuaW5uZXJNb2RlKGIpO2lmKCFkfHxkLm1vZGU9PWEpYnJlYWs7Yj1kLnN0YXRlO2E9ZC5tb2RlfXJldHVybiBkfHx7bW9kZTphLHN0YXRlOmJ9fWZ1bmN0aW9uIHRlKGEsYixkKXtyZXR1cm4gYS5zdGFydFN0YXRlP2Euc3RhcnRTdGF0ZShiLGQpOiEwfWZ1bmN0aW9uIHcoYSxiKXtiLT1hLmZpcnN0O2lmKDA+Ynx8Yj49YS5zaXplKXRocm93IEVycm9yKFwiVGhlcmUgaXMgbm8gbGluZSBcIitcbihiK2EuZmlyc3QpK1wiIGluIHRoZSBkb2N1bWVudC5cIik7Zm9yKDshYS5saW5lczspZm9yKHZhciBkPTA7OysrZCl7dmFyIGM9YS5jaGlsZHJlbltkXSxlPWMuY2h1bmtTaXplKCk7aWYoYjxlKXthPWM7YnJlYWt9Yi09ZX1yZXR1cm4gYS5saW5lc1tiXX1mdW5jdGlvbiBaYShhLGIsZCl7dmFyIGM9W10sZT1iLmxpbmU7YS5pdGVyKGIubGluZSxkLmxpbmUrMSxmdW5jdGlvbihmKXtmPWYudGV4dDtlPT1kLmxpbmUmJihmPWYuc2xpY2UoMCxkLmNoKSk7ZT09Yi5saW5lJiYoZj1mLnNsaWNlKGIuY2gpKTtjLnB1c2goZik7KytlfSk7cmV0dXJuIGN9ZnVuY3Rpb24gbmQoYSxiLGQpe3ZhciBjPVtdO2EuaXRlcihiLGQsZnVuY3Rpb24oZSl7Yy5wdXNoKGUudGV4dCl9KTtyZXR1cm4gY31mdW5jdGlvbiBEYShhLGIpe2lmKGItPWEuaGVpZ2h0KWZvcig7YTthPWEucGFyZW50KWEuaGVpZ2h0Kz1ifWZ1bmN0aW9uIE8oYSl7aWYobnVsbD09YS5wYXJlbnQpcmV0dXJuIG51bGw7dmFyIGI9YS5wYXJlbnQ7XG5hPWVhKGIubGluZXMsYSk7Zm9yKHZhciBkPWIucGFyZW50O2Q7Yj1kLGQ9ZC5wYXJlbnQpZm9yKHZhciBjPTA7ZC5jaGlsZHJlbltjXSE9YjsrK2MpYSs9ZC5jaGlsZHJlbltjXS5jaHVua1NpemUoKTtyZXR1cm4gYStiLmZpcnN0fWZ1bmN0aW9uICRhKGEsYil7dmFyIGQ9YS5maXJzdDthOmRve2Zvcih2YXIgYz0wO2M8YS5jaGlsZHJlbi5sZW5ndGg7KytjKXt2YXIgZT1hLmNoaWxkcmVuW2NdLGY9ZS5oZWlnaHQ7aWYoYjxmKXthPWU7Y29udGludWUgYX1iLT1mO2QrPWUuY2h1bmtTaXplKCl9cmV0dXJuIGR9d2hpbGUoIWEubGluZXMpO2ZvcihjPTA7YzxhLmxpbmVzLmxlbmd0aDsrK2Mpe2U9YS5saW5lc1tjXS5oZWlnaHQ7aWYoYjxlKWJyZWFrO2ItPWV9cmV0dXJuIGQrY31mdW5jdGlvbiBMYihhLGIpe3JldHVybiBiPj1hLmZpcnN0JiZiPGEuZmlyc3QrYS5zaXplfWZ1bmN0aW9uIG9kKGEsYil7cmV0dXJuIFN0cmluZyhhLmxpbmVOdW1iZXJGb3JtYXR0ZXIoYithLmZpcnN0TGluZU51bWJlcikpfVxuZnVuY3Rpb24gdChhLGIsZCl7dm9pZCAwPT09ZCYmKGQ9bnVsbCk7aWYoISh0aGlzIGluc3RhbmNlb2YgdCkpcmV0dXJuIG5ldyB0KGEsYixkKTt0aGlzLmxpbmU9YTt0aGlzLmNoPWI7dGhpcy5zdGlja3k9ZH1mdW5jdGlvbiBCKGEsYil7cmV0dXJuIGEubGluZS1iLmxpbmV8fGEuY2gtYi5jaH1mdW5jdGlvbiBwZChhLGIpe3JldHVybiBhLnN0aWNreT09Yi5zdGlja3kmJjA9PUIoYSxiKX1mdW5jdGlvbiBxZChhKXtyZXR1cm4gdChhLmxpbmUsYS5jaCl9ZnVuY3Rpb24gemMoYSxiKXtyZXR1cm4gMD5CKGEsYik/YjphfWZ1bmN0aW9uIEFjKGEsYil7cmV0dXJuIDA+QihhLGIpP2E6Yn1mdW5jdGlvbiBDKGEsYil7aWYoYi5saW5lPGEuZmlyc3QpcmV0dXJuIHQoYS5maXJzdCwwKTt2YXIgZD1hLmZpcnN0K2Euc2l6ZS0xO2lmKGIubGluZT5kKXJldHVybiB0KGQsdyhhLGQpLnRleHQubGVuZ3RoKTthPXcoYSxiLmxpbmUpLnRleHQubGVuZ3RoO2Q9Yi5jaDtiPW51bGw9PWR8fGQ+YT90KGIubGluZSxcbmEpOjA+ZD90KGIubGluZSwwKTpiO3JldHVybiBifWZ1bmN0aW9uIHVlKGEsYil7Zm9yKHZhciBkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKylkW2NdPUMoYSxiW2NdKTtyZXR1cm4gZH1mdW5jdGlvbiB2ZShhLGIsZCxjKXt2YXIgZT1bYS5zdGF0ZS5tb2RlR2VuXSxmPXt9O3dlKGEsYi50ZXh0LGEuZG9jLm1vZGUsZCxmdW5jdGlvbihrLGwpe3JldHVybiBlLnB1c2goayxsKX0sZixjKTt2YXIgZz1kLnN0YXRlO2M9ZnVuY3Rpb24oayl7ZC5iYXNlVG9rZW5zPWU7dmFyIGw9YS5zdGF0ZS5vdmVybGF5c1trXSxtPTEscT0wO2Quc3RhdGU9ITA7d2UoYSxiLnRleHQsbC5tb2RlLGQsZnVuY3Rpb24obixwKXtmb3IodmFyIHI9bTtxPG47KXt2YXIgdT1lW21dO3U+biYmZS5zcGxpY2UobSwxLG4sZVttKzFdLHUpO20rPTI7cT1NYXRoLm1pbihuLHUpfWlmKHApaWYobC5vcGFxdWUpZS5zcGxpY2UocixtLXIsbixcIm92ZXJsYXkgXCIrcCksbT1yKzI7ZWxzZSBmb3IoO3I8bTtyKz0yKW49ZVtyKzFdLFxuZVtyKzFdPShuP24rXCIgXCI6XCJcIikrXCJvdmVybGF5IFwiK3B9LGYpO2Quc3RhdGU9ZztkLmJhc2VUb2tlbnM9bnVsbDtkLmJhc2VUb2tlblBvcz0xfTtmb3IodmFyIGg9MDtoPGEuc3RhdGUub3ZlcmxheXMubGVuZ3RoOysraCljKGgpO3JldHVybntzdHlsZXM6ZSxjbGFzc2VzOmYuYmdDbGFzc3x8Zi50ZXh0Q2xhc3M/ZjpudWxsfX1mdW5jdGlvbiB4ZShhLGIsZCl7aWYoIWIuc3R5bGVzfHxiLnN0eWxlc1swXSE9YS5zdGF0ZS5tb2RlR2VuKXt2YXIgYz1NYihhLE8oYikpLGU9Yi50ZXh0Lmxlbmd0aD5hLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoJiZZYShhLmRvYy5tb2RlLGMuc3RhdGUpLGY9dmUoYSxiLGMpO2UmJihjLnN0YXRlPWUpO2Iuc3RhdGVBZnRlcj1jLnNhdmUoIWUpO2Iuc3R5bGVzPWYuc3R5bGVzO2YuY2xhc3Nlcz9iLnN0eWxlQ2xhc3Nlcz1mLmNsYXNzZXM6Yi5zdHlsZUNsYXNzZXMmJihiLnN0eWxlQ2xhc3Nlcz1udWxsKTtkPT09YS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXImJlxuKGEuZG9jLm1vZGVGcm9udGllcj1NYXRoLm1heChhLmRvYy5tb2RlRnJvbnRpZXIsKythLmRvYy5oaWdobGlnaHRGcm9udGllcikpfXJldHVybiBiLnN0eWxlc31mdW5jdGlvbiBNYihhLGIsZCl7dmFyIGM9YS5kb2MsZT1hLmRpc3BsYXk7aWYoIWMubW9kZS5zdGFydFN0YXRlKXJldHVybiBuZXcgRWEoYywhMCxiKTt2YXIgZj1FZyhhLGIsZCksZz1mPmMuZmlyc3QmJncoYyxmLTEpLnN0YXRlQWZ0ZXIsaD1nP0VhLmZyb21TYXZlZChjLGcsZik6bmV3IEVhKGMsdGUoYy5tb2RlKSxmKTtjLml0ZXIoZixiLGZ1bmN0aW9uKGspe3JkKGEsay50ZXh0LGgpO3ZhciBsPWgubGluZTtrLnN0YXRlQWZ0ZXI9bD09Yi0xfHwwPT1sJTV8fGw+PWUudmlld0Zyb20mJmw8ZS52aWV3VG8/aC5zYXZlKCk6bnVsbDtoLm5leHRMaW5lKCl9KTtkJiYoYy5tb2RlRnJvbnRpZXI9aC5saW5lKTtyZXR1cm4gaH1mdW5jdGlvbiByZChhLGIsZCxjKXt2YXIgZT1hLmRvYy5tb2RlO2E9bmV3IFkoYixhLm9wdGlvbnMudGFiU2l6ZSxcbmQpO2Euc3RhcnQ9YS5wb3M9Y3x8MDtmb3IoXCJcIj09YiYmeWUoZSxkLnN0YXRlKTshYS5lb2woKTspc2QoZSxhLGQuc3RhdGUpLGEuc3RhcnQ9YS5wb3N9ZnVuY3Rpb24geWUoYSxiKXtpZihhLmJsYW5rTGluZSlyZXR1cm4gYS5ibGFua0xpbmUoYik7aWYoYS5pbm5lck1vZGUmJihhPW1kKGEsYiksYS5tb2RlLmJsYW5rTGluZSkpcmV0dXJuIGEubW9kZS5ibGFua0xpbmUoYS5zdGF0ZSl9ZnVuY3Rpb24gc2QoYSxiLGQsYyl7Zm9yKHZhciBlPTA7MTA+ZTtlKyspe2MmJihjWzBdPW1kKGEsZCkubW9kZSk7dmFyIGY9YS50b2tlbihiLGQpO2lmKGIucG9zPmIuc3RhcnQpcmV0dXJuIGZ9dGhyb3cgRXJyb3IoXCJNb2RlIFwiK2EubmFtZStcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO31mdW5jdGlvbiB6ZShhLGIsZCxjKXt2YXIgZT1hLmRvYyxmPWUubW9kZTtiPUMoZSxiKTt2YXIgZz13KGUsYi5saW5lKTtkPU1iKGEsYi5saW5lLGQpO2E9bmV3IFkoZy50ZXh0LGEub3B0aW9ucy50YWJTaXplLFxuZCk7dmFyIGg7Zm9yKGMmJihoPVtdKTsoY3x8YS5wb3M8Yi5jaCkmJiFhLmVvbCgpOyl7YS5zdGFydD1hLnBvczt2YXIgaz1zZChmLGEsZC5zdGF0ZSk7YyYmaC5wdXNoKG5ldyBBZShhLGssWWEoZS5tb2RlLGQuc3RhdGUpKSl9cmV0dXJuIGM/aDpuZXcgQWUoYSxrLGQuc3RhdGUpfWZ1bmN0aW9uIEJlKGEsYil7aWYoYSlmb3IoOzspe3ZhciBkPWEubWF0Y2goLyg/Ol58XFxzKylsaW5lLShiYWNrZ3JvdW5kLSk/KFxcUyspLyk7aWYoIWQpYnJlYWs7YT1hLnNsaWNlKDAsZC5pbmRleCkrYS5zbGljZShkLmluZGV4K2RbMF0ubGVuZ3RoKTt2YXIgYz1kWzFdP1wiYmdDbGFzc1wiOlwidGV4dENsYXNzXCI7bnVsbD09YltjXT9iW2NdPWRbMl06KG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiK2RbMl0rXCIoPzokfFxcXFxzKVwiKSkudGVzdChiW2NdKXx8KGJbY10rPVwiIFwiK2RbMl0pfXJldHVybiBhfWZ1bmN0aW9uIHdlKGEsYixkLGMsZSxmLGcpe3ZhciBoPWQuZmxhdHRlblNwYW5zO251bGw9PWgmJihoPWEub3B0aW9ucy5mbGF0dGVuU3BhbnMpO1xudmFyIGs9MCxsPW51bGwsbT1uZXcgWShiLGEub3B0aW9ucy50YWJTaXplLGMpLHE9YS5vcHRpb25zLmFkZE1vZGVDbGFzcyYmW251bGxdO2ZvcihcIlwiPT1iJiZCZSh5ZShkLGMuc3RhdGUpLGYpOyFtLmVvbCgpOyl7aWYobS5wb3M+YS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCl7aD0hMTtnJiZyZChhLGIsYyxtLnBvcyk7bS5wb3M9Yi5sZW5ndGg7dmFyIG49bnVsbH1lbHNlIG49QmUoc2QoZCxtLGMuc3RhdGUscSksZik7aWYocSl7dmFyIHA9cVswXS5uYW1lO3AmJihuPVwibS1cIisobj9wK1wiIFwiK246cCkpfWlmKCFofHxsIT1uKXtmb3IoO2s8bS5zdGFydDspaz1NYXRoLm1pbihtLnN0YXJ0LGsrNUUzKSxlKGssbCk7bD1ufW0uc3RhcnQ9bS5wb3N9Zm9yKDtrPG0ucG9zOylhPU1hdGgubWluKG0ucG9zLGsrNUUzKSxlKGEsbCksaz1hfWZ1bmN0aW9uIEVnKGEsYixkKXtmb3IodmFyIGMsZSxmPWEuZG9jLGc9ZD8tMTpiLShhLmRvYy5tb2RlLmlubmVyTW9kZT8xRTM6MTAwKTtiPmc7LS1iKXtpZihiPD1cbmYuZmlyc3QpcmV0dXJuIGYuZmlyc3Q7dmFyIGg9dyhmLGItMSksaz1oLnN0YXRlQWZ0ZXI7aWYoayYmKCFkfHxiKyhrIGluc3RhbmNlb2YgQmM/ay5sb29rQWhlYWQ6MCk8PWYubW9kZUZyb250aWVyKSlyZXR1cm4gYjtoPXdhKGgudGV4dCxudWxsLGEub3B0aW9ucy50YWJTaXplKTtpZihudWxsPT1lfHxjPmgpZT1iLTEsYz1ofXJldHVybiBlfWZ1bmN0aW9uIEZnKGEsYil7YS5tb2RlRnJvbnRpZXI9TWF0aC5taW4oYS5tb2RlRnJvbnRpZXIsYik7aWYoIShhLmhpZ2hsaWdodEZyb250aWVyPGItMTApKXtmb3IodmFyIGQ9YS5maXJzdCxjPWItMTtjPmQ7Yy0tKXt2YXIgZT13KGEsYykuc3RhdGVBZnRlcjtpZihlJiYoIShlIGluc3RhbmNlb2YgQmMpfHxjK2UubG9va0FoZWFkPGIpKXtkPWMrMTticmVha319YS5oaWdobGlnaHRGcm9udGllcj1NYXRoLm1pbihhLmhpZ2hsaWdodEZyb250aWVyLGQpfX1mdW5jdGlvbiBDYyhhLGIsZCl7dGhpcy5tYXJrZXI9YTt0aGlzLmZyb209Yjt0aGlzLnRvPVxuZH1mdW5jdGlvbiBOYihhLGIpe2lmKGEpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDsrK2Qpe3ZhciBjPWFbZF07aWYoYy5tYXJrZXI9PWIpcmV0dXJuIGN9fWZ1bmN0aW9uIHRkKGEsYil7aWYoYi5mdWxsKXJldHVybiBudWxsO3ZhciBkPUxiKGEsYi5mcm9tLmxpbmUpJiZ3KGEsYi5mcm9tLmxpbmUpLm1hcmtlZFNwYW5zLGM9TGIoYSxiLnRvLmxpbmUpJiZ3KGEsYi50by5saW5lKS5tYXJrZWRTcGFucztpZighZCYmIWMpcmV0dXJuIG51bGw7YT1iLmZyb20uY2g7dmFyIGU9Yi50by5jaCxmPTA9PUIoYi5mcm9tLGIudG8pLGc7aWYoZClmb3IodmFyIGg9MDtoPGQubGVuZ3RoOysraCl7dmFyIGs9ZFtoXSxsPWsubWFya2VyO2lmKG51bGw9PWsuZnJvbXx8KGwuaW5jbHVzaXZlTGVmdD9rLmZyb208PWE6ay5mcm9tPGEpfHwhKGsuZnJvbSE9YXx8XCJib29rbWFya1wiIT1sLnR5cGV8fGYmJmsubWFya2VyLmluc2VydExlZnQpKXt2YXIgbT1udWxsPT1rLnRvfHwobC5pbmNsdXNpdmVSaWdodD9cbmsudG8+PWE6ay50bz5hKTsoZ3x8KGc9W10pKS5wdXNoKG5ldyBDYyhsLGsuZnJvbSxtP251bGw6ay50bykpfX1kPWc7dmFyIHE7aWYoYylmb3IoZz0wO2c8Yy5sZW5ndGg7KytnKWlmKGg9Y1tnXSxrPWgubWFya2VyLG51bGw9PWgudG98fChrLmluY2x1c2l2ZVJpZ2h0P2gudG8+PWU6aC50bz5lKXx8aC5mcm9tPT1lJiZcImJvb2ttYXJrXCI9PWsudHlwZSYmKCFmfHxoLm1hcmtlci5pbnNlcnRMZWZ0KSlsPW51bGw9PWguZnJvbXx8KGsuaW5jbHVzaXZlTGVmdD9oLmZyb208PWU6aC5mcm9tPGUpLChxfHwocT1bXSkpLnB1c2gobmV3IENjKGssbD9udWxsOmguZnJvbS1lLG51bGw9PWgudG8/bnVsbDpoLnRvLWUpKTtjPTE9PWIudGV4dC5sZW5ndGg7ZT1MKGIudGV4dCkubGVuZ3RoKyhjP2E6MCk7aWYoZClmb3IoZj0wO2Y8ZC5sZW5ndGg7KytmKWlmKGc9ZFtmXSxudWxsPT1nLnRvKShoPU5iKHEsZy5tYXJrZXIpLGgpP2MmJihnLnRvPW51bGw9PWgudG8/bnVsbDpoLnRvK2UpOmcudG89XG5hO2lmKHEpZm9yKGE9MDthPHEubGVuZ3RoOysrYSlmPXFbYV0sbnVsbCE9Zi50byYmKGYudG8rPWUpLG51bGw9PWYuZnJvbT9OYihkLGYubWFya2VyKXx8KGYuZnJvbT1lLGMmJihkfHwoZD1bXSkpLnB1c2goZikpOihmLmZyb20rPWUsYyYmKGR8fChkPVtdKSkucHVzaChmKSk7ZCYmKGQ9Q2UoZCkpO3EmJnEhPWQmJihxPUNlKHEpKTthPVtkXTtpZighYyl7Yj1iLnRleHQubGVuZ3RoLTI7dmFyIG47aWYoMDxiJiZkKWZvcihjPTA7YzxkLmxlbmd0aDsrK2MpbnVsbD09ZFtjXS50byYmKG58fChuPVtdKSkucHVzaChuZXcgQ2MoZFtjXS5tYXJrZXIsbnVsbCxudWxsKSk7Zm9yKGQ9MDtkPGI7KytkKWEucHVzaChuKTthLnB1c2gocSl9cmV0dXJuIGF9ZnVuY3Rpb24gQ2UoYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDsrK2Ipe3ZhciBkPWFbYl07bnVsbCE9ZC5mcm9tJiZkLmZyb209PWQudG8mJiExIT09ZC5tYXJrZXIuY2xlYXJXaGVuRW1wdHkmJmEuc3BsaWNlKGItLSwxKX1yZXR1cm4gYS5sZW5ndGg/XG5hOm51bGx9ZnVuY3Rpb24gR2coYSxiLGQpe3ZhciBjPW51bGw7YS5pdGVyKGIubGluZSxkLmxpbmUrMSxmdW5jdGlvbihtKXtpZihtLm1hcmtlZFNwYW5zKWZvcih2YXIgcT0wO3E8bS5tYXJrZWRTcGFucy5sZW5ndGg7KytxKXt2YXIgbj1tLm1hcmtlZFNwYW5zW3FdLm1hcmtlcjshbi5yZWFkT25seXx8YyYmLTEhPWVhKGMsbil8fChjfHwoYz1bXSkpLnB1c2gobil9fSk7aWYoIWMpcmV0dXJuIG51bGw7YT1be2Zyb206Yix0bzpkfV07Zm9yKGI9MDtiPGMubGVuZ3RoOysrYil7ZD1jW2JdO2Zvcih2YXIgZT1kLmZpbmQoMCksZj0wO2Y8YS5sZW5ndGg7KytmKXt2YXIgZz1hW2ZdO2lmKCEoMD5CKGcudG8sZS5mcm9tKXx8MDxCKGcuZnJvbSxlLnRvKSkpe3ZhciBoPVtmLDFdLGs9QihnLmZyb20sZS5mcm9tKSxsPUIoZy50byxlLnRvKTsoMD5rfHwhZC5pbmNsdXNpdmVMZWZ0JiYhaykmJmgucHVzaCh7ZnJvbTpnLmZyb20sdG86ZS5mcm9tfSk7KDA8bHx8IWQuaW5jbHVzaXZlUmlnaHQmJlxuIWwpJiZoLnB1c2goe2Zyb206ZS50byx0bzpnLnRvfSk7YS5zcGxpY2UuYXBwbHkoYSxoKTtmKz1oLmxlbmd0aC0zfX19cmV0dXJuIGF9ZnVuY3Rpb24gRGUoYSl7dmFyIGI9YS5tYXJrZWRTcGFucztpZihiKXtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoOysrZCliW2RdLm1hcmtlci5kZXRhY2hMaW5lKGEpO2EubWFya2VkU3BhbnM9bnVsbH19ZnVuY3Rpb24gRWUoYSxiKXtpZihiKXtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoOysrZCliW2RdLm1hcmtlci5hdHRhY2hMaW5lKGEpO2EubWFya2VkU3BhbnM9Yn19ZnVuY3Rpb24gdWQoYSxiKXt2YXIgZD1hLmxpbmVzLmxlbmd0aC1iLmxpbmVzLmxlbmd0aDtpZigwIT1kKXJldHVybiBkO2Q9YS5maW5kKCk7dmFyIGM9Yi5maW5kKCksZT1CKGQuZnJvbSxjLmZyb20pfHwoYS5pbmNsdXNpdmVMZWZ0Py0xOjApLShiLmluY2x1c2l2ZUxlZnQ/LTE6MCk7cmV0dXJuIGU/LWU6KGQ9QihkLnRvLGMudG8pfHwoYS5pbmNsdXNpdmVSaWdodD8xOjApLShiLmluY2x1c2l2ZVJpZ2h0P1xuMTowKSk/ZDpiLmlkLWEuaWR9ZnVuY3Rpb24gcWIoYSxiKXthPUthJiZhLm1hcmtlZFNwYW5zO2lmKGEpZm9yKHZhciBkLGM9MDtjPGEubGVuZ3RoOysrYylpZihkPWFbY10sZC5tYXJrZXIuY29sbGFwc2VkJiZudWxsPT0oYj9kLmZyb206ZC50bykmJighZXx8MD51ZChlLGQubWFya2VyKSkpdmFyIGU9ZC5tYXJrZXI7cmV0dXJuIGV9ZnVuY3Rpb24gRmUoYSxiLGQsYyxlKXthPXcoYSxiKTtpZihhPUthJiZhLm1hcmtlZFNwYW5zKWZvcihiPTA7YjxhLmxlbmd0aDsrK2Ipe3ZhciBmPWFbYl07aWYoZi5tYXJrZXIuY29sbGFwc2VkKXt2YXIgZz1mLm1hcmtlci5maW5kKDApLGg9QihnLmZyb20sZCl8fChmLm1hcmtlci5pbmNsdXNpdmVMZWZ0Py0xOjApLShlLmluY2x1c2l2ZUxlZnQ/LTE6MCksaz1CKGcudG8sYyl8fChmLm1hcmtlci5pbmNsdXNpdmVSaWdodD8xOjApLShlLmluY2x1c2l2ZVJpZ2h0PzE6MCk7aWYoISgwPD1oJiYwPj1rfHwwPj1oJiYwPD1rKSYmKDA+PWgmJihmLm1hcmtlci5pbmNsdXNpdmVSaWdodCYmXG5lLmluY2x1c2l2ZUxlZnQ/MDw9QihnLnRvLGQpOjA8QihnLnRvLGQpKXx8MDw9aCYmKGYubWFya2VyLmluY2x1c2l2ZVJpZ2h0JiZlLmluY2x1c2l2ZUxlZnQ/MD49QihnLmZyb20sYyk6MD5CKGcuZnJvbSxjKSkpKXJldHVybiEwfX19ZnVuY3Rpb24gRmEoYSl7Zm9yKHZhciBiO2I9cWIoYSwhMCk7KWE9Yi5maW5kKC0xLCEwKS5saW5lO3JldHVybiBhfWZ1bmN0aW9uIHZkKGEsYil7YT13KGEsYik7dmFyIGQ9RmEoYSk7cmV0dXJuIGE9PWQ/YjpPKGQpfWZ1bmN0aW9uIEdlKGEsYil7aWYoYj5hLmxhc3RMaW5lKCkpcmV0dXJuIGI7dmFyIGQ9dyhhLGIpO2lmKCFPYShhLGQpKXJldHVybiBiO2Zvcig7YT1xYihkLCExKTspZD1hLmZpbmQoMSwhMCkubGluZTtyZXR1cm4gTyhkKSsxfWZ1bmN0aW9uIE9hKGEsYil7dmFyIGQ9S2EmJmIubWFya2VkU3BhbnM7aWYoZClmb3IodmFyIGMsZT0wO2U8ZC5sZW5ndGg7KytlKWlmKGM9ZFtlXSxjLm1hcmtlci5jb2xsYXBzZWQmJihudWxsPT1jLmZyb218fFxuIWMubWFya2VyLndpZGdldE5vZGUmJjA9PWMuZnJvbSYmYy5tYXJrZXIuaW5jbHVzaXZlTGVmdCYmd2QoYSxiLGMpKSlyZXR1cm4hMH1mdW5jdGlvbiB3ZChhLGIsZCl7aWYobnVsbD09ZC50bylyZXR1cm4gYj1kLm1hcmtlci5maW5kKDEsITApLHdkKGEsYi5saW5lLE5iKGIubGluZS5tYXJrZWRTcGFucyxkLm1hcmtlcikpO2lmKGQubWFya2VyLmluY2x1c2l2ZVJpZ2h0JiZkLnRvPT1iLnRleHQubGVuZ3RoKXJldHVybiEwO2Zvcih2YXIgYyxlPTA7ZTxiLm1hcmtlZFNwYW5zLmxlbmd0aDsrK2UpaWYoYz1iLm1hcmtlZFNwYW5zW2VdLGMubWFya2VyLmNvbGxhcHNlZCYmIWMubWFya2VyLndpZGdldE5vZGUmJmMuZnJvbT09ZC50byYmKG51bGw9PWMudG98fGMudG8hPWQuZnJvbSkmJihjLm1hcmtlci5pbmNsdXNpdmVMZWZ0fHxkLm1hcmtlci5pbmNsdXNpdmVSaWdodCkmJndkKGEsYixjKSlyZXR1cm4hMH1mdW5jdGlvbiBHYShhKXthPUZhKGEpO2Zvcih2YXIgYj0wLGQ9YS5wYXJlbnQsXG5jPTA7YzxkLmxpbmVzLmxlbmd0aDsrK2Mpe3ZhciBlPWQubGluZXNbY107aWYoZT09YSlicmVhaztlbHNlIGIrPWUuaGVpZ2h0fWZvcihhPWQucGFyZW50O2E7ZD1hLGE9ZC5wYXJlbnQpZm9yKGM9MDtjPGEuY2hpbGRyZW4ubGVuZ3RoJiYoZT1hLmNoaWxkcmVuW2NdLGUhPWQpOysrYyliKz1lLmhlaWdodDtyZXR1cm4gYn1mdW5jdGlvbiBEYyhhKXtpZigwPT1hLmhlaWdodClyZXR1cm4gMDtmb3IodmFyIGI9YS50ZXh0Lmxlbmd0aCxkLGM9YTtkPXFiKGMsITApOylkPWQuZmluZCgwLCEwKSxjPWQuZnJvbS5saW5lLGIrPWQuZnJvbS5jaC1kLnRvLmNoO2ZvcihjPWE7ZD1xYihjLCExKTspYT1kLmZpbmQoMCwhMCksYi09Yy50ZXh0Lmxlbmd0aC1hLmZyb20uY2gsYz1hLnRvLmxpbmUsYis9Yy50ZXh0Lmxlbmd0aC1hLnRvLmNoO3JldHVybiBifWZ1bmN0aW9uIHhkKGEpe3ZhciBiPWEuZGlzcGxheTthPWEuZG9jO2IubWF4TGluZT13KGEsYS5maXJzdCk7Yi5tYXhMaW5lTGVuZ3RoPURjKGIubWF4TGluZSk7XG5iLm1heExpbmVDaGFuZ2VkPSEwO2EuaXRlcihmdW5jdGlvbihkKXt2YXIgYz1EYyhkKTtjPmIubWF4TGluZUxlbmd0aCYmKGIubWF4TGluZUxlbmd0aD1jLGIubWF4TGluZT1kKX0pfWZ1bmN0aW9uIEhlKGEsYil7aWYoIWF8fC9eXFxzKiQvLnRlc3QoYSkpcmV0dXJuIG51bGw7Yj1iLmFkZE1vZGVDbGFzcz9IZzpJZztyZXR1cm4gYlthXXx8KGJbYV09YS5yZXBsYWNlKC9cXFMrL2csXCJjbS0kJlwiKSl9ZnVuY3Rpb24gSWUoYSxiKXt2YXIgZD1LKFwic3BhblwiLG51bGwsbnVsbCxmYT9cInBhZGRpbmctcmlnaHQ6IC4xcHhcIjpudWxsKTtkPXtwcmU6SyhcInByZVwiLFtkXSxcIkNvZGVNaXJyb3ItbGluZVwiKSxjb250ZW50OmQsY29sOjAscG9zOjAsY206YSx0cmFpbGluZ1NwYWNlOiExLHNwbGl0U3BhY2VzOmEuZ2V0T3B0aW9uKFwibGluZVdyYXBwaW5nXCIpfTtiLm1lYXN1cmU9e307Zm9yKHZhciBjPTA7Yzw9KGIucmVzdD9iLnJlc3QubGVuZ3RoOjApO2MrKyl7dmFyIGU9Yz9iLnJlc3RbYy0xXTpiLmxpbmUsXG5mPXZvaWQgMDtkLnBvcz0wO2QuYWRkVG9rZW49Smc7dmFyIGc9YS5kaXNwbGF5Lm1lYXN1cmU7aWYobnVsbCE9eWQpZz15ZDtlbHNle3ZhciBoPUQoZyxkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSksaz1PYihoLDAsMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aD1PYihoLDEsMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7RShnKTtnPWsmJmsubGVmdCE9ay5yaWdodD95ZD0zPmgucmlnaHQtay5yaWdodDohMX1nJiYoZj1KYShlLGEuZG9jLmRpcmVjdGlvbikpJiYoZC5hZGRUb2tlbj1LZyhkLmFkZFRva2VuLGYpKTtkLm1hcD1bXTt2YXIgbD1iIT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCYmTyhlKTthOnt2YXIgbT1oPWs9Zz12b2lkIDAscT12b2lkIDAsbj12b2lkIDAscD12b2lkIDA7Zj1kO2w9eGUoYSxlLGwpO3ZhciByPWUubWFya2VkU3BhbnMsdT1lLnRleHQsQT0wO2lmKHIpZm9yKHZhciBIPXUubGVuZ3RoLHg9MCxRPTEsTT1cIlwiLFI9MDs7KXtpZihSPT1cbngpe3E9bT1oPW49XCJcIjtrPWc9bnVsbDtSPUluZmluaXR5O2Zvcih2YXIgVD1bXSxGPXZvaWQgMCxTPTA7UzxyLmxlbmd0aDsrK1Mpe3ZhciBJPXJbU10sTj1JLm1hcmtlcjtpZihcImJvb2ttYXJrXCI9PU4udHlwZSYmSS5mcm9tPT14JiZOLndpZGdldE5vZGUpVC5wdXNoKE4pO2Vsc2UgaWYoSS5mcm9tPD14JiYobnVsbD09SS50b3x8SS50bz54fHxOLmNvbGxhcHNlZCYmSS50bz09eCYmSS5mcm9tPT14KSl7bnVsbCE9SS50byYmSS50byE9eCYmUj5JLnRvJiYoUj1JLnRvLG09XCJcIik7Ti5jbGFzc05hbWUmJihxKz1cIiBcIitOLmNsYXNzTmFtZSk7Ti5jc3MmJihuPShuP24rXCI7XCI6XCJcIikrTi5jc3MpO04uc3RhcnRTdHlsZSYmSS5mcm9tPT14JiYoaCs9XCIgXCIrTi5zdGFydFN0eWxlKTtOLmVuZFN0eWxlJiZJLnRvPT1SJiYoRnx8KEY9W10pKS5wdXNoKE4uZW5kU3R5bGUsSS50byk7Ti50aXRsZSYmKChnfHwoZz17fSkpLnRpdGxlPU4udGl0bGUpO2lmKE4uYXR0cmlidXRlcylmb3IodmFyIGhhIGluIE4uYXR0cmlidXRlcykoZ3x8XG4oZz17fSkpW2hhXT1OLmF0dHJpYnV0ZXNbaGFdO04uY29sbGFwc2VkJiYoIWt8fDA+dWQoay5tYXJrZXIsTikpJiYoaz1JKX1lbHNlIEkuZnJvbT54JiZSPkkuZnJvbSYmKFI9SS5mcm9tKX1pZihGKWZvcihTPTA7UzxGLmxlbmd0aDtTKz0yKUZbUysxXT09UiYmKG0rPVwiIFwiK0ZbU10pO2lmKCFrfHxrLmZyb209PXgpZm9yKEY9MDtGPFQubGVuZ3RoOysrRilKZShmLDAsVFtGXSk7aWYoayYmKGsuZnJvbXx8MCk9PXgpe0plKGYsKG51bGw9PWsudG8/SCsxOmsudG8pLXgsay5tYXJrZXIsbnVsbD09ay5mcm9tKTtpZihudWxsPT1rLnRvKWJyZWFrIGE7ay50bz09eCYmKGs9ITEpfX1pZih4Pj1IKWJyZWFrO2ZvcihUPU1hdGgubWluKEgsUik7Oyl7aWYoTSl7Rj14K00ubGVuZ3RoO2t8fChTPUY+VD9NLnNsaWNlKDAsVC14KTpNLGYuYWRkVG9rZW4oZixTLHA/cCtxOnEsaCx4K1MubGVuZ3RoPT1SP206XCJcIixuLGcpKTtpZihGPj1UKXtNPU0uc2xpY2UoVC14KTt4PVQ7YnJlYWt9eD1GO2g9XG5cIlwifU09dS5zbGljZShBLEE9bFtRKytdKTtwPUhlKGxbUSsrXSxmLmNtLm9wdGlvbnMpfX1lbHNlIGZvcihnPTE7ZzxsLmxlbmd0aDtnKz0yKWYuYWRkVG9rZW4oZix1LnNsaWNlKEEsQT1sW2ddKSxIZShsW2crMV0sZi5jbS5vcHRpb25zKSl9ZS5zdHlsZUNsYXNzZXMmJihlLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzJiYoZC5iZ0NsYXNzPWNkKGUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsZC5iZ0NsYXNzfHxcIlwiKSksZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzJiYoZC50ZXh0Q2xhc3M9Y2QoZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLGQudGV4dENsYXNzfHxcIlwiKSkpOzA9PWQubWFwLmxlbmd0aCYmZC5tYXAucHVzaCgwLDAsZC5jb250ZW50LmFwcGVuZENoaWxkKEJnKGEuZGlzcGxheS5tZWFzdXJlKSkpOzA9PWM/KGIubWVhc3VyZS5tYXA9ZC5tYXAsYi5tZWFzdXJlLmNhY2hlPXt9KTooKGIubWVhc3VyZS5tYXBzfHwoYi5tZWFzdXJlLm1hcHM9W10pKS5wdXNoKGQubWFwKSwoYi5tZWFzdXJlLmNhY2hlc3x8XG4oYi5tZWFzdXJlLmNhY2hlcz1bXSkpLnB1c2goe30pKX1mYSYmKGhhPWQuY29udGVudC5sYXN0Q2hpbGQsL1xcYmNtLXRhYlxcYi8udGVzdChoYS5jbGFzc05hbWUpfHxoYS5xdWVyeVNlbGVjdG9yJiZoYS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRhYlwiKSkmJihkLmNvbnRlbnQuY2xhc3NOYW1lPVwiY20tdGFiLXdyYXAtaGFja1wiKTtYKGEsXCJyZW5kZXJMaW5lXCIsYSxiLmxpbmUsZC5wcmUpO2QucHJlLmNsYXNzTmFtZSYmKGQudGV4dENsYXNzPWNkKGQucHJlLmNsYXNzTmFtZSxkLnRleHRDbGFzc3x8XCJcIikpO3JldHVybiBkfWZ1bmN0aW9uIExnKGEpe3ZhciBiPXYoXCJzcGFuXCIsXCJcXHUyMDIyXCIsXCJjbS1pbnZhbGlkY2hhclwiKTtiLnRpdGxlPVwiXFxcXHVcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO2Iuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLGIudGl0bGUpO3JldHVybiBifWZ1bmN0aW9uIEpnKGEsYixkLGMsZSxmLGcpe2lmKGIpe2lmKGEuc3BsaXRTcGFjZXMpe3ZhciBoPWEudHJhaWxpbmdTcGFjZTtcbmlmKDE8Yi5sZW5ndGgmJiEvICAvLnRlc3QoYikpaD1iO2Vsc2V7Zm9yKHZhciBrPVwiXCIsbD0wO2w8Yi5sZW5ndGg7bCsrKXt2YXIgbT1iLmNoYXJBdChsKTtcIiBcIiE9bXx8IWh8fGwhPWIubGVuZ3RoLTEmJjMyIT1iLmNoYXJDb2RlQXQobCsxKXx8KG09XCJcXHUwMGEwXCIpO2srPW07aD1cIiBcIj09bX1oPWt9fWVsc2UgaD1iO2s9aDtsPWEuY20uc3RhdGUuc3BlY2lhbENoYXJzO209ITE7aWYobC50ZXN0KGIpKXtoPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtmb3IodmFyIHE9MDs7KXtsLmxhc3RJbmRleD1xO3ZhciBuPWwuZXhlYyhiKSxwPW4/bi5pbmRleC1xOmIubGVuZ3RoLXE7aWYocCl7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoay5zbGljZShxLHErcCkpO0cmJjk+VT9oLmFwcGVuZENoaWxkKHYoXCJzcGFuXCIsW3JdKSk6aC5hcHBlbmRDaGlsZChyKTthLm1hcC5wdXNoKGEucG9zLGEucG9zK3Ascik7YS5jb2wrPXA7YS5wb3MrPXB9aWYoIW4pYnJlYWs7cSs9XG5wKzE7XCJcXHRcIj09blswXT8obj1hLmNtLm9wdGlvbnMudGFiU2l6ZSxuLT1hLmNvbCVuLHA9aC5hcHBlbmRDaGlsZCh2KFwic3BhblwiLGZkKG4pLFwiY20tdGFiXCIpKSxwLnNldEF0dHJpYnV0ZShcInJvbGVcIixcInByZXNlbnRhdGlvblwiKSxwLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIixcIlxcdFwiKSxhLmNvbCs9bik6KFwiXFxyXCI9PW5bMF18fFwiXFxuXCI9PW5bMF0/KHA9aC5hcHBlbmRDaGlsZCh2KFwic3BhblwiLFwiXFxyXCI9PW5bMF0/XCJcXHUyNDBkXCI6XCJcXHUyNDI0XCIsXCJjbS1pbnZhbGlkY2hhclwiKSkscC5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsblswXSkpOihwPWEuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG5bMF0pLHAuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLG5bMF0pLEcmJjk+VT9oLmFwcGVuZENoaWxkKHYoXCJzcGFuXCIsW3BdKSk6aC5hcHBlbmRDaGlsZChwKSksYS5jb2wrPTEpO2EubWFwLnB1c2goYS5wb3MsYS5wb3MrMSxwKTthLnBvcysrfX1lbHNlIGEuY29sKz1iLmxlbmd0aCxoPVxuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoayksYS5tYXAucHVzaChhLnBvcyxhLnBvcytiLmxlbmd0aCxoKSxHJiY5PlUmJihtPSEwKSxhLnBvcys9Yi5sZW5ndGg7YS50cmFpbGluZ1NwYWNlPTMyPT1rLmNoYXJDb2RlQXQoYi5sZW5ndGgtMSk7aWYoZHx8Y3x8ZXx8bXx8Znx8Zyl7Yj1kfHxcIlwiO2MmJihiKz1jKTtlJiYoYis9ZSk7Yz12KFwic3BhblwiLFtoXSxiLGYpO2lmKGcpZm9yKHZhciB1IGluIGcpZy5oYXNPd25Qcm9wZXJ0eSh1KSYmXCJzdHlsZVwiIT11JiZcImNsYXNzXCIhPXUmJmMuc2V0QXR0cmlidXRlKHUsZ1t1XSk7cmV0dXJuIGEuY29udGVudC5hcHBlbmRDaGlsZChjKX1hLmNvbnRlbnQuYXBwZW5kQ2hpbGQoaCl9fWZ1bmN0aW9uIEtnKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGQsYyxlLGYsZyxoLGspe2U9ZT9lK1wiIGNtLWZvcmNlLWJvcmRlclwiOlwiY20tZm9yY2UtYm9yZGVyXCI7Zm9yKHZhciBsPWQucG9zLG09bCtjLmxlbmd0aDs7KXtmb3IodmFyIHE9dm9pZCAwLG49MDtuPGIubGVuZ3RoJiZcbiEocT1iW25dLHEudG8+bCYmcS5mcm9tPD1sKTtuKyspO2lmKHEudG8+PW0pcmV0dXJuIGEoZCxjLGUsZixnLGgsayk7YShkLGMuc2xpY2UoMCxxLnRvLWwpLGUsZixudWxsLGgsayk7Zj1udWxsO2M9Yy5zbGljZShxLnRvLWwpO2w9cS50b319fWZ1bmN0aW9uIEplKGEsYixkLGMpe3ZhciBlPSFjJiZkLndpZGdldE5vZGU7ZSYmYS5tYXAucHVzaChhLnBvcyxhLnBvcytiLGUpOyFjJiZhLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlJiYoZXx8KGU9YS5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKSksZS5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIixkLmlkKSk7ZSYmKGEuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGUpLGEuY29udGVudC5hcHBlbmRDaGlsZChlKSk7YS5wb3MrPWI7YS50cmFpbGluZ1NwYWNlPSExfWZ1bmN0aW9uIEtlKGEsYixkKXtmb3IodmFyIGM9dGhpcy5saW5lPWIsZTtjPXFiKGMsITEpOyljPVxuYy5maW5kKDEsITApLmxpbmUsKGV8fChlPVtdKSkucHVzaChjKTt0aGlzLnNpemU9KHRoaXMucmVzdD1lKT9PKEwodGhpcy5yZXN0KSktZCsxOjE7dGhpcy5ub2RlPXRoaXMudGV4dD1udWxsO3RoaXMuaGlkZGVuPU9hKGEsYil9ZnVuY3Rpb24gRWMoYSxiLGQpe3ZhciBjPVtdLGU7Zm9yKGU9YjtlPGQ7KWI9bmV3IEtlKGEuZG9jLHcoYS5kb2MsZSksZSksZSs9Yi5zaXplLGMucHVzaChiKTtyZXR1cm4gY31mdW5jdGlvbiBNZyhhLGIpe2lmKGE9YS5vd25zR3JvdXApdHJ5e3ZhciBkPWEuZGVsYXllZENhbGxiYWNrcyxjPTA7ZG97Zm9yKDtjPGQubGVuZ3RoO2MrKylkW2NdLmNhbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTxhLm9wcy5sZW5ndGg7ZSsrKXt2YXIgZj1hLm9wc1tlXTtpZihmLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMpZm9yKDtmLmN1cnNvckFjdGl2aXR5Q2FsbGVkPGYuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGg7KWYuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tmLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCxcbmYuY20pfX13aGlsZShjPGQubGVuZ3RoKX1maW5hbGx5e3JiPW51bGwsYihhKX19ZnVuY3Rpb24gY2EoYSxiKXt2YXIgZD1hLl9oYW5kbGVycyYmYS5faGFuZGxlcnNbYl18fHhjO2lmKGQubGVuZ3RoKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7aWYocmIpdmFyIGU9cmIuZGVsYXllZENhbGxiYWNrcztlbHNlIFBiP2U9UGI6KGU9UGI9W10sc2V0VGltZW91dChOZywwKSk7Zm9yKHZhciBmPWZ1bmN0aW9uKGgpe2UucHVzaChmdW5jdGlvbigpe3JldHVybiBkW2hdLmFwcGx5KG51bGwsYyl9KX0sZz0wO2c8ZC5sZW5ndGg7KytnKWYoZyl9fWZ1bmN0aW9uIE5nKCl7dmFyIGE9UGI7UGI9bnVsbDtmb3IodmFyIGI9MDtiPGEubGVuZ3RoOysrYilhW2JdKCl9ZnVuY3Rpb24gTGUoYSxiLGQsYyl7Zm9yKHZhciBlPTA7ZTxiLmNoYW5nZXMubGVuZ3RoO2UrKyl7dmFyIGY9Yi5jaGFuZ2VzW2VdO2lmKFwidGV4dFwiPT1mKXtmPWE7dmFyIGc9YixoPWcudGV4dC5jbGFzc05hbWUsXG5rPU1lKGYsZyk7Zy50ZXh0PT1nLm5vZGUmJihnLm5vZGU9ay5wcmUpO2cudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChrLnByZSxnLnRleHQpO2cudGV4dD1rLnByZTtrLmJnQ2xhc3MhPWcuYmdDbGFzc3x8ay50ZXh0Q2xhc3MhPWcudGV4dENsYXNzPyhnLmJnQ2xhc3M9ay5iZ0NsYXNzLGcudGV4dENsYXNzPWsudGV4dENsYXNzLHpkKGYsZykpOmgmJihnLnRleHQuY2xhc3NOYW1lPWgpfWVsc2UgaWYoXCJndXR0ZXJcIj09ZilOZShhLGIsZCxjKTtlbHNlIGlmKFwiY2xhc3NcIj09Zil6ZChhLGIpO2Vsc2UgaWYoXCJ3aWRnZXRcIj09Zil7Zj1hO2c9YjtoPWM7Zy5hbGlnbmFibGUmJihnLmFsaWduYWJsZT1udWxsKTtrPXkoXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7Zm9yKHZhciBsPWcubm9kZS5maXJzdENoaWxkLG07bDtsPW0pbT1sLm5leHRTaWJsaW5nLGsudGVzdChsLmNsYXNzTmFtZSkmJmcubm9kZS5yZW1vdmVDaGlsZChsKTtPZShmLGcsaCl9fWIuY2hhbmdlcz1udWxsfWZ1bmN0aW9uIFFiKGEpe2Eubm9kZT09XG5hLnRleHQmJihhLm5vZGU9dihcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZVwiKSxhLnRleHQucGFyZW50Tm9kZSYmYS50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGEubm9kZSxhLnRleHQpLGEubm9kZS5hcHBlbmRDaGlsZChhLnRleHQpLEcmJjg+VSYmKGEubm9kZS5zdHlsZS56SW5kZXg9MikpO3JldHVybiBhLm5vZGV9ZnVuY3Rpb24gTWUoYSxiKXt2YXIgZD1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtyZXR1cm4gZCYmZC5saW5lPT1iLmxpbmU/KGEuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkPW51bGwsYi5tZWFzdXJlPWQubWVhc3VyZSxkLmJ1aWx0KTpJZShhLGIpfWZ1bmN0aW9uIHpkKGEsYil7dmFyIGQ9Yi5iZ0NsYXNzP2IuYmdDbGFzcytcIiBcIisoYi5saW5lLmJnQ2xhc3N8fFwiXCIpOmIubGluZS5iZ0NsYXNzO2QmJihkKz1cIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXCIpO2lmKGIuYmFja2dyb3VuZClkP2IuYmFja2dyb3VuZC5jbGFzc05hbWU9XG5kOihiLmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiLmJhY2tncm91bmQpLGIuYmFja2dyb3VuZD1udWxsKTtlbHNlIGlmKGQpe3ZhciBjPVFiKGIpO2IuYmFja2dyb3VuZD1jLmluc2VydEJlZm9yZSh2KFwiZGl2XCIsbnVsbCxkKSxjLmZpcnN0Q2hpbGQpO2EuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGIuYmFja2dyb3VuZCl9Yi5saW5lLndyYXBDbGFzcz9RYihiKS5jbGFzc05hbWU9Yi5saW5lLndyYXBDbGFzczpiLm5vZGUhPWIudGV4dCYmKGIubm9kZS5jbGFzc05hbWU9XCJcIik7Yi50ZXh0LmNsYXNzTmFtZT0oYi50ZXh0Q2xhc3M/Yi50ZXh0Q2xhc3MrXCIgXCIrKGIubGluZS50ZXh0Q2xhc3N8fFwiXCIpOmIubGluZS50ZXh0Q2xhc3MpfHxcIlwifWZ1bmN0aW9uIE5lKGEsYixkLGMpe2IuZ3V0dGVyJiYoYi5ub2RlLnJlbW92ZUNoaWxkKGIuZ3V0dGVyKSxiLmd1dHRlcj1udWxsKTtiLmd1dHRlckJhY2tncm91bmQmJihiLm5vZGUucmVtb3ZlQ2hpbGQoYi5ndXR0ZXJCYWNrZ3JvdW5kKSxcbmIuZ3V0dGVyQmFja2dyb3VuZD1udWxsKTtpZihiLmxpbmUuZ3V0dGVyQ2xhc3Mpe3ZhciBlPVFiKGIpO2IuZ3V0dGVyQmFja2dyb3VuZD12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyLWJhY2tncm91bmQgXCIrYi5saW5lLmd1dHRlckNsYXNzLFwibGVmdDogXCIrKGEub3B0aW9ucy5maXhlZEd1dHRlcj9jLmZpeGVkUG9zOi1jLmd1dHRlclRvdGFsV2lkdGgpK1wicHg7IHdpZHRoOiBcIitjLmd1dHRlclRvdGFsV2lkdGgrXCJweFwiKTthLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShiLmd1dHRlckJhY2tncm91bmQpO2UuaW5zZXJ0QmVmb3JlKGIuZ3V0dGVyQmFja2dyb3VuZCxiLnRleHQpfWU9Yi5saW5lLmd1dHRlck1hcmtlcnM7aWYoYS5vcHRpb25zLmxpbmVOdW1iZXJzfHxlKXt2YXIgZj1RYihiKSxnPWIuZ3V0dGVyPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLFwibGVmdDogXCIrKGEub3B0aW9ucy5maXhlZEd1dHRlcj9jLmZpeGVkUG9zOi1jLmd1dHRlclRvdGFsV2lkdGgpK1xuXCJweFwiKTthLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShnKTtmLmluc2VydEJlZm9yZShnLGIudGV4dCk7Yi5saW5lLmd1dHRlckNsYXNzJiYoZy5jbGFzc05hbWUrPVwiIFwiK2IubGluZS5ndXR0ZXJDbGFzcyk7IWEub3B0aW9ucy5saW5lTnVtYmVyc3x8ZSYmZVtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl18fChiLmxpbmVOdW1iZXI9Zy5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsb2QoYS5vcHRpb25zLGQpLFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFwibGVmdDogXCIrYy5ndXR0ZXJMZWZ0W1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXStcInB4OyB3aWR0aDogXCIrYS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoK1wicHhcIikpKTtpZihlKWZvcihiPTA7YjxhLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOysrYilkPWEuZGlzcGxheS5ndXR0ZXJTcGVjc1tiXS5jbGFzc05hbWUsKGY9ZS5oYXNPd25Qcm9wZXJ0eShkKSYmZVtkXSkmJmcuYXBwZW5kQ2hpbGQodihcImRpdlwiLFxuW2ZdLFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXCJsZWZ0OiBcIitjLmd1dHRlckxlZnRbZF0rXCJweDsgd2lkdGg6IFwiK2MuZ3V0dGVyV2lkdGhbZF0rXCJweFwiKSl9fWZ1bmN0aW9uIE9nKGEsYixkLGMpe3ZhciBlPU1lKGEsYik7Yi50ZXh0PWIubm9kZT1lLnByZTtlLmJnQ2xhc3MmJihiLmJnQ2xhc3M9ZS5iZ0NsYXNzKTtlLnRleHRDbGFzcyYmKGIudGV4dENsYXNzPWUudGV4dENsYXNzKTt6ZChhLGIpO05lKGEsYixkLGMpO09lKGEsYixjKTtyZXR1cm4gYi5ub2RlfWZ1bmN0aW9uIE9lKGEsYixkKXtQZShhLGIubGluZSxiLGQsITApO2lmKGIucmVzdClmb3IodmFyIGM9MDtjPGIucmVzdC5sZW5ndGg7YysrKVBlKGEsYi5yZXN0W2NdLGIsZCwhMSl9ZnVuY3Rpb24gUGUoYSxiLGQsYyxlKXtpZihiLndpZGdldHMpe3ZhciBmPVFiKGQpLGc9MDtmb3IoYj1iLndpZGdldHM7ZzxiLmxlbmd0aDsrK2cpe3ZhciBoPWJbZ10saz12KFwiZGl2XCIsW2gubm9kZV0sXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIitcbihoLmNsYXNzTmFtZT9cIiBcIitoLmNsYXNzTmFtZTpcIlwiKSk7aC5oYW5kbGVNb3VzZUV2ZW50c3x8ay5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsXCJ0cnVlXCIpO3ZhciBsPWgsbT1rLHE9YztpZihsLm5vSFNjcm9sbCl7KGQuYWxpZ25hYmxlfHwoZC5hbGlnbmFibGU9W10pKS5wdXNoKG0pO3ZhciBuPXEud3JhcHBlcldpZHRoO20uc3R5bGUubGVmdD1xLmZpeGVkUG9zK1wicHhcIjtsLmNvdmVyR3V0dGVyfHwobi09cS5ndXR0ZXJUb3RhbFdpZHRoLG0uc3R5bGUucGFkZGluZ0xlZnQ9cS5ndXR0ZXJUb3RhbFdpZHRoK1wicHhcIik7bS5zdHlsZS53aWR0aD1uK1wicHhcIn1sLmNvdmVyR3V0dGVyJiYobS5zdHlsZS56SW5kZXg9NSxtLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixsLm5vSFNjcm9sbHx8KG0uc3R5bGUubWFyZ2luTGVmdD0tcS5ndXR0ZXJUb3RhbFdpZHRoK1wicHhcIikpO2EuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGspO2UmJmguYWJvdmU/Zi5pbnNlcnRCZWZvcmUoayxcbmQuZ3V0dGVyfHxkLnRleHQpOmYuYXBwZW5kQ2hpbGQoayk7Y2EoaCxcInJlZHJhd1wiKX19fWZ1bmN0aW9uIFJiKGEpe2lmKG51bGwhPWEuaGVpZ2h0KXJldHVybiBhLmhlaWdodDt2YXIgYj1hLmRvYy5jbTtpZighYilyZXR1cm4gMDtpZigha2EoZG9jdW1lbnQuYm9keSxhLm5vZGUpKXt2YXIgZD1cInBvc2l0aW9uOiByZWxhdGl2ZTtcIjthLmNvdmVyR3V0dGVyJiYoZCs9XCJtYXJnaW4tbGVmdDogLVwiK2IuZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoK1wicHg7XCIpO2Eubm9IU2Nyb2xsJiYoZCs9XCJ3aWR0aDogXCIrYi5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGgrXCJweDtcIik7RChiLmRpc3BsYXkubWVhc3VyZSx2KFwiZGl2XCIsW2Eubm9kZV0sbnVsbCxkKSl9cmV0dXJuIGEuaGVpZ2h0PWEubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodH1mdW5jdGlvbiBMYShhLGIpe2ZvcihiPWIudGFyZ2V0fHxiLnNyY0VsZW1lbnQ7YiE9YS53cmFwcGVyO2I9Yi5wYXJlbnROb2RlKWlmKCFifHwxPT1cbmIubm9kZVR5cGUmJlwidHJ1ZVwiPT1iLmdldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIil8fGIucGFyZW50Tm9kZT09YS5zaXplciYmYiE9YS5tb3ZlcilyZXR1cm4hMH1mdW5jdGlvbiBBZChhKXtyZXR1cm4gYS5tb3Zlci5vZmZzZXRIZWlnaHQtYS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0fWZ1bmN0aW9uIFFlKGEpe2lmKGEuY2FjaGVkUGFkZGluZ0gpcmV0dXJuIGEuY2FjaGVkUGFkZGluZ0g7dmFyIGI9RChhLm1lYXN1cmUsdihcInByZVwiLFwieFwiLFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIikpO2I9d2luZG93LmdldENvbXB1dGVkU3R5bGU/d2luZG93LmdldENvbXB1dGVkU3R5bGUoYik6Yi5jdXJyZW50U3R5bGU7Yj17bGVmdDpwYXJzZUludChiLnBhZGRpbmdMZWZ0KSxyaWdodDpwYXJzZUludChiLnBhZGRpbmdSaWdodCl9O2lzTmFOKGIubGVmdCl8fGlzTmFOKGIucmlnaHQpfHwoYS5jYWNoZWRQYWRkaW5nSD1iKTtyZXR1cm4gYn1mdW5jdGlvbiBIYShhKXtyZXR1cm4gNTAtYS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRofVxuZnVuY3Rpb24gYWIoYSl7cmV0dXJuIGEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aC1IYShhKS1hLmRpc3BsYXkuYmFyV2lkdGh9ZnVuY3Rpb24gQmQoYSl7cmV0dXJuIGEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQtSGEoYSktYS5kaXNwbGF5LmJhckhlaWdodH1mdW5jdGlvbiBSZShhLGIsZCl7aWYoYS5saW5lPT1iKXJldHVybnttYXA6YS5tZWFzdXJlLm1hcCxjYWNoZTphLm1lYXN1cmUuY2FjaGV9O2Zvcih2YXIgYz0wO2M8YS5yZXN0Lmxlbmd0aDtjKyspaWYoYS5yZXN0W2NdPT1iKXJldHVybnttYXA6YS5tZWFzdXJlLm1hcHNbY10sY2FjaGU6YS5tZWFzdXJlLmNhY2hlc1tjXX07Zm9yKGI9MDtiPGEucmVzdC5sZW5ndGg7YisrKWlmKE8oYS5yZXN0W2JdKT5kKXJldHVybnttYXA6YS5tZWFzdXJlLm1hcHNbYl0sY2FjaGU6YS5tZWFzdXJlLmNhY2hlc1tiXSxiZWZvcmU6ITB9fWZ1bmN0aW9uIENkKGEsYil7aWYoYj49YS5kaXNwbGF5LnZpZXdGcm9tJiZiPGEuZGlzcGxheS52aWV3VG8pcmV0dXJuIGEuZGlzcGxheS52aWV3W2JiKGEsXG5iKV07aWYoKGE9YS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQpJiZiPj1hLmxpbmVOJiZiPGEubGluZU4rYS5zaXplKXJldHVybiBhfWZ1bmN0aW9uIGNiKGEsYil7dmFyIGQ9TyhiKSxjPUNkKGEsZCk7YyYmIWMudGV4dD9jPW51bGw6YyYmYy5jaGFuZ2VzJiYoTGUoYSxjLGQsRGQoYSkpLGEuY3VyT3AuZm9yY2VVcGRhdGU9ITApO2lmKCFjKXt2YXIgZT1GYShiKTtjPU8oZSk7ZT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZD1uZXcgS2UoYS5kb2MsZSxjKTtlLmxpbmVOPWM7Yz1lLmJ1aWx0PUllKGEsZSk7ZS50ZXh0PWMucHJlO0QoYS5kaXNwbGF5LmxpbmVNZWFzdXJlLGMucHJlKTtjPWV9YT1SZShjLGIsZCk7cmV0dXJue2xpbmU6Yix2aWV3OmMscmVjdDpudWxsLG1hcDphLm1hcCxjYWNoZTphLmNhY2hlLGJlZm9yZTphLmJlZm9yZSxoYXNIZWlnaHRzOiExfX1mdW5jdGlvbiB6YShhLGIsZCxjLGUpe2IuYmVmb3JlJiYoZD0tMSk7dmFyIGY9ZCsoY3x8XCJcIik7aWYoYi5jYWNoZS5oYXNPd25Qcm9wZXJ0eShmKSlhPVxuYi5jYWNoZVtmXTtlbHNle2IucmVjdHx8KGIucmVjdD1iLnZpZXcudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7aWYoIWIuaGFzSGVpZ2h0cyl7dmFyIGc9Yi52aWV3LGg9Yi5yZWN0LGs9YS5vcHRpb25zLmxpbmVXcmFwcGluZyxsPWsmJmFiKGEpO2lmKCFnLm1lYXN1cmUuaGVpZ2h0c3x8ayYmZy5tZWFzdXJlLndpZHRoIT1sKXt2YXIgbT1nLm1lYXN1cmUuaGVpZ2h0cz1bXTtpZihrKWZvcihnLm1lYXN1cmUud2lkdGg9bCxnPWcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCksaz0wO2s8Zy5sZW5ndGgtMTtrKyspe2w9Z1trXTt2YXIgcT1nW2srMV07MjxNYXRoLmFicyhsLmJvdHRvbS1xLmJvdHRvbSkmJm0ucHVzaCgobC5ib3R0b20rcS50b3ApLzItaC50b3ApfW0ucHVzaChoLmJvdHRvbS1oLnRvcCl9Yi5oYXNIZWlnaHRzPSEwfW09YztnPVNlKGIubWFwLGQsbSk7Yz1nLm5vZGU7aD1nLnN0YXJ0O2s9Zy5lbmQ7ZD1nLmNvbGxhcHNlO2lmKDM9PWMubm9kZVR5cGUpe2Zvcih2YXIgbj1cbjA7ND5uO24rKyl7Zm9yKDtoJiZoZChiLmxpbmUudGV4dC5jaGFyQXQoZy5jb3ZlclN0YXJ0K2gpKTspLS1oO2Zvcig7Zy5jb3ZlclN0YXJ0K2s8Zy5jb3ZlckVuZCYmaGQoYi5saW5lLnRleHQuY2hhckF0KGcuY292ZXJTdGFydCtrKSk7KSsraztpZihHJiY5PlUmJjA9PWgmJms9PWcuY292ZXJFbmQtZy5jb3ZlclN0YXJ0KXZhciBwPWMucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlbHNle3A9T2IoYyxoLGspLmdldENsaWVudFJlY3RzKCk7az1UZTtpZihcImxlZnRcIj09bSlmb3IobD0wO2w8cC5sZW5ndGgmJihrPXBbbF0pLmxlZnQ9PWsucmlnaHQ7bCsrKTtlbHNlIGZvcihsPXAubGVuZ3RoLTE7MDw9bCYmKGs9cFtsXSkubGVmdD09ay5yaWdodDtsLS0pO3A9a31pZihwLmxlZnR8fHAucmlnaHR8fDA9PWgpYnJlYWs7az1oOy0taDtkPVwicmlnaHRcIn1HJiYxMT5VJiYoKG49IXdpbmRvdy5zY3JlZW58fG51bGw9PXNjcmVlbi5sb2dpY2FsWERQSXx8c2NyZWVuLmxvZ2ljYWxYRFBJPT1cbnNjcmVlbi5kZXZpY2VYRFBJKXx8KG51bGwhPUVkP249RWQ6KG09RChhLmRpc3BsYXkubWVhc3VyZSx2KFwic3BhblwiLFwieFwiKSksbj1tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG09T2IobSwwLDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49RWQ9MTxNYXRoLmFicyhuLmxlZnQtbS5sZWZ0KSksbj0hbiksbnx8KG49c2NyZWVuLmxvZ2ljYWxYRFBJL3NjcmVlbi5kZXZpY2VYRFBJLG09c2NyZWVuLmxvZ2ljYWxZRFBJL3NjcmVlbi5kZXZpY2VZRFBJLHA9e2xlZnQ6cC5sZWZ0Km4scmlnaHQ6cC5yaWdodCpuLHRvcDpwLnRvcCptLGJvdHRvbTpwLmJvdHRvbSptfSkpfWVsc2UgMDxoJiYoZD1tPVwicmlnaHRcIikscD1hLm9wdGlvbnMubGluZVdyYXBwaW5nJiYxPChuPWMuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoP25bXCJyaWdodFwiPT1tP24ubGVuZ3RoLTE6MF06Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTshKEcmJjk+VSl8fGh8fHAmJihwLmxlZnR8fHAucmlnaHQpfHwocD0ocD1jLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXSk/XG57bGVmdDpwLmxlZnQscmlnaHQ6cC5sZWZ0K3NiKGEuZGlzcGxheSksdG9wOnAudG9wLGJvdHRvbTpwLmJvdHRvbX06VGUpO2M9cC50b3AtYi5yZWN0LnRvcDtoPXAuYm90dG9tLWIucmVjdC50b3A7bj0oYytoKS8yO209Yi52aWV3Lm1lYXN1cmUuaGVpZ2h0cztmb3IoZz0wO2c8bS5sZW5ndGgtMSYmIShuPG1bZ10pO2crKyk7ZD17bGVmdDooXCJyaWdodFwiPT1kP3AucmlnaHQ6cC5sZWZ0KS1iLnJlY3QubGVmdCxyaWdodDooXCJsZWZ0XCI9PWQ/cC5sZWZ0OnAucmlnaHQpLWIucmVjdC5sZWZ0LHRvcDpnP21bZy0xXTowLGJvdHRvbTptW2ddfTtwLmxlZnR8fHAucmlnaHR8fChkLmJvZ3VzPSEwKTthLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZXx8KGQucnRvcD1jLGQucmJvdHRvbT1oKTthPWQ7YS5ib2d1c3x8KGIuY2FjaGVbZl09YSl9cmV0dXJue2xlZnQ6YS5sZWZ0LHJpZ2h0OmEucmlnaHQsdG9wOmU/YS5ydG9wOmEudG9wLGJvdHRvbTplP2EucmJvdHRvbTphLmJvdHRvbX19XG5mdW5jdGlvbiBTZShhLGIsZCl7Zm9yKHZhciBjLGUsZixnLGgsayxsPTA7bDxhLmxlbmd0aDtsKz0zKXtoPWFbbF07az1hW2wrMV07aWYoYjxoKWU9MCxmPTEsZz1cImxlZnRcIjtlbHNlIGlmKGI8ayllPWItaCxmPWUrMTtlbHNlIGlmKGw9PWEubGVuZ3RoLTN8fGI9PWsmJmFbbCszXT5iKWY9ay1oLGU9Zi0xLGI+PWsmJihnPVwicmlnaHRcIik7aWYobnVsbCE9ZSl7Yz1hW2wrMl07aD09ayYmZD09KGMuaW5zZXJ0TGVmdD9cImxlZnRcIjpcInJpZ2h0XCIpJiYoZz1kKTtpZihcImxlZnRcIj09ZCYmMD09ZSlmb3IoO2wmJmFbbC0yXT09YVtsLTNdJiZhW2wtMV0uaW5zZXJ0TGVmdDspYz1hWyhsLT0zKSsyXSxnPVwibGVmdFwiO2lmKFwicmlnaHRcIj09ZCYmZT09ay1oKWZvcig7bDxhLmxlbmd0aC0zJiZhW2wrM109PWFbbCs0XSYmIWFbbCs1XS5pbnNlcnRMZWZ0OyljPWFbKGwrPTMpKzJdLGc9XCJyaWdodFwiO2JyZWFrfX1yZXR1cm57bm9kZTpjLHN0YXJ0OmUsZW5kOmYsY29sbGFwc2U6Zyxjb3ZlclN0YXJ0OmgsXG5jb3ZlckVuZDprfX1mdW5jdGlvbiBVZShhKXtpZihhLm1lYXN1cmUmJihhLm1lYXN1cmUuY2FjaGU9e30sYS5tZWFzdXJlLmhlaWdodHM9bnVsbCxhLnJlc3QpKWZvcih2YXIgYj0wO2I8YS5yZXN0Lmxlbmd0aDtiKyspYS5tZWFzdXJlLmNhY2hlc1tiXT17fX1mdW5jdGlvbiBWZShhKXthLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlPW51bGw7RShhLmRpc3BsYXkubGluZU1lYXN1cmUpO2Zvcih2YXIgYj0wO2I8YS5kaXNwbGF5LnZpZXcubGVuZ3RoO2IrKylVZShhLmRpc3BsYXkudmlld1tiXSl9ZnVuY3Rpb24gU2IoYSl7VmUoYSk7YS5kaXNwbGF5LmNhY2hlZENoYXJXaWR0aD1hLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodD1hLmRpc3BsYXkuY2FjaGVkUGFkZGluZ0g9bnVsbDthLm9wdGlvbnMubGluZVdyYXBwaW5nfHwoYS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkPSEwKTthLmRpc3BsYXkubGluZU51bUNoYXJzPW51bGx9ZnVuY3Rpb24gV2UoKXtyZXR1cm4gRmMmJkdjPy0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LVxucGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5MZWZ0KSk6d2luZG93LnBhZ2VYT2Zmc2V0fHwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0fWZ1bmN0aW9uIFhlKCl7cmV0dXJuIEZjJiZHYz8tKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLXBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkubWFyZ2luVG9wKSk6d2luZG93LnBhZ2VZT2Zmc2V0fHwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3B9ZnVuY3Rpb24gRmQoYSl7dmFyIGI9MDtpZihhLndpZGdldHMpZm9yKHZhciBkPTA7ZDxhLndpZGdldHMubGVuZ3RoOysrZClhLndpZGdldHNbZF0uYWJvdmUmJihiKz1SYihhLndpZGdldHNbZF0pKTtyZXR1cm4gYn1mdW5jdGlvbiBIYyhhLGIsZCxjLGUpe2V8fChlPUZkKGIpLGQudG9wKz1lLGQuYm90dG9tKz1lKTtcbmlmKFwibGluZVwiPT1jKXJldHVybiBkO2N8fChjPVwibG9jYWxcIik7Yj1HYShiKTtiPVwibG9jYWxcIj09Yz9iK2EuZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0VG9wOmItYS5kaXNwbGF5LnZpZXdPZmZzZXQ7aWYoXCJwYWdlXCI9PWN8fFwid2luZG93XCI9PWMpYT1hLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGIrPWEudG9wKyhcIndpbmRvd1wiPT1jPzA6WGUoKSksYz1hLmxlZnQrKFwid2luZG93XCI9PWM/MDpXZSgpKSxkLmxlZnQrPWMsZC5yaWdodCs9YztkLnRvcCs9YjtkLmJvdHRvbSs9YjtyZXR1cm4gZH1mdW5jdGlvbiBZZShhLGIsZCl7aWYoXCJkaXZcIj09ZClyZXR1cm4gYjt2YXIgYz1iLmxlZnQ7Yj1iLnRvcDtcInBhZ2VcIj09ZD8oYy09V2UoKSxiLT1YZSgpKTpcImxvY2FsXCIhPWQmJmR8fChkPWEuZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxjKz1kLmxlZnQsYis9ZC50b3ApO2E9YS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbnJldHVybntsZWZ0OmMtYS5sZWZ0LHRvcDpiLWEudG9wfX1mdW5jdGlvbiBHZChhLGIsZCxjLGUpe2N8fChjPXcoYS5kb2MsYi5saW5lKSk7dmFyIGY9YztiPWIuY2g7Yz16YShhLGNiKGEsYyksYixlKTtyZXR1cm4gSGMoYSxmLGMsZCl9ZnVuY3Rpb24gQWEoYSxiLGQsYyxlLGYpe2Z1bmN0aW9uIGcobixwKXtuPXphKGEsZSxuLHA/XCJyaWdodFwiOlwibGVmdFwiLGYpO3A/bi5sZWZ0PW4ucmlnaHQ6bi5yaWdodD1uLmxlZnQ7cmV0dXJuIEhjKGEsYyxuLGQpfWZ1bmN0aW9uIGgobixwLHIpe3JldHVybiBnKHI/bi0xOm4sMT09a1twXS5sZXZlbCE9cil9Yz1jfHx3KGEuZG9jLGIubGluZSk7ZXx8KGU9Y2IoYSxjKSk7dmFyIGs9SmEoYyxhLmRvYy5kaXJlY3Rpb24pLGw9Yi5jaDtiPWIuc3RpY2t5O2w+PWMudGV4dC5sZW5ndGg/KGw9Yy50ZXh0Lmxlbmd0aCxiPVwiYmVmb3JlXCIpOjA+PWwmJihsPTAsYj1cImFmdGVyXCIpO2lmKCFrKXJldHVybiBnKFwiYmVmb3JlXCI9PWI/bC0xOmwsXCJiZWZvcmVcIj09XG5iKTt2YXIgbT1JYihrLGwsYikscT1KYjttPWgobCxtLFwiYmVmb3JlXCI9PWIpO251bGwhPXEmJihtLm90aGVyPWgobCxxLFwiYmVmb3JlXCIhPWIpKTtyZXR1cm4gbX1mdW5jdGlvbiBaZShhLGIpe3ZhciBkPTA7Yj1DKGEuZG9jLGIpO2Eub3B0aW9ucy5saW5lV3JhcHBpbmd8fChkPXNiKGEuZGlzcGxheSkqYi5jaCk7Yj13KGEuZG9jLGIubGluZSk7YT1HYShiKSthLmRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcDtyZXR1cm57bGVmdDpkLHJpZ2h0OmQsdG9wOmEsYm90dG9tOmErYi5oZWlnaHR9fWZ1bmN0aW9uIEhkKGEsYixkLGMsZSl7YT10KGEsYixkKTthLnhSZWw9ZTtjJiYoYS5vdXRzaWRlPWMpO3JldHVybiBhfWZ1bmN0aW9uIElkKGEsYixkKXt2YXIgYz1hLmRvYztkKz1hLmRpc3BsYXkudmlld09mZnNldDtpZigwPmQpcmV0dXJuIEhkKGMuZmlyc3QsMCxudWxsLC0xLC0xKTt2YXIgZT0kYShjLGQpLGY9Yy5maXJzdCtjLnNpemUtMTtpZihlPmYpcmV0dXJuIEhkKGMuZmlyc3QrXG5jLnNpemUtMSx3KGMsZikudGV4dC5sZW5ndGgsbnVsbCwxLDEpOzA+YiYmKGI9MCk7Zm9yKHZhciBnPXcoYyxlKTs7KXtmPVBnKGEsZyxlLGIsZCk7dmFyIGg9dm9pZCAwO3ZhciBrPWYuY2grKDA8Zi54UmVsfHwwPGYub3V0c2lkZT8xOjApO2lmKGc9S2EmJmcubWFya2VkU3BhbnMpZm9yKHZhciBsPTA7bDxnLmxlbmd0aDsrK2wpe3ZhciBtPWdbbF07bS5tYXJrZXIuY29sbGFwc2VkJiYobnVsbD09bS5mcm9tfHxtLmZyb208aykmJihudWxsPT1tLnRvfHxtLnRvPmspJiYoIWh8fDA+dWQoaCxtLm1hcmtlcikpJiYoaD1tLm1hcmtlcil9aWYoIWgpcmV0dXJuIGY7Zj1oLmZpbmQoMSk7aWYoZi5saW5lPT1lKXJldHVybiBmO2c9dyhjLGU9Zi5saW5lKX19ZnVuY3Rpb24gJGUoYSxiLGQsYyl7Yy09RmQoYik7Yj1iLnRleHQubGVuZ3RoO3ZhciBlPUhiKGZ1bmN0aW9uKGYpe3JldHVybiB6YShhLGQsZi0xKS5ib3R0b208PWN9LGIsMCk7Yj1IYihmdW5jdGlvbihmKXtyZXR1cm4gemEoYSxcbmQsZikudG9wPmN9LGUsYik7cmV0dXJue2JlZ2luOmUsZW5kOmJ9fWZ1bmN0aW9uIGFmKGEsYixkLGMpe2R8fChkPWNiKGEsYikpO2M9SGMoYSxiLHphKGEsZCxjKSxcImxpbmVcIikudG9wO3JldHVybiAkZShhLGIsZCxjKX1mdW5jdGlvbiBKZChhLGIsZCxjKXtyZXR1cm4gYS5ib3R0b208PWQ/ITE6YS50b3A+ZD8hMDooYz9hLmxlZnQ6YS5yaWdodCk+Yn1mdW5jdGlvbiBQZyhhLGIsZCxjLGUpe2UtPUdhKGIpO3ZhciBmPWNiKGEsYiksZz1GZChiKSxoPTAsaz1iLnRleHQubGVuZ3RoLGw9ITAsbT1KYShiLGEuZG9jLmRpcmVjdGlvbik7bSYmKG09KGEub3B0aW9ucy5saW5lV3JhcHBpbmc/UWc6UmcpKGEsYixkLGYsbSxjLGUpLGg9KGw9MSE9bS5sZXZlbCk/bS5mcm9tOm0udG8tMSxrPWw/bS50bzptLmZyb20tMSk7dmFyIHE9bnVsbCxuPW51bGw7bT1IYihmdW5jdGlvbihyKXt2YXIgdT16YShhLGYscik7dS50b3ArPWc7dS5ib3R0b20rPWc7aWYoIUpkKHUsYyxlLCExKSlyZXR1cm4hMTtcbnUudG9wPD1lJiZ1LmxlZnQ8PWMmJihxPXIsbj11KTtyZXR1cm4hMH0saCxrKTt2YXIgcD0hMTtuPyhoPWMtbi5sZWZ0PG4ucmlnaHQtYyxsPWg9PWwsbT1xKyhsPzA6MSksbD1sP1wiYWZ0ZXJcIjpcImJlZm9yZVwiLGg9aD9uLmxlZnQ6bi5yaWdodCk6KGx8fG0hPWsmJm0hPWh8fG0rKyxsPTA9PW0/XCJhZnRlclwiOm09PWIudGV4dC5sZW5ndGg/XCJiZWZvcmVcIjp6YShhLGYsbS0obD8xOjApKS5ib3R0b20rZzw9ZT09bD9cImFmdGVyXCI6XCJiZWZvcmVcIixwPUFhKGEsdChkLG0sbCksXCJsaW5lXCIsYixmKSxoPXAubGVmdCxwPWU8cC50b3A/LTE6ZT49cC5ib3R0b20/MTowKTttPXBlKGIudGV4dCxtLDEpO3JldHVybiBIZChkLG0sbCxwLGMtaCl9ZnVuY3Rpb24gUmcoYSxiLGQsYyxlLGYsZyl7dmFyIGg9SGIoZnVuY3Rpb24obSl7bT1lW21dO3ZhciBxPTEhPW0ubGV2ZWw7cmV0dXJuIEpkKEFhKGEsdChkLHE/bS50bzptLmZyb20scT9cImJlZm9yZVwiOlwiYWZ0ZXJcIiksXCJsaW5lXCIsYixjKSxmLGcsITApfSxcbjAsZS5sZW5ndGgtMSksaz1lW2hdO2lmKDA8aCl7dmFyIGw9MSE9ay5sZXZlbDtsPUFhKGEsdChkLGw/ay5mcm9tOmsudG8sbD9cImFmdGVyXCI6XCJiZWZvcmVcIiksXCJsaW5lXCIsYixjKTtKZChsLGYsZywhMCkmJmwudG9wPmcmJihrPWVbaC0xXSl9cmV0dXJuIGt9ZnVuY3Rpb24gUWcoYSxiLGQsYyxlLGYsZyl7Zz0kZShhLGIsYyxnKTtkPWcuYmVnaW47Zz1nLmVuZDsvXFxzLy50ZXN0KGIudGV4dC5jaGFyQXQoZy0xKSkmJmctLTtmb3IodmFyIGg9Yj1udWxsLGs9MDtrPGUubGVuZ3RoO2srKyl7dmFyIGw9ZVtrXTtpZighKGwuZnJvbT49Z3x8bC50bzw9ZCkpe3ZhciBtPXphKGEsYywxIT1sLmxldmVsP01hdGgubWluKGcsbC50byktMTpNYXRoLm1heChkLGwuZnJvbSkpLnJpZ2h0O209bTxmP2YtbSsxRTk6bS1mO2lmKCFifHxoPm0pYj1sLGg9bX19Ynx8KGI9ZVtlLmxlbmd0aC0xXSk7Yi5mcm9tPGQmJihiPXtmcm9tOmQsdG86Yi50byxsZXZlbDpiLmxldmVsfSk7Yi50bz5nJiYoYj17ZnJvbTpiLmZyb20sXG50bzpnLGxldmVsOmIubGV2ZWx9KTtyZXR1cm4gYn1mdW5jdGlvbiB0YihhKXtpZihudWxsIT1hLmNhY2hlZFRleHRIZWlnaHQpcmV0dXJuIGEuY2FjaGVkVGV4dEhlaWdodDtpZihudWxsPT1kYil7ZGI9dihcInByZVwiLG51bGwsXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtmb3IodmFyIGI9MDs0OT5iOysrYilkYi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpLGRiLmFwcGVuZENoaWxkKHYoXCJiclwiKSk7ZGIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKX1EKGEubWVhc3VyZSxkYik7Yj1kYi5vZmZzZXRIZWlnaHQvNTA7MzxiJiYoYS5jYWNoZWRUZXh0SGVpZ2h0PWIpO0UoYS5tZWFzdXJlKTtyZXR1cm4gYnx8MX1mdW5jdGlvbiBzYihhKXtpZihudWxsIT1hLmNhY2hlZENoYXJXaWR0aClyZXR1cm4gYS5jYWNoZWRDaGFyV2lkdGg7dmFyIGI9dihcInNwYW5cIixcInh4eHh4eHh4eHhcIiksZD12KFwicHJlXCIsW2JdLFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIik7XG5EKGEubWVhc3VyZSxkKTtiPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Yj0oYi5yaWdodC1iLmxlZnQpLzEwOzI8YiYmKGEuY2FjaGVkQ2hhcldpZHRoPWIpO3JldHVybiBifHwxMH1mdW5jdGlvbiBEZChhKXtmb3IodmFyIGI9YS5kaXNwbGF5LGQ9e30sYz17fSxlPWIuZ3V0dGVycy5jbGllbnRMZWZ0LGY9Yi5ndXR0ZXJzLmZpcnN0Q2hpbGQsZz0wO2Y7Zj1mLm5leHRTaWJsaW5nLCsrZyl7dmFyIGg9YS5kaXNwbGF5Lmd1dHRlclNwZWNzW2ddLmNsYXNzTmFtZTtkW2hdPWYub2Zmc2V0TGVmdCtmLmNsaWVudExlZnQrZTtjW2hdPWYuY2xpZW50V2lkdGh9cmV0dXJue2ZpeGVkUG9zOktkKGIpLGd1dHRlclRvdGFsV2lkdGg6Yi5ndXR0ZXJzLm9mZnNldFdpZHRoLGd1dHRlckxlZnQ6ZCxndXR0ZXJXaWR0aDpjLHdyYXBwZXJXaWR0aDpiLndyYXBwZXIuY2xpZW50V2lkdGh9fWZ1bmN0aW9uIEtkKGEpe3JldHVybiBhLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQtXG5hLnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnR9ZnVuY3Rpb24gYmYoYSl7dmFyIGI9dGIoYS5kaXNwbGF5KSxkPWEub3B0aW9ucy5saW5lV3JhcHBpbmcsYz1kJiZNYXRoLm1heCg1LGEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aC9zYihhLmRpc3BsYXkpLTMpO3JldHVybiBmdW5jdGlvbihlKXtpZihPYShhLmRvYyxlKSlyZXR1cm4gMDt2YXIgZj0wO2lmKGUud2lkZ2V0cylmb3IodmFyIGc9MDtnPGUud2lkZ2V0cy5sZW5ndGg7ZysrKWUud2lkZ2V0c1tnXS5oZWlnaHQmJihmKz1lLndpZGdldHNbZ10uaGVpZ2h0KTtyZXR1cm4gZD9mKyhNYXRoLmNlaWwoZS50ZXh0Lmxlbmd0aC9jKXx8MSkqYjpmK2J9fWZ1bmN0aW9uIExkKGEpe3ZhciBiPWEuZG9jLGQ9YmYoYSk7Yi5pdGVyKGZ1bmN0aW9uKGMpe3ZhciBlPWQoYyk7ZSE9Yy5oZWlnaHQmJkRhKGMsZSl9KX1mdW5jdGlvbiBlYihhLGIsZCxjKXt2YXIgZT1hLmRpc3BsYXk7aWYoIWQmJlwidHJ1ZVwiPT0oYi50YXJnZXR8fFxuYi5zcmNFbGVtZW50KS5nZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiKSlyZXR1cm4gbnVsbDtkPWUubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RyeXt2YXIgZj1iLmNsaWVudFgtZC5sZWZ0O3ZhciBnPWIuY2xpZW50WS1kLnRvcH1jYXRjaChrKXtyZXR1cm4gbnVsbH1iPUlkKGEsZixnKTt2YXIgaDtjJiYwPGIueFJlbCYmKGg9dyhhLmRvYyxiLmxpbmUpLnRleHQpLmxlbmd0aD09Yi5jaCYmKGM9d2EoaCxoLmxlbmd0aCxhLm9wdGlvbnMudGFiU2l6ZSktaC5sZW5ndGgsYj10KGIubGluZSxNYXRoLm1heCgwLE1hdGgucm91bmQoKGYtUWUoYS5kaXNwbGF5KS5sZWZ0KS9zYihhLmRpc3BsYXkpKS1jKSkpO3JldHVybiBifWZ1bmN0aW9uIGJiKGEsYil7aWYoYj49YS5kaXNwbGF5LnZpZXdUbylyZXR1cm4gbnVsbDtiLT1hLmRpc3BsYXkudmlld0Zyb207aWYoMD5iKXJldHVybiBudWxsO2E9YS5kaXNwbGF5LnZpZXc7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspaWYoYi09XG5hW2RdLnNpemUsMD5iKXJldHVybiBkfWZ1bmN0aW9uIG1hKGEsYixkLGMpe251bGw9PWImJihiPWEuZG9jLmZpcnN0KTtudWxsPT1kJiYoZD1hLmRvYy5maXJzdCthLmRvYy5zaXplKTtjfHwoYz0wKTt2YXIgZT1hLmRpc3BsYXk7YyYmZDxlLnZpZXdUbyYmKG51bGw9PWUudXBkYXRlTGluZU51bWJlcnN8fGUudXBkYXRlTGluZU51bWJlcnM+YikmJihlLnVwZGF0ZUxpbmVOdW1iZXJzPWIpO2EuY3VyT3Audmlld0NoYW5nZWQ9ITA7aWYoYj49ZS52aWV3VG8pS2EmJnZkKGEuZG9jLGIpPGUudmlld1RvJiZQYShhKTtlbHNlIGlmKGQ8PWUudmlld0Zyb20pS2EmJkdlKGEuZG9jLGQrYyk+ZS52aWV3RnJvbT9QYShhKTooZS52aWV3RnJvbSs9YyxlLnZpZXdUbys9Yyk7ZWxzZSBpZihiPD1lLnZpZXdGcm9tJiZkPj1lLnZpZXdUbylQYShhKTtlbHNlIGlmKGI8PWUudmlld0Zyb20pe3ZhciBmPUljKGEsZCxkK2MsMSk7Zj8oZS52aWV3PWUudmlldy5zbGljZShmLmluZGV4KSxlLnZpZXdGcm9tPVxuZi5saW5lTixlLnZpZXdUbys9Yyk6UGEoYSl9ZWxzZSBpZihkPj1lLnZpZXdUbykoZj1JYyhhLGIsYiwtMSkpPyhlLnZpZXc9ZS52aWV3LnNsaWNlKDAsZi5pbmRleCksZS52aWV3VG89Zi5saW5lTik6UGEoYSk7ZWxzZXtmPUljKGEsYixiLC0xKTt2YXIgZz1JYyhhLGQsZCtjLDEpO2YmJmc/KGUudmlldz1lLnZpZXcuc2xpY2UoMCxmLmluZGV4KS5jb25jYXQoRWMoYSxmLmxpbmVOLGcubGluZU4pKS5jb25jYXQoZS52aWV3LnNsaWNlKGcuaW5kZXgpKSxlLnZpZXdUbys9Yyk6UGEoYSl9aWYoYT1lLmV4dGVybmFsTWVhc3VyZWQpZDxhLmxpbmVOP2EubGluZU4rPWM6YjxhLmxpbmVOK2Euc2l6ZSYmKGUuZXh0ZXJuYWxNZWFzdXJlZD1udWxsKX1mdW5jdGlvbiBRYShhLGIsZCl7YS5jdXJPcC52aWV3Q2hhbmdlZD0hMDt2YXIgYz1hLmRpc3BsYXksZT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtlJiZiPj1lLmxpbmVOJiZiPGUubGluZU4rZS5zaXplJiYoYy5leHRlcm5hbE1lYXN1cmVkPVxubnVsbCk7YjxjLnZpZXdGcm9tfHxiPj1jLnZpZXdUb3x8KGE9Yy52aWV3W2JiKGEsYildLG51bGwhPWEubm9kZSYmKGE9YS5jaGFuZ2VzfHwoYS5jaGFuZ2VzPVtdKSwtMT09ZWEoYSxkKSYmYS5wdXNoKGQpKSl9ZnVuY3Rpb24gUGEoYSl7YS5kaXNwbGF5LnZpZXdGcm9tPWEuZGlzcGxheS52aWV3VG89YS5kb2MuZmlyc3Q7YS5kaXNwbGF5LnZpZXc9W107YS5kaXNwbGF5LnZpZXdPZmZzZXQ9MH1mdW5jdGlvbiBJYyhhLGIsZCxjKXt2YXIgZT1iYihhLGIpLGY9YS5kaXNwbGF5LnZpZXc7aWYoIUthfHxkPT1hLmRvYy5maXJzdCthLmRvYy5zaXplKXJldHVybntpbmRleDplLGxpbmVOOmR9O2Zvcih2YXIgZz1hLmRpc3BsYXkudmlld0Zyb20saD0wO2g8ZTtoKyspZys9ZltoXS5zaXplO2lmKGchPWIpe2lmKDA8Yyl7aWYoZT09Zi5sZW5ndGgtMSlyZXR1cm4gbnVsbDtiPWcrZltlXS5zaXplLWI7ZSsrfWVsc2UgYj1nLWI7ZCs9Yn1mb3IoO3ZkKGEuZG9jLGQpIT1kOyl7aWYoZT09KDA+XG5jPzA6Zi5sZW5ndGgtMSkpcmV0dXJuIG51bGw7ZCs9YypmW2UtKDA+Yz8xOjApXS5zaXplO2UrPWN9cmV0dXJue2luZGV4OmUsbGluZU46ZH19ZnVuY3Rpb24gY2YoYSl7YT1hLmRpc3BsYXkudmlldztmb3IodmFyIGI9MCxkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBjPWFbZF07Yy5oaWRkZW58fGMubm9kZSYmIWMuY2hhbmdlc3x8KytifXJldHVybiBifWZ1bmN0aW9uIFRiKGEpe2EuZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGEuZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpfWZ1bmN0aW9uIGRmKGEsYil7dm9pZCAwPT09YiYmKGI9ITApO2Zvcih2YXIgZD1hLmRvYyxjPXt9LGU9Yy5jdXJzb3JzPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxmPWMuc2VsZWN0aW9uPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxnPTA7ZzxkLnNlbC5yYW5nZXMubGVuZ3RoO2crKylpZihifHxnIT1kLnNlbC5wcmltSW5kZXgpe3ZhciBoPWQuc2VsLnJhbmdlc1tnXTtcbmlmKCEoaC5mcm9tKCkubGluZT49YS5kaXNwbGF5LnZpZXdUb3x8aC50bygpLmxpbmU8YS5kaXNwbGF5LnZpZXdGcm9tKSl7dmFyIGs9aC5lbXB0eSgpOyhrfHxhLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpJiZlZihhLGguaGVhZCxlKTtrfHxTZyhhLGgsZil9fXJldHVybiBjfWZ1bmN0aW9uIGVmKGEsYixkKXtiPUFhKGEsYixcImRpdlwiLG51bGwsbnVsbCwhYS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO3ZhciBjPWQuYXBwZW5kQ2hpbGQodihcImRpdlwiLFwiXFx1MDBhMFwiLFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO2Muc3R5bGUubGVmdD1iLmxlZnQrXCJweFwiO2Muc3R5bGUudG9wPWIudG9wK1wicHhcIjtjLnN0eWxlLmhlaWdodD1NYXRoLm1heCgwLGIuYm90dG9tLWIudG9wKSphLm9wdGlvbnMuY3Vyc29ySGVpZ2h0K1wicHhcIjtiLm90aGVyJiYoYT1kLmFwcGVuZENoaWxkKHYoXCJkaXZcIixcIlxcdTAwYTBcIixcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKSxcbmEuc3R5bGUuZGlzcGxheT1cIlwiLGEuc3R5bGUubGVmdD1iLm90aGVyLmxlZnQrXCJweFwiLGEuc3R5bGUudG9wPWIub3RoZXIudG9wK1wicHhcIixhLnN0eWxlLmhlaWdodD0uODUqKGIub3RoZXIuYm90dG9tLWIub3RoZXIudG9wKStcInB4XCIpfWZ1bmN0aW9uIEpjKGEsYil7cmV0dXJuIGEudG9wLWIudG9wfHxhLmxlZnQtYi5sZWZ0fWZ1bmN0aW9uIFNnKGEsYixkKXtmdW5jdGlvbiBjKHAscix1LEEpezA+ciYmKHI9MCk7cj1NYXRoLnJvdW5kKHIpO0E9TWF0aC5yb3VuZChBKTtoLmFwcGVuZENoaWxkKHYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcIitwK1wicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiK3IrXCJweDsgd2lkdGg6IFwiKyhudWxsPT11P20tcDp1KStcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIisoQS1yKStcInB4XCIpKX1mdW5jdGlvbiBlKHAscix1KXtmdW5jdGlvbiBBKEYsXG5TKXtyZXR1cm4gR2QoYSx0KHAsRiksXCJkaXZcIix4LFMpfWZ1bmN0aW9uIEgoRixTLEkpe0Y9YWYoYSx4LG51bGwsRik7Uz1cImx0clwiPT1TPT0oXCJhZnRlclwiPT1JKT9cImxlZnRcIjpcInJpZ2h0XCI7ST1cImFmdGVyXCI9PUk/Ri5iZWdpbjpGLmVuZC0oL1xccy8udGVzdCh4LnRleHQuY2hhckF0KEYuZW5kLTEpKT8yOjEpO3JldHVybiBBKEksUylbU119dmFyIHg9dyhnLHApLFE9eC50ZXh0Lmxlbmd0aCxNLFIsVD1KYSh4LGcuZGlyZWN0aW9uKTt6ZyhULHJ8fDAsbnVsbD09dT9ROnUsZnVuY3Rpb24oRixTLEksTil7dmFyIGhhPVwibHRyXCI9PUksbmE9QShGLGhhP1wibGVmdFwiOlwicmlnaHRcIiksc2E9QShTLTEsaGE/XCJyaWdodFwiOlwibGVmdFwiKSxmYj1udWxsPT1yJiYwPT1GLGdiPW51bGw9PXUmJlM9PVEsTWQ9MD09TjtOPSFUfHxOPT1ULmxlbmd0aC0xOzM+PXNhLnRvcC1uYS50b3A/KFM9KHE/ZmI6Z2IpJiZNZD9sOihoYT9uYTpzYSkubGVmdCxjKFMsbmEudG9wLCgocT9nYjpmYikmJk4/bTooaGE/c2E6XG5uYSkucmlnaHQpLVMsbmEuYm90dG9tKSk6KGhhPyhoYT1xJiZmYiYmTWQ/bDpuYS5sZWZ0LGZiPXE/bTpIKEYsSSxcImJlZm9yZVwiKSxGPXE/bDpIKFMsSSxcImFmdGVyXCIpLGdiPXEmJmdiJiZOP206c2EucmlnaHQpOihoYT1xP0goRixJLFwiYmVmb3JlXCIpOmwsZmI9IXEmJmZiJiZNZD9tOm5hLnJpZ2h0LEY9IXEmJmdiJiZOP2w6c2EubGVmdCxnYj1xP0goUyxJLFwiYWZ0ZXJcIik6bSksYyhoYSxuYS50b3AsZmItaGEsbmEuYm90dG9tKSxuYS5ib3R0b208c2EudG9wJiZjKGwsbmEuYm90dG9tLG51bGwsc2EudG9wKSxjKEYsc2EudG9wLGdiLUYsc2EuYm90dG9tKSk7aWYoIU18fDA+SmMobmEsTSkpTT1uYTswPkpjKHNhLE0pJiYoTT1zYSk7aWYoIVJ8fDA+SmMobmEsUikpUj1uYTswPkpjKHNhLFIpJiYoUj1zYSl9KTtyZXR1cm57c3RhcnQ6TSxlbmQ6Un19dmFyIGY9YS5kaXNwbGF5LGc9YS5kb2MsaD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaz1RZShhLmRpc3BsYXkpLFxubD1rLmxlZnQsbT1NYXRoLm1heChmLnNpemVyV2lkdGgsYWIoYSktZi5zaXplci5vZmZzZXRMZWZ0KS1rLnJpZ2h0LHE9XCJsdHJcIj09Zy5kaXJlY3Rpb247Zj1iLmZyb20oKTtiPWIudG8oKTtpZihmLmxpbmU9PWIubGluZSllKGYubGluZSxmLmNoLGIuY2gpO2Vsc2V7dmFyIG49dyhnLGYubGluZSk7az13KGcsYi5saW5lKTtrPUZhKG4pPT1GYShrKTtmPWUoZi5saW5lLGYuY2gsaz9uLnRleHQubGVuZ3RoKzE6bnVsbCkuZW5kO2I9ZShiLmxpbmUsaz8wOm51bGwsYi5jaCkuc3RhcnQ7ayYmKGYudG9wPGIudG9wLTI/KGMoZi5yaWdodCxmLnRvcCxudWxsLGYuYm90dG9tKSxjKGwsYi50b3AsYi5sZWZ0LGIuYm90dG9tKSk6YyhmLnJpZ2h0LGYudG9wLGIubGVmdC1mLnJpZ2h0LGYuYm90dG9tKSk7Zi5ib3R0b208Yi50b3AmJmMobCxmLmJvdHRvbSxudWxsLGIudG9wKX1kLmFwcGVuZENoaWxkKGgpfWZ1bmN0aW9uIE5kKGEpe2lmKGEuc3RhdGUuZm9jdXNlZCl7dmFyIGI9YS5kaXNwbGF5O1xuY2xlYXJJbnRlcnZhbChiLmJsaW5rZXIpO3ZhciBkPSEwO2IuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJcIjswPGEub3B0aW9ucy5jdXJzb3JCbGlua1JhdGU/Yi5ibGlua2VyPXNldEludGVydmFsKGZ1bmN0aW9uKCl7YS5oYXNGb2N1cygpfHx1YihhKTtiLmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5PShkPSFkKT9cIlwiOlwiaGlkZGVuXCJ9LGEub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpOjA+YS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSYmKGIuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIil9fWZ1bmN0aW9uIGZmKGEpe2Euc3RhdGUuZm9jdXNlZHx8KGEuZGlzcGxheS5pbnB1dC5mb2N1cygpLE9kKGEpKX1mdW5jdGlvbiBnZihhKXthLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50PSEwO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50JiYoYS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudD0hMSx1YihhKSl9LDEwMCl9ZnVuY3Rpb24gT2QoYSxcbmIpe2Euc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQmJihhLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50PSExKTtcIm5vY3Vyc29yXCIhPWEub3B0aW9ucy5yZWFkT25seSYmKGEuc3RhdGUuZm9jdXNlZHx8KFgoYSxcImZvY3VzXCIsYSxiKSxhLnN0YXRlLmZvY3VzZWQ9ITAsV2EoYS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLWZvY3VzZWRcIiksYS5jdXJPcHx8YS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51PT1hLmRvYy5zZWx8fChhLmRpc3BsYXkuaW5wdXQucmVzZXQoKSxmYSYmc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBhLmRpc3BsYXkuaW5wdXQucmVzZXQoITApfSwyMCkpLGEuZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCkpLE5kKGEpKX1mdW5jdGlvbiB1YihhLGIpe2Euc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnR8fChhLnN0YXRlLmZvY3VzZWQmJihYKGEsXCJibHVyXCIsYSxiKSxhLnN0YXRlLmZvY3VzZWQ9ITEsaGIoYS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLWZvY3VzZWRcIikpLFxuY2xlYXJJbnRlcnZhbChhLmRpc3BsYXkuYmxpbmtlciksc2V0VGltZW91dChmdW5jdGlvbigpe2Euc3RhdGUuZm9jdXNlZHx8KGEuZGlzcGxheS5zaGlmdD0hMSl9LDE1MCkpfWZ1bmN0aW9uIEtjKGEpe2Zvcih2YXIgYj1hLmRpc3BsYXksZD1iLmxpbmVEaXYub2Zmc2V0VG9wLGM9MDtjPGIudmlldy5sZW5ndGg7YysrKXt2YXIgZT1iLnZpZXdbY10sZj1hLm9wdGlvbnMubGluZVdyYXBwaW5nLGc9MDtpZighZS5oaWRkZW4pe2lmKEcmJjg+VSl7Zj1lLm5vZGUub2Zmc2V0VG9wK2Uubm9kZS5vZmZzZXRIZWlnaHQ7dmFyIGg9Zi1kO2Q9Zn1lbHNle3ZhciBrPWUubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtoPWsuYm90dG9tLWsudG9wOyFmJiZlLnRleHQuZmlyc3RDaGlsZCYmKGc9ZS50ZXh0LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQtay5sZWZ0LTEpfWY9ZS5saW5lLmhlaWdodC1oO2lmKC4wMDU8Znx8LS4wMDU+ZilpZihEYShlLmxpbmUsaCksXG5oZihlLmxpbmUpLGUucmVzdClmb3IoaD0wO2g8ZS5yZXN0Lmxlbmd0aDtoKyspaGYoZS5yZXN0W2hdKTtnPmEuZGlzcGxheS5zaXplcldpZHRoJiYoZz1NYXRoLmNlaWwoZy9zYihhLmRpc3BsYXkpKSxnPmEuZGlzcGxheS5tYXhMaW5lTGVuZ3RoJiYoYS5kaXNwbGF5Lm1heExpbmVMZW5ndGg9ZyxhLmRpc3BsYXkubWF4TGluZT1lLmxpbmUsYS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkPSEwKSl9fX1mdW5jdGlvbiBoZihhKXtpZihhLndpZGdldHMpZm9yKHZhciBiPTA7YjxhLndpZGdldHMubGVuZ3RoOysrYil7dmFyIGQ9YS53aWRnZXRzW2JdLGM9ZC5ub2RlLnBhcmVudE5vZGU7YyYmKGQuaGVpZ2h0PWMub2Zmc2V0SGVpZ2h0KX19ZnVuY3Rpb24gTGMoYSxiLGQpe3ZhciBjPWQmJm51bGwhPWQudG9wP01hdGgubWF4KDAsZC50b3ApOmEuc2Nyb2xsZXIuc2Nyb2xsVG9wO2M9TWF0aC5mbG9vcihjLWEubGluZVNwYWNlLm9mZnNldFRvcCk7dmFyIGU9ZCYmbnVsbCE9ZC5ib3R0b20/ZC5ib3R0b206XG5jK2Eud3JhcHBlci5jbGllbnRIZWlnaHQ7Yz0kYShiLGMpO2U9JGEoYixlKTtpZihkJiZkLmVuc3VyZSl7dmFyIGY9ZC5lbnN1cmUuZnJvbS5saW5lO2Q9ZC5lbnN1cmUudG8ubGluZTtmPGM/KGM9ZixlPSRhKGIsR2EodyhiLGYpKSthLndyYXBwZXIuY2xpZW50SGVpZ2h0KSk6TWF0aC5taW4oZCxiLmxhc3RMaW5lKCkpPj1lJiYoYz0kYShiLEdhKHcoYixkKSktYS53cmFwcGVyLmNsaWVudEhlaWdodCksZT1kKX1yZXR1cm57ZnJvbTpjLHRvOk1hdGgubWF4KGUsYysxKX19ZnVuY3Rpb24gUGQoYSxiKXt2YXIgZD1hLmRpc3BsYXksYz10YihhLmRpc3BsYXkpOzA+Yi50b3AmJihiLnRvcD0wKTt2YXIgZT1hLmN1ck9wJiZudWxsIT1hLmN1ck9wLnNjcm9sbFRvcD9hLmN1ck9wLnNjcm9sbFRvcDpkLnNjcm9sbGVyLnNjcm9sbFRvcCxmPUJkKGEpLGc9e307Yi5ib3R0b20tYi50b3A+ZiYmKGIuYm90dG9tPWIudG9wK2YpO3ZhciBoPWEuZG9jLmhlaWdodCtBZChkKSxrPWIudG9wPGM7Yz1cbmIuYm90dG9tPmgtYztiLnRvcDxlP2cuc2Nyb2xsVG9wPWs/MDpiLnRvcDpiLmJvdHRvbT5lK2YmJihmPU1hdGgubWluKGIudG9wLChjP2g6Yi5ib3R0b20pLWYpLGYhPWUmJihnLnNjcm9sbFRvcD1mKSk7ZT1hLmN1ck9wJiZudWxsIT1hLmN1ck9wLnNjcm9sbExlZnQ/YS5jdXJPcC5zY3JvbGxMZWZ0OmQuc2Nyb2xsZXIuc2Nyb2xsTGVmdDthPWFiKGEpLShhLm9wdGlvbnMuZml4ZWRHdXR0ZXI/ZC5ndXR0ZXJzLm9mZnNldFdpZHRoOjApO2lmKGQ9Yi5yaWdodC1iLmxlZnQ+YSliLnJpZ2h0PWIubGVmdCthOzEwPmIubGVmdD9nLnNjcm9sbExlZnQ9MDpiLmxlZnQ8ZT9nLnNjcm9sbExlZnQ9TWF0aC5tYXgoMCxiLmxlZnQtKGQ/MDoxMCkpOmIucmlnaHQ+YStlLTMmJihnLnNjcm9sbExlZnQ9Yi5yaWdodCsoZD8wOjEwKS1hKTtyZXR1cm4gZ31mdW5jdGlvbiBNYyhhLGIpe251bGwhPWImJihOYyhhKSxhLmN1ck9wLnNjcm9sbFRvcD0obnVsbD09YS5jdXJPcC5zY3JvbGxUb3A/YS5kb2Muc2Nyb2xsVG9wOlxuYS5jdXJPcC5zY3JvbGxUb3ApK2IpfWZ1bmN0aW9uIHZiKGEpe05jKGEpO3ZhciBiPWEuZ2V0Q3Vyc29yKCk7YS5jdXJPcC5zY3JvbGxUb1Bvcz17ZnJvbTpiLHRvOmIsbWFyZ2luOmEub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW59fWZ1bmN0aW9uIFViKGEsYixkKXtudWxsPT1iJiZudWxsPT1kfHxOYyhhKTtudWxsIT1iJiYoYS5jdXJPcC5zY3JvbGxMZWZ0PWIpO251bGwhPWQmJihhLmN1ck9wLnNjcm9sbFRvcD1kKX1mdW5jdGlvbiBOYyhhKXt2YXIgYj1hLmN1ck9wLnNjcm9sbFRvUG9zO2lmKGIpe2EuY3VyT3Auc2Nyb2xsVG9Qb3M9bnVsbDt2YXIgZD1aZShhLGIuZnJvbSksYz1aZShhLGIudG8pO2pmKGEsZCxjLGIubWFyZ2luKX19ZnVuY3Rpb24gamYoYSxiLGQsYyl7Yj1QZChhLHtsZWZ0Ok1hdGgubWluKGIubGVmdCxkLmxlZnQpLHRvcDpNYXRoLm1pbihiLnRvcCxkLnRvcCktYyxyaWdodDpNYXRoLm1heChiLnJpZ2h0LGQucmlnaHQpLGJvdHRvbTpNYXRoLm1heChiLmJvdHRvbSxcbmQuYm90dG9tKStjfSk7VWIoYSxiLnNjcm9sbExlZnQsYi5zY3JvbGxUb3ApfWZ1bmN0aW9uIFZiKGEsYil7Mj5NYXRoLmFicyhhLmRvYy5zY3JvbGxUb3AtYil8fChNYXx8UWQoYSx7dG9wOmJ9KSxrZihhLGIsITApLE1hJiZRZChhKSxXYihhLDEwMCkpfWZ1bmN0aW9uIGtmKGEsYixkKXtiPU1hdGgubWF4KDAsTWF0aC5taW4oYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodC1hLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LGIpKTtpZihhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wIT1ifHxkKWEuZG9jLnNjcm9sbFRvcD1iLGEuZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChiKSxhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wIT1iJiYoYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcD1iKX1mdW5jdGlvbiBpYihhLGIsZCxjKXtiPU1hdGgubWF4KDAsTWF0aC5taW4oYixhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGgtYS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKSk7XG4oZD9iPT1hLmRvYy5zY3JvbGxMZWZ0OjI+TWF0aC5hYnMoYS5kb2Muc2Nyb2xsTGVmdC1iKSkmJiFjfHwoYS5kb2Muc2Nyb2xsTGVmdD1iLGxmKGEpLGEuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0IT1iJiYoYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQ9YiksYS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChiKSl9ZnVuY3Rpb24gWGIoYSl7dmFyIGI9YS5kaXNwbGF5LGQ9Yi5ndXR0ZXJzLm9mZnNldFdpZHRoLGM9TWF0aC5yb3VuZChhLmRvYy5oZWlnaHQrQWQoYS5kaXNwbGF5KSk7cmV0dXJue2NsaWVudEhlaWdodDpiLnNjcm9sbGVyLmNsaWVudEhlaWdodCx2aWV3SGVpZ2h0OmIud3JhcHBlci5jbGllbnRIZWlnaHQsc2Nyb2xsV2lkdGg6Yi5zY3JvbGxlci5zY3JvbGxXaWR0aCxjbGllbnRXaWR0aDpiLnNjcm9sbGVyLmNsaWVudFdpZHRoLHZpZXdXaWR0aDpiLndyYXBwZXIuY2xpZW50V2lkdGgsYmFyTGVmdDphLm9wdGlvbnMuZml4ZWRHdXR0ZXI/ZDpcbjAsZG9jSGVpZ2h0OmMsc2Nyb2xsSGVpZ2h0OmMrSGEoYSkrYi5iYXJIZWlnaHQsbmF0aXZlQmFyV2lkdGg6Yi5uYXRpdmVCYXJXaWR0aCxndXR0ZXJXaWR0aDpkfX1mdW5jdGlvbiB3YihhLGIpe2J8fChiPVhiKGEpKTt2YXIgZD1hLmRpc3BsYXkuYmFyV2lkdGgsYz1hLmRpc3BsYXkuYmFySGVpZ2h0O21mKGEsYik7Zm9yKGI9MDs0PmImJmQhPWEuZGlzcGxheS5iYXJXaWR0aHx8YyE9YS5kaXNwbGF5LmJhckhlaWdodDtiKyspZCE9YS5kaXNwbGF5LmJhcldpZHRoJiZhLm9wdGlvbnMubGluZVdyYXBwaW5nJiZLYyhhKSxtZihhLFhiKGEpKSxkPWEuZGlzcGxheS5iYXJXaWR0aCxjPWEuZGlzcGxheS5iYXJIZWlnaHR9ZnVuY3Rpb24gbWYoYSxiKXt2YXIgZD1hLmRpc3BsYXksYz1kLnNjcm9sbGJhcnMudXBkYXRlKGIpO2Quc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0PShkLmJhcldpZHRoPWMucmlnaHQpK1wicHhcIjtkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b209KGQuYmFySGVpZ2h0PVxuYy5ib3R0b20pK1wicHhcIjtkLmhlaWdodEZvcmNlci5zdHlsZS5ib3JkZXJCb3R0b209Yy5ib3R0b20rXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiO2MucmlnaHQmJmMuYm90dG9tPyhkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQ9Yy5ib3R0b20rXCJweFwiLGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoPWMucmlnaHQrXCJweFwiKTpkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiXCI7Yy5ib3R0b20mJmEub3B0aW9ucy5jb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciYmYS5vcHRpb25zLmZpeGVkR3V0dGVyPyhkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQ9Yy5ib3R0b20rXCJweFwiLGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoPWIuZ3V0dGVyV2lkdGgrXCJweFwiKTpkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiXCJ9ZnVuY3Rpb24gbmYoYSl7YS5kaXNwbGF5LnNjcm9sbGJhcnMmJlxuKGEuZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKCksYS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MmJmhiKGEuZGlzcGxheS53cmFwcGVyLGEuZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKSk7YS5kaXNwbGF5LnNjcm9sbGJhcnM9bmV3IG9mW2Eub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24oYil7YS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKGIsYS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7eihiLFwibW91c2Vkb3duXCIsZnVuY3Rpb24oKXthLnN0YXRlLmZvY3VzZWQmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gYS5kaXNwbGF5LmlucHV0LmZvY3VzKCl9LDApfSk7Yi5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLFwidHJ1ZVwiKX0sZnVuY3Rpb24oYixkKXtcImhvcml6b250YWxcIj09ZD9pYihhLGIpOlZiKGEsYil9LGEpO2EuZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzJiZXYShhLmRpc3BsYXkud3JhcHBlcixhLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyl9XG5mdW5jdGlvbiBqYihhKXthLmN1ck9wPXtjbTphLHZpZXdDaGFuZ2VkOiExLHN0YXJ0SGVpZ2h0OmEuZG9jLmhlaWdodCxmb3JjZVVwZGF0ZTohMSx1cGRhdGVJbnB1dDowLHR5cGluZzohMSxjaGFuZ2VPYmpzOm51bGwsY3Vyc29yQWN0aXZpdHlIYW5kbGVyczpudWxsLGN1cnNvckFjdGl2aXR5Q2FsbGVkOjAsc2VsZWN0aW9uQ2hhbmdlZDohMSx1cGRhdGVNYXhMaW5lOiExLHNjcm9sbExlZnQ6bnVsbCxzY3JvbGxUb3A6bnVsbCxzY3JvbGxUb1BvczpudWxsLGZvY3VzOiExLGlkOisrVGd9O2E9YS5jdXJPcDtyYj9yYi5vcHMucHVzaChhKTphLm93bnNHcm91cD1yYj17b3BzOlthXSxkZWxheWVkQ2FsbGJhY2tzOltdfX1mdW5jdGlvbiBrYihhKXsoYT1hLmN1ck9wKSYmTWcoYSxmdW5jdGlvbihiKXtmb3IodmFyIGQ9MDtkPGIub3BzLmxlbmd0aDtkKyspYi5vcHNbZF0uY20uY3VyT3A9bnVsbDtiPWIub3BzO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBjPWJbZF0sZT1jLmNtLGY9XG5lLmRpc3BsYXksZz1lLmRpc3BsYXk7IWcuc2Nyb2xsYmFyc0NsaXBwZWQmJmcuc2Nyb2xsZXIub2Zmc2V0V2lkdGgmJihnLm5hdGl2ZUJhcldpZHRoPWcuc2Nyb2xsZXIub2Zmc2V0V2lkdGgtZy5zY3JvbGxlci5jbGllbnRXaWR0aCxnLmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQ9SGEoZSkrXCJweFwiLGcuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tPS1nLm5hdGl2ZUJhcldpZHRoK1wicHhcIixnLnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGg9SGEoZSkrXCJweFwiLGcuc2Nyb2xsYmFyc0NsaXBwZWQ9ITApO2MudXBkYXRlTWF4TGluZSYmeGQoZSk7Yy5tdXN0VXBkYXRlPWMudmlld0NoYW5nZWR8fGMuZm9yY2VVcGRhdGV8fG51bGwhPWMuc2Nyb2xsVG9wfHxjLnNjcm9sbFRvUG9zJiYoYy5zY3JvbGxUb1Bvcy5mcm9tLmxpbmU8Zi52aWV3RnJvbXx8Yy5zY3JvbGxUb1Bvcy50by5saW5lPj1mLnZpZXdUbyl8fGYubWF4TGluZUNoYW5nZWQmJmUub3B0aW9ucy5saW5lV3JhcHBpbmc7Yy51cGRhdGU9XG5jLm11c3RVcGRhdGUmJm5ldyBPYyhlLGMubXVzdFVwZGF0ZSYme3RvcDpjLnNjcm9sbFRvcCxlbnN1cmU6Yy5zY3JvbGxUb1Bvc30sYy5mb3JjZVVwZGF0ZSl9Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyljPWJbZF0sYy51cGRhdGVkRGlzcGxheT1jLm11c3RVcGRhdGUmJlJkKGMuY20sYy51cGRhdGUpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspaWYoYz1iW2RdLGU9Yy5jbSxmPWUuZGlzcGxheSxjLnVwZGF0ZWREaXNwbGF5JiZLYyhlKSxjLmJhck1lYXN1cmU9WGIoZSksZi5tYXhMaW5lQ2hhbmdlZCYmIWUub3B0aW9ucy5saW5lV3JhcHBpbmcmJihnPWYubWF4TGluZS50ZXh0Lmxlbmd0aCxnPXphKGUsY2IoZSxmLm1heExpbmUpLGcsdm9pZCAwKSxjLmFkanVzdFdpZHRoVG89Zy5sZWZ0KzMsZS5kaXNwbGF5LnNpemVyV2lkdGg9Yy5hZGp1c3RXaWR0aFRvLGMuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aD1NYXRoLm1heChmLnNjcm9sbGVyLmNsaWVudFdpZHRoLGYuc2l6ZXIub2Zmc2V0TGVmdCtcbmMuYWRqdXN0V2lkdGhUbytIYShlKStlLmRpc3BsYXkuYmFyV2lkdGgpLGMubWF4U2Nyb2xsTGVmdD1NYXRoLm1heCgwLGYuc2l6ZXIub2Zmc2V0TGVmdCtjLmFkanVzdFdpZHRoVG8tYWIoZSkpKSxjLnVwZGF0ZWREaXNwbGF5fHxjLnNlbGVjdGlvbkNoYW5nZWQpYy5wcmVwYXJlZFNlbGVjdGlvbj1mLmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKTtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9YltkXSxlPWMuY20sbnVsbCE9Yy5hZGp1c3RXaWR0aFRvJiYoZS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoPWMuYWRqdXN0V2lkdGhUbytcInB4XCIsYy5tYXhTY3JvbGxMZWZ0PGUuZG9jLnNjcm9sbExlZnQmJmliKGUsTWF0aC5taW4oZS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsYy5tYXhTY3JvbGxMZWZ0KSwhMCksZS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkPSExKSxmPWMuZm9jdXMmJmMuZm9jdXM9PXZhKCksYy5wcmVwYXJlZFNlbGVjdGlvbiYmZS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oYy5wcmVwYXJlZFNlbGVjdGlvbixcbmYpLChjLnVwZGF0ZWREaXNwbGF5fHxjLnN0YXJ0SGVpZ2h0IT1lLmRvYy5oZWlnaHQpJiZ3YihlLGMuYmFyTWVhc3VyZSksYy51cGRhdGVkRGlzcGxheSYmU2QoZSxjLmJhck1lYXN1cmUpLGMuc2VsZWN0aW9uQ2hhbmdlZCYmTmQoZSksZS5zdGF0ZS5mb2N1c2VkJiZjLnVwZGF0ZUlucHV0JiZlLmRpc3BsYXkuaW5wdXQucmVzZXQoYy50eXBpbmcpLGYmJmZmKGMuY20pO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBoPXZvaWQgMDtjPWJbZF07ZT1jLmNtO2Y9ZS5kaXNwbGF5O2c9ZS5kb2M7Yy51cGRhdGVkRGlzcGxheSYmcGYoZSxjLnVwZGF0ZSk7bnVsbD09Zi53aGVlbFN0YXJ0WHx8bnVsbD09Yy5zY3JvbGxUb3AmJm51bGw9PWMuc2Nyb2xsTGVmdCYmIWMuc2Nyb2xsVG9Qb3N8fChmLndoZWVsU3RhcnRYPWYud2hlZWxTdGFydFk9bnVsbCk7bnVsbCE9Yy5zY3JvbGxUb3AmJmtmKGUsYy5zY3JvbGxUb3AsYy5mb3JjZVNjcm9sbCk7bnVsbCE9Yy5zY3JvbGxMZWZ0JiZpYihlLFxuYy5zY3JvbGxMZWZ0LCEwLCEwKTtpZihjLnNjcm9sbFRvUG9zKXt2YXIgaz1DKGcsYy5zY3JvbGxUb1Bvcy5mcm9tKTt2YXIgbD1DKGcsYy5zY3JvbGxUb1Bvcy50byk7dmFyIG09Yy5zY3JvbGxUb1Bvcy5tYXJnaW47bnVsbD09bSYmKG09MCk7ZS5vcHRpb25zLmxpbmVXcmFwcGluZ3x8ayE9bHx8KGs9ay5jaD90KGsubGluZSxcImJlZm9yZVwiPT1rLnN0aWNreT9rLmNoLTE6ay5jaCxcImFmdGVyXCIpOmssbD1cImJlZm9yZVwiPT1rLnN0aWNreT90KGsubGluZSxrLmNoKzEsXCJiZWZvcmVcIik6ayk7Zm9yKHZhciBxPTA7NT5xO3ErKyl7dmFyIG49ITE7aD1BYShlLGspO3ZhciBwPWwmJmwhPWs/QWEoZSxsKTpoO2g9e2xlZnQ6TWF0aC5taW4oaC5sZWZ0LHAubGVmdCksdG9wOk1hdGgubWluKGgudG9wLHAudG9wKS1tLHJpZ2h0Ok1hdGgubWF4KGgubGVmdCxwLmxlZnQpLGJvdHRvbTpNYXRoLm1heChoLmJvdHRvbSxwLmJvdHRvbSkrbX07cD1QZChlLGgpO3ZhciByPWUuZG9jLnNjcm9sbFRvcCxcbnU9ZS5kb2Muc2Nyb2xsTGVmdDtudWxsIT1wLnNjcm9sbFRvcCYmKFZiKGUscC5zY3JvbGxUb3ApLDE8TWF0aC5hYnMoZS5kb2Muc2Nyb2xsVG9wLXIpJiYobj0hMCkpO251bGwhPXAuc2Nyb2xsTGVmdCYmKGliKGUscC5zY3JvbGxMZWZ0KSwxPE1hdGguYWJzKGUuZG9jLnNjcm9sbExlZnQtdSkmJihuPSEwKSk7aWYoIW4pYnJlYWt9bD1oO1ooZSxcInNjcm9sbEN1cnNvckludG9WaWV3XCIpfHwobT1lLmRpc3BsYXkscT1tLnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGs9bnVsbCwwPmwudG9wK3EudG9wP2s9ITA6bC5ib3R0b20rcS50b3A+KHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkmJihrPSExKSxudWxsPT1rfHxVZ3x8KGw9dihcImRpdlwiLFwiXFx1MjAwYlwiLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIrKGwudG9wLW0udmlld09mZnNldC1lLmRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcCkrXG5cInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiKyhsLmJvdHRvbS1sLnRvcCtIYShlKSttLmJhckhlaWdodCkrXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIrbC5sZWZ0K1wicHg7IHdpZHRoOiBcIitNYXRoLm1heCgyLGwucmlnaHQtbC5sZWZ0KStcInB4O1wiKSxlLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKGwpLGwuc2Nyb2xsSW50b1ZpZXcoayksZS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChsKSkpfWw9Yy5tYXliZUhpZGRlbk1hcmtlcnM7az1jLm1heWJlVW5oaWRkZW5NYXJrZXJzO2lmKGwpZm9yKG09MDttPGwubGVuZ3RoOysrbSlsW21dLmxpbmVzLmxlbmd0aHx8WChsW21dLFwiaGlkZVwiKTtpZihrKWZvcihsPTA7bDxrLmxlbmd0aDsrK2wpa1tsXS5saW5lcy5sZW5ndGgmJlgoa1tsXSxcInVuaGlkZVwiKTtmLndyYXBwZXIub2Zmc2V0SGVpZ2h0JiYoZy5zY3JvbGxUb3A9ZS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCk7XG5jLmNoYW5nZU9ianMmJlgoZSxcImNoYW5nZXNcIixlLGMuY2hhbmdlT2Jqcyk7Yy51cGRhdGUmJmMudXBkYXRlLmZpbmlzaCgpfX0pfWZ1bmN0aW9uIHBhKGEsYil7aWYoYS5jdXJPcClyZXR1cm4gYigpO2piKGEpO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7a2IoYSl9fWZ1bmN0aW9uIGFhKGEsYil7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoYS5jdXJPcClyZXR1cm4gYi5hcHBseShhLGFyZ3VtZW50cyk7amIoYSk7dHJ5e3JldHVybiBiLmFwcGx5KGEsYXJndW1lbnRzKX1maW5hbGx5e2tiKGEpfX19ZnVuY3Rpb24gaWEoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYodGhpcy5jdXJPcClyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7amIodGhpcyk7dHJ5e3JldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e2tiKHRoaXMpfX19ZnVuY3Rpb24gYmEoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5jbTtpZighYnx8Yi5jdXJPcClyZXR1cm4gYS5hcHBseSh0aGlzLFxuYXJndW1lbnRzKTtqYihiKTt0cnl7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmFsbHl7a2IoYil9fX1mdW5jdGlvbiBXYihhLGIpe2EuZG9jLmhpZ2hsaWdodEZyb250aWVyPGEuZGlzcGxheS52aWV3VG8mJmEuc3RhdGUuaGlnaGxpZ2h0LnNldChiLGRkKFZnLGEpKX1mdW5jdGlvbiBWZyhhKXt2YXIgYj1hLmRvYztpZighKGIuaGlnaGxpZ2h0RnJvbnRpZXI+PWEuZGlzcGxheS52aWV3VG8pKXt2YXIgZD0rbmV3IERhdGUrYS5vcHRpb25zLndvcmtUaW1lLGM9TWIoYSxiLmhpZ2hsaWdodEZyb250aWVyKSxlPVtdO2IuaXRlcihjLmxpbmUsTWF0aC5taW4oYi5maXJzdCtiLnNpemUsYS5kaXNwbGF5LnZpZXdUbys1MDApLGZ1bmN0aW9uKGYpe2lmKGMubGluZT49YS5kaXNwbGF5LnZpZXdGcm9tKXt2YXIgZz1mLnN0eWxlcyxoPWYudGV4dC5sZW5ndGg+YS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aD9ZYShiLm1vZGUsYy5zdGF0ZSk6bnVsbCxrPXZlKGEsZixjLCEwKTtcbmgmJihjLnN0YXRlPWgpO2Yuc3R5bGVzPWsuc3R5bGVzO2g9Zi5zdHlsZUNsYXNzZXM7KGs9ay5jbGFzc2VzKT9mLnN0eWxlQ2xhc3Nlcz1rOmgmJihmLnN0eWxlQ2xhc3Nlcz1udWxsKTtrPSFnfHxnLmxlbmd0aCE9Zi5zdHlsZXMubGVuZ3RofHxoIT1rJiYoIWh8fCFrfHxoLmJnQ2xhc3MhPWsuYmdDbGFzc3x8aC50ZXh0Q2xhc3MhPWsudGV4dENsYXNzKTtmb3IoaD0wOyFrJiZoPGcubGVuZ3RoOysraClrPWdbaF0hPWYuc3R5bGVzW2hdO2smJmUucHVzaChjLmxpbmUpO2Yuc3RhdGVBZnRlcj1jLnNhdmUoKX1lbHNlIGYudGV4dC5sZW5ndGg8PWEub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgmJnJkKGEsZi50ZXh0LGMpLGYuc3RhdGVBZnRlcj0wPT1jLmxpbmUlNT9jLnNhdmUoKTpudWxsO2MubmV4dExpbmUoKTtpZigrbmV3IERhdGU+ZClyZXR1cm4gV2IoYSxhLm9wdGlvbnMud29ya0RlbGF5KSwhMH0pO2IuaGlnaGxpZ2h0RnJvbnRpZXI9Yy5saW5lO2IubW9kZUZyb250aWVyPVxuTWF0aC5tYXgoYi5tb2RlRnJvbnRpZXIsYy5saW5lKTtlLmxlbmd0aCYmcGEoYSxmdW5jdGlvbigpe2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKVFhKGEsZVtmXSxcInRleHRcIil9KX19ZnVuY3Rpb24gUmQoYSxiKXt2YXIgZD1hLmRpc3BsYXksYz1hLmRvYztpZihiLmVkaXRvcklzSGlkZGVuKXJldHVybiBQYShhKSwhMTtpZighYi5mb3JjZSYmYi52aXNpYmxlLmZyb20+PWQudmlld0Zyb20mJmIudmlzaWJsZS50bzw9ZC52aWV3VG8mJihudWxsPT1kLnVwZGF0ZUxpbmVOdW1iZXJzfHxkLnVwZGF0ZUxpbmVOdW1iZXJzPj1kLnZpZXdUbykmJmQucmVuZGVyZWRWaWV3PT1kLnZpZXcmJjA9PWNmKGEpKXJldHVybiExO3FmKGEpJiYoUGEoYSksYi5kaW1zPURkKGEpKTt2YXIgZT1jLmZpcnN0K2Muc2l6ZSxmPU1hdGgubWF4KGIudmlzaWJsZS5mcm9tLWEub3B0aW9ucy52aWV3cG9ydE1hcmdpbixjLmZpcnN0KSxnPU1hdGgubWluKGUsYi52aXNpYmxlLnRvK2Eub3B0aW9ucy52aWV3cG9ydE1hcmdpbik7XG5kLnZpZXdGcm9tPGYmJjIwPmYtZC52aWV3RnJvbSYmKGY9TWF0aC5tYXgoYy5maXJzdCxkLnZpZXdGcm9tKSk7ZC52aWV3VG8+ZyYmMjA+ZC52aWV3VG8tZyYmKGc9TWF0aC5taW4oZSxkLnZpZXdUbykpO0thJiYoZj12ZChhLmRvYyxmKSxnPUdlKGEuZG9jLGcpKTtjPWYhPWQudmlld0Zyb218fGchPWQudmlld1RvfHxkLmxhc3RXcmFwSGVpZ2h0IT1iLndyYXBwZXJIZWlnaHR8fGQubGFzdFdyYXBXaWR0aCE9Yi53cmFwcGVyV2lkdGg7ZT1hLmRpc3BsYXk7MD09ZS52aWV3Lmxlbmd0aHx8Zj49ZS52aWV3VG98fGc8PWUudmlld0Zyb20/KGUudmlldz1FYyhhLGYsZyksZS52aWV3RnJvbT1mKTooZS52aWV3RnJvbT5mP2Uudmlldz1FYyhhLGYsZS52aWV3RnJvbSkuY29uY2F0KGUudmlldyk6ZS52aWV3RnJvbTxmJiYoZS52aWV3PWUudmlldy5zbGljZShiYihhLGYpKSksZS52aWV3RnJvbT1mLGUudmlld1RvPGc/ZS52aWV3PWUudmlldy5jb25jYXQoRWMoYSxlLnZpZXdUbyxnKSk6ZS52aWV3VG8+XG5nJiYoZS52aWV3PWUudmlldy5zbGljZSgwLGJiKGEsZykpKSk7ZS52aWV3VG89ZztkLnZpZXdPZmZzZXQ9R2EodyhhLmRvYyxkLnZpZXdGcm9tKSk7YS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcD1kLnZpZXdPZmZzZXQrXCJweFwiO2c9Y2YoYSk7aWYoIWMmJjA9PWcmJiFiLmZvcmNlJiZkLnJlbmRlcmVkVmlldz09ZC52aWV3JiYobnVsbD09ZC51cGRhdGVMaW5lTnVtYmVyc3x8ZC51cGRhdGVMaW5lTnVtYmVycz49ZC52aWV3VG8pKXJldHVybiExO2EuaGFzRm9jdXMoKT9mPW51bGw6KGY9dmEoKSkmJmthKGEuZGlzcGxheS5saW5lRGl2LGYpPyhmPXthY3RpdmVFbHQ6Zn0sd2luZG93LmdldFNlbGVjdGlvbiYmKGU9d2luZG93LmdldFNlbGVjdGlvbigpLGUuYW5jaG9yTm9kZSYmZS5leHRlbmQmJmthKGEuZGlzcGxheS5saW5lRGl2LGUuYW5jaG9yTm9kZSkmJihmLmFuY2hvck5vZGU9ZS5hbmNob3JOb2RlLGYuYW5jaG9yT2Zmc2V0PWUuYW5jaG9yT2Zmc2V0LGYuZm9jdXNOb2RlPWUuZm9jdXNOb2RlLFxuZi5mb2N1c09mZnNldD1lLmZvY3VzT2Zmc2V0KSkpOmY9bnVsbDs0PGcmJihkLmxpbmVEaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIik7V2coYSxkLnVwZGF0ZUxpbmVOdW1iZXJzLGIuZGltcyk7NDxnJiYoZC5saW5lRGl2LnN0eWxlLmRpc3BsYXk9XCJcIik7ZC5yZW5kZXJlZFZpZXc9ZC52aWV3OyhnPWYpJiZnLmFjdGl2ZUVsdCYmZy5hY3RpdmVFbHQhPXZhKCkmJihnLmFjdGl2ZUVsdC5mb2N1cygpLCEvXihJTlBVVHxURVhUQVJFQSkkLy50ZXN0KGcuYWN0aXZlRWx0Lm5vZGVOYW1lKSYmZy5hbmNob3JOb2RlJiZrYShkb2N1bWVudC5ib2R5LGcuYW5jaG9yTm9kZSkmJmthKGRvY3VtZW50LmJvZHksZy5mb2N1c05vZGUpJiYoZj13aW5kb3cuZ2V0U2VsZWN0aW9uKCksZT1kb2N1bWVudC5jcmVhdGVSYW5nZSgpLGUuc2V0RW5kKGcuYW5jaG9yTm9kZSxnLmFuY2hvck9mZnNldCksZS5jb2xsYXBzZSghMSksZi5yZW1vdmVBbGxSYW5nZXMoKSxmLmFkZFJhbmdlKGUpLGYuZXh0ZW5kKGcuZm9jdXNOb2RlLFxuZy5mb2N1c09mZnNldCkpKTtFKGQuY3Vyc29yRGl2KTtFKGQuc2VsZWN0aW9uRGl2KTtkLmd1dHRlcnMuc3R5bGUuaGVpZ2h0PWQuc2l6ZXIuc3R5bGUubWluSGVpZ2h0PTA7YyYmKGQubGFzdFdyYXBIZWlnaHQ9Yi53cmFwcGVySGVpZ2h0LGQubGFzdFdyYXBXaWR0aD1iLndyYXBwZXJXaWR0aCxXYihhLDQwMCkpO2QudXBkYXRlTGluZU51bWJlcnM9bnVsbDtyZXR1cm4hMH1mdW5jdGlvbiBwZihhLGIpe2Zvcih2YXIgZD1iLnZpZXdwb3J0LGM9ITA7O2M9ITEpe2lmKGMmJmEub3B0aW9ucy5saW5lV3JhcHBpbmcmJmIub2xkRGlzcGxheVdpZHRoIT1hYihhKSljJiYoYi52aXNpYmxlPUxjKGEuZGlzcGxheSxhLmRvYyxkKSk7ZWxzZSBpZihkJiZudWxsIT1kLnRvcCYmKGQ9e3RvcDpNYXRoLm1pbihhLmRvYy5oZWlnaHQrQWQoYS5kaXNwbGF5KS1CZChhKSxkLnRvcCl9KSxiLnZpc2libGU9TGMoYS5kaXNwbGF5LGEuZG9jLGQpLGIudmlzaWJsZS5mcm9tPj1hLmRpc3BsYXkudmlld0Zyb20mJlxuYi52aXNpYmxlLnRvPD1hLmRpc3BsYXkudmlld1RvKWJyZWFrO2lmKCFSZChhLGIpKWJyZWFrO0tjKGEpO2M9WGIoYSk7VGIoYSk7d2IoYSxjKTtTZChhLGMpO2IuZm9yY2U9ITF9Yi5zaWduYWwoYSxcInVwZGF0ZVwiLGEpO2lmKGEuZGlzcGxheS52aWV3RnJvbSE9YS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb218fGEuZGlzcGxheS52aWV3VG8hPWEuZGlzcGxheS5yZXBvcnRlZFZpZXdUbyliLnNpZ25hbChhLFwidmlld3BvcnRDaGFuZ2VcIixhLGEuZGlzcGxheS52aWV3RnJvbSxhLmRpc3BsYXkudmlld1RvKSxhLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbT1hLmRpc3BsYXkudmlld0Zyb20sYS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvPWEuZGlzcGxheS52aWV3VG99ZnVuY3Rpb24gUWQoYSxiKXtiPW5ldyBPYyhhLGIpO2lmKFJkKGEsYikpe0tjKGEpO3BmKGEsYik7dmFyIGQ9WGIoYSk7VGIoYSk7d2IoYSxkKTtTZChhLGQpO2IuZmluaXNoKCl9fWZ1bmN0aW9uIFdnKGEsYixkKXtmdW5jdGlvbiBjKG4pe3ZhciBwPVxubi5uZXh0U2libGluZztmYSYmeWEmJmEuZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQ9PW4/bi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiOm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKTtyZXR1cm4gcH12YXIgZT1hLmRpc3BsYXksZj1hLm9wdGlvbnMubGluZU51bWJlcnMsZz1lLmxpbmVEaXYsaD1nLmZpcnN0Q2hpbGQsaz1lLnZpZXc7ZT1lLnZpZXdGcm9tO2Zvcih2YXIgbD0wO2w8ay5sZW5ndGg7bCsrKXt2YXIgbT1rW2xdO2lmKCFtLmhpZGRlbilpZihtLm5vZGUmJm0ubm9kZS5wYXJlbnROb2RlPT1nKXtmb3IoO2ghPW0ubm9kZTspaD1jKGgpO2g9ZiYmbnVsbCE9YiYmYjw9ZSYmbS5saW5lTnVtYmVyO20uY2hhbmdlcyYmKC0xPGVhKG0uY2hhbmdlcyxcImd1dHRlclwiKSYmKGg9ITEpLExlKGEsbSxlLGQpKTtoJiYoRShtLmxpbmVOdW1iZXIpLG0ubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvZChhLm9wdGlvbnMsZSkpKSk7aD1tLm5vZGUubmV4dFNpYmxpbmd9ZWxzZXt2YXIgcT1cbk9nKGEsbSxlLGQpO2cuaW5zZXJ0QmVmb3JlKHEsaCl9ZSs9bS5zaXplfWZvcig7aDspaD1jKGgpfWZ1bmN0aW9uIFRkKGEpe2Euc2l6ZXIuc3R5bGUubWFyZ2luTGVmdD1hLmd1dHRlcnMub2Zmc2V0V2lkdGgrXCJweFwifWZ1bmN0aW9uIFNkKGEsYil7YS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodD1iLmRvY0hlaWdodCtcInB4XCI7YS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3A9Yi5kb2NIZWlnaHQrXCJweFwiO2EuZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodD1iLmRvY0hlaWdodCthLmRpc3BsYXkuYmFySGVpZ2h0K0hhKGEpK1wicHhcIn1mdW5jdGlvbiBsZihhKXt2YXIgYj1hLmRpc3BsYXksZD1iLnZpZXc7aWYoYi5hbGlnbldpZGdldHN8fGIuZ3V0dGVycy5maXJzdENoaWxkJiZhLm9wdGlvbnMuZml4ZWRHdXR0ZXIpe2Zvcih2YXIgYz1LZChiKS1iLnNjcm9sbGVyLnNjcm9sbExlZnQrYS5kb2Muc2Nyb2xsTGVmdCxlPWIuZ3V0dGVycy5vZmZzZXRXaWR0aCxmPWMrXG5cInB4XCIsZz0wO2c8ZC5sZW5ndGg7ZysrKWlmKCFkW2ddLmhpZGRlbil7YS5vcHRpb25zLmZpeGVkR3V0dGVyJiYoZFtnXS5ndXR0ZXImJihkW2ddLmd1dHRlci5zdHlsZS5sZWZ0PWYpLGRbZ10uZ3V0dGVyQmFja2dyb3VuZCYmKGRbZ10uZ3V0dGVyQmFja2dyb3VuZC5zdHlsZS5sZWZ0PWYpKTt2YXIgaD1kW2ddLmFsaWduYWJsZTtpZihoKWZvcih2YXIgaz0wO2s8aC5sZW5ndGg7aysrKWhba10uc3R5bGUubGVmdD1mfWEub3B0aW9ucy5maXhlZEd1dHRlciYmKGIuZ3V0dGVycy5zdHlsZS5sZWZ0PWMrZStcInB4XCIpfX1mdW5jdGlvbiBxZihhKXtpZighYS5vcHRpb25zLmxpbmVOdW1iZXJzKXJldHVybiExO3ZhciBiPWEuZG9jO2I9b2QoYS5vcHRpb25zLGIuZmlyc3QrYi5zaXplLTEpO3ZhciBkPWEuZGlzcGxheTtpZihiLmxlbmd0aCE9ZC5saW5lTnVtQ2hhcnMpe3ZhciBjPWQubWVhc3VyZS5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsW3YoXCJkaXZcIixiKV0sXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIpKSxcbmU9Yy5maXJzdENoaWxkLm9mZnNldFdpZHRoO2M9Yy5vZmZzZXRXaWR0aC1lO2QubGluZUd1dHRlci5zdHlsZS53aWR0aD1cIlwiO2QubGluZU51bUlubmVyV2lkdGg9TWF0aC5tYXgoZSxkLmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGgtYykrMTtkLmxpbmVOdW1XaWR0aD1kLmxpbmVOdW1Jbm5lcldpZHRoK2M7ZC5saW5lTnVtQ2hhcnM9ZC5saW5lTnVtSW5uZXJXaWR0aD9iLmxlbmd0aDotMTtkLmxpbmVHdXR0ZXIuc3R5bGUud2lkdGg9ZC5saW5lTnVtV2lkdGgrXCJweFwiO1RkKGEuZGlzcGxheSk7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gVWQoYSxiKXtmb3IodmFyIGQ9W10sYz0hMSxlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBmPWFbZV0sZz1udWxsO1wic3RyaW5nXCIhPXR5cGVvZiBmJiYoZz1mLnN0eWxlLGY9Zi5jbGFzc05hbWUpO2lmKFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiPT1mKWlmKGIpYz0hMDtlbHNlIGNvbnRpbnVlO2QucHVzaCh7Y2xhc3NOYW1lOmYsc3R5bGU6Z30pfWImJlxuIWMmJmQucHVzaCh7Y2xhc3NOYW1lOlwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiLHN0eWxlOm51bGx9KTtyZXR1cm4gZH1mdW5jdGlvbiByZihhKXt2YXIgYj1hLmd1dHRlcnMsZD1hLmd1dHRlclNwZWNzO0UoYik7YS5saW5lR3V0dGVyPW51bGw7Zm9yKHZhciBjPTA7YzxkLmxlbmd0aDsrK2Mpe3ZhciBlPWRbY10sZj1lLmNsYXNzTmFtZTtlPWUuc3R5bGU7dmFyIGc9Yi5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyIFwiK2YpKTtlJiYoZy5zdHlsZS5jc3NUZXh0PWUpO1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiPT1mJiYoYS5saW5lR3V0dGVyPWcsZy5zdHlsZS53aWR0aD0oYS5saW5lTnVtV2lkdGh8fDEpK1wicHhcIil9Yi5zdHlsZS5kaXNwbGF5PWQubGVuZ3RoP1wiXCI6XCJub25lXCI7VGQoYSl9ZnVuY3Rpb24gWWIoYSl7cmYoYS5kaXNwbGF5KTttYShhKTtsZihhKX1mdW5jdGlvbiBYZyhhLGIsZCxjKXt0aGlzLmlucHV0PWQ7dGhpcy5zY3JvbGxiYXJGaWxsZXI9XG52KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclwiKTt0aGlzLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLFwidHJ1ZVwiKTt0aGlzLmd1dHRlckZpbGxlcj12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclwiKTt0aGlzLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLFwidHJ1ZVwiKTt0aGlzLmxpbmVEaXY9SyhcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWNvZGVcIik7dGhpcy5zZWxlY3Rpb25EaXY9dihcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVwiKTt0aGlzLmN1cnNvckRpdj12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKTt0aGlzLm1lYXN1cmU9dihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7dGhpcy5saW5lTWVhc3VyZT12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTt0aGlzLmxpbmVTcGFjZT1LKFwiZGl2XCIsXG5bdGhpcy5tZWFzdXJlLHRoaXMubGluZU1lYXN1cmUsdGhpcy5zZWxlY3Rpb25EaXYsdGhpcy5jdXJzb3JEaXYsdGhpcy5saW5lRGl2XSxudWxsLFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXCIpO3ZhciBlPUsoXCJkaXZcIixbdGhpcy5saW5lU3BhY2VdLFwiQ29kZU1pcnJvci1saW5lc1wiKTt0aGlzLm1vdmVyPXYoXCJkaXZcIixbZV0sbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTt0aGlzLnNpemVyPXYoXCJkaXZcIixbdGhpcy5tb3Zlcl0sXCJDb2RlTWlycm9yLXNpemVyXCIpO3RoaXMuc2l6ZXJXaWR0aD1udWxsO3RoaXMuaGVpZ2h0Rm9yY2VyPXYoXCJkaXZcIixudWxsLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogNTBweDsgd2lkdGg6IDFweDtcIik7dGhpcy5ndXR0ZXJzPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO3RoaXMubGluZUd1dHRlcj1udWxsO3RoaXMuc2Nyb2xsZXI9dihcImRpdlwiLFt0aGlzLnNpemVyLHRoaXMuaGVpZ2h0Rm9yY2VyLHRoaXMuZ3V0dGVyc10sXG5cIkNvZGVNaXJyb3Itc2Nyb2xsXCIpO3RoaXMuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIixcIi0xXCIpO3RoaXMud3JhcHBlcj12KFwiZGl2XCIsW3RoaXMuc2Nyb2xsYmFyRmlsbGVyLHRoaXMuZ3V0dGVyRmlsbGVyLHRoaXMuc2Nyb2xsZXJdLFwiQ29kZU1pcnJvclwiKTtHJiY4PlUmJih0aGlzLmd1dHRlcnMuc3R5bGUuekluZGV4PS0xLHRoaXMuc2Nyb2xsZXIuc3R5bGUucGFkZGluZ1JpZ2h0PTApO2ZhfHxNYSYmWmJ8fCh0aGlzLnNjcm9sbGVyLmRyYWdnYWJsZT0hMCk7YSYmKGEuYXBwZW5kQ2hpbGQ/YS5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpOmEodGhpcy53cmFwcGVyKSk7dGhpcy5yZXBvcnRlZFZpZXdGcm9tPXRoaXMucmVwb3J0ZWRWaWV3VG89dGhpcy52aWV3RnJvbT10aGlzLnZpZXdUbz1iLmZpcnN0O3RoaXMudmlldz1bXTt0aGlzLmV4dGVybmFsTWVhc3VyZWQ9dGhpcy5yZW5kZXJlZFZpZXc9bnVsbDt0aGlzLmxhc3RXcmFwSGVpZ2h0PXRoaXMubGFzdFdyYXBXaWR0aD1cbnRoaXMudmlld09mZnNldD0wO3RoaXMudXBkYXRlTGluZU51bWJlcnM9bnVsbDt0aGlzLm5hdGl2ZUJhcldpZHRoPXRoaXMuYmFySGVpZ2h0PXRoaXMuYmFyV2lkdGg9MDt0aGlzLnNjcm9sbGJhcnNDbGlwcGVkPSExO3RoaXMubGluZU51bVdpZHRoPXRoaXMubGluZU51bUlubmVyV2lkdGg9dGhpcy5saW5lTnVtQ2hhcnM9bnVsbDt0aGlzLmFsaWduV2lkZ2V0cz0hMTt0aGlzLm1heExpbmU9dGhpcy5jYWNoZWRDaGFyV2lkdGg9dGhpcy5jYWNoZWRUZXh0SGVpZ2h0PXRoaXMuY2FjaGVkUGFkZGluZ0g9bnVsbDt0aGlzLm1heExpbmVMZW5ndGg9MDt0aGlzLm1heExpbmVDaGFuZ2VkPSExO3RoaXMud2hlZWxEWD10aGlzLndoZWVsRFk9dGhpcy53aGVlbFN0YXJ0WD10aGlzLndoZWVsU3RhcnRZPW51bGw7dGhpcy5zaGlmdD0hMTt0aGlzLmFjdGl2ZVRvdWNoPXRoaXMuc2VsRm9yQ29udGV4dE1lbnU9bnVsbDt0aGlzLmd1dHRlclNwZWNzPVVkKGMuZ3V0dGVycyxjLmxpbmVOdW1iZXJzKTtcbnJmKHRoaXMpO2QuaW5pdCh0aGlzKX1mdW5jdGlvbiBzZihhKXt2YXIgYj1hLndoZWVsRGVsdGFYLGQ9YS53aGVlbERlbHRhWTtudWxsPT1iJiZhLmRldGFpbCYmYS5heGlzPT1hLkhPUklaT05UQUxfQVhJUyYmKGI9YS5kZXRhaWwpO251bGw9PWQmJmEuZGV0YWlsJiZhLmF4aXM9PWEuVkVSVElDQUxfQVhJUz9kPWEuZGV0YWlsOm51bGw9PWQmJihkPWEud2hlZWxEZWx0YSk7cmV0dXJue3g6Yix5OmR9fWZ1bmN0aW9uIFlnKGEpe2E9c2YoYSk7YS54Kj10YTthLnkqPXRhO3JldHVybiBhfWZ1bmN0aW9uIHRmKGEsYil7dmFyIGQ9c2YoYiksYz1kLng7ZD1kLnk7dmFyIGU9YS5kaXNwbGF5LGY9ZS5zY3JvbGxlcixnPWYuc2Nyb2xsV2lkdGg+Zi5jbGllbnRXaWR0aCxoPWYuc2Nyb2xsSGVpZ2h0PmYuY2xpZW50SGVpZ2h0O2lmKGMmJmd8fGQmJmgpe2lmKGQmJnlhJiZmYSl7Zz1iLnRhcmdldDt2YXIgaz1lLnZpZXc7YTpmb3IoO2chPWY7Zz1nLnBhcmVudE5vZGUpZm9yKHZhciBsPTA7bDxcbmsubGVuZ3RoO2wrKylpZihrW2xdLm5vZGU9PWcpe2EuZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQ9ZzticmVhayBhfX0hY3x8TWF8fEJhfHxudWxsPT10YT8oZCYmbnVsbCE9dGEmJihiPWQqdGEsaD1hLmRvYy5zY3JvbGxUb3AsZz1oK2Uud3JhcHBlci5jbGllbnRIZWlnaHQsMD5iP2g9TWF0aC5tYXgoMCxoK2ItNTApOmc9TWF0aC5taW4oYS5kb2MuaGVpZ2h0LGcrYis1MCksUWQoYSx7dG9wOmgsYm90dG9tOmd9KSksMjA+UGMmJihudWxsPT1lLndoZWVsU3RhcnRYPyhlLndoZWVsU3RhcnRYPWYuc2Nyb2xsTGVmdCxlLndoZWVsU3RhcnRZPWYuc2Nyb2xsVG9wLGUud2hlZWxEWD1jLGUud2hlZWxEWT1kLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihudWxsIT1lLndoZWVsU3RhcnRYKXt2YXIgbT1mLnNjcm9sbExlZnQtZS53aGVlbFN0YXJ0WCxxPWYuc2Nyb2xsVG9wLWUud2hlZWxTdGFydFk7bT1xJiZlLndoZWVsRFkmJnEvZS53aGVlbERZfHxtJiZlLndoZWVsRFgmJm0vZS53aGVlbERYO1xuZS53aGVlbFN0YXJ0WD1lLndoZWVsU3RhcnRZPW51bGw7bSYmKHRhPSh0YSpQYyttKS8oUGMrMSksKytQYyl9fSwyMDApKTooZS53aGVlbERYKz1jLGUud2hlZWxEWSs9ZCkpKTooZCYmaCYmVmIoYSxNYXRoLm1heCgwLGYuc2Nyb2xsVG9wK2QqdGEpKSxpYihhLE1hdGgubWF4KDAsZi5zY3JvbGxMZWZ0K2MqdGEpKSwoIWR8fGQmJmgpJiZsYShiKSxlLndoZWVsU3RhcnRYPW51bGwpfX1mdW5jdGlvbiBDYShhLGIsZCl7YT1hJiZhLm9wdGlvbnMuc2VsZWN0aW9uc01heVRvdWNoO2Q9YltkXTtiLnNvcnQoZnVuY3Rpb24oayxsKXtyZXR1cm4gQihrLmZyb20oKSxsLmZyb20oKSl9KTtkPWVhKGIsZCk7Zm9yKHZhciBjPTE7YzxiLmxlbmd0aDtjKyspe3ZhciBlPWJbY10sZj1iW2MtMV0sZz1CKGYudG8oKSxlLmZyb20oKSk7aWYoYSYmIWUuZW1wdHkoKT8wPGc6MDw9Zyl7Zz1BYyhmLmZyb20oKSxlLmZyb20oKSk7dmFyIGg9emMoZi50bygpLGUudG8oKSk7ZT1mLmVtcHR5KCk/ZS5mcm9tKCk9PVxuZS5oZWFkOmYuZnJvbSgpPT1mLmhlYWQ7Yzw9ZCYmLS1kO2Iuc3BsaWNlKC0tYywyLG5ldyBKKGU/aDpnLGU/ZzpoKSl9fXJldHVybiBuZXcgdWEoYixkKX1mdW5jdGlvbiBOYShhLGIpe3JldHVybiBuZXcgdWEoW25ldyBKKGEsYnx8YSldLDApfWZ1bmN0aW9uIFJhKGEpe3JldHVybiBhLnRleHQ/dChhLmZyb20ubGluZSthLnRleHQubGVuZ3RoLTEsTChhLnRleHQpLmxlbmd0aCsoMT09YS50ZXh0Lmxlbmd0aD9hLmZyb20uY2g6MCkpOmEudG99ZnVuY3Rpb24gdWYoYSxiKXtpZigwPkIoYSxiLmZyb20pKXJldHVybiBhO2lmKDA+PUIoYSxiLnRvKSlyZXR1cm4gUmEoYik7dmFyIGQ9YS5saW5lK2IudGV4dC5sZW5ndGgtKGIudG8ubGluZS1iLmZyb20ubGluZSktMSxjPWEuY2g7YS5saW5lPT1iLnRvLmxpbmUmJihjKz1SYShiKS5jaC1iLnRvLmNoKTtyZXR1cm4gdChkLGMpfWZ1bmN0aW9uIFZkKGEsYil7Zm9yKHZhciBkPVtdLGM9MDtjPGEuc2VsLnJhbmdlcy5sZW5ndGg7YysrKXt2YXIgZT1cbmEuc2VsLnJhbmdlc1tjXTtkLnB1c2gobmV3IEoodWYoZS5hbmNob3IsYiksdWYoZS5oZWFkLGIpKSl9cmV0dXJuIENhKGEuY20sZCxhLnNlbC5wcmltSW5kZXgpfWZ1bmN0aW9uIHZmKGEsYixkKXtyZXR1cm4gYS5saW5lPT1iLmxpbmU/dChkLmxpbmUsYS5jaC1iLmNoK2QuY2gpOnQoZC5saW5lKyhhLmxpbmUtYi5saW5lKSxhLmNoKX1mdW5jdGlvbiBXZChhKXthLmRvYy5tb2RlPWxkKGEub3B0aW9ucyxhLmRvYy5tb2RlT3B0aW9uKTskYihhKX1mdW5jdGlvbiAkYihhKXthLmRvYy5pdGVyKGZ1bmN0aW9uKGIpe2Iuc3RhdGVBZnRlciYmKGIuc3RhdGVBZnRlcj1udWxsKTtiLnN0eWxlcyYmKGIuc3R5bGVzPW51bGwpfSk7YS5kb2MubW9kZUZyb250aWVyPWEuZG9jLmhpZ2hsaWdodEZyb250aWVyPWEuZG9jLmZpcnN0O1diKGEsMTAwKTthLnN0YXRlLm1vZGVHZW4rKzthLmN1ck9wJiZtYShhKX1mdW5jdGlvbiB3ZihhLGIpe3JldHVybiAwPT1iLmZyb20uY2gmJjA9PWIudG8uY2gmJlxuXCJcIj09TChiLnRleHQpJiYoIWEuY218fGEuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpfWZ1bmN0aW9uIFhkKGEsYixkLGMpe2Z1bmN0aW9uIGUocix1LEEpe3IudGV4dD11O3Iuc3RhdGVBZnRlciYmKHIuc3RhdGVBZnRlcj1udWxsKTtyLnN0eWxlcyYmKHIuc3R5bGVzPW51bGwpO251bGwhPXIub3JkZXImJihyLm9yZGVyPW51bGwpO0RlKHIpO0VlKHIsQSk7dT1jP2Mocik6MTt1IT1yLmhlaWdodCYmRGEocix1KTtjYShyLFwiY2hhbmdlXCIscixiKX1mdW5jdGlvbiBmKHIsdSl7Zm9yKHZhciBBPVtdO3I8dTsrK3IpQS5wdXNoKG5ldyB4YihrW3JdLGQ/ZFtyXTpudWxsLGMpKTtyZXR1cm4gQX12YXIgZz1iLmZyb20saD1iLnRvLGs9Yi50ZXh0LGw9dyhhLGcubGluZSksbT13KGEsaC5saW5lKSxxPUwoayksbj1kP2Rbay5sZW5ndGgtMV06bnVsbCxwPWgubGluZS1nLmxpbmU7Yi5mdWxsPyhhLmluc2VydCgwLGYoMCxrLmxlbmd0aCkpLGEucmVtb3ZlKGsubGVuZ3RoLGEuc2l6ZS1cbmsubGVuZ3RoKSk6d2YoYSxiKT8oaD1mKDAsay5sZW5ndGgtMSksZShtLG0udGV4dCxuKSxwJiZhLnJlbW92ZShnLmxpbmUscCksaC5sZW5ndGgmJmEuaW5zZXJ0KGcubGluZSxoKSk6bD09bT8xPT1rLmxlbmd0aD9lKGwsbC50ZXh0LnNsaWNlKDAsZy5jaCkrcStsLnRleHQuc2xpY2UoaC5jaCksbik6KHA9ZigxLGsubGVuZ3RoLTEpLHAucHVzaChuZXcgeGIocStsLnRleHQuc2xpY2UoaC5jaCksbixjKSksZShsLGwudGV4dC5zbGljZSgwLGcuY2gpK2tbMF0sZD9kWzBdOm51bGwpLGEuaW5zZXJ0KGcubGluZSsxLHApKToxPT1rLmxlbmd0aD8oZShsLGwudGV4dC5zbGljZSgwLGcuY2gpK2tbMF0rbS50ZXh0LnNsaWNlKGguY2gpLGQ/ZFswXTpudWxsKSxhLnJlbW92ZShnLmxpbmUrMSxwKSk6KGUobCxsLnRleHQuc2xpY2UoMCxnLmNoKStrWzBdLGQ/ZFswXTpudWxsKSxlKG0scSttLnRleHQuc2xpY2UoaC5jaCksbiksbj1mKDEsay5sZW5ndGgtMSksMTxwJiZhLnJlbW92ZShnLmxpbmUrXG4xLHAtMSksYS5pbnNlcnQoZy5saW5lKzEsbikpO2NhKGEsXCJjaGFuZ2VcIixhLGIpfWZ1bmN0aW9uIFNhKGEsYixkKXtmdW5jdGlvbiBjKGUsZixnKXtpZihlLmxpbmtlZClmb3IodmFyIGg9MDtoPGUubGlua2VkLmxlbmd0aDsrK2gpe3ZhciBrPWUubGlua2VkW2hdO2lmKGsuZG9jIT1mKXt2YXIgbD1nJiZrLnNoYXJlZEhpc3Q7aWYoIWR8fGwpYihrLmRvYyxsKSxjKGsuZG9jLGUsbCl9fX1jKGEsbnVsbCwhMCl9ZnVuY3Rpb24geGYoYSxiKXtpZihiLmNtKXRocm93IEVycm9yKFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cIik7YS5kb2M9YjtiLmNtPWE7TGQoYSk7V2QoYSk7eWYoYSk7YS5vcHRpb25zLmxpbmVXcmFwcGluZ3x8eGQoYSk7YS5vcHRpb25zLm1vZGU9Yi5tb2RlT3B0aW9uO21hKGEpfWZ1bmN0aW9uIHlmKGEpeyhcInJ0bFwiPT1hLmRvYy5kaXJlY3Rpb24/V2E6aGIpKGEuZGlzcGxheS5saW5lRGl2LFwiQ29kZU1pcnJvci1ydGxcIil9ZnVuY3Rpb24gWmcoYSl7cGEoYSxcbmZ1bmN0aW9uKCl7eWYoYSk7bWEoYSl9KX1mdW5jdGlvbiBRYyhhKXt0aGlzLmRvbmU9W107dGhpcy51bmRvbmU9W107dGhpcy51bmRvRGVwdGg9SW5maW5pdHk7dGhpcy5sYXN0TW9kVGltZT10aGlzLmxhc3RTZWxUaW1lPTA7dGhpcy5sYXN0T3JpZ2luPXRoaXMubGFzdFNlbE9yaWdpbj10aGlzLmxhc3RPcD10aGlzLmxhc3RTZWxPcD1udWxsO3RoaXMuZ2VuZXJhdGlvbj10aGlzLm1heEdlbmVyYXRpb249YXx8MX1mdW5jdGlvbiBZZChhLGIpe3ZhciBkPXtmcm9tOnFkKGIuZnJvbSksdG86UmEoYiksdGV4dDpaYShhLGIuZnJvbSxiLnRvKX07emYoYSxkLGIuZnJvbS5saW5lLGIudG8ubGluZSsxKTtTYShhLGZ1bmN0aW9uKGMpe3JldHVybiB6ZihjLGQsYi5mcm9tLmxpbmUsYi50by5saW5lKzEpfSwhMCk7cmV0dXJuIGR9ZnVuY3Rpb24gQWYoYSl7Zm9yKDthLmxlbmd0aDspaWYoTChhKS5yYW5nZXMpYS5wb3AoKTtlbHNlIGJyZWFrfWZ1bmN0aW9uIEJmKGEsYixkLGMpe3ZhciBlPVxuYS5oaXN0b3J5O2UudW5kb25lLmxlbmd0aD0wO3ZhciBmPStuZXcgRGF0ZSxnO2lmKGc9ZS5sYXN0T3A9PWN8fGUubGFzdE9yaWdpbj09Yi5vcmlnaW4mJmIub3JpZ2luJiYoXCIrXCI9PWIub3JpZ2luLmNoYXJBdCgwKSYmZS5sYXN0TW9kVGltZT5mLShhLmNtP2EuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheTo1MDApfHxcIipcIj09Yi5vcmlnaW4uY2hhckF0KDApKSl7aWYoZS5sYXN0T3A9PWMpe0FmKGUuZG9uZSk7dmFyIGg9TChlLmRvbmUpfWVsc2UgZS5kb25lLmxlbmd0aCYmIUwoZS5kb25lKS5yYW5nZXM/aD1MKGUuZG9uZSk6MTxlLmRvbmUubGVuZ3RoJiYhZS5kb25lW2UuZG9uZS5sZW5ndGgtMl0ucmFuZ2VzPyhlLmRvbmUucG9wKCksaD1MKGUuZG9uZSkpOmg9dm9pZCAwO2c9aH1pZihnKXt2YXIgaz1MKGguY2hhbmdlcyk7MD09QihiLmZyb20sYi50bykmJjA9PUIoYi5mcm9tLGsudG8pP2sudG89UmEoYik6aC5jaGFuZ2VzLnB1c2goWWQoYSxiKSl9ZWxzZSBmb3IoKGg9TChlLmRvbmUpKSYmXG5oLnJhbmdlc3x8UmMoYS5zZWwsZS5kb25lKSxoPXtjaGFuZ2VzOltZZChhLGIpXSxnZW5lcmF0aW9uOmUuZ2VuZXJhdGlvbn0sZS5kb25lLnB1c2goaCk7ZS5kb25lLmxlbmd0aD5lLnVuZG9EZXB0aDspZS5kb25lLnNoaWZ0KCksZS5kb25lWzBdLnJhbmdlc3x8ZS5kb25lLnNoaWZ0KCk7ZS5kb25lLnB1c2goZCk7ZS5nZW5lcmF0aW9uPSsrZS5tYXhHZW5lcmF0aW9uO2UubGFzdE1vZFRpbWU9ZS5sYXN0U2VsVGltZT1mO2UubGFzdE9wPWUubGFzdFNlbE9wPWM7ZS5sYXN0T3JpZ2luPWUubGFzdFNlbE9yaWdpbj1iLm9yaWdpbjtrfHxYKGEsXCJoaXN0b3J5QWRkZWRcIil9ZnVuY3Rpb24gUmMoYSxiKXt2YXIgZD1MKGIpO2QmJmQucmFuZ2VzJiZkLmVxdWFscyhhKXx8Yi5wdXNoKGEpfWZ1bmN0aW9uIHpmKGEsYixkLGMpe3ZhciBlPWJbXCJzcGFuc19cIithLmlkXSxmPTA7YS5pdGVyKE1hdGgubWF4KGEuZmlyc3QsZCksTWF0aC5taW4oYS5maXJzdCthLnNpemUsYyksZnVuY3Rpb24oZyl7Zy5tYXJrZWRTcGFucyYmXG4oKGV8fChlPWJbXCJzcGFuc19cIithLmlkXT17fSkpW2ZdPWcubWFya2VkU3BhbnMpOysrZn0pfWZ1bmN0aW9uICRnKGEpe2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYixkPTA7ZDxhLmxlbmd0aDsrK2QpYVtkXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQ/Ynx8KGI9YS5zbGljZSgwLGQpKTpiJiZiLnB1c2goYVtkXSk7cmV0dXJuIGI/Yi5sZW5ndGg/YjpudWxsOmF9ZnVuY3Rpb24gQ2YoYSxiKXt2YXIgZDtpZihkPWJbXCJzcGFuc19cIithLmlkXSl7Zm9yKHZhciBjPVtdLGU9MDtlPGIudGV4dC5sZW5ndGg7KytlKWMucHVzaCgkZyhkW2VdKSk7ZD1jfWVsc2UgZD1udWxsO2E9dGQoYSxiKTtpZighZClyZXR1cm4gYTtpZighYSlyZXR1cm4gZDtmb3IoYj0wO2I8ZC5sZW5ndGg7KytiKWlmKGM9ZFtiXSxlPWFbYl0sYyYmZSl7dmFyIGY9MDthOmZvcig7ZjxlLmxlbmd0aDsrK2Ype2Zvcih2YXIgZz1lW2ZdLGg9MDtoPGMubGVuZ3RoOysraClpZihjW2hdLm1hcmtlcj09Zy5tYXJrZXIpY29udGludWUgYTtcbmMucHVzaChnKX19ZWxzZSBlJiYoZFtiXT1lKTtyZXR1cm4gZH1mdW5jdGlvbiB5YihhLGIsZCl7Zm9yKHZhciBjPVtdLGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZihmLnJhbmdlcyljLnB1c2goZD91YS5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChmKTpmKTtlbHNle2Y9Zi5jaGFuZ2VzO3ZhciBnPVtdO2MucHVzaCh7Y2hhbmdlczpnfSk7Zm9yKHZhciBoPTA7aDxmLmxlbmd0aDsrK2gpe3ZhciBrPWZbaF0sbDtnLnB1c2goe2Zyb206ay5mcm9tLHRvOmsudG8sdGV4dDprLnRleHR9KTtpZihiKWZvcih2YXIgbSBpbiBrKShsPW0ubWF0Y2goL15zcGFuc18oXFxkKykkLykpJiYtMTxlYShiLE51bWJlcihsWzFdKSkmJihMKGcpW21dPWtbbV0sZGVsZXRlIGtbbV0pfX19cmV0dXJuIGN9ZnVuY3Rpb24gWmQoYSxiLGQsYyl7cmV0dXJuIGM/KGE9YS5hbmNob3IsZCYmKGM9MD5CKGIsYSksYyE9MD5CKGQsYSk/KGE9YixiPWQpOmMhPTA+QihiLGQpJiYoYj1kKSksbmV3IEooYSxcbmIpKTpuZXcgSihkfHxiLGIpfWZ1bmN0aW9uIFNjKGEsYixkLGMsZSl7bnVsbD09ZSYmKGU9YS5jbSYmKGEuY20uZGlzcGxheS5zaGlmdHx8YS5leHRlbmQpKTtkYShhLG5ldyB1YShbWmQoYS5zZWwucHJpbWFyeSgpLGIsZCxlKV0sMCksYyl9ZnVuY3Rpb24gRGYoYSxiLGQpe2Zvcih2YXIgYz1bXSxlPWEuY20mJihhLmNtLmRpc3BsYXkuc2hpZnR8fGEuZXh0ZW5kKSxmPTA7ZjxhLnNlbC5yYW5nZXMubGVuZ3RoO2YrKyljW2ZdPVpkKGEuc2VsLnJhbmdlc1tmXSxiW2ZdLG51bGwsZSk7Yj1DYShhLmNtLGMsYS5zZWwucHJpbUluZGV4KTtkYShhLGIsZCl9ZnVuY3Rpb24gJGQoYSxiLGQsYyl7dmFyIGU9YS5zZWwucmFuZ2VzLnNsaWNlKDApO2VbYl09ZDtkYShhLENhKGEuY20sZSxhLnNlbC5wcmltSW5kZXgpLGMpfWZ1bmN0aW9uIGFoKGEsYixkKXtkPXtyYW5nZXM6Yi5yYW5nZXMsdXBkYXRlOmZ1bmN0aW9uKGMpe3RoaXMucmFuZ2VzPVtdO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXRoaXMucmFuZ2VzW2VdPVxubmV3IEooQyhhLGNbZV0uYW5jaG9yKSxDKGEsY1tlXS5oZWFkKSl9LG9yaWdpbjpkJiZkLm9yaWdpbn07WChhLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsYSxkKTthLmNtJiZYKGEuY20sXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIixhLmNtLGQpO3JldHVybiBkLnJhbmdlcyE9Yi5yYW5nZXM/Q2EoYS5jbSxkLnJhbmdlcyxkLnJhbmdlcy5sZW5ndGgtMSk6Yn1mdW5jdGlvbiBFZihhLGIsZCl7dmFyIGM9YS5oaXN0b3J5LmRvbmUsZT1MKGMpO2UmJmUucmFuZ2VzPyhjW2MubGVuZ3RoLTFdPWIsVGMoYSxiLGQpKTpkYShhLGIsZCl9ZnVuY3Rpb24gZGEoYSxiLGQpe1RjKGEsYixkKTtiPWEuc2VsO3ZhciBjPWEuY20/YS5jbS5jdXJPcC5pZDpOYU4sZT1hLmhpc3RvcnksZj1kJiZkLm9yaWdpbixnO2lmKCEoZz1jPT1lLmxhc3RTZWxPcCkmJihnPWYmJmUubGFzdFNlbE9yaWdpbj09ZikmJiEoZz1lLmxhc3RNb2RUaW1lPT1lLmxhc3RTZWxUaW1lJiZlLmxhc3RPcmlnaW49PWYpKXtnPUwoZS5kb25lKTtcbnZhciBoPWYuY2hhckF0KDApO2c9XCIqXCI9PWh8fFwiK1wiPT1oJiZnLnJhbmdlcy5sZW5ndGg9PWIucmFuZ2VzLmxlbmd0aCYmZy5zb21ldGhpbmdTZWxlY3RlZCgpPT1iLnNvbWV0aGluZ1NlbGVjdGVkKCkmJm5ldyBEYXRlLWEuaGlzdG9yeS5sYXN0U2VsVGltZTw9KGEuY20/YS5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5OjUwMCl9Zz9lLmRvbmVbZS5kb25lLmxlbmd0aC0xXT1iOlJjKGIsZS5kb25lKTtlLmxhc3RTZWxUaW1lPStuZXcgRGF0ZTtlLmxhc3RTZWxPcmlnaW49ZjtlLmxhc3RTZWxPcD1jO2QmJiExIT09ZC5jbGVhclJlZG8mJkFmKGUudW5kb25lKX1mdW5jdGlvbiBUYyhhLGIsZCl7aWYoeGEoYSxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKXx8YS5jbSYmeGEoYS5jbSxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSliPWFoKGEsYixkKTt2YXIgYz1kJiZkLmJpYXN8fCgwPkIoYi5wcmltYXJ5KCkuaGVhZCxhLnNlbC5wcmltYXJ5KCkuaGVhZCk/LTE6MSk7RmYoYSxHZihhLFxuYixjLCEwKSk7ZCYmITE9PT1kLnNjcm9sbHx8IWEuY218fHZiKGEuY20pfWZ1bmN0aW9uIEZmKGEsYil7Yi5lcXVhbHMoYS5zZWwpfHwoYS5zZWw9YixhLmNtJiYoYS5jbS5jdXJPcC51cGRhdGVJbnB1dD0xLGEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZD0hMCxxZShhLmNtKSksY2EoYSxcImN1cnNvckFjdGl2aXR5XCIsYSkpfWZ1bmN0aW9uIEhmKGEpe0ZmKGEsR2YoYSxhLnNlbCxudWxsLCExKSl9ZnVuY3Rpb24gR2YoYSxiLGQsYyl7Zm9yKHZhciBlLGY9MDtmPGIucmFuZ2VzLmxlbmd0aDtmKyspe3ZhciBnPWIucmFuZ2VzW2ZdLGg9Yi5yYW5nZXMubGVuZ3RoPT1hLnNlbC5yYW5nZXMubGVuZ3RoJiZhLnNlbC5yYW5nZXNbZl0saz1VYyhhLGcuYW5jaG9yLGgmJmguYW5jaG9yLGQsYyk7aD1VYyhhLGcuaGVhZCxoJiZoLmhlYWQsZCxjKTtpZihlfHxrIT1nLmFuY2hvcnx8aCE9Zy5oZWFkKWV8fChlPWIucmFuZ2VzLnNsaWNlKDAsZikpLGVbZl09bmV3IEooayxoKX1yZXR1cm4gZT9cbkNhKGEuY20sZSxiLnByaW1JbmRleCk6Yn1mdW5jdGlvbiB6YihhLGIsZCxjLGUpe3ZhciBmPXcoYSxiLmxpbmUpO2lmKGYubWFya2VkU3BhbnMpZm9yKHZhciBnPTA7ZzxmLm1hcmtlZFNwYW5zLmxlbmd0aDsrK2cpe3ZhciBoPWYubWFya2VkU3BhbnNbZ10saz1oLm1hcmtlcixsPVwic2VsZWN0TGVmdFwiaW4gaz8hay5zZWxlY3RMZWZ0OmsuaW5jbHVzaXZlTGVmdCxtPVwic2VsZWN0UmlnaHRcImluIGs/IWsuc2VsZWN0UmlnaHQ6ay5pbmNsdXNpdmVSaWdodDtpZigobnVsbD09aC5mcm9tfHwobD9oLmZyb208PWIuY2g6aC5mcm9tPGIuY2gpKSYmKG51bGw9PWgudG98fChtP2gudG8+PWIuY2g6aC50bz5iLmNoKSkpe2lmKGUmJihYKGssXCJiZWZvcmVDdXJzb3JFbnRlclwiKSxrLmV4cGxpY2l0bHlDbGVhcmVkKSlpZihmLm1hcmtlZFNwYW5zKXstLWc7Y29udGludWV9ZWxzZSBicmVhaztpZihrLmF0b21pYyl7aWYoZCl7Zz1rLmZpbmQoMD5jPzE6LTEpO2g9dm9pZCAwO2lmKDA+Yz9tOmwpZz1cbklmKGEsZywtYyxnJiZnLmxpbmU9PWIubGluZT9mOm51bGwpO2lmKGcmJmcubGluZT09Yi5saW5lJiYoaD1CKGcsZCkpJiYoMD5jPzA+aDowPGgpKXJldHVybiB6YihhLGcsYixjLGUpfWQ9ay5maW5kKDA+Yz8tMToxKTtpZigwPmM/bDptKWQ9SWYoYSxkLGMsZC5saW5lPT1iLmxpbmU/ZjpudWxsKTtyZXR1cm4gZD96YihhLGQsYixjLGUpOm51bGx9fX1yZXR1cm4gYn1mdW5jdGlvbiBVYyhhLGIsZCxjLGUpe2M9Y3x8MTtiPXpiKGEsYixkLGMsZSl8fCFlJiZ6YihhLGIsZCxjLCEwKXx8emIoYSxiLGQsLWMsZSl8fCFlJiZ6YihhLGIsZCwtYywhMCk7cmV0dXJuIGI/YjooYS5jYW50RWRpdD0hMCx0KGEuZmlyc3QsMCkpfWZ1bmN0aW9uIElmKGEsYixkLGMpe3JldHVybiAwPmQmJjA9PWIuY2g/Yi5saW5lPmEuZmlyc3Q/QyhhLHQoYi5saW5lLTEpKTpudWxsOjA8ZCYmYi5jaD09KGN8fHcoYSxiLmxpbmUpKS50ZXh0Lmxlbmd0aD9iLmxpbmU8YS5maXJzdCthLnNpemUtMT90KGIubGluZStcbjEsMCk6bnVsbDpuZXcgdChiLmxpbmUsYi5jaCtkKX1mdW5jdGlvbiBKZihhKXthLnNldFNlbGVjdGlvbih0KGEuZmlyc3RMaW5lKCksMCksdChhLmxhc3RMaW5lKCkpLElhKX1mdW5jdGlvbiBLZihhLGIsZCl7dmFyIGM9e2NhbmNlbGVkOiExLGZyb206Yi5mcm9tLHRvOmIudG8sdGV4dDpiLnRleHQsb3JpZ2luOmIub3JpZ2luLGNhbmNlbDpmdW5jdGlvbigpe3JldHVybiBjLmNhbmNlbGVkPSEwfX07ZCYmKGMudXBkYXRlPWZ1bmN0aW9uKGUsZixnLGgpe2UmJihjLmZyb209QyhhLGUpKTtmJiYoYy50bz1DKGEsZikpO2cmJihjLnRleHQ9Zyk7dm9pZCAwIT09aCYmKGMub3JpZ2luPWgpfSk7WChhLFwiYmVmb3JlQ2hhbmdlXCIsYSxjKTthLmNtJiZYKGEuY20sXCJiZWZvcmVDaGFuZ2VcIixhLmNtLGMpO3JldHVybiBjLmNhbmNlbGVkPyhhLmNtJiYoYS5jbS5jdXJPcC51cGRhdGVJbnB1dD0yKSxudWxsKTp7ZnJvbTpjLmZyb20sdG86Yy50byx0ZXh0OmMudGV4dCxvcmlnaW46Yy5vcmlnaW59fVxuZnVuY3Rpb24gQWIoYSxiLGQpe2lmKGEuY20pe2lmKCFhLmNtLmN1ck9wKXJldHVybiBhYShhLmNtLEFiKShhLGIsZCk7aWYoYS5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKXJldHVybn1pZih4YShhLFwiYmVmb3JlQ2hhbmdlXCIpfHxhLmNtJiZ4YShhLmNtLFwiYmVmb3JlQ2hhbmdlXCIpKWlmKGI9S2YoYSxiLCEwKSwhYilyZXR1cm47aWYoZD1MZiYmIWQmJkdnKGEsYi5mcm9tLGIudG8pKWZvcih2YXIgYz1kLmxlbmd0aC0xOzA8PWM7LS1jKU1mKGEse2Zyb206ZFtjXS5mcm9tLHRvOmRbY10udG8sdGV4dDpjP1tcIlwiXTpiLnRleHQsb3JpZ2luOmIub3JpZ2lufSk7ZWxzZSBNZihhLGIpfWZ1bmN0aW9uIE1mKGEsYil7aWYoMSE9Yi50ZXh0Lmxlbmd0aHx8XCJcIiE9Yi50ZXh0WzBdfHwwIT1CKGIuZnJvbSxiLnRvKSl7dmFyIGQ9VmQoYSxiKTtCZihhLGIsZCxhLmNtP2EuY20uY3VyT3AuaWQ6TmFOKTthYyhhLGIsZCx0ZChhLGIpKTt2YXIgYz1bXTtTYShhLGZ1bmN0aW9uKGUsZil7Znx8LTEhPWVhKGMsXG5lLmhpc3RvcnkpfHwoTmYoZS5oaXN0b3J5LGIpLGMucHVzaChlLmhpc3RvcnkpKTthYyhlLGIsbnVsbCx0ZChlLGIpKX0pfX1mdW5jdGlvbiBWYyhhLGIsZCl7dmFyIGM9YS5jbSYmYS5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzO2lmKCFjfHxkKXtmb3IodmFyIGU9YS5oaXN0b3J5LGYsZz1hLnNlbCxoPVwidW5kb1wiPT1iP2UuZG9uZTplLnVuZG9uZSxrPVwidW5kb1wiPT1iP2UudW5kb25lOmUuZG9uZSxsPTA7bDxoLmxlbmd0aCYmKGY9aFtsXSxkPyFmLnJhbmdlc3x8Zi5lcXVhbHMoYS5zZWwpOmYucmFuZ2VzKTtsKyspO2lmKGwhPWgubGVuZ3RoKXtmb3IoZS5sYXN0T3JpZ2luPWUubGFzdFNlbE9yaWdpbj1udWxsOzspaWYoZj1oLnBvcCgpLGYucmFuZ2VzKXtSYyhmLGspO2lmKGQmJiFmLmVxdWFscyhhLnNlbCkpe2RhKGEsZix7Y2xlYXJSZWRvOiExfSk7cmV0dXJufWc9Zn1lbHNle2lmKGMpe2gucHVzaChmKTtyZXR1cm59YnJlYWt9dmFyIG09W107UmMoZyxrKTtrLnB1c2goe2NoYW5nZXM6bSxcbmdlbmVyYXRpb246ZS5nZW5lcmF0aW9ufSk7ZS5nZW5lcmF0aW9uPWYuZ2VuZXJhdGlvbnx8KytlLm1heEdlbmVyYXRpb247dmFyIHE9eGEoYSxcImJlZm9yZUNoYW5nZVwiKXx8YS5jbSYmeGEoYS5jbSxcImJlZm9yZUNoYW5nZVwiKTtkPWZ1bmN0aW9uKG4pe3ZhciBwPWYuY2hhbmdlc1tuXTtwLm9yaWdpbj1iO2lmKHEmJiFLZihhLHAsITEpKXJldHVybiBoLmxlbmd0aD0wLHt9O20ucHVzaChZZChhLHApKTt2YXIgcj1uP1ZkKGEscCk6TChoKTthYyhhLHAscixDZihhLHApKTshbiYmYS5jbSYmYS5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTpwLmZyb20sdG86UmEocCl9KTt2YXIgdT1bXTtTYShhLGZ1bmN0aW9uKEEsSCl7SHx8LTEhPWVhKHUsQS5oaXN0b3J5KXx8KE5mKEEuaGlzdG9yeSxwKSx1LnB1c2goQS5oaXN0b3J5KSk7YWMoQSxwLG51bGwsQ2YoQSxwKSl9KX07Zm9yKGM9Zi5jaGFuZ2VzLmxlbmd0aC0xOzA8PWM7LS1jKWlmKGU9ZChjKSlyZXR1cm4gZS52fX19ZnVuY3Rpb24gT2YoYSxcbmIpe2lmKDAhPWImJihhLmZpcnN0Kz1iLGEuc2VsPW5ldyB1YSh2YyhhLnNlbC5yYW5nZXMsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBKKHQoZS5hbmNob3IubGluZStiLGUuYW5jaG9yLmNoKSx0KGUuaGVhZC5saW5lK2IsZS5oZWFkLmNoKSl9KSxhLnNlbC5wcmltSW5kZXgpLGEuY20pKXttYShhLmNtLGEuZmlyc3QsYS5maXJzdC1iLGIpO2Zvcih2YXIgZD1hLmNtLmRpc3BsYXksYz1kLnZpZXdGcm9tO2M8ZC52aWV3VG87YysrKVFhKGEuY20sYyxcImd1dHRlclwiKX19ZnVuY3Rpb24gYWMoYSxiLGQsYyl7aWYoYS5jbSYmIWEuY20uY3VyT3ApcmV0dXJuIGFhKGEuY20sYWMpKGEsYixkLGMpO2lmKGIudG8ubGluZTxhLmZpcnN0KU9mKGEsYi50ZXh0Lmxlbmd0aC0xLShiLnRvLmxpbmUtYi5mcm9tLmxpbmUpKTtlbHNlIGlmKCEoYi5mcm9tLmxpbmU+YS5sYXN0TGluZSgpKSl7aWYoYi5mcm9tLmxpbmU8YS5maXJzdCl7dmFyIGU9Yi50ZXh0Lmxlbmd0aC0xLShhLmZpcnN0LWIuZnJvbS5saW5lKTtcbk9mKGEsZSk7Yj17ZnJvbTp0KGEuZmlyc3QsMCksdG86dChiLnRvLmxpbmUrZSxiLnRvLmNoKSx0ZXh0OltMKGIudGV4dCldLG9yaWdpbjpiLm9yaWdpbn19ZT1hLmxhc3RMaW5lKCk7Yi50by5saW5lPmUmJihiPXtmcm9tOmIuZnJvbSx0bzp0KGUsdyhhLGUpLnRleHQubGVuZ3RoKSx0ZXh0OltiLnRleHRbMF1dLG9yaWdpbjpiLm9yaWdpbn0pO2IucmVtb3ZlZD1aYShhLGIuZnJvbSxiLnRvKTtkfHwoZD1WZChhLGIpKTthLmNtP2JoKGEuY20sYixjKTpYZChhLGIsYyk7VGMoYSxkLElhKTthLmNhbnRFZGl0JiZVYyhhLHQoYS5maXJzdExpbmUoKSwwKSkmJihhLmNhbnRFZGl0PSExKX19ZnVuY3Rpb24gYmgoYSxiLGQpe3ZhciBjPWEuZG9jLGU9YS5kaXNwbGF5LGY9Yi5mcm9tLGc9Yi50byxoPSExLGs9Zi5saW5lO2Eub3B0aW9ucy5saW5lV3JhcHBpbmd8fChrPU8oRmEodyhjLGYubGluZSkpKSxjLml0ZXIoayxnLmxpbmUrMSxmdW5jdGlvbihsKXtpZihsPT1lLm1heExpbmUpcmV0dXJuIGg9XG4hMH0pKTstMTxjLnNlbC5jb250YWlucyhiLmZyb20sYi50bykmJnFlKGEpO1hkKGMsYixkLGJmKGEpKTthLm9wdGlvbnMubGluZVdyYXBwaW5nfHwoYy5pdGVyKGssZi5saW5lK2IudGV4dC5sZW5ndGgsZnVuY3Rpb24obCl7dmFyIG09RGMobCk7bT5lLm1heExpbmVMZW5ndGgmJihlLm1heExpbmU9bCxlLm1heExpbmVMZW5ndGg9bSxlLm1heExpbmVDaGFuZ2VkPSEwLGg9ITEpfSksaCYmKGEuY3VyT3AudXBkYXRlTWF4TGluZT0hMCkpO0ZnKGMsZi5saW5lKTtXYihhLDQwMCk7ZD1iLnRleHQubGVuZ3RoLShnLmxpbmUtZi5saW5lKS0xO2IuZnVsbD9tYShhKTpmLmxpbmUhPWcubGluZXx8MSE9Yi50ZXh0Lmxlbmd0aHx8d2YoYS5kb2MsYik/bWEoYSxmLmxpbmUsZy5saW5lKzEsZCk6UWEoYSxmLmxpbmUsXCJ0ZXh0XCIpO2Q9eGEoYSxcImNoYW5nZXNcIik7aWYoKGM9eGEoYSxcImNoYW5nZVwiKSl8fGQpYj17ZnJvbTpmLHRvOmcsdGV4dDpiLnRleHQscmVtb3ZlZDpiLnJlbW92ZWQsb3JpZ2luOmIub3JpZ2lufSxcbmMmJmNhKGEsXCJjaGFuZ2VcIixhLGIpLGQmJihhLmN1ck9wLmNoYW5nZU9ianN8fChhLmN1ck9wLmNoYW5nZU9ianM9W10pKS5wdXNoKGIpO2EuZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudT1udWxsfWZ1bmN0aW9uIEJiKGEsYixkLGMsZSl7Y3x8KGM9ZCk7MD5CKGMsZCkmJihjPVtjLGRdLGQ9Y1swXSxjPWNbMV0pO1wic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj1hLnNwbGl0TGluZXMoYikpO0FiKGEse2Zyb206ZCx0bzpjLHRleHQ6YixvcmlnaW46ZX0pfWZ1bmN0aW9uIFBmKGEsYixkLGMpe2Q8YS5saW5lP2EubGluZSs9YzpiPGEubGluZSYmKGEubGluZT1iLGEuY2g9MCl9ZnVuY3Rpb24gUWYoYSxiLGQsYyl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV0sZz0hMDtpZihmLnJhbmdlcylmb3IoZi5jb3BpZWR8fChmPWFbZV09Zi5kZWVwQ29weSgpLGYuY29waWVkPSEwKSxnPTA7ZzxmLnJhbmdlcy5sZW5ndGg7ZysrKVBmKGYucmFuZ2VzW2ddLmFuY2hvcixiLGQsYyksXG5QZihmLnJhbmdlc1tnXS5oZWFkLGIsZCxjKTtlbHNle2Zvcih2YXIgaD0wO2g8Zi5jaGFuZ2VzLmxlbmd0aDsrK2gpe3ZhciBrPWYuY2hhbmdlc1toXTtpZihkPGsuZnJvbS5saW5lKWsuZnJvbT10KGsuZnJvbS5saW5lK2Msay5mcm9tLmNoKSxrLnRvPXQoay50by5saW5lK2Msay50by5jaCk7ZWxzZSBpZihiPD1rLnRvLmxpbmUpe2c9ITE7YnJlYWt9fWd8fChhLnNwbGljZSgwLGUrMSksZT0wKX19fWZ1bmN0aW9uIE5mKGEsYil7dmFyIGQ9Yi5mcm9tLmxpbmUsYz1iLnRvLmxpbmU7Yj1iLnRleHQubGVuZ3RoLShjLWQpLTE7UWYoYS5kb25lLGQsYyxiKTtRZihhLnVuZG9uZSxkLGMsYil9ZnVuY3Rpb24gYmMoYSxiLGQsYyl7dmFyIGU9YixmPWI7XCJudW1iZXJcIj09dHlwZW9mIGI/Zj13KGEsTWF0aC5tYXgoYS5maXJzdCxNYXRoLm1pbihiLGEuZmlyc3QrYS5zaXplLTEpKSk6ZT1PKGIpO2lmKG51bGw9PWUpcmV0dXJuIG51bGw7YyhmLGUpJiZhLmNtJiZRYShhLmNtLGUsZCk7cmV0dXJuIGZ9XG5mdW5jdGlvbiBjYyhhKXt0aGlzLmxpbmVzPWE7dGhpcy5wYXJlbnQ9bnVsbDtmb3IodmFyIGI9MCxkPTA7ZDxhLmxlbmd0aDsrK2QpYVtkXS5wYXJlbnQ9dGhpcyxiKz1hW2RdLmhlaWdodDt0aGlzLmhlaWdodD1ifWZ1bmN0aW9uIGRjKGEpe3RoaXMuY2hpbGRyZW49YTtmb3IodmFyIGI9MCxkPTAsYz0wO2M8YS5sZW5ndGg7KytjKXt2YXIgZT1hW2NdO2IrPWUuY2h1bmtTaXplKCk7ZCs9ZS5oZWlnaHQ7ZS5wYXJlbnQ9dGhpc310aGlzLnNpemU9Yjt0aGlzLmhlaWdodD1kO3RoaXMucGFyZW50PW51bGx9ZnVuY3Rpb24gY2goYSxiLGQsYyl7dmFyIGU9bmV3IGVjKGEsZCxjKSxmPWEuY207ZiYmZS5ub0hTY3JvbGwmJihmLmRpc3BsYXkuYWxpZ25XaWRnZXRzPSEwKTtiYyhhLGIsXCJ3aWRnZXRcIixmdW5jdGlvbihnKXt2YXIgaD1nLndpZGdldHN8fChnLndpZGdldHM9W10pO251bGw9PWUuaW5zZXJ0QXQ/aC5wdXNoKGUpOmguc3BsaWNlKE1hdGgubWluKGgubGVuZ3RoLTEsTWF0aC5tYXgoMCxcbmUuaW5zZXJ0QXQpKSwwLGUpO2UubGluZT1nO2YmJiFPYShhLGcpJiYoaD1HYShnKTxhLnNjcm9sbFRvcCxEYShnLGcuaGVpZ2h0K1JiKGUpKSxoJiZNYyhmLGUuaGVpZ2h0KSxmLmN1ck9wLmZvcmNlVXBkYXRlPSEwKTtyZXR1cm4hMH0pO2YmJmNhKGYsXCJsaW5lV2lkZ2V0QWRkZWRcIixmLGUsXCJudW1iZXJcIj09dHlwZW9mIGI/YjpPKGIpKTtyZXR1cm4gZX1mdW5jdGlvbiBDYihhLGIsZCxjLGUpe2lmKGMmJmMuc2hhcmVkKXJldHVybiBkaChhLGIsZCxjLGUpO2lmKGEuY20mJiFhLmNtLmN1ck9wKXJldHVybiBhYShhLmNtLENiKShhLGIsZCxjLGUpO3ZhciBmPW5ldyBUYShhLGUpO2U9QihiLGQpO2MmJlhhKGMsZiwhMSk7aWYoMDxlfHwwPT1lJiYhMSE9PWYuY2xlYXJXaGVuRW1wdHkpcmV0dXJuIGY7Zi5yZXBsYWNlZFdpdGgmJihmLmNvbGxhcHNlZD0hMCxmLndpZGdldE5vZGU9SyhcInNwYW5cIixbZi5yZXBsYWNlZFdpdGhdLFwiQ29kZU1pcnJvci13aWRnZXRcIiksYy5oYW5kbGVNb3VzZUV2ZW50c3x8XG5mLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLFwidHJ1ZVwiKSxjLmluc2VydExlZnQmJihmLndpZGdldE5vZGUuaW5zZXJ0TGVmdD0hMCkpO2lmKGYuY29sbGFwc2VkKXtpZihGZShhLGIubGluZSxiLGQsZil8fGIubGluZSE9ZC5saW5lJiZGZShhLGQubGluZSxiLGQsZikpdGhyb3cgRXJyb3IoXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXCIpO0thPSEwfWYuYWRkVG9IaXN0b3J5JiZCZihhLHtmcm9tOmIsdG86ZCxvcmlnaW46XCJtYXJrVGV4dFwifSxhLnNlbCxOYU4pO3ZhciBnPWIubGluZSxoPWEuY20sazthLml0ZXIoZyxkLmxpbmUrMSxmdW5jdGlvbihsKXtoJiZmLmNvbGxhcHNlZCYmIWgub3B0aW9ucy5saW5lV3JhcHBpbmcmJkZhKGwpPT1oLmRpc3BsYXkubWF4TGluZSYmKGs9ITApO2YuY29sbGFwc2VkJiZnIT1iLmxpbmUmJkRhKGwsMCk7dmFyIG09bmV3IENjKGYsZz09Yi5saW5lP1xuYi5jaDpudWxsLGc9PWQubGluZT9kLmNoOm51bGwpO2wubWFya2VkU3BhbnM9bC5tYXJrZWRTcGFucz9sLm1hcmtlZFNwYW5zLmNvbmNhdChbbV0pOlttXTttLm1hcmtlci5hdHRhY2hMaW5lKGwpOysrZ30pO2YuY29sbGFwc2VkJiZhLml0ZXIoYi5saW5lLGQubGluZSsxLGZ1bmN0aW9uKGwpe09hKGEsbCkmJkRhKGwsMCl9KTtmLmNsZWFyT25FbnRlciYmeihmLFwiYmVmb3JlQ3Vyc29yRW50ZXJcIixmdW5jdGlvbigpe3JldHVybiBmLmNsZWFyKCl9KTtmLnJlYWRPbmx5JiYoTGY9ITAsKGEuaGlzdG9yeS5kb25lLmxlbmd0aHx8YS5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpJiZhLmNsZWFySGlzdG9yeSgpKTtmLmNvbGxhcHNlZCYmKGYuaWQ9KytSZixmLmF0b21pYz0hMCk7aWYoaCl7ayYmKGguY3VyT3AudXBkYXRlTWF4TGluZT0hMCk7aWYoZi5jb2xsYXBzZWQpbWEoaCxiLmxpbmUsZC5saW5lKzEpO2Vsc2UgaWYoZi5jbGFzc05hbWV8fGYuc3RhcnRTdHlsZXx8Zi5lbmRTdHlsZXx8Zi5jc3N8fFxuZi5hdHRyaWJ1dGVzfHxmLnRpdGxlKWZvcihjPWIubGluZTtjPD1kLmxpbmU7YysrKVFhKGgsYyxcInRleHRcIik7Zi5hdG9taWMmJkhmKGguZG9jKTtjYShoLFwibWFya2VyQWRkZWRcIixoLGYpfXJldHVybiBmfWZ1bmN0aW9uIGRoKGEsYixkLGMsZSl7Yz1YYShjKTtjLnNoYXJlZD0hMTt2YXIgZj1bQ2IoYSxiLGQsYyxlKV0sZz1mWzBdLGg9Yy53aWRnZXROb2RlO1NhKGEsZnVuY3Rpb24oayl7aCYmKGMud2lkZ2V0Tm9kZT1oLmNsb25lTm9kZSghMCkpO2YucHVzaChDYihrLEMoayxiKSxDKGssZCksYyxlKSk7Zm9yKHZhciBsPTA7bDxrLmxpbmtlZC5sZW5ndGg7KytsKWlmKGsubGlua2VkW2xdLmlzUGFyZW50KXJldHVybjtnPUwoZil9KTtyZXR1cm4gbmV3IGZjKGYsZyl9ZnVuY3Rpb24gU2YoYSl7cmV0dXJuIGEuZmluZE1hcmtzKHQoYS5maXJzdCwwKSxhLmNsaXBQb3ModChhLmxhc3RMaW5lKCkpKSxmdW5jdGlvbihiKXtyZXR1cm4gYi5wYXJlbnR9KX1mdW5jdGlvbiBlaChhKXtmb3IodmFyIGI9XG5mdW5jdGlvbihjKXtjPWFbY107dmFyIGU9W2MucHJpbWFyeS5kb2NdO1NhKGMucHJpbWFyeS5kb2MsZnVuY3Rpb24oaCl7cmV0dXJuIGUucHVzaChoKX0pO2Zvcih2YXIgZj0wO2Y8Yy5tYXJrZXJzLmxlbmd0aDtmKyspe3ZhciBnPWMubWFya2Vyc1tmXTstMT09ZWEoZSxnLmRvYykmJihnLnBhcmVudD1udWxsLGMubWFya2Vycy5zcGxpY2UoZi0tLDEpKX19LGQ9MDtkPGEubGVuZ3RoO2QrKyliKGQpfWZ1bmN0aW9uIGZoKGEpe3ZhciBiPXRoaXM7VGYoYik7aWYoIVooYixhKSYmIUxhKGIuZGlzcGxheSxhKSl7bGEoYSk7RyYmKFVmPStuZXcgRGF0ZSk7dmFyIGQ9ZWIoYixhLCEwKSxjPWEuZGF0YVRyYW5zZmVyLmZpbGVzO2lmKGQmJiFiLmlzUmVhZE9ubHkoKSlpZihjJiZjLmxlbmd0aCYmd2luZG93LkZpbGVSZWFkZXImJndpbmRvdy5GaWxlKWZvcih2YXIgZT1jLmxlbmd0aCxmPUFycmF5KGUpLGc9MCxoPWZ1bmN0aW9uKCl7KytnPT1lJiZhYShiLGZ1bmN0aW9uKCl7ZD1DKGIuZG9jLFxuZCk7dmFyIG09e2Zyb206ZCx0bzpkLHRleHQ6Yi5kb2Muc3BsaXRMaW5lcyhmLmZpbHRlcihmdW5jdGlvbihxKXtyZXR1cm4gbnVsbCE9cX0pLmpvaW4oYi5kb2MubGluZVNlcGFyYXRvcigpKSksb3JpZ2luOlwicGFzdGVcIn07QWIoYi5kb2MsbSk7RWYoYi5kb2MsTmEoQyhiLmRvYyxkKSxDKGIuZG9jLFJhKG0pKSkpfSkoKX0saz1mdW5jdGlvbihtLHEpe2lmKGIub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMmJi0xPT1lYShiLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLG0udHlwZSkpaCgpO2Vsc2V7dmFyIG49bmV3IEZpbGVSZWFkZXI7bi5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIGgoKX07bi5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgcD1uLnJlc3VsdDsvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHApfHwoZltxXT1wKTtoKCl9O24ucmVhZEFzVGV4dChtKX19LGw9MDtsPGMubGVuZ3RoO2wrKylrKGNbbF0sbCk7ZWxzZSBpZihiLnN0YXRlLmRyYWdnaW5nVGV4dCYmXG4tMTxiLmRvYy5zZWwuY29udGFpbnMoZCkpYi5zdGF0ZS5kcmFnZ2luZ1RleHQoYSksc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBiLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sMjApO2Vsc2UgdHJ5e2lmKGs9YS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIikpe2Iuc3RhdGUuZHJhZ2dpbmdUZXh0JiYhYi5zdGF0ZS5kcmFnZ2luZ1RleHQuY29weSYmKGw9Yi5saXN0U2VsZWN0aW9ucygpKTtUYyhiLmRvYyxOYShkLGQpKTtpZihsKWZvcihjPTA7YzxsLmxlbmd0aDsrK2MpQmIoYi5kb2MsXCJcIixsW2NdLmFuY2hvcixsW2NdLmhlYWQsXCJkcmFnXCIpO2IucmVwbGFjZVNlbGVjdGlvbihrLFwiYXJvdW5kXCIsXCJwYXN0ZVwiKTtiLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX19Y2F0Y2gobSl7fX19ZnVuY3Rpb24gVGYoYSl7YS5kaXNwbGF5LmRyYWdDdXJzb3ImJihhLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGEuZGlzcGxheS5kcmFnQ3Vyc29yKSxhLmRpc3BsYXkuZHJhZ0N1cnNvcj1cbm51bGwpfWZ1bmN0aW9uIFZmKGEpe2lmKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpe2Zvcih2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiQ29kZU1pcnJvclwiKSxkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGU9YltjXS5Db2RlTWlycm9yO2UmJmQucHVzaChlKX1kLmxlbmd0aCYmZFswXS5vcGVyYXRpb24oZnVuY3Rpb24oKXtmb3IodmFyIGY9MDtmPGQubGVuZ3RoO2YrKylhKGRbZl0pfSl9fWZ1bmN0aW9uIGdoKCl7dmFyIGE7eih3aW5kb3csXCJyZXNpemVcIixmdW5jdGlvbigpe251bGw9PWEmJihhPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthPW51bGw7VmYoaGgpfSwxMDApKX0pO3ood2luZG93LFwiYmx1clwiLGZ1bmN0aW9uKCl7cmV0dXJuIFZmKHViKX0pfWZ1bmN0aW9uIGhoKGEpe3ZhciBiPWEuZGlzcGxheTtiLmNhY2hlZENoYXJXaWR0aD1iLmNhY2hlZFRleHRIZWlnaHQ9Yi5jYWNoZWRQYWRkaW5nSD1udWxsO2Iuc2Nyb2xsYmFyc0NsaXBwZWQ9XG4hMTthLnNldFNpemUoKX1mdW5jdGlvbiBpaChhKXt2YXIgYj1hLnNwbGl0KC8tKD8hJCkvKTthPWJbYi5sZW5ndGgtMV07Zm9yKHZhciBkLGMsZSxmLGc9MDtnPGIubGVuZ3RoLTE7ZysrKXt2YXIgaD1iW2ddO2lmKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QoaCkpZj0hMDtlbHNlIGlmKC9eYShsdCk/JC9pLnRlc3QoaCkpZD0hMDtlbHNlIGlmKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KGgpKWM9ITA7ZWxzZSBpZigvXnMoaGlmdCk/JC9pLnRlc3QoaCkpZT0hMDtlbHNlIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiK2gpO31kJiYoYT1cIkFsdC1cIithKTtjJiYoYT1cIkN0cmwtXCIrYSk7ZiYmKGE9XCJDbWQtXCIrYSk7ZSYmKGE9XCJTaGlmdC1cIithKTtyZXR1cm4gYX1mdW5jdGlvbiBqaChhKXt2YXIgYj17fSxkO2ZvcihkIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShkKSl7dmFyIGM9YVtkXTtpZighL14obmFtZXxmYWxsdGhyb3VnaHwoZGV8YXQpdGFjaCkkLy50ZXN0KGQpKXtpZihcIi4uLlwiIT1cbmMpZm9yKHZhciBlPXZjKGQuc3BsaXQoXCIgXCIpLGloKSxmPTA7ZjxlLmxlbmd0aDtmKyspe2lmKGY9PWUubGVuZ3RoLTEpe3ZhciBnPWUuam9pbihcIiBcIik7dmFyIGg9Y31lbHNlIGc9ZS5zbGljZSgwLGYrMSkuam9pbihcIiBcIiksaD1cIi4uLlwiO3ZhciBrPWJbZ107aWYoIWspYltnXT1oO2Vsc2UgaWYoayE9aCl0aHJvdyBFcnJvcihcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXCIrZyk7fWRlbGV0ZSBhW2RdfX1mb3IodmFyIGwgaW4gYilhW2xdPWJbbF07cmV0dXJuIGF9ZnVuY3Rpb24gRGIoYSxiLGQsYyl7Yj1XYyhiKTt2YXIgZT1iLmNhbGw/Yi5jYWxsKGEsYyk6YlthXTtpZighMT09PWUpcmV0dXJuXCJub3RoaW5nXCI7aWYoXCIuLi5cIj09PWUpcmV0dXJuXCJtdWx0aVwiO2lmKG51bGwhPWUmJmQoZSkpcmV0dXJuXCJoYW5kbGVkXCI7aWYoYi5mYWxsdGhyb3VnaCl7aWYoXCJbb2JqZWN0IEFycmF5XVwiIT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYi5mYWxsdGhyb3VnaCkpcmV0dXJuIERiKGEsXG5iLmZhbGx0aHJvdWdoLGQsYyk7Zm9yKGU9MDtlPGIuZmFsbHRocm91Z2gubGVuZ3RoO2UrKyl7dmFyIGY9RGIoYSxiLmZhbGx0aHJvdWdoW2VdLGQsYyk7aWYoZilyZXR1cm4gZn19fWZ1bmN0aW9uIFdmKGEpe2E9XCJzdHJpbmdcIj09dHlwZW9mIGE/YTpVYVthLmtleUNvZGVdO3JldHVyblwiQ3RybFwiPT1hfHxcIkFsdFwiPT1hfHxcIlNoaWZ0XCI9PWF8fFwiTW9kXCI9PWF9ZnVuY3Rpb24gWGYoYSxiLGQpe3ZhciBjPWE7Yi5hbHRLZXkmJlwiQWx0XCIhPWMmJihhPVwiQWx0LVwiK2EpOyhZZj9iLm1ldGFLZXk6Yi5jdHJsS2V5KSYmXCJDdHJsXCIhPWMmJihhPVwiQ3RybC1cIithKTsoWWY/Yi5jdHJsS2V5OmIubWV0YUtleSkmJlwiTW9kXCIhPWMmJihhPVwiQ21kLVwiK2EpOyFkJiZiLnNoaWZ0S2V5JiZcIlNoaWZ0XCIhPWMmJihhPVwiU2hpZnQtXCIrYSk7cmV0dXJuIGF9ZnVuY3Rpb24gWmYoYSxiKXtpZihCYSYmMzQ9PWEua2V5Q29kZSYmYVtcImNoYXJcIl0pcmV0dXJuITE7dmFyIGQ9VWFbYS5rZXlDb2RlXTtpZihudWxsPT1cbmR8fGEuYWx0R3JhcGhLZXkpcmV0dXJuITE7Mz09YS5rZXlDb2RlJiZhLmNvZGUmJihkPWEuY29kZSk7cmV0dXJuIFhmKGQsYSxiKX1mdW5jdGlvbiBXYyhhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYT9nY1thXTphfWZ1bmN0aW9uIEViKGEsYil7Zm9yKHZhciBkPWEuZG9jLnNlbC5yYW5nZXMsYz1bXSxlPTA7ZTxkLmxlbmd0aDtlKyspe2Zvcih2YXIgZj1iKGRbZV0pO2MubGVuZ3RoJiYwPj1CKGYuZnJvbSxMKGMpLnRvKTspe3ZhciBnPWMucG9wKCk7aWYoMD5CKGcuZnJvbSxmLmZyb20pKXtmLmZyb209Zy5mcm9tO2JyZWFrfX1jLnB1c2goZil9cGEoYSxmdW5jdGlvbigpe2Zvcih2YXIgaD1jLmxlbmd0aC0xOzA8PWg7aC0tKUJiKGEuZG9jLFwiXCIsY1toXS5mcm9tLGNbaF0udG8sXCIrZGVsZXRlXCIpO3ZiKGEpfSl9ZnVuY3Rpb24gYWUoYSxiLGQpe2I9cGUoYS50ZXh0LGIrZCxkKTtyZXR1cm4gMD5ifHxiPmEudGV4dC5sZW5ndGg/bnVsbDpifWZ1bmN0aW9uIGJlKGEsYixkKXthPVxuYWUoYSxiLmNoLGQpO3JldHVybiBudWxsPT1hP251bGw6bmV3IHQoYi5saW5lLGEsMD5kP1wiYWZ0ZXJcIjpcImJlZm9yZVwiKX1mdW5jdGlvbiBjZShhLGIsZCxjLGUpe2lmKGEmJihcInJ0bFwiPT1iLmRvYy5kaXJlY3Rpb24mJihlPS1lKSxhPUphKGQsYi5kb2MuZGlyZWN0aW9uKSkpe2E9MD5lP0woYSk6YVswXTt2YXIgZj0wPmU9PSgxPT1hLmxldmVsKT9cImFmdGVyXCI6XCJiZWZvcmVcIjtpZigwPGEubGV2ZWx8fFwicnRsXCI9PWIuZG9jLmRpcmVjdGlvbil7dmFyIGc9Y2IoYixkKTt2YXIgaD0wPmU/ZC50ZXh0Lmxlbmd0aC0xOjA7dmFyIGs9emEoYixnLGgpLnRvcDtoPUhiKGZ1bmN0aW9uKGwpe3JldHVybiB6YShiLGcsbCkudG9wPT1rfSwwPmU9PSgxPT1hLmxldmVsKT9hLmZyb206YS50by0xLGgpO1wiYmVmb3JlXCI9PWYmJihoPWFlKGQsaCwxKSl9ZWxzZSBoPTA+ZT9hLnRvOmEuZnJvbTtyZXR1cm4gbmV3IHQoYyxoLGYpfXJldHVybiBuZXcgdChjLDA+ZT9kLnRleHQubGVuZ3RoOjAsMD5lP1wiYmVmb3JlXCI6XG5cImFmdGVyXCIpfWZ1bmN0aW9uIGtoKGEsYixkLGMpe3ZhciBlPUphKGIsYS5kb2MuZGlyZWN0aW9uKTtpZighZSlyZXR1cm4gYmUoYixkLGMpO2QuY2g+PWIudGV4dC5sZW5ndGg/KGQuY2g9Yi50ZXh0Lmxlbmd0aCxkLnN0aWNreT1cImJlZm9yZVwiKTowPj1kLmNoJiYoZC5jaD0wLGQuc3RpY2t5PVwiYWZ0ZXJcIik7dmFyIGY9SWIoZSxkLmNoLGQuc3RpY2t5KSxnPWVbZl07aWYoXCJsdHJcIj09YS5kb2MuZGlyZWN0aW9uJiYwPT1nLmxldmVsJTImJigwPGM/Zy50bz5kLmNoOmcuZnJvbTxkLmNoKSlyZXR1cm4gYmUoYixkLGMpO3ZhciBoPWZ1bmN0aW9uKHAscil7cmV0dXJuIGFlKGIscCBpbnN0YW5jZW9mIHQ/cC5jaDpwLHIpfSxrLGw9ZnVuY3Rpb24ocCl7aWYoIWEub3B0aW9ucy5saW5lV3JhcHBpbmcpcmV0dXJue2JlZ2luOjAsZW5kOmIudGV4dC5sZW5ndGh9O2s9a3x8Y2IoYSxiKTtyZXR1cm4gYWYoYSxiLGsscCl9LG09bChcImJlZm9yZVwiPT1kLnN0aWNreT9oKGQsLTEpOmQuY2gpO2lmKFwicnRsXCI9PVxuYS5kb2MuZGlyZWN0aW9ufHwxPT1nLmxldmVsKXt2YXIgcT0xPT1nLmxldmVsPT0wPmMsbj1oKGQscT8xOi0xKTtpZihudWxsIT1uJiYocT9uPD1nLnRvJiZuPD1tLmVuZDpuPj1nLmZyb20mJm4+PW0uYmVnaW4pKXJldHVybiBuZXcgdChkLmxpbmUsbixxP1wiYmVmb3JlXCI6XCJhZnRlclwiKX1nPWZ1bmN0aW9uKHAscix1KXtmb3IodmFyIEE9ZnVuY3Rpb24oTSxSKXtyZXR1cm4gUj9uZXcgdChkLmxpbmUsaChNLDEpLFwiYmVmb3JlXCIpOm5ldyB0KGQubGluZSxNLFwiYWZ0ZXJcIil9OzA8PXAmJnA8ZS5sZW5ndGg7cCs9cil7dmFyIEg9ZVtwXSx4PTA8cj09KDEhPUgubGV2ZWwpLFE9eD91LmJlZ2luOmgodS5lbmQsLTEpO2lmKEguZnJvbTw9USYmUTxILnRvKXJldHVybiBBKFEseCk7UT14P0guZnJvbTpoKEgudG8sLTEpO2lmKHUuYmVnaW48PVEmJlE8dS5lbmQpcmV0dXJuIEEoUSx4KX19O2lmKGY9ZyhmK2MsYyxtKSlyZXR1cm4gZjttPTA8Yz9tLmVuZDpoKG0uYmVnaW4sLTEpO3JldHVybiBudWxsPT1cbm18fDA8YyYmbT09Yi50ZXh0Lmxlbmd0aHx8IShmPWcoMDxjPzA6ZS5sZW5ndGgtMSxjLGwobSkpKT9udWxsOmZ9ZnVuY3Rpb24gJGYoYSxiKXt2YXIgZD13KGEuZG9jLGIpLGM9RmEoZCk7YyE9ZCYmKGI9TyhjKSk7cmV0dXJuIGNlKCEwLGEsYyxiLDEpfWZ1bmN0aW9uIGFnKGEsYil7dmFyIGQ9JGYoYSxiLmxpbmUpLGM9dyhhLmRvYyxkLmxpbmUpO2E9SmEoYyxhLmRvYy5kaXJlY3Rpb24pO3JldHVybiBhJiYwIT1hWzBdLmxldmVsP2Q6KGM9TWF0aC5tYXgoZC5jaCxjLnRleHQuc2VhcmNoKC9cXFMvKSksdChkLmxpbmUsYi5saW5lPT1kLmxpbmUmJmIuY2g8PWMmJmIuY2g/MDpjLGQuc3RpY2t5KSl9ZnVuY3Rpb24gWGMoYSxiLGQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj1oY1tiXSwhYikpcmV0dXJuITE7YS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO3ZhciBjPWEuZGlzcGxheS5zaGlmdCxlPSExO3RyeXthLmlzUmVhZE9ubHkoKSYmKGEuc3RhdGUuc3VwcHJlc3NFZGl0cz1cbiEwKSxkJiYoYS5kaXNwbGF5LnNoaWZ0PSExKSxlPWIoYSkhPVljfWZpbmFsbHl7YS5kaXNwbGF5LnNoaWZ0PWMsYS5zdGF0ZS5zdXBwcmVzc0VkaXRzPSExfXJldHVybiBlfWZ1bmN0aW9uIGljKGEsYixkLGMpe3ZhciBlPWEuc3RhdGUua2V5U2VxO2lmKGUpe2lmKFdmKGIpKXJldHVyblwiaGFuZGxlZFwiOy8nJC8udGVzdChiKT9hLnN0YXRlLmtleVNlcT1udWxsOmxoLnNldCg1MCxmdW5jdGlvbigpe2Euc3RhdGUua2V5U2VxPT1lJiYoYS5zdGF0ZS5rZXlTZXE9bnVsbCxhLmRpc3BsYXkuaW5wdXQucmVzZXQoKSl9KTtpZihiZyhhLGUrXCIgXCIrYixkLGMpKXJldHVybiEwfXJldHVybiBiZyhhLGIsZCxjKX1mdW5jdGlvbiBiZyhhLGIsZCxjKXthOntmb3IodmFyIGU9MDtlPGEuc3RhdGUua2V5TWFwcy5sZW5ndGg7ZSsrKXt2YXIgZj1EYihiLGEuc3RhdGUua2V5TWFwc1tlXSxjLGEpO2lmKGYpe2M9ZjticmVhayBhfX1jPWEub3B0aW9ucy5leHRyYUtleXMmJkRiKGIsYS5vcHRpb25zLmV4dHJhS2V5cyxcbmMsYSl8fERiKGIsYS5vcHRpb25zLmtleU1hcCxjLGEpfVwibXVsdGlcIj09YyYmKGEuc3RhdGUua2V5U2VxPWIpO1wiaGFuZGxlZFwiPT1jJiZjYShhLFwia2V5SGFuZGxlZFwiLGEsYixkKTtpZihcImhhbmRsZWRcIj09Y3x8XCJtdWx0aVwiPT1jKWxhKGQpLE5kKGEpO3JldHVybiEhY31mdW5jdGlvbiBjZyhhLGIpe3ZhciBkPVpmKGIsITApO3JldHVybiBkP2Iuc2hpZnRLZXkmJiFhLnN0YXRlLmtleVNlcT9pYyhhLFwiU2hpZnQtXCIrZCxiLGZ1bmN0aW9uKGMpe3JldHVybiBYYyhhLGMsITApfSl8fGljKGEsZCxiLGZ1bmN0aW9uKGMpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBjPy9eZ29bQS1aXS8udGVzdChjKTpjLm1vdGlvbilyZXR1cm4gWGMoYSxjKX0pOmljKGEsZCxiLGZ1bmN0aW9uKGMpe3JldHVybiBYYyhhLGMpfSk6ITF9ZnVuY3Rpb24gbWgoYSxiLGQpe3JldHVybiBpYyhhLFwiJ1wiK2QrXCInXCIsYixmdW5jdGlvbihjKXtyZXR1cm4gWGMoYSxjLCEwKX0pfWZ1bmN0aW9uIGRnKGEpe2lmKCFhLnRhcmdldHx8XG5hLnRhcmdldD09dGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkpaWYodGhpcy5jdXJPcC5mb2N1cz12YSgpLCFaKHRoaXMsYSkpe0cmJjExPlUmJjI3PT1hLmtleUNvZGUmJihhLnJldHVyblZhbHVlPSExKTt2YXIgYj1hLmtleUNvZGU7dGhpcy5kaXNwbGF5LnNoaWZ0PTE2PT1ifHxhLnNoaWZ0S2V5O3ZhciBkPWNnKHRoaXMsYSk7QmEmJihkZT1kP2I6bnVsbCwhZCYmODg9PWImJiFuaCYmKHlhP2EubWV0YUtleTphLmN0cmxLZXkpJiZ0aGlzLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiY3V0XCIpKTtNYSYmIXlhJiYhZCYmNDY9PWImJmEuc2hpZnRLZXkmJiFhLmN0cmxLZXkmJmRvY3VtZW50LmV4ZWNDb21tYW5kJiZkb2N1bWVudC5leGVjQ29tbWFuZChcImN1dFwiKTsxOCE9Ynx8L1xcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxiLy50ZXN0KHRoaXMuZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSl8fG9oKHRoaXMpfX1mdW5jdGlvbiBvaChhKXtmdW5jdGlvbiBiKGMpezE4IT1jLmtleUNvZGUmJlxuYy5hbHRLZXl8fChoYihkLFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIikscmEoZG9jdW1lbnQsXCJrZXl1cFwiLGIpLHJhKGRvY3VtZW50LFwibW91c2VvdmVyXCIsYikpfXZhciBkPWEuZGlzcGxheS5saW5lRGl2O1dhKGQsXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTt6KGRvY3VtZW50LFwia2V5dXBcIixiKTt6KGRvY3VtZW50LFwibW91c2VvdmVyXCIsYil9ZnVuY3Rpb24gZWcoYSl7MTY9PWEua2V5Q29kZSYmKHRoaXMuZG9jLnNlbC5zaGlmdD0hMSk7Wih0aGlzLGEpfWZ1bmN0aW9uIGZnKGEpe2lmKCEoYS50YXJnZXQmJmEudGFyZ2V0IT10aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKXx8TGEodGhpcy5kaXNwbGF5LGEpfHxaKHRoaXMsYSl8fGEuY3RybEtleSYmIWEuYWx0S2V5fHx5YSYmYS5tZXRhS2V5KSl7dmFyIGI9YS5rZXlDb2RlLGQ9YS5jaGFyQ29kZTtpZihCYSYmYj09ZGUpZGU9bnVsbCxsYShhKTtlbHNlIGlmKCFCYXx8YS53aGljaCYmISgxMD5hLndoaWNoKXx8IWNnKHRoaXMsYSkpaWYoYj1cblN0cmluZy5mcm9tQ2hhckNvZGUobnVsbD09ZD9iOmQpLFwiXFxiXCIhPWImJiFtaCh0aGlzLGEsYikpdGhpcy5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoYSl9fWZ1bmN0aW9uIHBoKGEsYil7dmFyIGQ9K25ldyBEYXRlO2lmKGpjJiZqYy5jb21wYXJlKGQsYSxiKSlyZXR1cm4ga2M9amM9bnVsbCxcInRyaXBsZVwiO2lmKGtjJiZrYy5jb21wYXJlKGQsYSxiKSlyZXR1cm4gamM9bmV3IGVlKGQsYSxiKSxrYz1udWxsLFwiZG91YmxlXCI7a2M9bmV3IGVlKGQsYSxiKTtqYz1udWxsO3JldHVyblwic2luZ2xlXCJ9ZnVuY3Rpb24gZ2coYSl7dmFyIGI9dGhpcy5kaXNwbGF5O2lmKCEoWih0aGlzLGEpfHxiLmFjdGl2ZVRvdWNoJiZiLmlucHV0LnN1cHBvcnRzVG91Y2goKSkpaWYoYi5pbnB1dC5lbnN1cmVQb2xsZWQoKSxiLnNoaWZ0PWEuc2hpZnRLZXksTGEoYixhKSlmYXx8KGIuc2Nyb2xsZXIuZHJhZ2dhYmxlPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gYi5zY3JvbGxlci5kcmFnZ2FibGU9XG4hMH0sMTAwKSk7ZWxzZSBpZighWmModGhpcyxhLFwiZ3V0dGVyQ2xpY2tcIiwhMCkpe3ZhciBkPWViKHRoaXMsYSksYz1zZShhKSxlPWQ/cGgoZCxjKTpcInNpbmdsZVwiO3dpbmRvdy5mb2N1cygpOzE9PWMmJnRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCYmdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KGEpO2lmKCFkfHwhcWgodGhpcyxjLGQsZSxhKSlpZigxPT1jKWQ/cmgodGhpcyxkLGUsYSk6KGEudGFyZ2V0fHxhLnNyY0VsZW1lbnQpPT1iLnNjcm9sbGVyJiZsYShhKTtlbHNlIGlmKDI9PWMpZCYmU2ModGhpcy5kb2MsZCksc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBiLmlucHV0LmZvY3VzKCl9LDIwKTtlbHNlIGlmKDM9PWMpaWYoZmUpdGhpcy5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoYSk7ZWxzZSBnZih0aGlzKX19ZnVuY3Rpb24gcWgoYSxiLGQsYyxlKXt2YXIgZj1cIkNsaWNrXCI7XCJkb3VibGVcIj09Yz9mPVwiRG91YmxlXCIrZjpcInRyaXBsZVwiPT1jJiYoZj1cIlRyaXBsZVwiK1xuZik7cmV0dXJuIGljKGEsWGYoKDE9PWI/XCJMZWZ0XCI6Mj09Yj9cIk1pZGRsZVwiOlwiUmlnaHRcIikrZixlKSxlLGZ1bmN0aW9uKGcpe1wic3RyaW5nXCI9PXR5cGVvZiBnJiYoZz1oY1tnXSk7aWYoIWcpcmV0dXJuITE7dmFyIGg9ITE7dHJ5e2EuaXNSZWFkT25seSgpJiYoYS5zdGF0ZS5zdXBwcmVzc0VkaXRzPSEwKSxoPWcoYSxkKSE9WWN9ZmluYWxseXthLnN0YXRlLnN1cHByZXNzRWRpdHM9ITF9cmV0dXJuIGh9KX1mdW5jdGlvbiByaChhLGIsZCxjKXtHP3NldFRpbWVvdXQoZGQoZmYsYSksMCk6YS5jdXJPcC5mb2N1cz12YSgpO3ZhciBlPWEuZ2V0T3B0aW9uKFwiY29uZmlndXJlTW91c2VcIik7ZT1lP2UoYSxkLGMpOnt9O251bGw9PWUudW5pdCYmKGUudW5pdD0oc2g/Yy5zaGlmdEtleSYmYy5tZXRhS2V5OmMuYWx0S2V5KT9cInJlY3RhbmdsZVwiOlwic2luZ2xlXCI9PWQ/XCJjaGFyXCI6XCJkb3VibGVcIj09ZD9cIndvcmRcIjpcImxpbmVcIik7aWYobnVsbD09ZS5leHRlbmR8fGEuZG9jLmV4dGVuZCllLmV4dGVuZD1cbmEuZG9jLmV4dGVuZHx8Yy5zaGlmdEtleTtudWxsPT1lLmFkZE5ldyYmKGUuYWRkTmV3PXlhP2MubWV0YUtleTpjLmN0cmxLZXkpO251bGw9PWUubW92ZU9uRHJhZyYmKGUubW92ZU9uRHJhZz0hKHlhP2MuYWx0S2V5OmMuY3RybEtleSkpO3ZhciBmPWEuZG9jLnNlbCxnO2Eub3B0aW9ucy5kcmFnRHJvcCYmdGgmJiFhLmlzUmVhZE9ubHkoKSYmXCJzaW5nbGVcIj09ZCYmLTE8KGc9Zi5jb250YWlucyhiKSkmJigwPkIoKGc9Zi5yYW5nZXNbZ10pLmZyb20oKSxiKXx8MDxiLnhSZWwpJiYoMDxCKGcudG8oKSxiKXx8MD5iLnhSZWwpP3VoKGEsYyxiLGUpOnZoKGEsYyxiLGUpfWZ1bmN0aW9uIHVoKGEsYixkLGMpe3ZhciBlPWEuZGlzcGxheSxmPSExLGc9YWEoYSxmdW5jdGlvbihsKXtmYSYmKGUuc2Nyb2xsZXIuZHJhZ2dhYmxlPSExKTthLnN0YXRlLmRyYWdnaW5nVGV4dD0hMTtyYShlLndyYXBwZXIub3duZXJEb2N1bWVudCxcIm1vdXNldXBcIixnKTtyYShlLndyYXBwZXIub3duZXJEb2N1bWVudCxcblwibW91c2Vtb3ZlXCIsaCk7cmEoZS5zY3JvbGxlcixcImRyYWdzdGFydFwiLGspO3JhKGUuc2Nyb2xsZXIsXCJkcm9wXCIsZyk7Znx8KGxhKGwpLGMuYWRkTmV3fHxTYyhhLmRvYyxkLG51bGwsbnVsbCxjLmV4dGVuZCksZmEmJiFnZXx8RyYmOT09VT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS53cmFwcGVyLm93bmVyRG9jdW1lbnQuYm9keS5mb2N1cyh7cHJldmVudFNjcm9sbDohMH0pO2UuaW5wdXQuZm9jdXMoKX0sMjApOmUuaW5wdXQuZm9jdXMoKSl9KSxoPWZ1bmN0aW9uKGwpe2Y9Znx8MTA8PU1hdGguYWJzKGIuY2xpZW50WC1sLmNsaWVudFgpK01hdGguYWJzKGIuY2xpZW50WS1sLmNsaWVudFkpfSxrPWZ1bmN0aW9uKCl7cmV0dXJuIGY9ITB9O2ZhJiYoZS5zY3JvbGxlci5kcmFnZ2FibGU9ITApO2Euc3RhdGUuZHJhZ2dpbmdUZXh0PWc7Zy5jb3B5PSFjLm1vdmVPbkRyYWc7ZS5zY3JvbGxlci5kcmFnRHJvcCYmZS5zY3JvbGxlci5kcmFnRHJvcCgpO3ooZS53cmFwcGVyLm93bmVyRG9jdW1lbnQsXG5cIm1vdXNldXBcIixnKTt6KGUud3JhcHBlci5vd25lckRvY3VtZW50LFwibW91c2Vtb3ZlXCIsaCk7eihlLnNjcm9sbGVyLFwiZHJhZ3N0YXJ0XCIsayk7eihlLnNjcm9sbGVyLFwiZHJvcFwiLGcpO2dmKGEpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZS5pbnB1dC5mb2N1cygpfSwyMCl9ZnVuY3Rpb24gaGcoYSxiLGQpe2lmKFwiY2hhclwiPT1kKXJldHVybiBuZXcgSihiLGIpO2lmKFwid29yZFwiPT1kKXJldHVybiBhLmZpbmRXb3JkQXQoYik7aWYoXCJsaW5lXCI9PWQpcmV0dXJuIG5ldyBKKHQoYi5saW5lLDApLEMoYS5kb2MsdChiLmxpbmUrMSwwKSkpO2E9ZChhLGIpO3JldHVybiBuZXcgSihhLmZyb20sYS50byl9ZnVuY3Rpb24gdmgoYSxiLGQsYyl7ZnVuY3Rpb24gZSh4KXtpZigwIT1CKHAseCkpaWYocD14LFwicmVjdGFuZ2xlXCI9PWMudW5pdCl7dmFyIFE9W10sTT1hLm9wdGlvbnMudGFiU2l6ZSxSPXdhKHcoayxkLmxpbmUpLnRleHQsZC5jaCxNKSxUPXdhKHcoayx4LmxpbmUpLnRleHQsXG54LmNoLE0pLEY9TWF0aC5taW4oUixUKTtSPU1hdGgubWF4KFIsVCk7VD1NYXRoLm1pbihkLmxpbmUseC5saW5lKTtmb3IodmFyIFM9TWF0aC5taW4oYS5sYXN0TGluZSgpLE1hdGgubWF4KGQubGluZSx4LmxpbmUpKTtUPD1TO1QrKyl7dmFyIEk9dyhrLFQpLnRleHQsTj1lZChJLEYsTSk7Rj09Uj9RLnB1c2gobmV3IEoodChULE4pLHQoVCxOKSkpOkkubGVuZ3RoPk4mJlEucHVzaChuZXcgSih0KFQsTiksdChULGVkKEksUixNKSkpKX1RLmxlbmd0aHx8US5wdXNoKG5ldyBKKGQsZCkpO2RhKGssQ2EoYSxsLnJhbmdlcy5zbGljZSgwLHEpLmNvbmNhdChRKSxxKSx7b3JpZ2luOlwiKm1vdXNlXCIsc2Nyb2xsOiExfSk7YS5zY3JvbGxJbnRvVmlldyh4KX1lbHNlIFE9bixGPWhnKGEseCxjLnVuaXQpLHg9US5hbmNob3IsMDxCKEYuYW5jaG9yLHgpPyhNPUYuaGVhZCx4PUFjKFEuZnJvbSgpLEYuYW5jaG9yKSk6KE09Ri5hbmNob3IseD16YyhRLnRvKCksRi5oZWFkKSksUT1sLnJhbmdlcy5zbGljZSgwKSxcblFbcV09d2goYSxuZXcgSihDKGsseCksTSkpLGRhKGssQ2EoYSxRLHEpLGhlKX1mdW5jdGlvbiBmKHgpe3ZhciBRPSsrdSxNPWViKGEseCwhMCxcInJlY3RhbmdsZVwiPT1jLnVuaXQpO2lmKE0paWYoMCE9QihNLHApKXthLmN1ck9wLmZvY3VzPXZhKCk7ZShNKTt2YXIgUj1MYyhoLGspOyhNLmxpbmU+PVIudG98fE0ubGluZTxSLmZyb20pJiZzZXRUaW1lb3V0KGFhKGEsZnVuY3Rpb24oKXt1PT1RJiZmKHgpfSksMTUwKX1lbHNle3ZhciBUPXguY2xpZW50WTxyLnRvcD8tMjA6eC5jbGllbnRZPnIuYm90dG9tPzIwOjA7VCYmc2V0VGltZW91dChhYShhLGZ1bmN0aW9uKCl7dT09USYmKGguc2Nyb2xsZXIuc2Nyb2xsVG9wKz1ULGYoeCkpfSksNTApfX1mdW5jdGlvbiBnKHgpe2Euc3RhdGUuc2VsZWN0aW5nVGV4dD0hMTt1PUluZmluaXR5O3gmJihsYSh4KSxoLmlucHV0LmZvY3VzKCkpO3JhKGgud3JhcHBlci5vd25lckRvY3VtZW50LFwibW91c2Vtb3ZlXCIsQSk7cmEoaC53cmFwcGVyLm93bmVyRG9jdW1lbnQsXG5cIm1vdXNldXBcIixIKTtrLmhpc3RvcnkubGFzdFNlbE9yaWdpbj1udWxsfXZhciBoPWEuZGlzcGxheSxrPWEuZG9jO2xhKGIpO3ZhciBsPWsuc2VsLG09bC5yYW5nZXM7aWYoYy5hZGROZXcmJiFjLmV4dGVuZCl7dmFyIHE9ay5zZWwuY29udGFpbnMoZCk7dmFyIG49LTE8cT9tW3FdOm5ldyBKKGQsZCl9ZWxzZSBuPWsuc2VsLnByaW1hcnkoKSxxPWsuc2VsLnByaW1JbmRleDtcInJlY3RhbmdsZVwiPT1jLnVuaXQ/KGMuYWRkTmV3fHwobj1uZXcgSihkLGQpKSxkPWViKGEsYiwhMCwhMCkscT0tMSk6KGI9aGcoYSxkLGMudW5pdCksbj1jLmV4dGVuZD9aZChuLGIuYW5jaG9yLGIuaGVhZCxjLmV4dGVuZCk6Yik7Yy5hZGROZXc/LTE9PXE/KHE9bS5sZW5ndGgsZGEoayxDYShhLG0uY29uY2F0KFtuXSkscSkse3Njcm9sbDohMSxvcmlnaW46XCIqbW91c2VcIn0pKToxPG0ubGVuZ3RoJiZtW3FdLmVtcHR5KCkmJlwiY2hhclwiPT1jLnVuaXQmJiFjLmV4dGVuZD8oZGEoayxDYShhLG0uc2xpY2UoMCxxKS5jb25jYXQobS5zbGljZShxK1xuMSkpLDApLHtzY3JvbGw6ITEsb3JpZ2luOlwiKm1vdXNlXCJ9KSxsPWsuc2VsKTokZChrLHEsbixoZSk6KHE9MCxkYShrLG5ldyB1YShbbl0sMCksaGUpLGw9ay5zZWwpO3ZhciBwPWQscj1oLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksdT0wLEE9YWEoYSxmdW5jdGlvbih4KXswIT09eC5idXR0b25zJiZzZSh4KT9mKHgpOmcoeCl9KSxIPWFhKGEsZyk7YS5zdGF0ZS5zZWxlY3RpbmdUZXh0PUg7eihoLndyYXBwZXIub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLEEpO3ooaC53cmFwcGVyLm93bmVyRG9jdW1lbnQsXCJtb3VzZXVwXCIsSCl9ZnVuY3Rpb24gd2goYSxiKXt2YXIgZD1iLmFuY2hvcixjPWIuaGVhZCxlPXcoYS5kb2MsZC5saW5lKTtpZigwPT1CKGQsYykmJmQuc3RpY2t5PT1jLnN0aWNreSlyZXR1cm4gYjtlPUphKGUpO2lmKCFlKXJldHVybiBiO3ZhciBmPUliKGUsZC5jaCxkLnN0aWNreSksZz1lW2ZdO2lmKGcuZnJvbSE9ZC5jaCYmZy50byE9ZC5jaClyZXR1cm4gYjtcbnZhciBoPWYrKGcuZnJvbT09ZC5jaD09KDEhPWcubGV2ZWwpPzA6MSk7aWYoMD09aHx8aD09ZS5sZW5ndGgpcmV0dXJuIGI7Yy5saW5lIT1kLmxpbmU/YT0wPChjLmxpbmUtZC5saW5lKSooXCJsdHJcIj09YS5kb2MuZGlyZWN0aW9uPzE6LTEpOihhPUliKGUsYy5jaCxjLnN0aWNreSksZj1hLWZ8fChjLmNoLWQuY2gpKigxPT1nLmxldmVsPy0xOjEpLGE9YT09aC0xfHxhPT1oPzA+ZjowPGYpO2U9ZVtoKyhhPy0xOjApXTtlPShoPWE9PSgxPT1lLmxldmVsKSk/ZS5mcm9tOmUudG87aD1oP1wiYWZ0ZXJcIjpcImJlZm9yZVwiO3JldHVybiBkLmNoPT1lJiZkLnN0aWNreT09aD9iOm5ldyBKKG5ldyB0KGQubGluZSxlLGgpLGMpfWZ1bmN0aW9uIFpjKGEsYixkLGMpe2lmKGIudG91Y2hlcyl7dmFyIGU9Yi50b3VjaGVzWzBdLmNsaWVudFg7dmFyIGY9Yi50b3VjaGVzWzBdLmNsaWVudFl9ZWxzZSB0cnl7ZT1iLmNsaWVudFgsZj1iLmNsaWVudFl9Y2F0Y2goayl7cmV0dXJuITF9aWYoZT49TWF0aC5mbG9vcihhLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpcmV0dXJuITE7XG5jJiZsYShiKTtjPWEuZGlzcGxheTt2YXIgZz1jLmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoZj5nLmJvdHRvbXx8IXhhKGEsZCkpcmV0dXJuIGlkKGIpO2YtPWcudG9wLWMudmlld09mZnNldDtmb3IoZz0wO2c8YS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aDsrK2cpe3ZhciBoPWMuZ3V0dGVycy5jaGlsZE5vZGVzW2ddO2lmKGgmJmguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ+PWUpcmV0dXJuIGU9JGEoYS5kb2MsZiksWChhLGQsYSxlLGEuZGlzcGxheS5ndXR0ZXJTcGVjc1tnXS5jbGFzc05hbWUsYiksaWQoYil9fWZ1bmN0aW9uIGlnKGEsYil7dmFyIGQ7KGQ9TGEoYS5kaXNwbGF5LGIpKXx8KGQ9eGEoYSxcImd1dHRlckNvbnRleHRNZW51XCIpP1pjKGEsYixcImd1dHRlckNvbnRleHRNZW51XCIsITEpOiExKTtpZighZCYmIVooYSxiLFwiY29udGV4dG1lbnVcIikmJiFmZSlhLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShiKX1mdW5jdGlvbiBqZyhhKXthLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWU9XG5hLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLFwiXCIpK2Eub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLFwiIGNtLXMtXCIpO1NiKGEpfWZ1bmN0aW9uIHhoKGEsYixkKXshYiE9IShkJiZkIT1GYikmJihkPWEuZGlzcGxheS5kcmFnRnVuY3Rpb25zLGI9Yj96OnJhLGIoYS5kaXNwbGF5LnNjcm9sbGVyLFwiZHJhZ3N0YXJ0XCIsZC5zdGFydCksYihhLmRpc3BsYXkuc2Nyb2xsZXIsXCJkcmFnZW50ZXJcIixkLmVudGVyKSxiKGEuZGlzcGxheS5zY3JvbGxlcixcImRyYWdvdmVyXCIsZC5vdmVyKSxiKGEuZGlzcGxheS5zY3JvbGxlcixcImRyYWdsZWF2ZVwiLGQubGVhdmUpLGIoYS5kaXNwbGF5LnNjcm9sbGVyLFwiZHJvcFwiLGQuZHJvcCkpfWZ1bmN0aW9uIHloKGEpe2Eub3B0aW9ucy5saW5lV3JhcHBpbmc/KFdhKGEuZGlzcGxheS53cmFwcGVyLFwiQ29kZU1pcnJvci13cmFwXCIpLGEuZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aD1cIlwiLGEuZGlzcGxheS5zaXplcldpZHRoPVxubnVsbCk6KGhiKGEuZGlzcGxheS53cmFwcGVyLFwiQ29kZU1pcnJvci13cmFwXCIpLHhkKGEpKTtMZChhKTttYShhKTtTYihhKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHdiKGEpfSwxMDApfWZ1bmN0aW9uIFYoYSxiKXt2YXIgZD10aGlzO2lmKCEodGhpcyBpbnN0YW5jZW9mIFYpKXJldHVybiBuZXcgVihhLGIpO3RoaXMub3B0aW9ucz1iPWI/WGEoYik6e307WGEoa2csYiwhMSk7dmFyIGM9Yi52YWx1ZTtcInN0cmluZ1wiPT10eXBlb2YgYz9jPW5ldyBvYShjLGIubW9kZSxudWxsLGIubGluZVNlcGFyYXRvcixiLmRpcmVjdGlvbik6Yi5tb2RlJiYoYy5tb2RlT3B0aW9uPWIubW9kZSk7dGhpcy5kb2M9Yzt2YXIgZT1uZXcgVi5pbnB1dFN0eWxlc1tiLmlucHV0U3R5bGVdKHRoaXMpO2E9dGhpcy5kaXNwbGF5PW5ldyBYZyhhLGMsZSxiKTthLndyYXBwZXIuQ29kZU1pcnJvcj10aGlzO2pnKHRoaXMpO2IubGluZVdyYXBwaW5nJiYodGhpcy5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lKz1cblwiIENvZGVNaXJyb3Itd3JhcFwiKTtuZih0aGlzKTt0aGlzLnN0YXRlPXtrZXlNYXBzOltdLG92ZXJsYXlzOltdLG1vZGVHZW46MCxvdmVyd3JpdGU6ITEsZGVsYXlpbmdCbHVyRXZlbnQ6ITEsZm9jdXNlZDohMSxzdXBwcmVzc0VkaXRzOiExLHBhc3RlSW5jb21pbmc6LTEsY3V0SW5jb21pbmc6LTEsc2VsZWN0aW5nVGV4dDohMSxkcmFnZ2luZ1RleHQ6ITEsaGlnaGxpZ2h0Om5ldyBWYSxrZXlTZXE6bnVsbCxzcGVjaWFsQ2hhcnM6bnVsbH07Yi5hdXRvZm9jdXMmJiFaYiYmYS5pbnB1dC5mb2N1cygpO0cmJjExPlUmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZC5kaXNwbGF5LmlucHV0LnJlc2V0KCEwKX0sMjApO3poKHRoaXMpO2xnfHwoZ2goKSxsZz0hMCk7amIodGhpcyk7dGhpcy5jdXJPcC5mb3JjZVVwZGF0ZT0hMDt4Zih0aGlzLGMpO2IuYXV0b2ZvY3VzJiYhWmJ8fHRoaXMuaGFzRm9jdXMoKT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5oYXNGb2N1cygpJiYhZC5zdGF0ZS5mb2N1c2VkJiZcbk9kKGQpfSwyMCk6dWIodGhpcyk7Zm9yKHZhciBmIGluICRjKWlmKCRjLmhhc093blByb3BlcnR5KGYpKSRjW2ZdKHRoaXMsYltmXSxGYik7cWYodGhpcyk7Yi5maW5pc2hJbml0JiZiLmZpbmlzaEluaXQodGhpcyk7Zm9yKGM9MDtjPGllLmxlbmd0aDsrK2MpaWVbY10odGhpcyk7a2IodGhpcyk7ZmEmJmIubGluZVdyYXBwaW5nJiZcIm9wdGltaXplbGVnaWJpbGl0eVwiPT1nZXRDb21wdXRlZFN0eWxlKGEubGluZURpdikudGV4dFJlbmRlcmluZyYmKGEubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nPVwiYXV0b1wiKX1mdW5jdGlvbiB6aChhKXtmdW5jdGlvbiBiKCl7Yy5hY3RpdmVUb3VjaCYmKGU9c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBjLmFjdGl2ZVRvdWNoPW51bGx9LDFFMyksZj1jLmFjdGl2ZVRvdWNoLGYuZW5kPStuZXcgRGF0ZSl9ZnVuY3Rpb24gZChoLGspe2lmKG51bGw9PWsubGVmdClyZXR1cm4hMDt2YXIgbD1rLmxlZnQtaC5sZWZ0O2g9ay50b3AtaC50b3A7cmV0dXJuIDQwMDxcbmwqbCtoKmh9dmFyIGM9YS5kaXNwbGF5O3ooYy5zY3JvbGxlcixcIm1vdXNlZG93blwiLGFhKGEsZ2cpKTtHJiYxMT5VP3ooYy5zY3JvbGxlcixcImRibGNsaWNrXCIsYWEoYSxmdW5jdGlvbihoKXtpZighWihhLGgpKXt2YXIgaz1lYihhLGgpOyFrfHxaYyhhLGgsXCJndXR0ZXJDbGlja1wiLCEwKXx8TGEoYS5kaXNwbGF5LGgpfHwobGEoaCksaD1hLmZpbmRXb3JkQXQoayksU2MoYS5kb2MsaC5hbmNob3IsaC5oZWFkKSl9fSkpOnooYy5zY3JvbGxlcixcImRibGNsaWNrXCIsZnVuY3Rpb24oaCl7cmV0dXJuIFooYSxoKXx8bGEoaCl9KTt6KGMuc2Nyb2xsZXIsXCJjb250ZXh0bWVudVwiLGZ1bmN0aW9uKGgpe3JldHVybiBpZyhhLGgpfSk7eihjLmlucHV0LmdldEZpZWxkKCksXCJjb250ZXh0bWVudVwiLGZ1bmN0aW9uKGgpe2Muc2Nyb2xsZXIuY29udGFpbnMoaC50YXJnZXQpfHxpZyhhLGgpfSk7dmFyIGUsZj17ZW5kOjB9O3ooYy5zY3JvbGxlcixcInRvdWNoc3RhcnRcIixmdW5jdGlvbihoKXt2YXIgaztpZihrPVxuIVooYSxoKSkxIT1oLnRvdWNoZXMubGVuZ3RoP2s9ITE6KGs9aC50b3VjaGVzWzBdLGs9MT49ay5yYWRpdXNYJiYxPj1rLnJhZGl1c1kpLGs9IWs7ayYmIVpjKGEsaCxcImd1dHRlckNsaWNrXCIsITApJiYoYy5pbnB1dC5lbnN1cmVQb2xsZWQoKSxjbGVhclRpbWVvdXQoZSksaz0rbmV3IERhdGUsYy5hY3RpdmVUb3VjaD17c3RhcnQ6ayxtb3ZlZDohMSxwcmV2OjMwMD49ay1mLmVuZD9mOm51bGx9LDE9PWgudG91Y2hlcy5sZW5ndGgmJihjLmFjdGl2ZVRvdWNoLmxlZnQ9aC50b3VjaGVzWzBdLnBhZ2VYLGMuYWN0aXZlVG91Y2gudG9wPWgudG91Y2hlc1swXS5wYWdlWSkpfSk7eihjLnNjcm9sbGVyLFwidG91Y2htb3ZlXCIsZnVuY3Rpb24oKXtjLmFjdGl2ZVRvdWNoJiYoYy5hY3RpdmVUb3VjaC5tb3ZlZD0hMCl9KTt6KGMuc2Nyb2xsZXIsXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKGgpe3ZhciBrPWMuYWN0aXZlVG91Y2g7aWYoayYmIUxhKGMsaCkmJm51bGwhPWsubGVmdCYmIWsubW92ZWQmJjMwMD5cbm5ldyBEYXRlLWsuc3RhcnQpe3ZhciBsPWEuY29vcmRzQ2hhcihjLmFjdGl2ZVRvdWNoLFwicGFnZVwiKTtrPSFrLnByZXZ8fGQoayxrLnByZXYpP25ldyBKKGwsbCk6IWsucHJldi5wcmV2fHxkKGssay5wcmV2LnByZXYpP2EuZmluZFdvcmRBdChsKTpuZXcgSih0KGwubGluZSwwKSxDKGEuZG9jLHQobC5saW5lKzEsMCkpKTthLnNldFNlbGVjdGlvbihrLmFuY2hvcixrLmhlYWQpO2EuZm9jdXMoKTtsYShoKX1iKCl9KTt6KGMuc2Nyb2xsZXIsXCJ0b3VjaGNhbmNlbFwiLGIpO3ooYy5zY3JvbGxlcixcInNjcm9sbFwiLGZ1bmN0aW9uKCl7Yy5zY3JvbGxlci5jbGllbnRIZWlnaHQmJihWYihhLGMuc2Nyb2xsZXIuc2Nyb2xsVG9wKSxpYihhLGMuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwhMCksWChhLFwic2Nyb2xsXCIsYSkpfSk7eihjLnNjcm9sbGVyLFwibW91c2V3aGVlbFwiLGZ1bmN0aW9uKGgpe3JldHVybiB0ZihhLGgpfSk7eihjLnNjcm9sbGVyLFwiRE9NTW91c2VTY3JvbGxcIixmdW5jdGlvbihoKXtyZXR1cm4gdGYoYSxcbmgpfSk7eihjLndyYXBwZXIsXCJzY3JvbGxcIixmdW5jdGlvbigpe3JldHVybiBjLndyYXBwZXIuc2Nyb2xsVG9wPWMud3JhcHBlci5zY3JvbGxMZWZ0PTB9KTtjLmRyYWdGdW5jdGlvbnM9e2VudGVyOmZ1bmN0aW9uKGgpe1ooYSxoKXx8S2IoaCl9LG92ZXI6ZnVuY3Rpb24oaCl7aWYoIVooYSxoKSl7dmFyIGs9ZWIoYSxoKTtpZihrKXt2YXIgbD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7ZWYoYSxrLGwpO2EuZGlzcGxheS5kcmFnQ3Vyc29yfHwoYS5kaXNwbGF5LmRyYWdDdXJzb3I9dihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWN1cnNvcnMgQ29kZU1pcnJvci1kcmFnY3Vyc29yc1wiKSxhLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShhLmRpc3BsYXkuZHJhZ0N1cnNvcixhLmRpc3BsYXkuY3Vyc29yRGl2KSk7RChhLmRpc3BsYXkuZHJhZ0N1cnNvcixsKX1LYihoKX19LHN0YXJ0OmZ1bmN0aW9uKGgpe2lmKEcmJighYS5zdGF0ZS5kcmFnZ2luZ1RleHR8fDEwMD5cbituZXcgRGF0ZS1VZikpS2IoaCk7ZWxzZSBpZighWihhLGgpJiYhTGEoYS5kaXNwbGF5LGgpJiYoaC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIixhLmdldFNlbGVjdGlvbigpKSxoLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkPVwiY29weU1vdmVcIixoLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UmJiFnZSkpe3ZhciBrPXYoXCJpbWdcIixudWxsLG51bGwsXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IDA7IHRvcDogMDtcIik7ay5zcmM9XCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO0JhJiYoay53aWR0aD1rLmhlaWdodD0xLGEuZGlzcGxheS53cmFwcGVyLmFwcGVuZENoaWxkKGspLGsuX3RvcD1rLm9mZnNldFRvcCk7aC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGssMCwwKTtCYSYmay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGspfX0sZHJvcDphYShhLGZoKSxsZWF2ZTpmdW5jdGlvbihoKXtaKGEsXG5oKXx8VGYoYSl9fTt2YXIgZz1jLmlucHV0LmdldEZpZWxkKCk7eihnLFwia2V5dXBcIixmdW5jdGlvbihoKXtyZXR1cm4gZWcuY2FsbChhLGgpfSk7eihnLFwia2V5ZG93blwiLGFhKGEsZGcpKTt6KGcsXCJrZXlwcmVzc1wiLGFhKGEsZmcpKTt6KGcsXCJmb2N1c1wiLGZ1bmN0aW9uKGgpe3JldHVybiBPZChhLGgpfSk7eihnLFwiYmx1clwiLGZ1bmN0aW9uKGgpe3JldHVybiB1YihhLGgpfSl9ZnVuY3Rpb24gbGMoYSxiLGQsYyl7dmFyIGU9YS5kb2MsZjtudWxsPT1kJiYoZD1cImFkZFwiKTtcInNtYXJ0XCI9PWQmJihlLm1vZGUuaW5kZW50P2Y9TWIoYSxiKS5zdGF0ZTpkPVwicHJldlwiKTt2YXIgZz1hLm9wdGlvbnMudGFiU2l6ZSxoPXcoZSxiKSxrPXdhKGgudGV4dCxudWxsLGcpO2guc3RhdGVBZnRlciYmKGguc3RhdGVBZnRlcj1udWxsKTt2YXIgbD1oLnRleHQubWF0Y2goL15cXHMqLylbMF07aWYoIWMmJiEvXFxTLy50ZXN0KGgudGV4dCkpe3ZhciBtPTA7ZD1cIm5vdFwifWVsc2UgaWYoXCJzbWFydFwiPT1kJiYobT1cbmUubW9kZS5pbmRlbnQoZixoLnRleHQuc2xpY2UobC5sZW5ndGgpLGgudGV4dCksbT09WWN8fDE1MDxtKSl7aWYoIWMpcmV0dXJuO2Q9XCJwcmV2XCJ9XCJwcmV2XCI9PWQ/bT1iPmUuZmlyc3Q/d2EodyhlLGItMSkudGV4dCxudWxsLGcpOjA6XCJhZGRcIj09ZD9tPWsrYS5vcHRpb25zLmluZGVudFVuaXQ6XCJzdWJ0cmFjdFwiPT1kP209ay1hLm9wdGlvbnMuaW5kZW50VW5pdDpcIm51bWJlclwiPT10eXBlb2YgZCYmKG09aytkKTttPU1hdGgubWF4KDAsbSk7ZD1cIlwiO2M9MDtpZihhLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpZm9yKGE9TWF0aC5mbG9vcihtL2cpO2E7LS1hKWMrPWcsZCs9XCJcXHRcIjtjPG0mJihkKz1mZChtLWMpKTtpZihkIT1sKXJldHVybiBCYihlLGQsdChiLDApLHQoYixsLmxlbmd0aCksXCIraW5wdXRcIiksaC5zdGF0ZUFmdGVyPW51bGwsITA7Zm9yKGc9MDtnPGUuc2VsLnJhbmdlcy5sZW5ndGg7ZysrKWlmKGg9ZS5zZWwucmFuZ2VzW2ddLGguaGVhZC5saW5lPT1iJiZoLmhlYWQuY2g8XG5sLmxlbmd0aCl7Yj10KGIsbC5sZW5ndGgpOyRkKGUsZyxuZXcgSihiLGIpKTticmVha319ZnVuY3Rpb24gamUoYSxiLGQsYyxlKXt2YXIgZj1hLmRvYzthLmRpc3BsYXkuc2hpZnQ9ITE7Y3x8KGM9Zi5zZWwpO3ZhciBnPStuZXcgRGF0ZS0yMDAsaD1cInBhc3RlXCI9PWV8fGEuc3RhdGUucGFzdGVJbmNvbWluZz5nLGs9a2UoYiksbD1udWxsO2lmKGgmJjE8Yy5yYW5nZXMubGVuZ3RoKWlmKHFhJiZxYS50ZXh0LmpvaW4oXCJcXG5cIik9PWIpe2lmKDA9PWMucmFuZ2VzLmxlbmd0aCVxYS50ZXh0Lmxlbmd0aCl7bD1bXTtmb3IodmFyIG09MDttPHFhLnRleHQubGVuZ3RoO20rKylsLnB1c2goZi5zcGxpdExpbmVzKHFhLnRleHRbbV0pKX19ZWxzZSBrLmxlbmd0aD09Yy5yYW5nZXMubGVuZ3RoJiZhLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbiYmKGw9dmMoayxmdW5jdGlvbih1KXtyZXR1cm5bdV19KSk7bT1hLmN1ck9wLnVwZGF0ZUlucHV0O2Zvcih2YXIgcT1jLnJhbmdlcy5sZW5ndGgtXG4xOzA8PXE7cS0tKXt2YXIgbj1jLnJhbmdlc1txXSxwPW4uZnJvbSgpLHI9bi50bygpO24uZW1wdHkoKSYmKGQmJjA8ZD9wPXQocC5saW5lLHAuY2gtZCk6YS5zdGF0ZS5vdmVyd3JpdGUmJiFoP3I9dChyLmxpbmUsTWF0aC5taW4odyhmLHIubGluZSkudGV4dC5sZW5ndGgsci5jaCtMKGspLmxlbmd0aCkpOmgmJnFhJiZxYS5saW5lV2lzZSYmcWEudGV4dC5qb2luKFwiXFxuXCIpPT1rLmpvaW4oXCJcXG5cIikmJihwPXI9dChwLmxpbmUsMCkpKTtuPXtmcm9tOnAsdG86cix0ZXh0Omw/bFtxJWwubGVuZ3RoXTprLG9yaWdpbjplfHwoaD9cInBhc3RlXCI6YS5zdGF0ZS5jdXRJbmNvbWluZz5nP1wiY3V0XCI6XCIraW5wdXRcIil9O0FiKGEuZG9jLG4pO2NhKGEsXCJpbnB1dFJlYWRcIixhLG4pfWImJiFoJiZtZyhhLGIpO3ZiKGEpOzI+YS5jdXJPcC51cGRhdGVJbnB1dCYmKGEuY3VyT3AudXBkYXRlSW5wdXQ9bSk7YS5jdXJPcC50eXBpbmc9ITA7YS5zdGF0ZS5wYXN0ZUluY29taW5nPWEuc3RhdGUuY3V0SW5jb21pbmc9XG4tMX1mdW5jdGlvbiBuZyhhLGIpe3ZhciBkPWEuY2xpcGJvYXJkRGF0YSYmYS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO2lmKGQpcmV0dXJuIGEucHJldmVudERlZmF1bHQoKSxiLmlzUmVhZE9ubHkoKXx8Yi5vcHRpb25zLmRpc2FibGVJbnB1dHx8cGEoYixmdW5jdGlvbigpe3JldHVybiBqZShiLGQsMCxudWxsLFwicGFzdGVcIil9KSwhMH1mdW5jdGlvbiBtZyhhLGIpe2lmKGEub3B0aW9ucy5lbGVjdHJpY0NoYXJzJiZhLm9wdGlvbnMuc21hcnRJbmRlbnQpZm9yKHZhciBkPWEuZG9jLnNlbCxjPWQucmFuZ2VzLmxlbmd0aC0xOzA8PWM7Yy0tKXt2YXIgZT1kLnJhbmdlc1tjXTtpZighKDEwMDxlLmhlYWQuY2h8fGMmJmQucmFuZ2VzW2MtMV0uaGVhZC5saW5lPT1lLmhlYWQubGluZSkpe3ZhciBmPWEuZ2V0TW9kZUF0KGUuaGVhZCksZz0hMTtpZihmLmVsZWN0cmljQ2hhcnMpZm9yKHZhciBoPTA7aDxmLmVsZWN0cmljQ2hhcnMubGVuZ3RoO2grKyl7aWYoLTE8Yi5pbmRleE9mKGYuZWxlY3RyaWNDaGFycy5jaGFyQXQoaCkpKXtnPVxubGMoYSxlLmhlYWQubGluZSxcInNtYXJ0XCIpO2JyZWFrfX1lbHNlIGYuZWxlY3RyaWNJbnB1dCYmZi5lbGVjdHJpY0lucHV0LnRlc3QodyhhLmRvYyxlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLGUuaGVhZC5jaCkpJiYoZz1sYyhhLGUuaGVhZC5saW5lLFwic21hcnRcIikpO2cmJmNhKGEsXCJlbGVjdHJpY0lucHV0XCIsYSxlLmhlYWQubGluZSl9fX1mdW5jdGlvbiBvZyhhKXtmb3IodmFyIGI9W10sZD1bXSxjPTA7YzxhLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDtjKyspe3ZhciBlPWEuZG9jLnNlbC5yYW5nZXNbY10uaGVhZC5saW5lO2U9e2FuY2hvcjp0KGUsMCksaGVhZDp0KGUrMSwwKX07ZC5wdXNoKGUpO2IucHVzaChhLmdldFJhbmdlKGUuYW5jaG9yLGUuaGVhZCkpfXJldHVybnt0ZXh0OmIscmFuZ2VzOmR9fWZ1bmN0aW9uIHBnKGEsYixkLGMpe2Euc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIixkP1wiXCI6XCJvZmZcIik7YS5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLGM/XCJcIjpcIm9mZlwiKTtcbmEuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCEhYil9ZnVuY3Rpb24gcWcoKXt2YXIgYT12KFwidGV4dGFyZWFcIixudWxsLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogLTFlbTsgcGFkZGluZzogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxZW07IG91dGxpbmU6IG5vbmVcIiksYj12KFwiZGl2XCIsW2FdLG51bGwsXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtmYT9hLnN0eWxlLndpZHRoPVwiMTAwMHB4XCI6YS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsXCJvZmZcIik7bWMmJihhLnN0eWxlLmJvcmRlcj1cIjFweCBzb2xpZCBibGFja1wiKTtwZyhhKTtyZXR1cm4gYn1mdW5jdGlvbiBsZShhLGIsZCxjLGUpe2Z1bmN0aW9uIGYodSl7aWYoXCJjb2RlcG9pbnRcIj09Yyl7dmFyIEE9ay50ZXh0LmNoYXJDb2RlQXQoYi5jaCsoMDxjPzA6LTEpKTtBPWlzTmFOKEEpP251bGw6bmV3IHQoYi5saW5lLE1hdGgubWF4KDAsTWF0aC5taW4oay50ZXh0Lmxlbmd0aCxcbmIuY2grZCooNTUyOTY8PUEmJjU2MzIwPkE/MjoxKSkpLC1kKX1lbHNlIEE9ZT9raChhLmNtLGssYixkKTpiZShrLGIsZCk7aWYobnVsbD09QSl7aWYodT0hdSl1PWIubGluZStsLHU8YS5maXJzdHx8dT49YS5maXJzdCthLnNpemU/dT0hMTooYj1uZXcgdCh1LGIuY2gsYi5zdGlja3kpLHU9az13KGEsdSkpO2lmKHUpYj1jZShlLGEuY20sayxiLmxpbmUsbCk7ZWxzZSByZXR1cm4hMX1lbHNlIGI9QTtyZXR1cm4hMH12YXIgZz1iLGg9ZCxrPXcoYSxiLmxpbmUpLGw9ZSYmXCJydGxcIj09YS5kaXJlY3Rpb24/LWQ6ZDtpZihcImNoYXJcIj09Y3x8XCJjb2RlcG9pbnRcIj09YylmKCk7ZWxzZSBpZihcImNvbHVtblwiPT1jKWYoITApO2Vsc2UgaWYoXCJ3b3JkXCI9PWN8fFwiZ3JvdXBcIj09Yylmb3IodmFyIG09bnVsbCxxPVwiZ3JvdXBcIj09YyxuPWEuY20mJmEuY20uZ2V0SGVscGVyKGIsXCJ3b3JkQ2hhcnNcIikscD0hMDshKDA+ZCl8fGYoIXApO3A9ITEpe3ZhciByPWsudGV4dC5jaGFyQXQoYi5jaCl8fFwiXFxuXCI7XG5yPXdjKHIsbik/XCJ3XCI6cSYmXCJcXG5cIj09cj9cIm5cIjohcXx8L1xccy8udGVzdChyKT9udWxsOlwicFwiOyFxfHxwfHxyfHwocj1cInNcIik7aWYobSYmbSE9cil7MD5kJiYoZD0xLGYoKSxiLnN0aWNreT1cImFmdGVyXCIpO2JyZWFrfXImJihtPXIpO2lmKDA8ZCYmIWYoIXApKWJyZWFrfWg9VWMoYSxiLGcsaCwhMCk7cGQoZyxoKSYmKGguaGl0U2lkZT0hMCk7cmV0dXJuIGh9ZnVuY3Rpb24gcmcoYSxiLGQsYyl7dmFyIGU9YS5kb2MsZj1iLmxlZnQ7aWYoXCJwYWdlXCI9PWMpe3ZhciBnPU1hdGgubWF4KE1hdGgubWluKGEuZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCx3aW5kb3cuaW5uZXJIZWlnaHR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpLS41KnRiKGEuZGlzcGxheSksMyk7Zz0oMDxkP2IuYm90dG9tOmIudG9wKStkKmd9ZWxzZVwibGluZVwiPT1jJiYoZz0wPGQ/Yi5ib3R0b20rMzpiLnRvcC0zKTtmb3IoOzspe2I9SWQoYSxmLGcpO2lmKCFiLm91dHNpZGUpYnJlYWs7XG5pZigwPmQ/MD49ZzpnPj1lLmhlaWdodCl7Yi5oaXRTaWRlPSEwO2JyZWFrfWcrPTUqZH1yZXR1cm4gYn1mdW5jdGlvbiBzZyhhLGIpe3ZhciBkPUNkKGEsYi5saW5lKTtpZighZHx8ZC5oaWRkZW4pcmV0dXJuIG51bGw7dmFyIGM9dyhhLmRvYyxiLmxpbmUpO2Q9UmUoZCxjLGIubGluZSk7YT1KYShjLGEuZG9jLmRpcmVjdGlvbik7Yz1cImxlZnRcIjthJiYoYz1JYihhLGIuY2gpJTI/XCJyaWdodFwiOlwibGVmdFwiKTtiPVNlKGQubWFwLGIuY2gsYyk7Yi5vZmZzZXQ9XCJyaWdodFwiPT1iLmNvbGxhcHNlP2IuZW5kOmIuc3RhcnQ7cmV0dXJuIGJ9ZnVuY3Rpb24gQWgoYSl7Zm9yKDthO2E9YS5wYXJlbnROb2RlKWlmKC9Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyLy50ZXN0KGEuY2xhc3NOYW1lKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBHYihhLGIpe2ImJihhLmJhZD0hMCk7cmV0dXJuIGF9ZnVuY3Rpb24gQmgoYSxiLGQsYyxlKXtmdW5jdGlvbiBmKHApe3JldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gci5pZD09XG5wfX1mdW5jdGlvbiBnKCl7bSYmKGwrPXEsbiYmKGwrPXEpLG09bj0hMSl9ZnVuY3Rpb24gaChwKXtwJiYoZygpLGwrPXApfWZ1bmN0aW9uIGsocCl7aWYoMT09cC5ub2RlVHlwZSl7dmFyIHI9cC5nZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIpO2lmKHIpaChyKTtlbHNle3I9cC5nZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIik7dmFyIHU7aWYocilwPWEuZmluZE1hcmtzKHQoYywwKSx0KGUrMSwwKSxmKCtyKSkscC5sZW5ndGgmJih1PXBbMF0uZmluZCgwKSkmJmgoWmEoYS5kb2MsdS5mcm9tLHUudG8pLmpvaW4ocSkpO2Vsc2UgaWYoXCJmYWxzZVwiIT1wLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSYmKHU9L14ocHJlfGRpdnxwfGxpfHRhYmxlfGJyKSQvaS50ZXN0KHAubm9kZU5hbWUpLC9eYnIkL2kudGVzdChwLm5vZGVOYW1lKXx8MCE9cC50ZXh0Q29udGVudC5sZW5ndGgpKXt1JiZnKCk7Zm9yKHI9MDtyPHAuY2hpbGROb2Rlcy5sZW5ndGg7cisrKWsocC5jaGlsZE5vZGVzW3JdKTtcbi9eKHByZXxwKSQvaS50ZXN0KHAubm9kZU5hbWUpJiYobj0hMCk7dSYmKG09ITApfX19ZWxzZSAzPT1wLm5vZGVUeXBlJiZoKHAubm9kZVZhbHVlLnJlcGxhY2UoL1xcdTIwMGIvZyxcIlwiKS5yZXBsYWNlKC9cXHUwMGEwL2csXCIgXCIpKX1mb3IodmFyIGw9XCJcIixtPSExLHE9YS5kb2MubGluZVNlcGFyYXRvcigpLG49ITE7Oyl7ayhiKTtpZihiPT1kKWJyZWFrO2I9Yi5uZXh0U2libGluZztuPSExfXJldHVybiBsfWZ1bmN0aW9uIGFkKGEsYixkKXtpZihiPT1hLmRpc3BsYXkubGluZURpdil7dmFyIGM9YS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tkXTtpZighYylyZXR1cm4gR2IoYS5jbGlwUG9zKHQoYS5kaXNwbGF5LnZpZXdUby0xKSksITApO2I9bnVsbDtkPTB9ZWxzZSBmb3IoYz1iOztjPWMucGFyZW50Tm9kZSl7aWYoIWN8fGM9PWEuZGlzcGxheS5saW5lRGl2KXJldHVybiBudWxsO2lmKGMucGFyZW50Tm9kZSYmYy5wYXJlbnROb2RlPT1hLmRpc3BsYXkubGluZURpdilicmVha31mb3IodmFyIGU9XG4wO2U8YS5kaXNwbGF5LnZpZXcubGVuZ3RoO2UrKyl7dmFyIGY9YS5kaXNwbGF5LnZpZXdbZV07aWYoZi5ub2RlPT1jKXJldHVybiBDaChmLGIsZCl9fWZ1bmN0aW9uIENoKGEsYixkKXtmdW5jdGlvbiBjKG0scSxuKXtmb3IodmFyIHA9LTE7cDwobD9sLmxlbmd0aDowKTtwKyspZm9yKHZhciByPTA+cD9rLm1hcDpsW3BdLHU9MDt1PHIubGVuZ3RoO3UrPTMpe3ZhciBBPXJbdSsyXTtpZihBPT1tfHxBPT1xKXtxPU8oMD5wP2EubGluZTphLnJlc3RbcF0pO3A9clt1XStuO2lmKDA+bnx8QSE9bSlwPXJbdSsobj8xOjApXTtyZXR1cm4gdChxLHApfX19dmFyIGU9YS50ZXh0LmZpcnN0Q2hpbGQsZj0hMTtpZighYnx8IWthKGUsYikpcmV0dXJuIEdiKHQoTyhhLmxpbmUpLDApLCEwKTtpZihiPT1lJiYoZj0hMCxiPWUuY2hpbGROb2Rlc1tkXSxkPTAsIWIpKXJldHVybiBkPWEucmVzdD9MKGEucmVzdCk6YS5saW5lLEdiKHQoTyhkKSxkLnRleHQubGVuZ3RoKSxmKTt2YXIgZz0zPT1iLm5vZGVUeXBlP1xuYjpudWxsLGg9YjtnfHwxIT1iLmNoaWxkTm9kZXMubGVuZ3RofHwzIT1iLmZpcnN0Q2hpbGQubm9kZVR5cGV8fChnPWIuZmlyc3RDaGlsZCxkJiYoZD1nLm5vZGVWYWx1ZS5sZW5ndGgpKTtmb3IoO2gucGFyZW50Tm9kZSE9ZTspaD1oLnBhcmVudE5vZGU7dmFyIGs9YS5tZWFzdXJlLGw9ay5tYXBzO2lmKGI9YyhnLGgsZCkpcmV0dXJuIEdiKGIsZik7ZT1oLm5leHRTaWJsaW5nO2ZvcihnPWc/Zy5ub2RlVmFsdWUubGVuZ3RoLWQ6MDtlO2U9ZS5uZXh0U2libGluZyl7aWYoYj1jKGUsZS5maXJzdENoaWxkLDApKXJldHVybiBHYih0KGIubGluZSxiLmNoLWcpLGYpO2crPWUudGV4dENvbnRlbnQubGVuZ3RofWZvcihoPWgucHJldmlvdXNTaWJsaW5nO2g7aD1oLnByZXZpb3VzU2libGluZyl7aWYoYj1jKGgsaC5maXJzdENoaWxkLC0xKSlyZXR1cm4gR2IodChiLmxpbmUsYi5jaCtkKSxmKTtkKz1oLnRleHRDb250ZW50Lmxlbmd0aH19dmFyIGphPW5hdmlnYXRvci51c2VyQWdlbnQsdGc9XG5uYXZpZ2F0b3IucGxhdGZvcm0sTWE9L2dlY2tvXFwvXFxkL2kudGVzdChqYSksdWc9L01TSUUgXFxkLy50ZXN0KGphKSx2Zz0vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoamEpLG5jPS9FZGdlXFwvKFxcZCspLy5leGVjKGphKSxHPXVnfHx2Z3x8bmMsVT1HJiYodWc/ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw2OisobmN8fHZnKVsxXSksZmE9IW5jJiYvV2ViS2l0XFwvLy50ZXN0KGphKSxEaD1mYSYmL1F0XFwvXFxkK1xcLlxcZCsvLnRlc3QoamEpLEZjPSFuYyYmL0Nocm9tZVxcLy8udGVzdChqYSksQmE9L09wZXJhXFwvLy50ZXN0KGphKSxnZT0vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvciksRWg9L01hYyBPUyBYIDFcXGRcXEQoWzgtOV18XFxkXFxkKVxcRC8udGVzdChqYSksVWc9L1BoYW50b21KUy8udGVzdChqYSksbWM9IW5jJiYvQXBwbGVXZWJLaXQvLnRlc3QoamEpJiYvTW9iaWxlXFwvXFx3Ky8udGVzdChqYSksR2M9L0FuZHJvaWQvLnRlc3QoamEpLFxuWmI9bWN8fEdjfHwvd2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KGphKSx5YT1tY3x8L01hYy8udGVzdCh0Zyksc2g9L1xcYkNyT1NcXGIvLnRlc3QoamEpLEZoPS93aW4vaS50ZXN0KHRnKSxsYj1CYSYmamEubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7bGImJihsYj1OdW1iZXIobGJbMV0pKTtsYiYmMTU8PWxiJiYoQmE9ITEsZmE9ITApO3ZhciBZZj15YSYmKERofHxCYSYmKG51bGw9PWxifHwxMi4xMT5sYikpLGZlPU1hfHxHJiY5PD1VLGhiPWZ1bmN0aW9uKGEsYil7dmFyIGQ9YS5jbGFzc05hbWU7aWYoYj15KGIpLmV4ZWMoZCkpe3ZhciBjPWQuc2xpY2UoYi5pbmRleCtiWzBdLmxlbmd0aCk7YS5jbGFzc05hbWU9ZC5zbGljZSgwLGIuaW5kZXgpKyhjP2JbMV0rYzpcIlwiKX19O3ZhciBPYj1kb2N1bWVudC5jcmVhdGVSYW5nZT9mdW5jdGlvbihhLGIsZCxjKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2Uuc2V0RW5kKGN8fFxuYSxkKTtlLnNldFN0YXJ0KGEsYik7cmV0dXJuIGV9OmZ1bmN0aW9uKGEsYixkKXt2YXIgYz1kb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO3RyeXtjLm1vdmVUb0VsZW1lbnRUZXh0KGEucGFyZW50Tm9kZSl9Y2F0Y2goZSl7cmV0dXJuIGN9Yy5jb2xsYXBzZSghMCk7Yy5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsZCk7Yy5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIixiKTtyZXR1cm4gY307dmFyIG9jPWZ1bmN0aW9uKGEpe2Euc2VsZWN0KCl9O21jP29jPWZ1bmN0aW9uKGEpe2Euc2VsZWN0aW9uU3RhcnQ9MDthLnNlbGVjdGlvbkVuZD1hLnZhbHVlLmxlbmd0aH06RyYmKG9jPWZ1bmN0aW9uKGEpe3RyeXthLnNlbGVjdCgpfWNhdGNoKGIpe319KTt2YXIgVmE9ZnVuY3Rpb24oKXt0aGlzLmY9dGhpcy5pZD1udWxsO3RoaXMudGltZT0wO3RoaXMuaGFuZGxlcj1kZCh0aGlzLm9uVGltZW91dCx0aGlzKX07VmEucHJvdG90eXBlLm9uVGltZW91dD1mdW5jdGlvbihhKXthLmlkPTA7YS50aW1lPD1cbituZXcgRGF0ZT9hLmYoKTpzZXRUaW1lb3V0KGEuaGFuZGxlcixhLnRpbWUtK25ldyBEYXRlKX07VmEucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3RoaXMuZj1iO2I9K25ldyBEYXRlK2E7aWYoIXRoaXMuaWR8fGI8dGhpcy50aW1lKWNsZWFyVGltZW91dCh0aGlzLmlkKSx0aGlzLmlkPXNldFRpbWVvdXQodGhpcy5oYW5kbGVyLGEpLHRoaXMudGltZT1ifTt2YXIgWWM9e3RvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJDb2RlTWlycm9yLlBhc3NcIn19LElhPXtzY3JvbGw6ITF9LGhlPXtvcmlnaW46XCIqbW91c2VcIn0scGM9e29yaWdpbjpcIittb3ZlXCJ9LHVjPVtcIlwiXSx4Zz0vW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS8seWc9L1tcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NWVcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZS1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDkwMC1cXHUwOTAyXFx1MDkzY1xcdTA5NDEtXFx1MDk0OFxcdTA5NGRcXHUwOTUxLVxcdTA5NTVcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOWJjXFx1MDliZVxcdTA5YzEtXFx1MDljNFxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwYTAxXFx1MGEwMlxcdTBhM2NcXHUwYTQxXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNzBcXHUwYTcxXFx1MGE3NVxcdTBhODFcXHUwYTgyXFx1MGFiY1xcdTBhYzEtXFx1MGFjNVxcdTBhYzdcXHUwYWM4XFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGIwMVxcdTBiM2NcXHUwYjNlXFx1MGIzZlxcdTBiNDEtXFx1MGI0NFxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI4MlxcdTBiYmVcXHUwYmMwXFx1MGJjZFxcdTBiZDdcXHUwYzNlLVxcdTBjNDBcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGNiY1xcdTBjYmZcXHUwY2MyXFx1MGNjNlxcdTBjY2NcXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBkM2VcXHUwZDQxLVxcdTBkNDRcXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGRjYVxcdTBkY2ZcXHUwZGQyLVxcdTBkZDRcXHUwZGQ2XFx1MGRkZlxcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZWIxXFx1MGViNC1cXHUwZWI5XFx1MGViYlxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZjE4XFx1MGYxOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNzEtXFx1MGY3ZVxcdTBmODAtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY5MC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNhXFx1MTAzZFxcdTEwM2VcXHUxMDU4XFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOGRcXHUxMDlkXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I3LVxcdTE3YmRcXHUxN2M2XFx1MTdjOS1cXHUxN2QzXFx1MTdkZFxcdTE4MGItXFx1MTgwZFxcdTE4YTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M2JcXHUxYTE3XFx1MWExOFxcdTFhNTZcXHUxYTU4LVxcdTFhNWVcXHUxYTYwXFx1MWE2MlxcdTFhNjUtXFx1MWE2Y1xcdTFhNzMtXFx1MWE3Y1xcdTFhN2ZcXHUxYjAwLVxcdTFiMDNcXHUxYjM0XFx1MWIzNi1cXHUxYjNhXFx1MWIzY1xcdTFiNDJcXHUxYjZiLVxcdTFiNzNcXHUxYjgwXFx1MWI4MVxcdTFiYTItXFx1MWJhNVxcdTFiYThcXHUxYmE5XFx1MWMyYy1cXHUxYzMzXFx1MWMzNlxcdTFjMzdcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZTBcXHUxY2UyLVxcdTFjZThcXHUxY2VkXFx1MWRjMC1cXHUxZGU2XFx1MWRmZC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMGQwLVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2NmYtXFx1YTY3MlxcdWE2N2NcXHVhNjdkXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODI1XFx1YTgyNlxcdWE4YzRcXHVhOGUwLVxcdWE4ZjFcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTFcXHVhOTgwLVxcdWE5ODJcXHVhOWIzXFx1YTliNi1cXHVhOWI5XFx1YTliY1xcdWFhMjktXFx1YWEyZVxcdWFhMzFcXHVhYTMyXFx1YWEzNVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFiZTVcXHVhYmU4XFx1YWJlZFxcdWRjMDAtXFx1ZGZmZlxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZjllXFx1ZmY5Zl0vLFxuSmI9bnVsbCxBZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoaCl7cmV0dXJuIDI0Nz49aD9cImJiYmJiYmJiYnRzdHdzYmJiYmJiYmJiYmJiYmJzc3N0d05OJSUlTk5OTk5OLE4sTjExMTExMTExMTFOTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5iYmJiYmJzYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmIsTiUlJSVOTk5OTE5OTk5OJSUxMU5MTk5OMUxOTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTkxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExOXCIuY2hhckF0KGgpOjE0MjQ8PWgmJjE1MjQ+PWg/XCJSXCI6MTUzNjw9aCYmMTc4NT49aD9cIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcIi5jaGFyQXQoaC1cbjE1MzYpOjE3NzQ8PWgmJjIyMjA+PWg/XCJyXCI6ODE5Mjw9aCYmODIwMz49aD9cIndcIjo4MjA0PT1oP1wiYlwiOlwiTFwifWZ1bmN0aW9uIGIoaCxrLGwpe3RoaXMubGV2ZWw9aDt0aGlzLmZyb209azt0aGlzLnRvPWx9dmFyIGQ9L1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLyxjPS9bc3R3Tl0vLGU9L1tMUnJdLyxmPS9bTGIxbl0vLGc9L1sxbl0vO3JldHVybiBmdW5jdGlvbihoLGspe3ZhciBsPVwibHRyXCI9PWs/XCJMXCI6XCJSXCI7aWYoMD09aC5sZW5ndGh8fFwibHRyXCI9PWsmJiFkLnRlc3QoaCkpcmV0dXJuITE7Zm9yKHZhciBtPWgubGVuZ3RoLHE9W10sbj0wO248bTsrK24pcS5wdXNoKGEoaC5jaGFyQ29kZUF0KG4pKSk7bj0wO2Zvcih2YXIgcD1sO248bTsrK24pe3ZhciByPXFbbl07XCJtXCI9PXI/cVtuXT1wOnA9cn1uPTA7Zm9yKHA9bDtuPG07KytuKXI9cVtuXSxcIjFcIj09ciYmXCJyXCI9PXA/cVtuXT1cIm5cIjplLnRlc3QocikmJihwPXIsXCJyXCI9PXImJihxW25dPVwiUlwiKSk7XG5uPTE7Zm9yKHA9cVswXTtuPG0tMTsrK24pcj1xW25dLFwiK1wiPT1yJiZcIjFcIj09cCYmXCIxXCI9PXFbbisxXT9xW25dPVwiMVwiOlwiLFwiIT1yfHxwIT1xW24rMV18fFwiMVwiIT1wJiZcIm5cIiE9cHx8KHFbbl09cCkscD1yO2ZvcihuPTA7bjxtOysrbilpZihwPXFbbl0sXCIsXCI9PXApcVtuXT1cIk5cIjtlbHNlIGlmKFwiJVwiPT1wKXtmb3IocD1uKzE7cDxtJiZcIiVcIj09cVtwXTsrK3ApO2ZvcihyPW4mJlwiIVwiPT1xW24tMV18fHA8bSYmXCIxXCI9PXFbcF0/XCIxXCI6XCJOXCI7bjxwOysrbilxW25dPXI7bj1wLTF9bj0wO2ZvcihwPWw7bjxtOysrbilyPXFbbl0sXCJMXCI9PXAmJlwiMVwiPT1yP3Fbbl09XCJMXCI6ZS50ZXN0KHIpJiYocD1yKTtmb3IocD0wO3A8bTsrK3ApaWYoYy50ZXN0KHFbcF0pKXtmb3Iobj1wKzE7bjxtJiZjLnRlc3QocVtuXSk7KytuKTtyPVwiTFwiPT0ocD9xW3AtMV06bCk7Zm9yKHI9cj09KFwiTFwiPT0objxtP3Fbbl06bCkpP3I/XCJMXCI6XCJSXCI6bDtwPG47KytwKXFbcF09cjtwPW4tMX1sPVtdO3ZhciB1O2ZvcihuPVxuMDtuPG07KWlmKGYudGVzdChxW25dKSl7cD1uO2ZvcigrK247bjxtJiZmLnRlc3QocVtuXSk7KytuKTtsLnB1c2gobmV3IGIoMCxwLG4pKX1lbHNle3ZhciBBPW47cD1sLmxlbmd0aDtyPVwicnRsXCI9PWs/MTowO2ZvcigrK247bjxtJiZcIkxcIiE9cVtuXTsrK24pO2Zvcih2YXIgSD1BO0g8bjspaWYoZy50ZXN0KHFbSF0pKXtBPEgmJihsLnNwbGljZShwLDAsbmV3IGIoMSxBLEgpKSxwKz1yKTtBPUg7Zm9yKCsrSDtIPG4mJmcudGVzdChxW0hdKTsrK0gpO2wuc3BsaWNlKHAsMCxuZXcgYigyLEEsSCkpO3ArPXI7QT1IfWVsc2UrK0g7QTxuJiZsLnNwbGljZShwLDAsbmV3IGIoMSxBLG4pKX1cImx0clwiPT1rJiYoMT09bFswXS5sZXZlbCYmKHU9aC5tYXRjaCgvXlxccysvKSkmJihsWzBdLmZyb209dVswXS5sZW5ndGgsbC51bnNoaWZ0KG5ldyBiKDAsMCx1WzBdLmxlbmd0aCkpKSwxPT1MKGwpLmxldmVsJiYodT1oLm1hdGNoKC9cXHMrJC8pKSYmKEwobCkudG8tPXVbMF0ubGVuZ3RoLGwucHVzaChuZXcgYigwLFxubS11WzBdLmxlbmd0aCxtKSkpKTtyZXR1cm5cInJ0bFwiPT1rP2wucmV2ZXJzZSgpOmx9fSgpLHhjPVtdLHo9ZnVuY3Rpb24oYSxiLGQpe2EuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixkLCExKTphLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsZCk6KGE9YS5faGFuZGxlcnN8fChhLl9oYW5kbGVycz17fSksYVtiXT0oYVtiXXx8eGMpLmNvbmNhdChkKSl9LHRoPWZ1bmN0aW9uKCl7aWYoRyYmOT5VKXJldHVybiExO3ZhciBhPXYoXCJkaXZcIik7cmV0dXJuXCJkcmFnZ2FibGVcImluIGF8fFwiZHJhZ0Ryb3BcImluIGF9KCksamQseWQsa2U9MyE9XCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aD9mdW5jdGlvbihhKXtmb3IodmFyIGI9MCxkPVtdLGM9YS5sZW5ndGg7Yjw9Yzspe3ZhciBlPWEuaW5kZXhPZihcIlxcblwiLGIpOy0xPT1lJiYoZT1hLmxlbmd0aCk7dmFyIGY9YS5zbGljZShiLFwiXFxyXCI9PWEuY2hhckF0KGUtMSk/ZS0xOmUpLGc9Zi5pbmRleE9mKFwiXFxyXCIpO1xuLTEhPWc/KGQucHVzaChmLnNsaWNlKDAsZykpLGIrPWcrMSk6KGQucHVzaChmKSxiPWUrMSl9cmV0dXJuIGR9OmZ1bmN0aW9uKGEpe3JldHVybiBhLnNwbGl0KC9cXHJcXG4/fFxcbi8pfSxHaD13aW5kb3cuZ2V0U2VsZWN0aW9uP2Z1bmN0aW9uKGEpe3RyeXtyZXR1cm4gYS5zZWxlY3Rpb25TdGFydCE9YS5zZWxlY3Rpb25FbmR9Y2F0Y2goYil7cmV0dXJuITF9fTpmdW5jdGlvbihhKXt0cnl7dmFyIGI9YS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpfWNhdGNoKGQpe31yZXR1cm4gYiYmYi5wYXJlbnRFbGVtZW50KCk9PWE/MCE9Yi5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLGIpOiExfSxuaD1mdW5jdGlvbigpe3ZhciBhPXYoXCJkaXZcIik7aWYoXCJvbmNvcHlcImluIGEpcmV0dXJuITA7YS5zZXRBdHRyaWJ1dGUoXCJvbmNvcHlcIixcInJldHVybjtcIik7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYS5vbmNvcHl9KCksRWQ9bnVsbCxrZD17fSxvYj17fSxwYj17fSxZPVxuZnVuY3Rpb24oYSxiLGQpe3RoaXMucG9zPXRoaXMuc3RhcnQ9MDt0aGlzLnN0cmluZz1hO3RoaXMudGFiU2l6ZT1ifHw4O3RoaXMubGluZVN0YXJ0PXRoaXMubGFzdENvbHVtblBvcz10aGlzLmxhc3RDb2x1bW5WYWx1ZT0wO3RoaXMubGluZU9yYWNsZT1kfTtZLnByb3RvdHlwZS5lb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3M+PXRoaXMuc3RyaW5nLmxlbmd0aH07WS5wcm90b3R5cGUuc29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zPT10aGlzLmxpbmVTdGFydH07WS5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpfHx2b2lkIDB9O1kucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvczx0aGlzLnN0cmluZy5sZW5ndGgpcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKX07WS5wcm90b3R5cGUuZWF0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG5pZihcInN0cmluZ1wiPT10eXBlb2YgYT9iPT1hOmImJihhLnRlc3Q/YS50ZXN0KGIpOmEoYikpKXJldHVybisrdGhpcy5wb3MsYn07WS5wcm90b3R5cGUuZWF0V2hpbGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMucG9zO3RoaXMuZWF0KGEpOyk7cmV0dXJuIHRoaXMucG9zPmJ9O1kucHJvdG90eXBlLmVhdFNwYWNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMucG9zOy9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSk7KSsrdGhpcy5wb3M7cmV0dXJuIHRoaXMucG9zPmF9O1kucHJvdG90eXBlLnNraXBUb0VuZD1mdW5jdGlvbigpe3RoaXMucG9zPXRoaXMuc3RyaW5nLmxlbmd0aH07WS5wcm90b3R5cGUuc2tpcFRvPWZ1bmN0aW9uKGEpe2E9dGhpcy5zdHJpbmcuaW5kZXhPZihhLHRoaXMucG9zKTtpZigtMTxhKXJldHVybiB0aGlzLnBvcz1hLCEwfTtZLnByb3RvdHlwZS5iYWNrVXA9ZnVuY3Rpb24oYSl7dGhpcy5wb3MtPWF9O1kucHJvdG90eXBlLmNvbHVtbj1cbmZ1bmN0aW9uKCl7dGhpcy5sYXN0Q29sdW1uUG9zPHRoaXMuc3RhcnQmJih0aGlzLmxhc3RDb2x1bW5WYWx1ZT13YSh0aGlzLnN0cmluZyx0aGlzLnN0YXJ0LHRoaXMudGFiU2l6ZSx0aGlzLmxhc3RDb2x1bW5Qb3MsdGhpcy5sYXN0Q29sdW1uVmFsdWUpLHRoaXMubGFzdENvbHVtblBvcz10aGlzLnN0YXJ0KTtyZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUtKHRoaXMubGluZVN0YXJ0P3dhKHRoaXMuc3RyaW5nLHRoaXMubGluZVN0YXJ0LHRoaXMudGFiU2l6ZSk6MCl9O1kucHJvdG90eXBlLmluZGVudGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHdhKHRoaXMuc3RyaW5nLG51bGwsdGhpcy50YWJTaXplKS0odGhpcy5saW5lU3RhcnQ/d2EodGhpcy5zdHJpbmcsdGhpcy5saW5lU3RhcnQsdGhpcy50YWJTaXplKTowKX07WS5wcm90b3R5cGUubWF0Y2g9ZnVuY3Rpb24oYSxiLGQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXt2YXIgYz1mdW5jdGlvbihmKXtyZXR1cm4gZD9mLnRvTG93ZXJDYXNlKCk6XG5mfSxlPXRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcyxhLmxlbmd0aCk7aWYoYyhlKT09YyhhKSlyZXR1cm4hMSE9PWImJih0aGlzLnBvcys9YS5sZW5ndGgpLCEwfWVsc2V7aWYoKGE9dGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKGEpKSYmMDxhLmluZGV4KXJldHVybiBudWxsO2EmJiExIT09YiYmKHRoaXMucG9zKz1hWzBdLmxlbmd0aCk7cmV0dXJuIGF9fTtZLnByb3RvdHlwZS5jdXJyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsdGhpcy5wb3MpfTtZLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycz1mdW5jdGlvbihhLGIpe3RoaXMubGluZVN0YXJ0Kz1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7dGhpcy5saW5lU3RhcnQtPWF9fTtZLnByb3RvdHlwZS5sb29rQWhlYWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5lT3JhY2xlO3JldHVybiBiJiZiLmxvb2tBaGVhZChhKX07WS5wcm90b3R5cGUuYmFzZVRva2VuPWZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLmxpbmVPcmFjbGU7cmV0dXJuIGEmJmEuYmFzZVRva2VuKHRoaXMucG9zKX07dmFyIEJjPWZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZT1hO3RoaXMubG9va0FoZWFkPWJ9LEVhPWZ1bmN0aW9uKGEsYixkLGMpe3RoaXMuc3RhdGU9Yjt0aGlzLmRvYz1hO3RoaXMubGluZT1kO3RoaXMubWF4TG9va0FoZWFkPWN8fDA7dGhpcy5iYXNlVG9rZW5zPW51bGw7dGhpcy5iYXNlVG9rZW5Qb3M9MX07RWEucHJvdG90eXBlLmxvb2tBaGVhZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmRvYy5nZXRMaW5lKHRoaXMubGluZSthKTtudWxsIT1iJiZhPnRoaXMubWF4TG9va0FoZWFkJiYodGhpcy5tYXhMb29rQWhlYWQ9YSk7cmV0dXJuIGJ9O0VhLnByb3RvdHlwZS5iYXNlVG9rZW49ZnVuY3Rpb24oYSl7aWYoIXRoaXMuYmFzZVRva2VucylyZXR1cm4gbnVsbDtmb3IoO3RoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc108PWE7KXRoaXMuYmFzZVRva2VuUG9zKz0yO3ZhciBiPXRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvcytcbjFdO3JldHVybnt0eXBlOmImJmIucmVwbGFjZSgvKCB8XilvdmVybGF5IC4qLyxcIlwiKSxzaXplOnRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc10tYX19O0VhLnByb3RvdHlwZS5uZXh0TGluZT1mdW5jdGlvbigpe3RoaXMubGluZSsrOzA8dGhpcy5tYXhMb29rQWhlYWQmJnRoaXMubWF4TG9va0FoZWFkLS19O0VhLmZyb21TYXZlZD1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIGIgaW5zdGFuY2VvZiBCYz9uZXcgRWEoYSxZYShhLm1vZGUsYi5zdGF0ZSksZCxiLmxvb2tBaGVhZCk6bmV3IEVhKGEsWWEoYS5tb2RlLGIpLGQpfTtFYS5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihhKXthPSExIT09YT9ZYSh0aGlzLmRvYy5tb2RlLHRoaXMuc3RhdGUpOnRoaXMuc3RhdGU7cmV0dXJuIDA8dGhpcy5tYXhMb29rQWhlYWQ/bmV3IEJjKGEsdGhpcy5tYXhMb29rQWhlYWQpOmF9O3ZhciBBZT1mdW5jdGlvbihhLGIsZCl7dGhpcy5zdGFydD1hLnN0YXJ0O3RoaXMuZW5kPWEucG9zO3RoaXMuc3RyaW5nPVxuYS5jdXJyZW50KCk7dGhpcy50eXBlPWJ8fG51bGw7dGhpcy5zdGF0ZT1kfSxMZj0hMSxLYT0hMSx4Yj1mdW5jdGlvbihhLGIsZCl7dGhpcy50ZXh0PWE7RWUodGhpcyxiKTt0aGlzLmhlaWdodD1kP2QodGhpcyk6MX07eGIucHJvdG90eXBlLmxpbmVObz1mdW5jdGlvbigpe3JldHVybiBPKHRoaXMpfTtuYih4Yik7dmFyIElnPXt9LEhnPXt9LHJiPW51bGwsUGI9bnVsbCxUZT17bGVmdDowLHJpZ2h0OjAsdG9wOjAsYm90dG9tOjB9LGRiLG1iPWZ1bmN0aW9uKGEsYixkKXt0aGlzLmNtPWQ7dmFyIGM9dGhpcy52ZXJ0PXYoXCJkaXZcIixbdihcImRpdlwiLG51bGwsbnVsbCxcIm1pbi13aWR0aDogMXB4XCIpXSxcIkNvZGVNaXJyb3ItdnNjcm9sbGJhclwiKSxlPXRoaXMuaG9yaXo9dihcImRpdlwiLFt2KFwiZGl2XCIsbnVsbCxudWxsLFwiaGVpZ2h0OiAxMDAlOyBtaW4taGVpZ2h0OiAxcHhcIildLFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXCIpO2MudGFiSW5kZXg9ZS50YWJJbmRleD0tMTthKGMpO2EoZSk7eihjLFxuXCJzY3JvbGxcIixmdW5jdGlvbigpe2MuY2xpZW50SGVpZ2h0JiZiKGMuc2Nyb2xsVG9wLFwidmVydGljYWxcIil9KTt6KGUsXCJzY3JvbGxcIixmdW5jdGlvbigpe2UuY2xpZW50V2lkdGgmJmIoZS5zY3JvbGxMZWZ0LFwiaG9yaXpvbnRhbFwiKX0pO3RoaXMuY2hlY2tlZFplcm9XaWR0aD0hMTtHJiY4PlUmJih0aGlzLmhvcml6LnN0eWxlLm1pbkhlaWdodD10aGlzLnZlcnQuc3R5bGUubWluV2lkdGg9XCIxOHB4XCIpfTttYi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpe3ZhciBiPWEuc2Nyb2xsV2lkdGg+YS5jbGllbnRXaWR0aCsxLGQ9YS5zY3JvbGxIZWlnaHQ+YS5jbGllbnRIZWlnaHQrMSxjPWEubmF0aXZlQmFyV2lkdGg7ZD8odGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMudmVydC5zdHlsZS5ib3R0b209Yj9jK1wicHhcIjpcIjBcIix0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxhLnNjcm9sbEhlaWdodC1hLmNsaWVudEhlaWdodCsoYS52aWV3SGVpZ2h0LVxuKGI/YzowKSkpK1wicHhcIik6KHRoaXMudmVydC5zdHlsZS5kaXNwbGF5PVwiXCIsdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0PVwiMFwiKTtiPyh0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuaG9yaXouc3R5bGUucmlnaHQ9ZD9jK1wicHhcIjpcIjBcIix0aGlzLmhvcml6LnN0eWxlLmxlZnQ9YS5iYXJMZWZ0K1wicHhcIix0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9TWF0aC5tYXgoMCxhLnNjcm9sbFdpZHRoLWEuY2xpZW50V2lkdGgrKGEudmlld1dpZHRoLWEuYmFyTGVmdC0oZD9jOjApKSkrXCJweFwiKToodGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5PVwiXCIsdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoPVwiMFwiKTshdGhpcy5jaGVja2VkWmVyb1dpZHRoJiYwPGEuY2xpZW50SGVpZ2h0JiYoMD09YyYmdGhpcy56ZXJvV2lkdGhIYWNrKCksdGhpcy5jaGVja2VkWmVyb1dpZHRoPSEwKTtyZXR1cm57cmlnaHQ6ZD9jOjAsYm90dG9tOmI/YzowfX07XG5tYi5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdD1mdW5jdGlvbihhKXt0aGlzLmhvcml6LnNjcm9sbExlZnQhPWEmJih0aGlzLmhvcml6LnNjcm9sbExlZnQ9YSk7dGhpcy5kaXNhYmxlSG9yaXomJnRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosdGhpcy5kaXNhYmxlSG9yaXosXCJob3JpelwiKX07bWIucHJvdG90eXBlLnNldFNjcm9sbFRvcD1mdW5jdGlvbihhKXt0aGlzLnZlcnQuc2Nyb2xsVG9wIT1hJiYodGhpcy52ZXJ0LnNjcm9sbFRvcD1hKTt0aGlzLmRpc2FibGVWZXJ0JiZ0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsdGhpcy5kaXNhYmxlVmVydCxcInZlcnRcIil9O21iLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrPWZ1bmN0aW9uKCl7dGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQ9dGhpcy52ZXJ0LnN0eWxlLndpZHRoPXlhJiYhRWg/XCIxMnB4XCI6XCIxOHB4XCI7dGhpcy5ob3Jpei5zdHlsZS5wb2ludGVyRXZlbnRzPXRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzPVxuXCJub25lXCI7dGhpcy5kaXNhYmxlSG9yaXo9bmV3IFZhO3RoaXMuZGlzYWJsZVZlcnQ9bmV3IFZhfTttYi5wcm90b3R5cGUuZW5hYmxlWmVyb1dpZHRoQmFyPWZ1bmN0aW9uKGEsYixkKXtmdW5jdGlvbiBjKCl7dmFyIGU9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsoXCJ2ZXJ0XCI9PWQ/ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLnJpZ2h0LTEsKGUudG9wK2UuYm90dG9tKS8yKTpkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KChlLnJpZ2h0K2UubGVmdCkvMixlLmJvdHRvbS0xKSkhPWE/YS5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiOmIuc2V0KDFFMyxjKX1hLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJhdXRvXCI7Yi5zZXQoMUUzLGMpfTttYi5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmhvcml6LnBhcmVudE5vZGU7YS5yZW1vdmVDaGlsZCh0aGlzLmhvcml6KTthLnJlbW92ZUNoaWxkKHRoaXMudmVydCl9O3ZhciBxYz1mdW5jdGlvbigpe307cWMucHJvdG90eXBlLnVwZGF0ZT1cbmZ1bmN0aW9uKCl7cmV0dXJue2JvdHRvbTowLHJpZ2h0OjB9fTtxYy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdD1mdW5jdGlvbigpe307cWMucHJvdG90eXBlLnNldFNjcm9sbFRvcD1mdW5jdGlvbigpe307cWMucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7fTt2YXIgb2Y9e1wibmF0aXZlXCI6bWIsXCJudWxsXCI6cWN9LFRnPTAsT2M9ZnVuY3Rpb24oYSxiLGQpe3ZhciBjPWEuZGlzcGxheTt0aGlzLnZpZXdwb3J0PWI7dGhpcy52aXNpYmxlPUxjKGMsYS5kb2MsYik7dGhpcy5lZGl0b3JJc0hpZGRlbj0hYy53cmFwcGVyLm9mZnNldFdpZHRoO3RoaXMud3JhcHBlckhlaWdodD1jLndyYXBwZXIuY2xpZW50SGVpZ2h0O3RoaXMud3JhcHBlcldpZHRoPWMud3JhcHBlci5jbGllbnRXaWR0aDt0aGlzLm9sZERpc3BsYXlXaWR0aD1hYihhKTt0aGlzLmZvcmNlPWQ7dGhpcy5kaW1zPURkKGEpO3RoaXMuZXZlbnRzPVtdfTtPYy5wcm90b3R5cGUuc2lnbmFsPWZ1bmN0aW9uKGEsYil7eGEoYSxiKSYmXG50aGlzLmV2ZW50cy5wdXNoKGFyZ3VtZW50cyl9O09jLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuZXZlbnRzLmxlbmd0aDthKyspWC5hcHBseShudWxsLHRoaXMuZXZlbnRzW2FdKX07dmFyIFBjPTAsdGE9bnVsbDtHP3RhPS0uNTM6TWE/dGE9MTU6RmM/dGE9LS43OmdlJiYodGE9LTEvMyk7dmFyIHVhPWZ1bmN0aW9uKGEsYil7dGhpcy5yYW5nZXM9YTt0aGlzLnByaW1JbmRleD1ifTt1YS5wcm90b3R5cGUucHJpbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJhbmdlc1t0aGlzLnByaW1JbmRleF19O3VhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7aWYoYT09dGhpcylyZXR1cm4hMDtpZihhLnByaW1JbmRleCE9dGhpcy5wcmltSW5kZXh8fGEucmFuZ2VzLmxlbmd0aCE9dGhpcy5yYW5nZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgYj0wO2I8dGhpcy5yYW5nZXMubGVuZ3RoO2IrKyl7dmFyIGQ9dGhpcy5yYW5nZXNbYl0sYz1hLnJhbmdlc1tiXTtcbmlmKCFwZChkLmFuY2hvcixjLmFuY2hvcil8fCFwZChkLmhlYWQsYy5oZWFkKSlyZXR1cm4hMX1yZXR1cm4hMH07dWEucHJvdG90eXBlLmRlZXBDb3B5PWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGI9MDtiPHRoaXMucmFuZ2VzLmxlbmd0aDtiKyspYVtiXT1uZXcgSihxZCh0aGlzLnJhbmdlc1tiXS5hbmNob3IpLHFkKHRoaXMucmFuZ2VzW2JdLmhlYWQpKTtyZXR1cm4gbmV3IHVhKGEsdGhpcy5wcmltSW5kZXgpfTt1YS5wcm90b3R5cGUuc29tZXRoaW5nU2VsZWN0ZWQ9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMucmFuZ2VzLmxlbmd0aDthKyspaWYoIXRoaXMucmFuZ2VzW2FdLmVtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9O3VhLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbihhLGIpe2J8fChiPWEpO2Zvcih2YXIgZD0wO2Q8dGhpcy5yYW5nZXMubGVuZ3RoO2QrKyl7dmFyIGM9dGhpcy5yYW5nZXNbZF07aWYoMDw9QihiLGMuZnJvbSgpKSYmMD49QihhLGMudG8oKSkpcmV0dXJuIGR9cmV0dXJuLTF9O1xudmFyIEo9ZnVuY3Rpb24oYSxiKXt0aGlzLmFuY2hvcj1hO3RoaXMuaGVhZD1ifTtKLnByb3RvdHlwZS5mcm9tPWZ1bmN0aW9uKCl7cmV0dXJuIEFjKHRoaXMuYW5jaG9yLHRoaXMuaGVhZCl9O0oucHJvdG90eXBlLnRvPWZ1bmN0aW9uKCl7cmV0dXJuIHpjKHRoaXMuYW5jaG9yLHRoaXMuaGVhZCl9O0oucHJvdG90eXBlLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5saW5lPT10aGlzLmFuY2hvci5saW5lJiZ0aGlzLmhlYWQuY2g9PXRoaXMuYW5jaG9yLmNofTtjYy5wcm90b3R5cGU9e2NodW5rU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmVzLmxlbmd0aH0scmVtb3ZlSW5uZXI6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGQ9YSxjPWErYjtkPGM7KytkKXt2YXIgZT10aGlzLmxpbmVzW2RdO3RoaXMuaGVpZ2h0LT1lLmhlaWdodDt2YXIgZj1lO2YucGFyZW50PW51bGw7RGUoZik7Y2EoZSxcImRlbGV0ZVwiKX10aGlzLmxpbmVzLnNwbGljZShhLGIpfSxjb2xsYXBzZTpmdW5jdGlvbihhKXthLnB1c2guYXBwbHkoYSxcbnRoaXMubGluZXMpfSxpbnNlcnRJbm5lcjpmdW5jdGlvbihhLGIsZCl7dGhpcy5oZWlnaHQrPWQ7dGhpcy5saW5lcz10aGlzLmxpbmVzLnNsaWNlKDAsYSkuY29uY2F0KGIpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGEpKTtmb3IoYT0wO2E8Yi5sZW5ndGg7KythKWJbYV0ucGFyZW50PXRoaXN9LGl0ZXJOOmZ1bmN0aW9uKGEsYixkKXtmb3IoYj1hK2I7YTxiOysrYSlpZihkKHRoaXMubGluZXNbYV0pKXJldHVybiEwfX07ZGMucHJvdG90eXBlPXtjaHVua1NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplfSxyZW1vdmVJbm5lcjpmdW5jdGlvbihhLGIpe3RoaXMuc2l6ZS09Yjtmb3IodmFyIGQ9MDtkPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysrZCl7dmFyIGM9dGhpcy5jaGlsZHJlbltkXSxlPWMuY2h1bmtTaXplKCk7aWYoYTxlKXt2YXIgZj1NYXRoLm1pbihiLGUtYSksZz1jLmhlaWdodDtjLnJlbW92ZUlubmVyKGEsZik7dGhpcy5oZWlnaHQtPWctYy5oZWlnaHQ7ZT09ZiYmKHRoaXMuY2hpbGRyZW4uc3BsaWNlKGQtLSxcbjEpLGMucGFyZW50PW51bGwpO2lmKDA9PShiLT1mKSlicmVhazthPTB9ZWxzZSBhLT1lfTI1PnRoaXMuc2l6ZS1iJiYoMTx0aGlzLmNoaWxkcmVuLmxlbmd0aHx8ISh0aGlzLmNoaWxkcmVuWzBdaW5zdGFuY2VvZiBjYykpJiYoYT1bXSx0aGlzLmNvbGxhcHNlKGEpLHRoaXMuY2hpbGRyZW49W25ldyBjYyhhKV0sdGhpcy5jaGlsZHJlblswXS5wYXJlbnQ9dGhpcyl9LGNvbGxhcHNlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytiKXRoaXMuY2hpbGRyZW5bYl0uY29sbGFwc2UoYSl9LGluc2VydElubmVyOmZ1bmN0aW9uKGEsYixkKXt0aGlzLnNpemUrPWIubGVuZ3RoO3RoaXMuaGVpZ2h0Kz1kO2Zvcih2YXIgYz0wO2M8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytjKXt2YXIgZT10aGlzLmNoaWxkcmVuW2NdLGY9ZS5jaHVua1NpemUoKTtpZihhPD1mKXtlLmluc2VydElubmVyKGEsYixkKTtpZihlLmxpbmVzJiY1MDxlLmxpbmVzLmxlbmd0aCl7Zm9yKGI9XG5hPWUubGluZXMubGVuZ3RoJTI1KzI1O2I8ZS5saW5lcy5sZW5ndGg7KWQ9bmV3IGNjKGUubGluZXMuc2xpY2UoYixiKz0yNSkpLGUuaGVpZ2h0LT1kLmhlaWdodCx0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2MsMCxkKSxkLnBhcmVudD10aGlzO2UubGluZXM9ZS5saW5lcy5zbGljZSgwLGEpO3RoaXMubWF5YmVTcGlsbCgpfWJyZWFrfWEtPWZ9fSxtYXliZVNwaWxsOmZ1bmN0aW9uKCl7aWYoISgxMD49dGhpcy5jaGlsZHJlbi5sZW5ndGgpKXt2YXIgYT10aGlzO2Rve3ZhciBiPWEuY2hpbGRyZW4uc3BsaWNlKGEuY2hpbGRyZW4ubGVuZ3RoLTUsNSk7Yj1uZXcgZGMoYik7aWYoYS5wYXJlbnQpe2Euc2l6ZS09Yi5zaXplO2EuaGVpZ2h0LT1iLmhlaWdodDt2YXIgZD1lYShhLnBhcmVudC5jaGlsZHJlbixhKTthLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoZCsxLDAsYil9ZWxzZSBkPW5ldyBkYyhhLmNoaWxkcmVuKSxkLnBhcmVudD1hLGEuY2hpbGRyZW49W2QsYl0sYT1kO2IucGFyZW50PWEucGFyZW50fXdoaWxlKDEwPFxuYS5jaGlsZHJlbi5sZW5ndGgpO2EucGFyZW50Lm1heWJlU3BpbGwoKX19LGl0ZXJOOmZ1bmN0aW9uKGEsYixkKXtmb3IodmFyIGM9MDtjPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysrYyl7dmFyIGU9dGhpcy5jaGlsZHJlbltjXSxmPWUuY2h1bmtTaXplKCk7aWYoYTxmKXtmPU1hdGgubWluKGIsZi1hKTtpZihlLml0ZXJOKGEsZixkKSlyZXR1cm4hMDtpZigwPT0oYi09ZikpYnJlYWs7YT0wfWVsc2UgYS09Zn19fTt2YXIgZWM9ZnVuY3Rpb24oYSxiLGQpe2lmKGQpZm9yKHZhciBjIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShjKSYmKHRoaXNbY109ZFtjXSk7dGhpcy5kb2M9YTt0aGlzLm5vZGU9Yn07ZWMucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kb2MuY20sYj10aGlzLmxpbmUud2lkZ2V0cyxkPXRoaXMubGluZSxjPU8oZCk7aWYobnVsbCE9YyYmYil7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDsrK2UpYltlXT09dGhpcyYmYi5zcGxpY2UoZS0tLDEpO2IubGVuZ3RofHxcbihkLndpZGdldHM9bnVsbCk7dmFyIGY9UmIodGhpcyk7RGEoZCxNYXRoLm1heCgwLGQuaGVpZ2h0LWYpKTthJiYocGEoYSxmdW5jdGlvbigpe3ZhciBnPS1mO0dhKGQpPChhLmN1ck9wJiZhLmN1ck9wLnNjcm9sbFRvcHx8YS5kb2Muc2Nyb2xsVG9wKSYmTWMoYSxnKTtRYShhLGMsXCJ3aWRnZXRcIil9KSxjYShhLFwibGluZVdpZGdldENsZWFyZWRcIixhLHRoaXMsYykpfX07ZWMucHJvdG90eXBlLmNoYW5nZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5oZWlnaHQsZD10aGlzLmRvYy5jbSxjPXRoaXMubGluZTt0aGlzLmhlaWdodD1udWxsO3ZhciBlPVJiKHRoaXMpLWI7ZSYmKE9hKHRoaXMuZG9jLGMpfHxEYShjLGMuaGVpZ2h0K2UpLGQmJnBhKGQsZnVuY3Rpb24oKXtkLmN1ck9wLmZvcmNlVXBkYXRlPSEwO0dhKGMpPChkLmN1ck9wJiZkLmN1ck9wLnNjcm9sbFRvcHx8ZC5kb2Muc2Nyb2xsVG9wKSYmTWMoZCxlKTtjYShkLFwibGluZVdpZGdldENoYW5nZWRcIixkLGEsTyhjKSl9KSl9O1xubmIoZWMpO3ZhciBSZj0wLFRhPWZ1bmN0aW9uKGEsYil7dGhpcy5saW5lcz1bXTt0aGlzLnR5cGU9Yjt0aGlzLmRvYz1hO3RoaXMuaWQ9KytSZn07VGEucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7aWYoIXRoaXMuZXhwbGljaXRseUNsZWFyZWQpe3ZhciBhPXRoaXMuZG9jLmNtLGI9YSYmIWEuY3VyT3A7YiYmamIoYSk7aWYoeGEodGhpcyxcImNsZWFyXCIpKXt2YXIgZD10aGlzLmZpbmQoKTtkJiZjYSh0aGlzLFwiY2xlYXJcIixkLmZyb20sZC50byl9Zm9yKHZhciBjPWQ9bnVsbCxlPTA7ZTx0aGlzLmxpbmVzLmxlbmd0aDsrK2Upe3ZhciBmPXRoaXMubGluZXNbZV0sZz1OYihmLm1hcmtlZFNwYW5zLHRoaXMpO2EmJiF0aGlzLmNvbGxhcHNlZD9RYShhLE8oZiksXCJ0ZXh0XCIpOmEmJihudWxsIT1nLnRvJiYoYz1PKGYpKSxudWxsIT1nLmZyb20mJihkPU8oZikpKTtmb3IodmFyIGg9ZixrPXZvaWQgMCxsPWYubWFya2VkU3BhbnMsbT1nLHE9MDtxPGwubGVuZ3RoOysrcSlsW3FdIT1tJiYoa3x8XG4oaz1bXSkpLnB1c2gobFtxXSk7aC5tYXJrZWRTcGFucz1rO251bGw9PWcuZnJvbSYmdGhpcy5jb2xsYXBzZWQmJiFPYSh0aGlzLmRvYyxmKSYmYSYmRGEoZix0YihhLmRpc3BsYXkpKX1pZihhJiZ0aGlzLmNvbGxhcHNlZCYmIWEub3B0aW9ucy5saW5lV3JhcHBpbmcpZm9yKGU9MDtlPHRoaXMubGluZXMubGVuZ3RoOysrZSlmPUZhKHRoaXMubGluZXNbZV0pLGc9RGMoZiksZz5hLmRpc3BsYXkubWF4TGluZUxlbmd0aCYmKGEuZGlzcGxheS5tYXhMaW5lPWYsYS5kaXNwbGF5Lm1heExpbmVMZW5ndGg9ZyxhLmRpc3BsYXkubWF4TGluZUNoYW5nZWQ9ITApO251bGwhPWQmJmEmJnRoaXMuY29sbGFwc2VkJiZtYShhLGQsYysxKTt0aGlzLmxpbmVzLmxlbmd0aD0wO3RoaXMuZXhwbGljaXRseUNsZWFyZWQ9ITA7dGhpcy5hdG9taWMmJnRoaXMuZG9jLmNhbnRFZGl0JiYodGhpcy5kb2MuY2FudEVkaXQ9ITEsYSYmSGYoYS5kb2MpKTthJiZjYShhLFwibWFya2VyQ2xlYXJlZFwiLGEsdGhpcyxkLFxuYyk7YiYma2IoYSk7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmNsZWFyKCl9fTtUYS5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihhLGIpe251bGw9PWEmJlwiYm9va21hcmtcIj09dGhpcy50eXBlJiYoYT0xKTtmb3IodmFyIGQsYyxlPTA7ZTx0aGlzLmxpbmVzLmxlbmd0aDsrK2Upe3ZhciBmPXRoaXMubGluZXNbZV0sZz1OYihmLm1hcmtlZFNwYW5zLHRoaXMpO2lmKG51bGwhPWcuZnJvbSYmKGQ9dChiP2Y6TyhmKSxnLmZyb20pLC0xPT1hKSlyZXR1cm4gZDtpZihudWxsIT1nLnRvJiYoYz10KGI/ZjpPKGYpLGcudG8pLDE9PWEpKXJldHVybiBjfXJldHVybiBkJiZ7ZnJvbTpkLHRvOmN9fTtUYS5wcm90b3R5cGUuY2hhbmdlZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmZpbmQoLTEsITApLGQ9dGhpcyxjPXRoaXMuZG9jLmNtO2ImJmMmJnBhKGMsZnVuY3Rpb24oKXt2YXIgZT1iLmxpbmUsZj1PKGIubGluZSk7aWYoZj1DZChjLGYpKVVlKGYpLGMuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZD1cbmMuY3VyT3AuZm9yY2VVcGRhdGU9ITA7Yy5jdXJPcC51cGRhdGVNYXhMaW5lPSEwO09hKGQuZG9jLGUpfHxudWxsPT1kLmhlaWdodHx8KGY9ZC5oZWlnaHQsZC5oZWlnaHQ9bnVsbCwoZj1SYihkKS1mKSYmRGEoZSxlLmhlaWdodCtmKSk7Y2EoYyxcIm1hcmtlckNoYW5nZWRcIixjLGEpfSl9O1RhLnByb3RvdHlwZS5hdHRhY2hMaW5lPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLmxpbmVzLmxlbmd0aCYmdGhpcy5kb2MuY20pe3ZhciBiPXRoaXMuZG9jLmNtLmN1ck9wO2IubWF5YmVIaWRkZW5NYXJrZXJzJiYtMSE9ZWEoYi5tYXliZUhpZGRlbk1hcmtlcnMsdGhpcyl8fChiLm1heWJlVW5oaWRkZW5NYXJrZXJzfHwoYi5tYXliZVVuaGlkZGVuTWFya2Vycz1bXSkpLnB1c2godGhpcyl9dGhpcy5saW5lcy5wdXNoKGEpfTtUYS5wcm90b3R5cGUuZGV0YWNoTGluZT1mdW5jdGlvbihhKXt0aGlzLmxpbmVzLnNwbGljZShlYSh0aGlzLmxpbmVzLGEpLDEpOyF0aGlzLmxpbmVzLmxlbmd0aCYmdGhpcy5kb2MuY20mJlxuKGE9dGhpcy5kb2MuY20uY3VyT3AsKGEubWF5YmVIaWRkZW5NYXJrZXJzfHwoYS5tYXliZUhpZGRlbk1hcmtlcnM9W10pKS5wdXNoKHRoaXMpKX07bmIoVGEpO3ZhciBmYz1mdW5jdGlvbihhLGIpe3RoaXMubWFya2Vycz1hO3RoaXMucHJpbWFyeT1iO2ZvcihiPTA7YjxhLmxlbmd0aDsrK2IpYVtiXS5wYXJlbnQ9dGhpc307ZmMucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7aWYoIXRoaXMuZXhwbGljaXRseUNsZWFyZWQpe3RoaXMuZXhwbGljaXRseUNsZWFyZWQ9ITA7Zm9yKHZhciBhPTA7YTx0aGlzLm1hcmtlcnMubGVuZ3RoOysrYSl0aGlzLm1hcmtlcnNbYV0uY2xlYXIoKTtjYSh0aGlzLFwiY2xlYXJcIil9fTtmYy5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnByaW1hcnkuZmluZChhLGIpfTtuYihmYyk7dmFyIEhoPTAsb2E9ZnVuY3Rpb24oYSxiLGQsYyxlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBvYSkpcmV0dXJuIG5ldyBvYShhLGIsZCxjLGUpO251bGw9PVxuZCYmKGQ9MCk7ZGMuY2FsbCh0aGlzLFtuZXcgY2MoW25ldyB4YihcIlwiLG51bGwpXSldKTt0aGlzLmZpcnN0PWQ7dGhpcy5zY3JvbGxUb3A9dGhpcy5zY3JvbGxMZWZ0PTA7dGhpcy5jYW50RWRpdD0hMTt0aGlzLmNsZWFuR2VuZXJhdGlvbj0xO3RoaXMubW9kZUZyb250aWVyPXRoaXMuaGlnaGxpZ2h0RnJvbnRpZXI9ZDtkPXQoZCwwKTt0aGlzLnNlbD1OYShkKTt0aGlzLmhpc3Rvcnk9bmV3IFFjKG51bGwpO3RoaXMuaWQ9KytIaDt0aGlzLm1vZGVPcHRpb249Yjt0aGlzLmxpbmVTZXA9Yzt0aGlzLmRpcmVjdGlvbj1cInJ0bFwiPT1lP1wicnRsXCI6XCJsdHJcIjt0aGlzLmV4dGVuZD0hMTtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9dGhpcy5zcGxpdExpbmVzKGEpKTtYZCh0aGlzLHtmcm9tOmQsdG86ZCx0ZXh0OmF9KTtkYSh0aGlzLE5hKGQpLElhKX07b2EucHJvdG90eXBlPW5lKGRjLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6b2EsaXRlcjpmdW5jdGlvbihhLGIsZCl7ZD90aGlzLml0ZXJOKGEtdGhpcy5maXJzdCxcbmItYSxkKTp0aGlzLml0ZXJOKHRoaXMuZmlyc3QsdGhpcy5maXJzdCt0aGlzLnNpemUsYSl9LGluc2VydDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgZD0wLGM9MDtjPGIubGVuZ3RoOysrYylkKz1iW2NdLmhlaWdodDt0aGlzLmluc2VydElubmVyKGEtdGhpcy5maXJzdCxiLGQpfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt0aGlzLnJlbW92ZUlubmVyKGEtdGhpcy5maXJzdCxiKX0sZ2V0VmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9bmQodGhpcyx0aGlzLmZpcnN0LHRoaXMuZmlyc3QrdGhpcy5zaXplKTtyZXR1cm4hMT09PWE/YjpiLmpvaW4oYXx8dGhpcy5saW5lU2VwYXJhdG9yKCkpfSxzZXRWYWx1ZTpiYShmdW5jdGlvbihhKXt2YXIgYj10KHRoaXMuZmlyc3QsMCksZD10aGlzLmZpcnN0K3RoaXMuc2l6ZS0xO0FiKHRoaXMse2Zyb206Yix0bzp0KGQsdyh0aGlzLGQpLnRleHQubGVuZ3RoKSx0ZXh0OnRoaXMuc3BsaXRMaW5lcyhhKSxvcmlnaW46XCJzZXRWYWx1ZVwiLGZ1bGw6ITB9LCEwKTt0aGlzLmNtJiZcblViKHRoaXMuY20sMCwwKTtkYSh0aGlzLE5hKGIpLElhKX0pLHJlcGxhY2VSYW5nZTpmdW5jdGlvbihhLGIsZCxjKXtiPUModGhpcyxiKTtkPWQ/Qyh0aGlzLGQpOmI7QmIodGhpcyxhLGIsZCxjKX0sZ2V0UmFuZ2U6ZnVuY3Rpb24oYSxiLGQpe2E9WmEodGhpcyxDKHRoaXMsYSksQyh0aGlzLGIpKTtyZXR1cm4hMT09PWQ/YTphLmpvaW4oZHx8dGhpcy5saW5lU2VwYXJhdG9yKCkpfSxnZXRMaW5lOmZ1bmN0aW9uKGEpe3JldHVybihhPXRoaXMuZ2V0TGluZUhhbmRsZShhKSkmJmEudGV4dH0sZ2V0TGluZUhhbmRsZTpmdW5jdGlvbihhKXtpZihMYih0aGlzLGEpKXJldHVybiB3KHRoaXMsYSl9LGdldExpbmVOdW1iZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIE8oYSl9LGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDpmdW5jdGlvbihhKXtcIm51bWJlclwiPT10eXBlb2YgYSYmKGE9dyh0aGlzLGEpKTtyZXR1cm4gRmEoYSl9LGxpbmVDb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemV9LGZpcnN0TGluZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0fSxcbmxhc3RMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlyc3QrdGhpcy5zaXplLTF9LGNsaXBQb3M6ZnVuY3Rpb24oYSl7cmV0dXJuIEModGhpcyxhKX0sZ2V0Q3Vyc29yOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2VsLnByaW1hcnkoKTtyZXR1cm4gbnVsbD09YXx8XCJoZWFkXCI9PWE/Yi5oZWFkOlwiYW5jaG9yXCI9PWE/Yi5hbmNob3I6XCJlbmRcIj09YXx8XCJ0b1wiPT1hfHwhMT09PWE/Yi50bygpOmIuZnJvbSgpfSxsaXN0U2VsZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbC5yYW5nZXN9LHNvbWV0aGluZ1NlbGVjdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LHNldEN1cnNvcjpiYShmdW5jdGlvbihhLGIsZCl7YT1DKHRoaXMsXCJudW1iZXJcIj09dHlwZW9mIGE/dChhLGJ8fDApOmEpO2RhKHRoaXMsTmEoYSxudWxsKSxkKX0pLHNldFNlbGVjdGlvbjpiYShmdW5jdGlvbihhLGIsZCl7dmFyIGM9Qyh0aGlzLGEpO2E9Qyh0aGlzLGJ8fFxuYSk7ZGEodGhpcyxOYShjLGEpLGQpfSksZXh0ZW5kU2VsZWN0aW9uOmJhKGZ1bmN0aW9uKGEsYixkKXtTYyh0aGlzLEModGhpcyxhKSxiJiZDKHRoaXMsYiksZCl9KSxleHRlbmRTZWxlY3Rpb25zOmJhKGZ1bmN0aW9uKGEsYil7RGYodGhpcyx1ZSh0aGlzLGEpLGIpfSksZXh0ZW5kU2VsZWN0aW9uc0J5OmJhKGZ1bmN0aW9uKGEsYil7YT12Yyh0aGlzLnNlbC5yYW5nZXMsYSk7RGYodGhpcyx1ZSh0aGlzLGEpLGIpfSksc2V0U2VsZWN0aW9uczpiYShmdW5jdGlvbihhLGIsZCl7aWYoYS5sZW5ndGgpe2Zvcih2YXIgYz1bXSxlPTA7ZTxhLmxlbmd0aDtlKyspY1tlXT1uZXcgSihDKHRoaXMsYVtlXS5hbmNob3IpLEModGhpcyxhW2VdLmhlYWQpKTtudWxsPT1iJiYoYj1NYXRoLm1pbihhLmxlbmd0aC0xLHRoaXMuc2VsLnByaW1JbmRleCkpO2RhKHRoaXMsQ2EodGhpcy5jbSxjLGIpLGQpfX0pLGFkZFNlbGVjdGlvbjpiYShmdW5jdGlvbihhLGIsZCl7dmFyIGM9dGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuYy5wdXNoKG5ldyBKKEModGhpcyxhKSxDKHRoaXMsYnx8YSkpKTtkYSh0aGlzLENhKHRoaXMuY20sYyxjLmxlbmd0aC0xKSxkKX0pLGdldFNlbGVjdGlvbjpmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5zZWwucmFuZ2VzLGQsYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZT1aYSh0aGlzLGJbY10uZnJvbSgpLGJbY10udG8oKSk7ZD1kP2QuY29uY2F0KGUpOmV9cmV0dXJuITE9PT1hP2Q6ZC5qb2luKGF8fHRoaXMubGluZVNlcGFyYXRvcigpKX0sZ2V0U2VsZWN0aW9uczpmdW5jdGlvbihhKXtmb3IodmFyIGI9W10sZD10aGlzLnNlbC5yYW5nZXMsYz0wO2M8ZC5sZW5ndGg7YysrKXt2YXIgZT1aYSh0aGlzLGRbY10uZnJvbSgpLGRbY10udG8oKSk7ITEhPT1hJiYoZT1lLmpvaW4oYXx8dGhpcy5saW5lU2VwYXJhdG9yKCkpKTtiW2NdPWV9cmV0dXJuIGJ9LHJlcGxhY2VTZWxlY3Rpb246ZnVuY3Rpb24oYSxiLGQpe2Zvcih2YXIgYz1bXSxlPTA7ZTx0aGlzLnNlbC5yYW5nZXMubGVuZ3RoO2UrKyljW2VdPVxuYTt0aGlzLnJlcGxhY2VTZWxlY3Rpb25zKGMsYixkfHxcIitpbnB1dFwiKX0scmVwbGFjZVNlbGVjdGlvbnM6YmEoZnVuY3Rpb24oYSxiLGQpe2Zvcih2YXIgYz1bXSxlPXRoaXMuc2VsLGY9MDtmPGUucmFuZ2VzLmxlbmd0aDtmKyspe3ZhciBnPWUucmFuZ2VzW2ZdO2NbZl09e2Zyb206Zy5mcm9tKCksdG86Zy50bygpLHRleHQ6dGhpcy5zcGxpdExpbmVzKGFbZl0pLG9yaWdpbjpkfX1pZihhPWImJlwiZW5kXCIhPWIpe2E9W107ZT1kPXQodGhpcy5maXJzdCwwKTtmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdO2c9dmYoaC5mcm9tLGQsZSk7dmFyIGs9dmYoUmEoaCksZCxlKTtkPWgudG87ZT1rO1wiYXJvdW5kXCI9PWI/KGg9dGhpcy5zZWwucmFuZ2VzW2ZdLGg9MD5CKGguaGVhZCxoLmFuY2hvciksYVtmXT1uZXcgSihoP2s6ZyxoP2c6aykpOmFbZl09bmV3IEooZyxnKX1hPW5ldyB1YShhLHRoaXMuc2VsLnByaW1JbmRleCl9Yj1hO2ZvcihhPWMubGVuZ3RoLTE7MDw9YTthLS0pQWIodGhpcyxcbmNbYV0pO2I/RWYodGhpcyxiKTp0aGlzLmNtJiZ2Yih0aGlzLmNtKX0pLHVuZG86YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwidW5kb1wiKX0pLHJlZG86YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwicmVkb1wiKX0pLHVuZG9TZWxlY3Rpb246YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwidW5kb1wiLCEwKX0pLHJlZG9TZWxlY3Rpb246YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwicmVkb1wiLCEwKX0pLHNldEV4dGVuZGluZzpmdW5jdGlvbihhKXt0aGlzLmV4dGVuZD1hfSxnZXRFeHRlbmRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHRlbmR9LGhpc3RvcnlTaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuaGlzdG9yeSxiPTAsZD0wLGM9MDtjPGEuZG9uZS5sZW5ndGg7YysrKWEuZG9uZVtjXS5yYW5nZXN8fCsrYjtmb3IoYz0wO2M8YS51bmRvbmUubGVuZ3RoO2MrKylhLnVuZG9uZVtjXS5yYW5nZXN8fCsrZDtyZXR1cm57dW5kbzpiLHJlZG86ZH19LGNsZWFySGlzdG9yeTpmdW5jdGlvbigpe3ZhciBhPVxudGhpczt0aGlzLmhpc3Rvcnk9bmV3IFFjKHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtTYSh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiBiLmhpc3Rvcnk9YS5oaXN0b3J5fSwhMCl9LG1hcmtDbGVhbjpmdW5jdGlvbigpe3RoaXMuY2xlYW5HZW5lcmF0aW9uPXRoaXMuY2hhbmdlR2VuZXJhdGlvbighMCl9LGNoYW5nZUdlbmVyYXRpb246ZnVuY3Rpb24oYSl7YSYmKHRoaXMuaGlzdG9yeS5sYXN0T3A9dGhpcy5oaXN0b3J5Lmxhc3RTZWxPcD10aGlzLmhpc3RvcnkubGFzdE9yaWdpbj1udWxsKTtyZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb259LGlzQ2xlYW46ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uPT0oYXx8dGhpcy5jbGVhbkdlbmVyYXRpb24pfSxnZXRIaXN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6eWIodGhpcy5oaXN0b3J5LmRvbmUpLHVuZG9uZTp5Yih0aGlzLmhpc3RvcnkudW5kb25lKX19LHNldEhpc3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9XG50aGlzLmhpc3Rvcnk9bmV3IFFjKHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtiLmRvbmU9eWIoYS5kb25lLnNsaWNlKDApLG51bGwsITApO2IudW5kb25lPXliKGEudW5kb25lLnNsaWNlKDApLG51bGwsITApfSxzZXRHdXR0ZXJNYXJrZXI6YmEoZnVuY3Rpb24oYSxiLGQpe3JldHVybiBiYyh0aGlzLGEsXCJndXR0ZXJcIixmdW5jdGlvbihjKXt2YXIgZT1jLmd1dHRlck1hcmtlcnN8fChjLmd1dHRlck1hcmtlcnM9e30pO2VbYl09ZDshZCYmb2UoZSkmJihjLmd1dHRlck1hcmtlcnM9bnVsbCk7cmV0dXJuITB9KX0pLGNsZWFyR3V0dGVyOmJhKGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5pdGVyKGZ1bmN0aW9uKGQpe2QuZ3V0dGVyTWFya2VycyYmZC5ndXR0ZXJNYXJrZXJzW2FdJiZiYyhiLGQsXCJndXR0ZXJcIixmdW5jdGlvbigpe2QuZ3V0dGVyTWFya2Vyc1thXT1udWxsO29lKGQuZ3V0dGVyTWFya2VycykmJihkLmd1dHRlck1hcmtlcnM9bnVsbCk7cmV0dXJuITB9KX0pfSksXG5saW5lSW5mbzpmdW5jdGlvbihhKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSl7aWYoIUxiKHRoaXMsYSkpcmV0dXJuIG51bGw7dmFyIGI9YTthPXcodGhpcyxhKTtpZighYSlyZXR1cm4gbnVsbH1lbHNlIGlmKGI9TyhhKSxudWxsPT1iKXJldHVybiBudWxsO3JldHVybntsaW5lOmIsaGFuZGxlOmEsdGV4dDphLnRleHQsZ3V0dGVyTWFya2VyczphLmd1dHRlck1hcmtlcnMsdGV4dENsYXNzOmEudGV4dENsYXNzLGJnQ2xhc3M6YS5iZ0NsYXNzLHdyYXBDbGFzczphLndyYXBDbGFzcyx3aWRnZXRzOmEud2lkZ2V0c319LGFkZExpbmVDbGFzczpiYShmdW5jdGlvbihhLGIsZCl7cmV0dXJuIGJjKHRoaXMsYSxcImd1dHRlclwiPT1iP1wiZ3V0dGVyXCI6XCJjbGFzc1wiLGZ1bmN0aW9uKGMpe3ZhciBlPVwidGV4dFwiPT1iP1widGV4dENsYXNzXCI6XCJiYWNrZ3JvdW5kXCI9PWI/XCJiZ0NsYXNzXCI6XCJndXR0ZXJcIj09Yj9cImd1dHRlckNsYXNzXCI6XCJ3cmFwQ2xhc3NcIjtpZihjW2VdKXtpZih5KGQpLnRlc3QoY1tlXSkpcmV0dXJuITE7XG5jW2VdKz1cIiBcIitkfWVsc2UgY1tlXT1kO3JldHVybiEwfSl9KSxyZW1vdmVMaW5lQ2xhc3M6YmEoZnVuY3Rpb24oYSxiLGQpe3JldHVybiBiYyh0aGlzLGEsXCJndXR0ZXJcIj09Yj9cImd1dHRlclwiOlwiY2xhc3NcIixmdW5jdGlvbihjKXt2YXIgZT1cInRleHRcIj09Yj9cInRleHRDbGFzc1wiOlwiYmFja2dyb3VuZFwiPT1iP1wiYmdDbGFzc1wiOlwiZ3V0dGVyXCI9PWI/XCJndXR0ZXJDbGFzc1wiOlwid3JhcENsYXNzXCIsZj1jW2VdO2lmKGYpaWYobnVsbD09ZCljW2VdPW51bGw7ZWxzZXt2YXIgZz1mLm1hdGNoKHkoZCkpO2lmKCFnKXJldHVybiExO3ZhciBoPWcuaW5kZXgrZ1swXS5sZW5ndGg7Y1tlXT1mLnNsaWNlKDAsZy5pbmRleCkrKGcuaW5kZXgmJmghPWYubGVuZ3RoP1wiIFwiOlwiXCIpK2Yuc2xpY2UoaCl8fG51bGx9ZWxzZSByZXR1cm4hMTtyZXR1cm4hMH0pfSksYWRkTGluZVdpZGdldDpiYShmdW5jdGlvbihhLGIsZCl7cmV0dXJuIGNoKHRoaXMsYSxiLGQpfSkscmVtb3ZlTGluZVdpZGdldDpmdW5jdGlvbihhKXthLmNsZWFyKCl9LFxubWFya1RleHQ6ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBDYih0aGlzLEModGhpcyxhKSxDKHRoaXMsYiksZCxkJiZkLnR5cGV8fFwicmFuZ2VcIil9LHNldEJvb2ttYXJrOmZ1bmN0aW9uKGEsYil7Yj17cmVwbGFjZWRXaXRoOmImJihudWxsPT1iLm5vZGVUeXBlP2Iud2lkZ2V0OmIpLGluc2VydExlZnQ6YiYmYi5pbnNlcnRMZWZ0LGNsZWFyV2hlbkVtcHR5OiExLHNoYXJlZDpiJiZiLnNoYXJlZCxoYW5kbGVNb3VzZUV2ZW50czpiJiZiLmhhbmRsZU1vdXNlRXZlbnRzfTthPUModGhpcyxhKTtyZXR1cm4gQ2IodGhpcyxhLGEsYixcImJvb2ttYXJrXCIpfSxmaW5kTWFya3NBdDpmdW5jdGlvbihhKXthPUModGhpcyxhKTt2YXIgYj1bXSxkPXcodGhpcyxhLmxpbmUpLm1hcmtlZFNwYW5zO2lmKGQpZm9yKHZhciBjPTA7YzxkLmxlbmd0aDsrK2Mpe3ZhciBlPWRbY107KG51bGw9PWUuZnJvbXx8ZS5mcm9tPD1hLmNoKSYmKG51bGw9PWUudG98fGUudG8+PWEuY2gpJiZiLnB1c2goZS5tYXJrZXIucGFyZW50fHxcbmUubWFya2VyKX1yZXR1cm4gYn0sZmluZE1hcmtzOmZ1bmN0aW9uKGEsYixkKXthPUModGhpcyxhKTtiPUModGhpcyxiKTt2YXIgYz1bXSxlPWEubGluZTt0aGlzLml0ZXIoYS5saW5lLGIubGluZSsxLGZ1bmN0aW9uKGYpe2lmKGY9Zi5tYXJrZWRTcGFucylmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXTtudWxsIT1oLnRvJiZlPT1hLmxpbmUmJmEuY2g+PWgudG98fG51bGw9PWguZnJvbSYmZSE9YS5saW5lfHxudWxsIT1oLmZyb20mJmU9PWIubGluZSYmaC5mcm9tPj1iLmNofHxkJiYhZChoLm1hcmtlcil8fGMucHVzaChoLm1hcmtlci5wYXJlbnR8fGgubWFya2VyKX0rK2V9KTtyZXR1cm4gY30sZ2V0QWxsTWFya3M6ZnVuY3Rpb24oKXt2YXIgYT1bXTt0aGlzLml0ZXIoZnVuY3Rpb24oYil7aWYoYj1iLm1hcmtlZFNwYW5zKWZvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7KytkKW51bGwhPWJbZF0uZnJvbSYmYS5wdXNoKGJbZF0ubWFya2VyKX0pO3JldHVybiBhfSxwb3NGcm9tSW5kZXg6ZnVuY3Rpb24oYSl7dmFyIGIsXG5kPXRoaXMuZmlyc3QsYz10aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7dGhpcy5pdGVyKGZ1bmN0aW9uKGUpe2U9ZS50ZXh0Lmxlbmd0aCtjO2lmKGU+YSlyZXR1cm4gYj1hLCEwO2EtPWU7KytkfSk7cmV0dXJuIEModGhpcyx0KGQsYikpfSxpbmRleEZyb21Qb3M6ZnVuY3Rpb24oYSl7YT1DKHRoaXMsYSk7dmFyIGI9YS5jaDtpZihhLmxpbmU8dGhpcy5maXJzdHx8MD5hLmNoKXJldHVybiAwO3ZhciBkPXRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDt0aGlzLml0ZXIodGhpcy5maXJzdCxhLmxpbmUsZnVuY3Rpb24oYyl7Yis9Yy50ZXh0Lmxlbmd0aCtkfSk7cmV0dXJuIGJ9LGNvcHk6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG9hKG5kKHRoaXMsdGhpcy5maXJzdCx0aGlzLmZpcnN0K3RoaXMuc2l6ZSksdGhpcy5tb2RlT3B0aW9uLHRoaXMuZmlyc3QsdGhpcy5saW5lU2VwLHRoaXMuZGlyZWN0aW9uKTtiLnNjcm9sbFRvcD10aGlzLnNjcm9sbFRvcDtiLnNjcm9sbExlZnQ9dGhpcy5zY3JvbGxMZWZ0O1xuYi5zZWw9dGhpcy5zZWw7Yi5leHRlbmQ9ITE7YSYmKGIuaGlzdG9yeS51bmRvRGVwdGg9dGhpcy5oaXN0b3J5LnVuZG9EZXB0aCxiLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpKTtyZXR1cm4gYn0sbGlua2VkRG9jOmZ1bmN0aW9uKGEpe2F8fChhPXt9KTt2YXIgYj10aGlzLmZpcnN0LGQ9dGhpcy5maXJzdCt0aGlzLnNpemU7bnVsbCE9YS5mcm9tJiZhLmZyb20+YiYmKGI9YS5mcm9tKTtudWxsIT1hLnRvJiZhLnRvPGQmJihkPWEudG8pO2I9bmV3IG9hKG5kKHRoaXMsYixkKSxhLm1vZGV8fHRoaXMubW9kZU9wdGlvbixiLHRoaXMubGluZVNlcCx0aGlzLmRpcmVjdGlvbik7YS5zaGFyZWRIaXN0JiYoYi5oaXN0b3J5PXRoaXMuaGlzdG9yeSk7KHRoaXMubGlua2VkfHwodGhpcy5saW5rZWQ9W10pKS5wdXNoKHtkb2M6YixzaGFyZWRIaXN0OmEuc2hhcmVkSGlzdH0pO2IubGlua2VkPVt7ZG9jOnRoaXMsaXNQYXJlbnQ6ITAsc2hhcmVkSGlzdDphLnNoYXJlZEhpc3R9XTthPVNmKHRoaXMpO1xuZm9yKGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGM9YVtkXSxlPWMuZmluZCgpLGY9Yi5jbGlwUG9zKGUuZnJvbSk7ZT1iLmNsaXBQb3MoZS50byk7QihmLGUpJiYoZj1DYihiLGYsZSxjLnByaW1hcnksYy5wcmltYXJ5LnR5cGUpLGMubWFya2Vycy5wdXNoKGYpLGYucGFyZW50PWMpfXJldHVybiBifSx1bmxpbmtEb2M6ZnVuY3Rpb24oYSl7YSBpbnN0YW5jZW9mIFYmJihhPWEuZG9jKTtpZih0aGlzLmxpbmtlZClmb3IodmFyIGI9MDtiPHRoaXMubGlua2VkLmxlbmd0aDsrK2IpaWYodGhpcy5saW5rZWRbYl0uZG9jPT1hKXt0aGlzLmxpbmtlZC5zcGxpY2UoYiwxKTthLnVubGlua0RvYyh0aGlzKTtlaChTZih0aGlzKSk7YnJlYWt9aWYoYS5oaXN0b3J5PT10aGlzLmhpc3Rvcnkpe3ZhciBkPVthLmlkXTtTYShhLGZ1bmN0aW9uKGMpe3JldHVybiBkLnB1c2goYy5pZCl9LCEwKTthLmhpc3Rvcnk9bmV3IFFjKG51bGwpO2EuaGlzdG9yeS5kb25lPXliKHRoaXMuaGlzdG9yeS5kb25lLGQpO1xuYS5oaXN0b3J5LnVuZG9uZT15Yih0aGlzLmhpc3RvcnkudW5kb25lLGQpfX0saXRlckxpbmtlZERvY3M6ZnVuY3Rpb24oYSl7U2EodGhpcyxhKX0sZ2V0TW9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGV9LGdldEVkaXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNtfSxzcGxpdExpbmVzOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmxpbmVTZXA/YS5zcGxpdCh0aGlzLmxpbmVTZXApOmtlKGEpfSxsaW5lU2VwYXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZVNlcHx8XCJcXG5cIn0sc2V0RGlyZWN0aW9uOmJhKGZ1bmN0aW9uKGEpe1wicnRsXCIhPWEmJihhPVwibHRyXCIpO2EhPXRoaXMuZGlyZWN0aW9uJiYodGhpcy5kaXJlY3Rpb249YSx0aGlzLml0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGIub3JkZXI9bnVsbH0pLHRoaXMuY20mJlpnKHRoaXMuY20pKX0pfSk7b2EucHJvdG90eXBlLmVhY2hMaW5lPW9hLnByb3RvdHlwZS5pdGVyO2Zvcih2YXIgVWY9MCxsZz0hMSxVYT17MzpcIlBhdXNlXCIsXG44OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDdHJsXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjXCIsMzI6XCJTcGFjZVwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJMZWZ0XCIsMzg6XCJVcFwiLDM5OlwiUmlnaHRcIiw0MDpcIkRvd25cIiw0NDpcIlByaW50U2NyblwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiw1OTpcIjtcIiw2MTpcIj1cIiw5MTpcIk1vZFwiLDkyOlwiTW9kXCIsOTM6XCJNb2RcIiwxMDY6XCIqXCIsMTA3OlwiPVwiLDEwOTpcIi1cIiwxMTA6XCIuXCIsMTExOlwiL1wiLDE0NTpcIlNjcm9sbExvY2tcIiwxNzM6XCItXCIsMTg2OlwiO1wiLDE4NzpcIj1cIiwxODg6XCIsXCIsMTg5OlwiLVwiLDE5MDpcIi5cIiwxOTE6XCIvXCIsMTkyOlwiYFwiLDIxOTpcIltcIiwyMjA6XCJcXFxcXCIsMjIxOlwiXVwiLDIyMjpcIidcIiwyMjQ6XCJNb2RcIiw2MzIzMjpcIlVwXCIsNjMyMzM6XCJEb3duXCIsNjMyMzQ6XCJMZWZ0XCIsNjMyMzU6XCJSaWdodFwiLDYzMjcyOlwiRGVsZXRlXCIsXG42MzI3MzpcIkhvbWVcIiw2MzI3NTpcIkVuZFwiLDYzMjc2OlwiUGFnZVVwXCIsNjMyNzc6XCJQYWdlRG93blwiLDYzMzAyOlwiSW5zZXJ0XCJ9LHJjPTA7MTA+cmM7cmMrKylVYVtyYys0OF09VWFbcmMrOTZdPVN0cmluZyhyYyk7Zm9yKHZhciBiZD02NTs5MD49YmQ7YmQrKylVYVtiZF09U3RyaW5nLmZyb21DaGFyQ29kZShiZCk7Zm9yKHZhciBzYz0xOzEyPj1zYztzYysrKVVhW3NjKzExMV09VWFbc2MrNjMyMzVdPVwiRlwiK3NjO3ZhciBnYz17YmFzaWM6e0xlZnQ6XCJnb0NoYXJMZWZ0XCIsUmlnaHQ6XCJnb0NoYXJSaWdodFwiLFVwOlwiZ29MaW5lVXBcIixEb3duOlwiZ29MaW5lRG93blwiLEVuZDpcImdvTGluZUVuZFwiLEhvbWU6XCJnb0xpbmVTdGFydFNtYXJ0XCIsUGFnZVVwOlwiZ29QYWdlVXBcIixQYWdlRG93bjpcImdvUGFnZURvd25cIixEZWxldGU6XCJkZWxDaGFyQWZ0ZXJcIixCYWNrc3BhY2U6XCJkZWxDaGFyQmVmb3JlXCIsXCJTaGlmdC1CYWNrc3BhY2VcIjpcImRlbENoYXJCZWZvcmVcIixUYWI6XCJkZWZhdWx0VGFiXCIsXCJTaGlmdC1UYWJcIjpcImluZGVudEF1dG9cIixcbkVudGVyOlwibmV3bGluZUFuZEluZGVudFwiLEluc2VydDpcInRvZ2dsZU92ZXJ3cml0ZVwiLEVzYzpcInNpbmdsZVNlbGVjdGlvblwifSxwY0RlZmF1bHQ6e1wiQ3RybC1BXCI6XCJzZWxlY3RBbGxcIixcIkN0cmwtRFwiOlwiZGVsZXRlTGluZVwiLFwiQ3RybC1aXCI6XCJ1bmRvXCIsXCJTaGlmdC1DdHJsLVpcIjpcInJlZG9cIixcIkN0cmwtWVwiOlwicmVkb1wiLFwiQ3RybC1Ib21lXCI6XCJnb0RvY1N0YXJ0XCIsXCJDdHJsLUVuZFwiOlwiZ29Eb2NFbmRcIixcIkN0cmwtVXBcIjpcImdvTGluZVVwXCIsXCJDdHJsLURvd25cIjpcImdvTGluZURvd25cIixcIkN0cmwtTGVmdFwiOlwiZ29Hcm91cExlZnRcIixcIkN0cmwtUmlnaHRcIjpcImdvR3JvdXBSaWdodFwiLFwiQWx0LUxlZnRcIjpcImdvTGluZVN0YXJ0XCIsXCJBbHQtUmlnaHRcIjpcImdvTGluZUVuZFwiLFwiQ3RybC1CYWNrc3BhY2VcIjpcImRlbEdyb3VwQmVmb3JlXCIsXCJDdHJsLURlbGV0ZVwiOlwiZGVsR3JvdXBBZnRlclwiLFwiQ3RybC1TXCI6XCJzYXZlXCIsXCJDdHJsLUZcIjpcImZpbmRcIixcIkN0cmwtR1wiOlwiZmluZE5leHRcIixcIlNoaWZ0LUN0cmwtR1wiOlwiZmluZFByZXZcIixcblwiU2hpZnQtQ3RybC1GXCI6XCJyZXBsYWNlXCIsXCJTaGlmdC1DdHJsLVJcIjpcInJlcGxhY2VBbGxcIixcIkN0cmwtW1wiOlwiaW5kZW50TGVzc1wiLFwiQ3RybC1dXCI6XCJpbmRlbnRNb3JlXCIsXCJDdHJsLVVcIjpcInVuZG9TZWxlY3Rpb25cIixcIlNoaWZ0LUN0cmwtVVwiOlwicmVkb1NlbGVjdGlvblwiLFwiQWx0LVVcIjpcInJlZG9TZWxlY3Rpb25cIixmYWxsdGhyb3VnaDpcImJhc2ljXCJ9LGVtYWNzeTp7XCJDdHJsLUZcIjpcImdvQ2hhclJpZ2h0XCIsXCJDdHJsLUJcIjpcImdvQ2hhckxlZnRcIixcIkN0cmwtUFwiOlwiZ29MaW5lVXBcIixcIkN0cmwtTlwiOlwiZ29MaW5lRG93blwiLFwiQWx0LUZcIjpcImdvV29yZFJpZ2h0XCIsXCJBbHQtQlwiOlwiZ29Xb3JkTGVmdFwiLFwiQ3RybC1BXCI6XCJnb0xpbmVTdGFydFwiLFwiQ3RybC1FXCI6XCJnb0xpbmVFbmRcIixcIkN0cmwtVlwiOlwiZ29QYWdlRG93blwiLFwiU2hpZnQtQ3RybC1WXCI6XCJnb1BhZ2VVcFwiLFwiQ3RybC1EXCI6XCJkZWxDaGFyQWZ0ZXJcIixcIkN0cmwtSFwiOlwiZGVsQ2hhckJlZm9yZVwiLFwiQWx0LURcIjpcImRlbFdvcmRBZnRlclwiLFwiQWx0LUJhY2tzcGFjZVwiOlwiZGVsV29yZEJlZm9yZVwiLFxuXCJDdHJsLUtcIjpcImtpbGxMaW5lXCIsXCJDdHJsLVRcIjpcInRyYW5zcG9zZUNoYXJzXCIsXCJDdHJsLU9cIjpcIm9wZW5MaW5lXCJ9LG1hY0RlZmF1bHQ6e1wiQ21kLUFcIjpcInNlbGVjdEFsbFwiLFwiQ21kLURcIjpcImRlbGV0ZUxpbmVcIixcIkNtZC1aXCI6XCJ1bmRvXCIsXCJTaGlmdC1DbWQtWlwiOlwicmVkb1wiLFwiQ21kLVlcIjpcInJlZG9cIixcIkNtZC1Ib21lXCI6XCJnb0RvY1N0YXJ0XCIsXCJDbWQtVXBcIjpcImdvRG9jU3RhcnRcIixcIkNtZC1FbmRcIjpcImdvRG9jRW5kXCIsXCJDbWQtRG93blwiOlwiZ29Eb2NFbmRcIixcIkFsdC1MZWZ0XCI6XCJnb0dyb3VwTGVmdFwiLFwiQWx0LVJpZ2h0XCI6XCJnb0dyb3VwUmlnaHRcIixcIkNtZC1MZWZ0XCI6XCJnb0xpbmVMZWZ0XCIsXCJDbWQtUmlnaHRcIjpcImdvTGluZVJpZ2h0XCIsXCJBbHQtQmFja3NwYWNlXCI6XCJkZWxHcm91cEJlZm9yZVwiLFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJBbHQtRGVsZXRlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJDbWQtU1wiOlwic2F2ZVwiLFwiQ21kLUZcIjpcImZpbmRcIixcIkNtZC1HXCI6XCJmaW5kTmV4dFwiLFxuXCJTaGlmdC1DbWQtR1wiOlwiZmluZFByZXZcIixcIkNtZC1BbHQtRlwiOlwicmVwbGFjZVwiLFwiU2hpZnQtQ21kLUFsdC1GXCI6XCJyZXBsYWNlQWxsXCIsXCJDbWQtW1wiOlwiaW5kZW50TGVzc1wiLFwiQ21kLV1cIjpcImluZGVudE1vcmVcIixcIkNtZC1CYWNrc3BhY2VcIjpcImRlbFdyYXBwZWRMaW5lTGVmdFwiLFwiQ21kLURlbGV0ZVwiOlwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFwiQ21kLVVcIjpcInVuZG9TZWxlY3Rpb25cIixcIlNoaWZ0LUNtZC1VXCI6XCJyZWRvU2VsZWN0aW9uXCIsXCJDdHJsLVVwXCI6XCJnb0RvY1N0YXJ0XCIsXCJDdHJsLURvd25cIjpcImdvRG9jRW5kXCIsZmFsbHRocm91Z2g6W1wiYmFzaWNcIixcImVtYWNzeVwiXX19O2djW1wiZGVmYXVsdFwiXT15YT9nYy5tYWNEZWZhdWx0OmdjLnBjRGVmYXVsdDt2YXIgaGM9e3NlbGVjdEFsbDpKZixzaW5nbGVTZWxlY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2V0U2VsZWN0aW9uKGEuZ2V0Q3Vyc29yKFwiYW5jaG9yXCIpLGEuZ2V0Q3Vyc29yKFwiaGVhZFwiKSxJYSl9LGtpbGxMaW5lOmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLFxuZnVuY3Rpb24oYil7aWYoYi5lbXB0eSgpKXt2YXIgZD13KGEuZG9jLGIuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtyZXR1cm4gYi5oZWFkLmNoPT1kJiZiLmhlYWQubGluZTxhLmxhc3RMaW5lKCk/e2Zyb206Yi5oZWFkLHRvOnQoYi5oZWFkLmxpbmUrMSwwKX06e2Zyb206Yi5oZWFkLHRvOnQoYi5oZWFkLmxpbmUsZCl9fXJldHVybntmcm9tOmIuZnJvbSgpLHRvOmIudG8oKX19KX0sZGVsZXRlTGluZTpmdW5jdGlvbihhKXtyZXR1cm4gRWIoYSxmdW5jdGlvbihiKXtyZXR1cm57ZnJvbTp0KGIuZnJvbSgpLmxpbmUsMCksdG86QyhhLmRvYyx0KGIudG8oKS5saW5lKzEsMCkpfX0pfSxkZWxMaW5lTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gRWIoYSxmdW5jdGlvbihiKXtyZXR1cm57ZnJvbTp0KGIuZnJvbSgpLmxpbmUsMCksdG86Yi5mcm9tKCl9fSl9LGRlbFdyYXBwZWRMaW5lTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gRWIoYSxmdW5jdGlvbihiKXt2YXIgZD1hLmNoYXJDb29yZHMoYi5oZWFkLFxuXCJkaXZcIikudG9wKzU7cmV0dXJue2Zyb206YS5jb29yZHNDaGFyKHtsZWZ0OjAsdG9wOmR9LFwiZGl2XCIpLHRvOmIuZnJvbSgpfX0pfSxkZWxXcmFwcGVkTGluZVJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLGZ1bmN0aW9uKGIpe3ZhciBkPWEuY2hhckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7ZD1hLmNvb3Jkc0NoYXIoe2xlZnQ6YS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGgrMTAwLHRvcDpkfSxcImRpdlwiKTtyZXR1cm57ZnJvbTpiLmZyb20oKSx0bzpkfX0pfSx1bmRvOmZ1bmN0aW9uKGEpe3JldHVybiBhLnVuZG8oKX0scmVkbzpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWRvKCl9LHVuZG9TZWxlY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuIGEudW5kb1NlbGVjdGlvbigpfSxyZWRvU2VsZWN0aW9uOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlZG9TZWxlY3Rpb24oKX0sZ29Eb2NTdGFydDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb24odChhLmZpcnN0TGluZSgpLFxuMCkpfSxnb0RvY0VuZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb24odChhLmxhc3RMaW5lKCkpKX0sZ29MaW5lU3RhcnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe3JldHVybiAkZihhLGIuaGVhZC5saW5lKX0se29yaWdpbjpcIittb3ZlXCIsYmlhczoxfSl9LGdvTGluZVN0YXJ0U21hcnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe3JldHVybiBhZyhhLGIuaGVhZCl9LHtvcmlnaW46XCIrbW92ZVwiLGJpYXM6MX0pfSxnb0xpbmVFbmQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe2I9Yi5oZWFkLmxpbmU7dmFyIGQ9dyhhLmRvYyxiKTt2YXIgYz1kO2Zvcih2YXIgZTtlPXFiKGMsITEpOyljPWUuZmluZCgxLCEwKS5saW5lO2MhPWQmJihiPU8oYykpO3JldHVybiBjZSghMCxhLGQsYiwtMSl9LHtvcmlnaW46XCIrbW92ZVwiLGJpYXM6LTF9KX0sXG5nb0xpbmVSaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24oYil7Yj1hLmN1cnNvckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7cmV0dXJuIGEuY29vcmRzQ2hhcih7bGVmdDphLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCsxMDAsdG9wOmJ9LFwiZGl2XCIpfSxwYyl9LGdvTGluZUxlZnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe2I9YS5jdXJzb3JDb29yZHMoYi5oZWFkLFwiZGl2XCIpLnRvcCs1O3JldHVybiBhLmNvb3Jkc0NoYXIoe2xlZnQ6MCx0b3A6Yn0sXCJkaXZcIil9LHBjKX0sZ29MaW5lTGVmdFNtYXJ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihiKXt2YXIgZD1hLmN1cnNvckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7ZD1hLmNvb3Jkc0NoYXIoe2xlZnQ6MCx0b3A6ZH0sXCJkaXZcIik7cmV0dXJuIGQuY2g8YS5nZXRMaW5lKGQubGluZSkuc2VhcmNoKC9cXFMvKT9cbmFnKGEsYi5oZWFkKTpkfSxwYyl9LGdvTGluZVVwOmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVWKC0xLFwibGluZVwiKX0sZ29MaW5lRG93bjpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlVigxLFwibGluZVwiKX0sZ29QYWdlVXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZVYoLTEsXCJwYWdlXCIpfSxnb1BhZ2VEb3duOmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVWKDEsXCJwYWdlXCIpfSxnb0NoYXJMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKC0xLFwiY2hhclwiKX0sZ29DaGFyUmlnaHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZUgoMSxcImNoYXJcIil9LGdvQ29sdW1uTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgtMSxcImNvbHVtblwiKX0sZ29Db2x1bW5SaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgxLFwiY29sdW1uXCIpfSxnb1dvcmRMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKC0xLFwid29yZFwiKX0sZ29Hcm91cFJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKDEsXG5cImdyb3VwXCIpfSxnb0dyb3VwTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgtMSxcImdyb3VwXCIpfSxnb1dvcmRSaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgxLFwid29yZFwiKX0sZGVsQ2hhckJlZm9yZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKC0xLFwiY29kZXBvaW50XCIpfSxkZWxDaGFyQWZ0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGVsZXRlSCgxLFwiY2hhclwiKX0sZGVsV29yZEJlZm9yZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKC0xLFwid29yZFwiKX0sZGVsV29yZEFmdGVyOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoMSxcIndvcmRcIil9LGRlbEdyb3VwQmVmb3JlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoLTEsXCJncm91cFwiKX0sZGVsR3JvdXBBZnRlcjpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKDEsXCJncm91cFwiKX0saW5kZW50QXV0bzpmdW5jdGlvbihhKXtyZXR1cm4gYS5pbmRlbnRTZWxlY3Rpb24oXCJzbWFydFwiKX0sXG5pbmRlbnRNb3JlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmluZGVudFNlbGVjdGlvbihcImFkZFwiKX0saW5kZW50TGVzczpmdW5jdGlvbihhKXtyZXR1cm4gYS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKX0saW5zZXJ0VGFiOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIil9LGluc2VydFNvZnRUYWI6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGQ9YS5saXN0U2VsZWN0aW9ucygpLGM9YS5vcHRpb25zLnRhYlNpemUsZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdLmZyb20oKTtmPXdhKGEuZ2V0TGluZShmLmxpbmUpLGYuY2gsYyk7Yi5wdXNoKGZkKGMtZiVjKSl9YS5yZXBsYWNlU2VsZWN0aW9ucyhiKX0sZGVmYXVsdFRhYjpmdW5jdGlvbihhKXthLnNvbWV0aGluZ1NlbGVjdGVkKCk/YS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik6YS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKX0sdHJhbnNwb3NlQ2hhcnM6ZnVuY3Rpb24oYSl7cmV0dXJuIHBhKGEsZnVuY3Rpb24oKXtmb3IodmFyIGI9XG5hLmxpc3RTZWxlY3Rpb25zKCksZD1bXSxjPTA7YzxiLmxlbmd0aDtjKyspaWYoYltjXS5lbXB0eSgpKXt2YXIgZT1iW2NdLmhlYWQsZj13KGEuZG9jLGUubGluZSkudGV4dDtpZihmKWlmKGUuY2g9PWYubGVuZ3RoJiYoZT1uZXcgdChlLmxpbmUsZS5jaC0xKSksMDxlLmNoKWU9bmV3IHQoZS5saW5lLGUuY2grMSksYS5yZXBsYWNlUmFuZ2UoZi5jaGFyQXQoZS5jaC0xKStmLmNoYXJBdChlLmNoLTIpLHQoZS5saW5lLGUuY2gtMiksZSxcIit0cmFuc3Bvc2VcIik7ZWxzZSBpZihlLmxpbmU+YS5kb2MuZmlyc3Qpe3ZhciBnPXcoYS5kb2MsZS5saW5lLTEpLnRleHQ7ZyYmKGU9bmV3IHQoZS5saW5lLDEpLGEucmVwbGFjZVJhbmdlKGYuY2hhckF0KDApK2EuZG9jLmxpbmVTZXBhcmF0b3IoKStnLmNoYXJBdChnLmxlbmd0aC0xKSx0KGUubGluZS0xLGcubGVuZ3RoLTEpLGUsXCIrdHJhbnNwb3NlXCIpKX1kLnB1c2gobmV3IEooZSxlKSl9YS5zZXRTZWxlY3Rpb25zKGQpfSl9LG5ld2xpbmVBbmRJbmRlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHBhKGEsXG5mdW5jdGlvbigpe2Zvcih2YXIgYj1hLmxpc3RTZWxlY3Rpb25zKCksZD1iLmxlbmd0aC0xOzA8PWQ7ZC0tKWEucmVwbGFjZVJhbmdlKGEuZG9jLmxpbmVTZXBhcmF0b3IoKSxiW2RdLmFuY2hvcixiW2RdLmhlYWQsXCIraW5wdXRcIik7Yj1hLmxpc3RTZWxlY3Rpb25zKCk7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylhLmluZGVudExpbmUoYltkXS5mcm9tKCkubGluZSxudWxsLCEwKTt2YihhKX0pfSxvcGVuTGluZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlU2VsZWN0aW9uKFwiXFxuXCIsXCJzdGFydFwiKX0sdG9nZ2xlT3ZlcndyaXRlOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRvZ2dsZU92ZXJ3cml0ZSgpfX0sbGg9bmV3IFZhLGRlPW51bGwsZWU9ZnVuY3Rpb24oYSxiLGQpe3RoaXMudGltZT1hO3RoaXMucG9zPWI7dGhpcy5idXR0b249ZH07ZWUucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oYSxiLGQpe3JldHVybiB0aGlzLnRpbWUrNDAwPmEmJjA9PUIoYix0aGlzLnBvcykmJmQ9PXRoaXMuYnV0dG9ufTtcbnZhciBrYyxqYyxGYj17dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkNvZGVNaXJyb3IuSW5pdFwifX0sa2c9e30sJGM9e307Vi5kZWZhdWx0cz1rZztWLm9wdGlvbkhhbmRsZXJzPSRjO3ZhciBpZT1bXTtWLmRlZmluZUluaXRIb29rPWZ1bmN0aW9uKGEpe3JldHVybiBpZS5wdXNoKGEpfTt2YXIgcWE9bnVsbCxQPWZ1bmN0aW9uKGEpe3RoaXMuY209YTt0aGlzLmxhc3RBbmNob3JOb2RlPXRoaXMubGFzdEFuY2hvck9mZnNldD10aGlzLmxhc3RGb2N1c05vZGU9dGhpcy5sYXN0Rm9jdXNPZmZzZXQ9bnVsbDt0aGlzLnBvbGxpbmc9bmV3IFZhO3RoaXMuY29tcG9zaW5nPW51bGw7dGhpcy5ncmFjZVBlcmlvZD0hMTt0aGlzLnJlYWRET01UaW1lb3V0PW51bGx9O1AucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihoKXtmb3IoaD1oLnRhcmdldDtoO2g9aC5wYXJlbnROb2RlKXtpZihoPT1nKXJldHVybiEwO2lmKC9cXGJDb2RlTWlycm9yLSg/OmxpbmUpP3dpZGdldFxcYi8udGVzdChoLmNsYXNzTmFtZSkpYnJlYWt9cmV0dXJuITF9XG5mdW5jdGlvbiBkKGgpe2lmKGIoaCkmJiFaKGYsaCkpe2lmKGYuc29tZXRoaW5nU2VsZWN0ZWQoKSlxYT17bGluZVdpc2U6ITEsdGV4dDpmLmdldFNlbGVjdGlvbnMoKX0sXCJjdXRcIj09aC50eXBlJiZmLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiY3V0XCIpO2Vsc2UgaWYoZi5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCl7dmFyIGs9b2coZik7cWE9e2xpbmVXaXNlOiEwLHRleHQ6ay50ZXh0fTtcImN1dFwiPT1oLnR5cGUmJmYub3BlcmF0aW9uKGZ1bmN0aW9uKCl7Zi5zZXRTZWxlY3Rpb25zKGsucmFuZ2VzLDAsSWEpO2YucmVwbGFjZVNlbGVjdGlvbihcIlwiLG51bGwsXCJjdXRcIil9KX1lbHNlIHJldHVybjtpZihoLmNsaXBib2FyZERhdGEpe2guY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTt2YXIgbD1xYS50ZXh0LmpvaW4oXCJcXG5cIik7aC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsbCk7aWYoaC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpPT1sKXtoLnByZXZlbnREZWZhdWx0KCk7XG5yZXR1cm59fXZhciBtPXFnKCk7aD1tLmZpcnN0Q2hpbGQ7Zi5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUobSxmLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO2gudmFsdWU9cWEudGV4dC5qb2luKFwiXFxuXCIpO3ZhciBxPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7b2MoaCk7c2V0VGltZW91dChmdW5jdGlvbigpe2YuZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQobSk7cS5mb2N1cygpO3E9PWcmJmUuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKX0sNTApfX12YXIgYz10aGlzLGU9dGhpcyxmPWUuY20sZz1lLmRpdj1hLmxpbmVEaXY7cGcoZyxmLm9wdGlvbnMuc3BlbGxjaGVjayxmLm9wdGlvbnMuYXV0b2NvcnJlY3QsZi5vcHRpb25zLmF1dG9jYXBpdGFsaXplKTt6KGcsXCJwYXN0ZVwiLGZ1bmN0aW9uKGgpeyFiKGgpfHxaKGYsaCl8fG5nKGgsZil8fDExPj1VJiZzZXRUaW1lb3V0KGFhKGYsZnVuY3Rpb24oKXtyZXR1cm4gYy51cGRhdGVGcm9tRE9NKCl9KSwyMCl9KTt6KGcsXG5cImNvbXBvc2l0aW9uc3RhcnRcIixmdW5jdGlvbihoKXtjLmNvbXBvc2luZz17ZGF0YTpoLmRhdGEsZG9uZTohMX19KTt6KGcsXCJjb21wb3NpdGlvbnVwZGF0ZVwiLGZ1bmN0aW9uKGgpe2MuY29tcG9zaW5nfHwoYy5jb21wb3Npbmc9e2RhdGE6aC5kYXRhLGRvbmU6ITF9KX0pO3ooZyxcImNvbXBvc2l0aW9uZW5kXCIsZnVuY3Rpb24oaCl7Yy5jb21wb3NpbmcmJihoLmRhdGEhPWMuY29tcG9zaW5nLmRhdGEmJmMucmVhZEZyb21ET01Tb29uKCksYy5jb21wb3NpbmcuZG9uZT0hMCl9KTt6KGcsXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oKXtyZXR1cm4gZS5mb3JjZUNvbXBvc2l0aW9uRW5kKCl9KTt6KGcsXCJpbnB1dFwiLGZ1bmN0aW9uKCl7Yy5jb21wb3Npbmd8fGMucmVhZEZyb21ET01Tb29uKCl9KTt6KGcsXCJjb3B5XCIsZCk7eihnLFwiY3V0XCIsZCl9O1AucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZD1mdW5jdGlvbihhKXthP3RoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcbmEpOnRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIil9O1AucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYT1kZih0aGlzLmNtLCExKTthLmZvY3VzPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PXRoaXMuZGl2O3JldHVybiBhfTtQLnByb3RvdHlwZS5zaG93U2VsZWN0aW9uPWZ1bmN0aW9uKGEsYil7YSYmdGhpcy5jbS5kaXNwbGF5LnZpZXcubGVuZ3RoJiYoKGEuZm9jdXN8fGIpJiZ0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCksdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGEpKX07UC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCl9O1AucHJvdG90eXBlLnNob3dQcmltYXJ5U2VsZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb24oKSxiPXRoaXMuY20sZD1iLmRvYy5zZWwucHJpbWFyeSgpLFxuYz1kLmZyb20oKTtkPWQudG8oKTtpZihiLmRpc3BsYXkudmlld1RvPT1iLmRpc3BsYXkudmlld0Zyb218fGMubGluZT49Yi5kaXNwbGF5LnZpZXdUb3x8ZC5saW5lPGIuZGlzcGxheS52aWV3RnJvbSlhLnJlbW92ZUFsbFJhbmdlcygpO2Vsc2V7dmFyIGU9YWQoYixhLmFuY2hvck5vZGUsYS5hbmNob3JPZmZzZXQpLGY9YWQoYixhLmZvY3VzTm9kZSxhLmZvY3VzT2Zmc2V0KTtpZighZXx8ZS5iYWR8fCFmfHxmLmJhZHx8MCE9QihBYyhlLGYpLGMpfHwwIT1CKHpjKGUsZiksZCkpaWYoZT1iLmRpc3BsYXkudmlldyxjPWMubGluZT49Yi5kaXNwbGF5LnZpZXdGcm9tJiZzZyhiLGMpfHx7bm9kZTplWzBdLm1lYXN1cmUubWFwWzJdLG9mZnNldDowfSxkPWQubGluZTxiLmRpc3BsYXkudmlld1RvJiZzZyhiLGQpLGR8fChkPWVbZS5sZW5ndGgtMV0ubWVhc3VyZSxkPWQubWFwcz9kLm1hcHNbZC5tYXBzLmxlbmd0aC0xXTpkLm1hcCxkPXtub2RlOmRbZC5sZW5ndGgtMV0sb2Zmc2V0OmRbZC5sZW5ndGgtXG4yXS1kW2QubGVuZ3RoLTNdfSksYyYmZCl7ZT1hLnJhbmdlQ291bnQmJmEuZ2V0UmFuZ2VBdCgwKTt0cnl7dmFyIGc9T2IoYy5ub2RlLGMub2Zmc2V0LGQub2Zmc2V0LGQubm9kZSl9Y2F0Y2goaCl7fWcmJighTWEmJmIuc3RhdGUuZm9jdXNlZD8oYS5jb2xsYXBzZShjLm5vZGUsYy5vZmZzZXQpLGcuY29sbGFwc2VkfHwoYS5yZW1vdmVBbGxSYW5nZXMoKSxhLmFkZFJhbmdlKGcpKSk6KGEucmVtb3ZlQWxsUmFuZ2VzKCksYS5hZGRSYW5nZShnKSksZSYmbnVsbD09YS5hbmNob3JOb2RlP2EuYWRkUmFuZ2UoZSk6TWEmJnRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpKTt0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCl9ZWxzZSBhLnJlbW92ZUFsbFJhbmdlcygpfX07UC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7Y2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO3RoaXMuZ3JhY2VQZXJpb2Q9c2V0VGltZW91dChmdW5jdGlvbigpe2EuZ3JhY2VQZXJpb2Q9XG4hMTthLnNlbGVjdGlvbkNoYW5nZWQoKSYmYS5jbS5vcGVyYXRpb24oZnVuY3Rpb24oKXtyZXR1cm4gYS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPSEwfSl9LDIwKX07UC5wcm90b3R5cGUuc2hvd011bHRpcGxlU2VsZWN0aW9ucz1mdW5jdGlvbihhKXtEKHRoaXMuY20uZGlzcGxheS5jdXJzb3JEaXYsYS5jdXJzb3JzKTtEKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsYS5zZWxlY3Rpb24pfTtQLnByb3RvdHlwZS5yZW1lbWJlclNlbGVjdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U2VsZWN0aW9uKCk7dGhpcy5sYXN0QW5jaG9yTm9kZT1hLmFuY2hvck5vZGU7dGhpcy5sYXN0QW5jaG9yT2Zmc2V0PWEuYW5jaG9yT2Zmc2V0O3RoaXMubGFzdEZvY3VzTm9kZT1hLmZvY3VzTm9kZTt0aGlzLmxhc3RGb2N1c09mZnNldD1hLmZvY3VzT2Zmc2V0fTtQLnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U2VsZWN0aW9uKCk7aWYoIWEucmFuZ2VDb3VudClyZXR1cm4hMTtcbmE9YS5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO3JldHVybiBrYSh0aGlzLmRpdixhKX07UC5wcm90b3R5cGUuZm9jdXM9ZnVuY3Rpb24oKXtcIm5vY3Vyc29yXCIhPXRoaXMuY20ub3B0aW9ucy5yZWFkT25seSYmKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSYmZG9jdW1lbnQuYWN0aXZlRWxlbWVudD09dGhpcy5kaXZ8fHRoaXMuc2hvd1NlbGVjdGlvbih0aGlzLnByZXBhcmVTZWxlY3Rpb24oKSwhMCksdGhpcy5kaXYuZm9jdXMoKSl9O1AucHJvdG90eXBlLmJsdXI9ZnVuY3Rpb24oKXt0aGlzLmRpdi5ibHVyKCl9O1AucHJvdG90eXBlLmdldEZpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGl2fTtQLnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoPWZ1bmN0aW9uKCl7cmV0dXJuITB9O1AucHJvdG90eXBlLnJlY2VpdmVkRm9jdXM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7Yi5jbS5zdGF0ZS5mb2N1c2VkJiYoYi5wb2xsU2VsZWN0aW9uKCksYi5wb2xsaW5nLnNldChiLmNtLm9wdGlvbnMucG9sbEludGVydmFsLFxuYSkpfXZhciBiPXRoaXM7dGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpP3RoaXMucG9sbFNlbGVjdGlvbigpOnBhKHRoaXMuY20sZnVuY3Rpb24oKXtyZXR1cm4gYi5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPSEwfSk7dGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLGEpfTtQLnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb24oKTtyZXR1cm4gYS5hbmNob3JOb2RlIT10aGlzLmxhc3RBbmNob3JOb2RlfHxhLmFuY2hvck9mZnNldCE9dGhpcy5sYXN0QW5jaG9yT2Zmc2V0fHxhLmZvY3VzTm9kZSE9dGhpcy5sYXN0Rm9jdXNOb2RlfHxhLmZvY3VzT2Zmc2V0IT10aGlzLmxhc3RGb2N1c09mZnNldH07UC5wcm90b3R5cGUucG9sbFNlbGVjdGlvbj1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucmVhZERPTVRpbWVvdXQmJiF0aGlzLmdyYWNlUGVyaW9kJiZ0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSl7dmFyIGE9XG50aGlzLmdldFNlbGVjdGlvbigpLGI9dGhpcy5jbTtpZihHYyYmRmMmJnRoaXMuY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGgmJkFoKGEuYW5jaG9yTm9kZSkpdGhpcy5jbS50cmlnZ2VyT25LZXlEb3duKHt0eXBlOlwia2V5ZG93blwiLGtleUNvZGU6OCxwcmV2ZW50RGVmYXVsdDpNYXRoLmFic30pLHRoaXMuYmx1cigpLHRoaXMuZm9jdXMoKTtlbHNlIGlmKCF0aGlzLmNvbXBvc2luZyl7dGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO3ZhciBkPWFkKGIsYS5hbmNob3JOb2RlLGEuYW5jaG9yT2Zmc2V0KSxjPWFkKGIsYS5mb2N1c05vZGUsYS5mb2N1c09mZnNldCk7ZCYmYyYmcGEoYixmdW5jdGlvbigpe2RhKGIuZG9jLE5hKGQsYyksSWEpO2lmKGQuYmFkfHxjLmJhZCliLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQ9ITB9KX19fTtQLnByb3RvdHlwZS5wb2xsQ29udGVudD1mdW5jdGlvbigpe251bGwhPXRoaXMucmVhZERPTVRpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCksXG50aGlzLnJlYWRET01UaW1lb3V0PW51bGwpO3ZhciBhPXRoaXMuY20sYj1hLmRpc3BsYXksZD1hLmRvYy5zZWwucHJpbWFyeSgpLGM9ZC5mcm9tKCksZT1kLnRvKCk7MD09Yy5jaCYmYy5saW5lPmEuZmlyc3RMaW5lKCkmJihjPXQoYy5saW5lLTEsdyhhLmRvYyxjLmxpbmUtMSkubGVuZ3RoKSk7ZS5jaD09dyhhLmRvYyxlLmxpbmUpLnRleHQubGVuZ3RoJiZlLmxpbmU8YS5sYXN0TGluZSgpJiYoZT10KGUubGluZSsxLDApKTtpZihjLmxpbmU8Yi52aWV3RnJvbXx8ZS5saW5lPmIudmlld1RvLTEpcmV0dXJuITE7dmFyIGY7Yy5saW5lPT1iLnZpZXdGcm9tfHwwPT0oZj1iYihhLGMubGluZSkpPyhkPU8oYi52aWV3WzBdLmxpbmUpLGY9Yi52aWV3WzBdLm5vZGUpOihkPU8oYi52aWV3W2ZdLmxpbmUpLGY9Yi52aWV3W2YtMV0ubm9kZS5uZXh0U2libGluZyk7dmFyIGc9YmIoYSxlLmxpbmUpO2c9PWIudmlldy5sZW5ndGgtMT8oZT1iLnZpZXdUby0xLGI9Yi5saW5lRGl2Lmxhc3RDaGlsZCk6XG4oZT1PKGIudmlld1tnKzFdLmxpbmUpLTEsYj1iLnZpZXdbZysxXS5ub2RlLnByZXZpb3VzU2libGluZyk7aWYoIWYpcmV0dXJuITE7Yj1hLmRvYy5zcGxpdExpbmVzKEJoKGEsZixiLGQsZSkpO2ZvcihmPVphKGEuZG9jLHQoZCwwKSx0KGUsdyhhLmRvYyxlKS50ZXh0Lmxlbmd0aCkpOzE8Yi5sZW5ndGgmJjE8Zi5sZW5ndGg7KWlmKEwoYik9PUwoZikpYi5wb3AoKSxmLnBvcCgpLGUtLTtlbHNlIGlmKGJbMF09PWZbMF0pYi5zaGlmdCgpLGYuc2hpZnQoKSxkKys7ZWxzZSBicmVhazt2YXIgaD0wO2c9MDtmb3IodmFyIGs9YlswXSxsPWZbMF0sbT1NYXRoLm1pbihrLmxlbmd0aCxsLmxlbmd0aCk7aDxtJiZrLmNoYXJDb2RlQXQoaCk9PWwuY2hhckNvZGVBdChoKTspKytoO2s9TChiKTtsPUwoZik7Zm9yKG09TWF0aC5taW4oay5sZW5ndGgtKDE9PWIubGVuZ3RoP2g6MCksbC5sZW5ndGgtKDE9PWYubGVuZ3RoP2g6MCkpO2c8bSYmay5jaGFyQ29kZUF0KGsubGVuZ3RoLWctMSk9PWwuY2hhckNvZGVBdChsLmxlbmd0aC1cbmctMSk7KSsrZztpZigxPT1iLmxlbmd0aCYmMT09Zi5sZW5ndGgmJmQ9PWMubGluZSlmb3IoO2gmJmg+Yy5jaCYmay5jaGFyQ29kZUF0KGsubGVuZ3RoLWctMSk9PWwuY2hhckNvZGVBdChsLmxlbmd0aC1nLTEpOyloLS0sZysrO2JbYi5sZW5ndGgtMV09ay5zbGljZSgwLGsubGVuZ3RoLWcpLnJlcGxhY2UoL15cXHUyMDBiKy8sXCJcIik7YlswXT1iWzBdLnNsaWNlKGgpLnJlcGxhY2UoL1xcdTIwMGIrJC8sXCJcIik7Yz10KGQsaCk7ZD10KGUsZi5sZW5ndGg/TChmKS5sZW5ndGgtZzowKTtpZigxPGIubGVuZ3RofHxiWzBdfHxCKGMsZCkpcmV0dXJuIEJiKGEuZG9jLGIsYyxkLFwiK2lucHV0XCIpLCEwfTtQLnByb3RvdHlwZS5lbnN1cmVQb2xsZWQ9ZnVuY3Rpb24oKXt0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKX07UC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKX07UC5wcm90b3R5cGUuZm9yY2VDb21wb3NpdGlvbkVuZD1mdW5jdGlvbigpe3RoaXMuY29tcG9zaW5nJiZcbihjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCksdGhpcy5jb21wb3Npbmc9bnVsbCx0aGlzLnVwZGF0ZUZyb21ET00oKSx0aGlzLmRpdi5ibHVyKCksdGhpcy5kaXYuZm9jdXMoKSl9O1AucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bnVsbD09dGhpcy5yZWFkRE9NVGltZW91dCYmKHRoaXMucmVhZERPTVRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2EucmVhZERPTVRpbWVvdXQ9bnVsbDtpZihhLmNvbXBvc2luZylpZihhLmNvbXBvc2luZy5kb25lKWEuY29tcG9zaW5nPW51bGw7ZWxzZSByZXR1cm47YS51cGRhdGVGcm9tRE9NKCl9LDgwKSl9O1AucHJvdG90eXBlLnVwZGF0ZUZyb21ET009ZnVuY3Rpb24oKXt2YXIgYT10aGlzOyF0aGlzLmNtLmlzUmVhZE9ubHkoKSYmdGhpcy5wb2xsQ29udGVudCgpfHxwYSh0aGlzLmNtLGZ1bmN0aW9uKCl7cmV0dXJuIG1hKGEuY20pfSl9O1AucHJvdG90eXBlLnNldFVuZWRpdGFibGU9ZnVuY3Rpb24oYSl7YS5jb250ZW50RWRpdGFibGU9XG5cImZhbHNlXCJ9O1AucHJvdG90eXBlLm9uS2V5UHJlc3M9ZnVuY3Rpb24oYSl7MD09YS5jaGFyQ29kZXx8dGhpcy5jb21wb3Npbmd8fChhLnByZXZlbnREZWZhdWx0KCksdGhpcy5jbS5pc1JlYWRPbmx5KCl8fGFhKHRoaXMuY20samUpKHRoaXMuY20sU3RyaW5nLmZyb21DaGFyQ29kZShudWxsPT1hLmNoYXJDb2RlP2Eua2V5Q29kZTphLmNoYXJDb2RlKSwwKSl9O1AucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZD1mdW5jdGlvbihhKXt0aGlzLmRpdi5jb250ZW50RWRpdGFibGU9U3RyaW5nKFwibm9jdXJzb3JcIiE9YSl9O1AucHJvdG90eXBlLm9uQ29udGV4dE1lbnU9ZnVuY3Rpb24oKXt9O1AucHJvdG90eXBlLnJlc2V0UG9zaXRpb249ZnVuY3Rpb24oKXt9O1AucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZT0hMDt2YXIgVz1mdW5jdGlvbihhKXt0aGlzLmNtPWE7dGhpcy5wcmV2SW5wdXQ9XCJcIjt0aGlzLnBvbGxpbmdGYXN0PSExO3RoaXMucG9sbGluZz1uZXcgVmE7dGhpcy5oYXNTZWxlY3Rpb249XG4hMTt0aGlzLmNvbXBvc2luZz1udWxsfTtXLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoZyl7aWYoIVooZSxnKSl7aWYoZS5zb21ldGhpbmdTZWxlY3RlZCgpKXFhPXtsaW5lV2lzZTohMSx0ZXh0OmUuZ2V0U2VsZWN0aW9ucygpfTtlbHNlIGlmKGUub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpe3ZhciBoPW9nKGUpO3FhPXtsaW5lV2lzZTohMCx0ZXh0OmgudGV4dH07XCJjdXRcIj09Zy50eXBlP2Uuc2V0U2VsZWN0aW9ucyhoLnJhbmdlcyxudWxsLElhKTooYy5wcmV2SW5wdXQ9XCJcIixmLnZhbHVlPWgudGV4dC5qb2luKFwiXFxuXCIpLG9jKGYpKX1lbHNlIHJldHVybjtcImN1dFwiPT1nLnR5cGUmJihlLnN0YXRlLmN1dEluY29taW5nPStuZXcgRGF0ZSl9fXZhciBkPXRoaXMsYz10aGlzLGU9dGhpcy5jbTt0aGlzLmNyZWF0ZUZpZWxkKGEpO3ZhciBmPXRoaXMudGV4dGFyZWE7YS53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLndyYXBwZXIsYS53cmFwcGVyLmZpcnN0Q2hpbGQpO1xubWMmJihmLnN0eWxlLndpZHRoPVwiMHB4XCIpO3ooZixcImlucHV0XCIsZnVuY3Rpb24oKXtHJiY5PD1VJiZkLmhhc1NlbGVjdGlvbiYmKGQuaGFzU2VsZWN0aW9uPW51bGwpO2MucG9sbCgpfSk7eihmLFwicGFzdGVcIixmdW5jdGlvbihnKXtaKGUsZyl8fG5nKGcsZSl8fChlLnN0YXRlLnBhc3RlSW5jb21pbmc9K25ldyBEYXRlLGMuZmFzdFBvbGwoKSl9KTt6KGYsXCJjdXRcIixiKTt6KGYsXCJjb3B5XCIsYik7eihhLnNjcm9sbGVyLFwicGFzdGVcIixmdW5jdGlvbihnKXtpZighTGEoYSxnKSYmIVooZSxnKSlpZihmLmRpc3BhdGNoRXZlbnQpe3ZhciBoPW5ldyBFdmVudChcInBhc3RlXCIpO2guY2xpcGJvYXJkRGF0YT1nLmNsaXBib2FyZERhdGE7Zi5kaXNwYXRjaEV2ZW50KGgpfWVsc2UgZS5zdGF0ZS5wYXN0ZUluY29taW5nPStuZXcgRGF0ZSxjLmZvY3VzKCl9KTt6KGEubGluZVNwYWNlLFwic2VsZWN0c3RhcnRcIixmdW5jdGlvbihnKXtMYShhLGcpfHxsYShnKX0pO3ooZixcImNvbXBvc2l0aW9uc3RhcnRcIixcbmZ1bmN0aW9uKCl7dmFyIGc9ZS5nZXRDdXJzb3IoXCJmcm9tXCIpO2MuY29tcG9zaW5nJiZjLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO2MuY29tcG9zaW5nPXtzdGFydDpnLHJhbmdlOmUubWFya1RleHQoZyxlLmdldEN1cnNvcihcInRvXCIpLHtjbGFzc05hbWU6XCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSl9fSk7eihmLFwiY29tcG9zaXRpb25lbmRcIixmdW5jdGlvbigpe2MuY29tcG9zaW5nJiYoYy5wb2xsKCksYy5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKSxjLmNvbXBvc2luZz1udWxsKX0pfTtXLnByb3RvdHlwZS5jcmVhdGVGaWVsZD1mdW5jdGlvbihhKXt0aGlzLndyYXBwZXI9cWcoKTt0aGlzLnRleHRhcmVhPXRoaXMud3JhcHBlci5maXJzdENoaWxkfTtXLnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQ9ZnVuY3Rpb24oYSl7YT90aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixhKTp0aGlzLnRleHRhcmVhLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIil9O1xuVy5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY20sYj1hLmRpc3BsYXksZD1hLmRvYyxjPWRmKGEpO2lmKGEub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKXthPUFhKGEsZC5zZWwucHJpbWFyeSgpLmhlYWQsXCJkaXZcIik7ZD1iLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIGU9Yi5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2MudGVUb3A9TWF0aC5tYXgoMCxNYXRoLm1pbihiLndyYXBwZXIuY2xpZW50SGVpZ2h0LTEwLGEudG9wK2UudG9wLWQudG9wKSk7Yy50ZUxlZnQ9TWF0aC5tYXgoMCxNYXRoLm1pbihiLndyYXBwZXIuY2xpZW50V2lkdGgtMTAsYS5sZWZ0K2UubGVmdC1kLmxlZnQpKX1yZXR1cm4gY307Vy5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNtLmRpc3BsYXk7RChiLmN1cnNvckRpdixhLmN1cnNvcnMpO0QoYi5zZWxlY3Rpb25EaXYsYS5zZWxlY3Rpb24pO1xubnVsbCE9YS50ZVRvcCYmKHRoaXMud3JhcHBlci5zdHlsZS50b3A9YS50ZVRvcCtcInB4XCIsdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQ9YS50ZUxlZnQrXCJweFwiKX07Vy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuY29udGV4dE1lbnVQZW5kaW5nJiYhdGhpcy5jb21wb3Npbmcpe3ZhciBiPXRoaXMuY207Yi5zb21ldGhpbmdTZWxlY3RlZCgpPyh0aGlzLnByZXZJbnB1dD1cIlwiLGE9Yi5nZXRTZWxlY3Rpb24oKSx0aGlzLnRleHRhcmVhLnZhbHVlPWEsYi5zdGF0ZS5mb2N1c2VkJiZvYyh0aGlzLnRleHRhcmVhKSxHJiY5PD1VJiYodGhpcy5oYXNTZWxlY3Rpb249YSkpOmF8fCh0aGlzLnByZXZJbnB1dD10aGlzLnRleHRhcmVhLnZhbHVlPVwiXCIsRyYmOTw9VSYmKHRoaXMuaGFzU2VsZWN0aW9uPW51bGwpKX19O1cucHJvdG90eXBlLmdldEZpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dGFyZWF9O1cucHJvdG90eXBlLnN1cHBvcnRzVG91Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMX07XG5XLnByb3RvdHlwZS5mb2N1cz1mdW5jdGlvbigpe2lmKFwibm9jdXJzb3JcIiE9dGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5JiYoIVpifHx2YSgpIT10aGlzLnRleHRhcmVhKSl0cnl7dGhpcy50ZXh0YXJlYS5mb2N1cygpfWNhdGNoKGEpe319O1cucHJvdG90eXBlLmJsdXI9ZnVuY3Rpb24oKXt0aGlzLnRleHRhcmVhLmJsdXIoKX07Vy5wcm90b3R5cGUucmVzZXRQb3NpdGlvbj1mdW5jdGlvbigpe3RoaXMud3JhcHBlci5zdHlsZS50b3A9dGhpcy53cmFwcGVyLnN0eWxlLmxlZnQ9MH07Vy5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cz1mdW5jdGlvbigpe3RoaXMuc2xvd1BvbGwoKX07Vy5wcm90b3R5cGUuc2xvd1BvbGw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMucG9sbGluZ0Zhc3R8fHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCxmdW5jdGlvbigpe2EucG9sbCgpO2EuY20uc3RhdGUuZm9jdXNlZCYmYS5zbG93UG9sbCgpfSl9O1cucHJvdG90eXBlLmZhc3RQb2xsPVxuZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7ZC5wb2xsKCl8fGI/KGQucG9sbGluZ0Zhc3Q9ITEsZC5zbG93UG9sbCgpKTooYj0hMCxkLnBvbGxpbmcuc2V0KDYwLGEpKX12YXIgYj0hMSxkPXRoaXM7ZC5wb2xsaW5nRmFzdD0hMDtkLnBvbGxpbmcuc2V0KDIwLGEpfTtXLnByb3RvdHlwZS5wb2xsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMuY20sZD10aGlzLnRleHRhcmVhLGM9dGhpcy5wcmV2SW5wdXQ7aWYodGhpcy5jb250ZXh0TWVudVBlbmRpbmd8fCFiLnN0YXRlLmZvY3VzZWR8fEdoKGQpJiYhYyYmIXRoaXMuY29tcG9zaW5nfHxiLmlzUmVhZE9ubHkoKXx8Yi5vcHRpb25zLmRpc2FibGVJbnB1dHx8Yi5zdGF0ZS5rZXlTZXEpcmV0dXJuITE7dmFyIGU9ZC52YWx1ZTtpZihlPT1jJiYhYi5zb21ldGhpbmdTZWxlY3RlZCgpKXJldHVybiExO2lmKEcmJjk8PVUmJnRoaXMuaGFzU2VsZWN0aW9uPT09ZXx8eWEmJi9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdChlKSlyZXR1cm4gYi5kaXNwbGF5LmlucHV0LnJlc2V0KCksXG4hMTtpZihiLmRvYy5zZWw9PWIuZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSl7dmFyIGY9ZS5jaGFyQ29kZUF0KDApOzgyMDMhPWZ8fGN8fChjPVwiXFx1MjAwYlwiKTtpZig4NjY2PT1mKXJldHVybiB0aGlzLnJlc2V0KCksdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIil9dmFyIGc9MDtmb3IoZj1NYXRoLm1pbihjLmxlbmd0aCxlLmxlbmd0aCk7ZzxmJiZjLmNoYXJDb2RlQXQoZyk9PWUuY2hhckNvZGVBdChnKTspKytnO3BhKGIsZnVuY3Rpb24oKXtqZShiLGUuc2xpY2UoZyksYy5sZW5ndGgtZyxudWxsLGEuY29tcG9zaW5nP1wiKmNvbXBvc2VcIjpudWxsKTsxRTM8ZS5sZW5ndGh8fC0xPGUuaW5kZXhPZihcIlxcblwiKT9kLnZhbHVlPWEucHJldklucHV0PVwiXCI6YS5wcmV2SW5wdXQ9ZTthLmNvbXBvc2luZyYmKGEuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCksYS5jb21wb3NpbmcucmFuZ2U9Yi5tYXJrVGV4dChhLmNvbXBvc2luZy5zdGFydCxiLmdldEN1cnNvcihcInRvXCIpLHtjbGFzc05hbWU6XCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSkpfSk7XG5yZXR1cm4hMH07Vy5wcm90b3R5cGUuZW5zdXJlUG9sbGVkPWZ1bmN0aW9uKCl7dGhpcy5wb2xsaW5nRmFzdCYmdGhpcy5wb2xsKCkmJih0aGlzLnBvbGxpbmdGYXN0PSExKX07Vy5wcm90b3R5cGUub25LZXlQcmVzcz1mdW5jdGlvbigpe0cmJjk8PVUmJih0aGlzLmhhc1NlbGVjdGlvbj1udWxsKTt0aGlzLmZhc3RQb2xsKCl9O1cucHJvdG90eXBlLm9uQ29udGV4dE1lbnU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2lmKG51bGwhPWcuc2VsZWN0aW9uU3RhcnQpe3ZhciBwPWUuc29tZXRoaW5nU2VsZWN0ZWQoKSxyPVwiXFx1MjAwYlwiKyhwP2cudmFsdWU6XCJcIik7Zy52YWx1ZT1cIlxcdTIxZGFcIjtnLnZhbHVlPXI7Yy5wcmV2SW5wdXQ9cD9cIlwiOlwiXFx1MjAwYlwiO2cuc2VsZWN0aW9uU3RhcnQ9MTtnLnNlbGVjdGlvbkVuZD1yLmxlbmd0aDtmLnNlbEZvckNvbnRleHRNZW51PWUuZG9jLnNlbH19ZnVuY3Rpb24gZCgpe2lmKGMuY29udGV4dE1lbnVQZW5kaW5nPT1kJiYoYy5jb250ZXh0TWVudVBlbmRpbmc9XG4hMSxjLndyYXBwZXIuc3R5bGUuY3NzVGV4dD1tLGcuc3R5bGUuY3NzVGV4dD1sLEcmJjk+VSYmZi5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChmLnNjcm9sbGVyLnNjcm9sbFRvcD1rKSxudWxsIT1nLnNlbGVjdGlvblN0YXJ0KSl7KCFHfHxHJiY5PlUpJiZiKCk7dmFyIHA9MCxyPWZ1bmN0aW9uKCl7Zi5zZWxGb3JDb250ZXh0TWVudT09ZS5kb2Muc2VsJiYwPT1nLnNlbGVjdGlvblN0YXJ0JiYwPGcuc2VsZWN0aW9uRW5kJiZcIlxcdTIwMGJcIj09Yy5wcmV2SW5wdXQ/YWEoZSxKZikoZSk6MTA+cCsrP2YuZGV0ZWN0aW5nU2VsZWN0QWxsPXNldFRpbWVvdXQociw1MDApOihmLnNlbEZvckNvbnRleHRNZW51PW51bGwsZi5pbnB1dC5yZXNldCgpKX07Zi5kZXRlY3RpbmdTZWxlY3RBbGw9c2V0VGltZW91dChyLDIwMCl9fXZhciBjPXRoaXMsZT1jLmNtLGY9ZS5kaXNwbGF5LGc9Yy50ZXh0YXJlYTtjLmNvbnRleHRNZW51UGVuZGluZyYmYy5jb250ZXh0TWVudVBlbmRpbmcoKTt2YXIgaD1lYihlLFxuYSksaz1mLnNjcm9sbGVyLnNjcm9sbFRvcDtpZihoJiYhQmEpe2Uub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUmJi0xPT1lLmRvYy5zZWwuY29udGFpbnMoaCkmJmFhKGUsZGEpKGUuZG9jLE5hKGgpLElhKTt2YXIgbD1nLnN0eWxlLmNzc1RleHQsbT1jLndyYXBwZXIuc3R5bGUuY3NzVGV4dDtoPWMud3JhcHBlci5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Yy53cmFwcGVyLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjogc3RhdGljXCI7Zy5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMzBweDsgaGVpZ2h0OiAzMHB4O1xcbiAgICAgIHRvcDogXCIrKGEuY2xpZW50WS1oLnRvcC01KStcInB4OyBsZWZ0OiBcIisoYS5jbGllbnRYLWgubGVmdC01KStcInB4O1xcbiAgICAgIHotaW5kZXg6IDEwMDA7IGJhY2tncm91bmQ6IFwiKyhHP1wicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXCI6XCJ0cmFuc3BhcmVudFwiKStcIjtcXG4gICAgICBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiO1xuaWYoZmEpdmFyIHE9d2luZG93LnNjcm9sbFk7Zi5pbnB1dC5mb2N1cygpO2ZhJiZ3aW5kb3cuc2Nyb2xsVG8obnVsbCxxKTtmLmlucHV0LnJlc2V0KCk7ZS5zb21ldGhpbmdTZWxlY3RlZCgpfHwoZy52YWx1ZT1jLnByZXZJbnB1dD1cIiBcIik7Yy5jb250ZXh0TWVudVBlbmRpbmc9ZDtmLnNlbEZvckNvbnRleHRNZW51PWUuZG9jLnNlbDtjbGVhclRpbWVvdXQoZi5kZXRlY3RpbmdTZWxlY3RBbGwpO0cmJjk8PVUmJmIoKTtpZihmZSl7S2IoYSk7dmFyIG49ZnVuY3Rpb24oKXtyYSh3aW5kb3csXCJtb3VzZXVwXCIsbik7c2V0VGltZW91dChkLDIwKX07eih3aW5kb3csXCJtb3VzZXVwXCIsbil9ZWxzZSBzZXRUaW1lb3V0KGQsNTApfX07Vy5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkPWZ1bmN0aW9uKGEpe2F8fHRoaXMucmVzZXQoKTt0aGlzLnRleHRhcmVhLmRpc2FibGVkPVwibm9jdXJzb3JcIj09YTt0aGlzLnRleHRhcmVhLnJlYWRPbmx5PSEhYX07Vy5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZT1cbmZ1bmN0aW9uKCl7fTtXLnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGU9ITE7KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYyxlLGYsZyl7YS5kZWZhdWx0c1tjXT1lO2YmJihkW2NdPWc/ZnVuY3Rpb24oaCxrLGwpe2whPUZiJiZmKGgsayxsKX06Zil9dmFyIGQ9YS5vcHRpb25IYW5kbGVyczthLmRlZmluZU9wdGlvbj1iO2EuSW5pdD1GYjtiKFwidmFsdWVcIixcIlwiLGZ1bmN0aW9uKGMsZSl7cmV0dXJuIGMuc2V0VmFsdWUoZSl9LCEwKTtiKFwibW9kZVwiLG51bGwsZnVuY3Rpb24oYyxlKXtjLmRvYy5tb2RlT3B0aW9uPWU7V2QoYyl9LCEwKTtiKFwiaW5kZW50VW5pdFwiLDIsV2QsITApO2IoXCJpbmRlbnRXaXRoVGFic1wiLCExKTtiKFwic21hcnRJbmRlbnRcIiwhMCk7YihcInRhYlNpemVcIiw0LGZ1bmN0aW9uKGMpeyRiKGMpO1NiKGMpO21hKGMpfSwhMCk7YihcImxpbmVTZXBhcmF0b3JcIixudWxsLGZ1bmN0aW9uKGMsZSl7aWYoYy5kb2MubGluZVNlcD1lKXt2YXIgZj1bXSxnPWMuZG9jLmZpcnN0O1xuYy5kb2MuaXRlcihmdW5jdGlvbihrKXtmb3IodmFyIGw9MDs7KXt2YXIgbT1rLnRleHQuaW5kZXhPZihlLGwpO2lmKC0xPT1tKWJyZWFrO2w9bStlLmxlbmd0aDtmLnB1c2godChnLG0pKX1nKyt9KTtmb3IodmFyIGg9Zi5sZW5ndGgtMTswPD1oO2gtLSlCYihjLmRvYyxlLGZbaF0sdChmW2hdLmxpbmUsZltoXS5jaCtlLmxlbmd0aCkpfX0pO2IoXCJzcGVjaWFsQ2hhcnNcIiwvW1xcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYi1cXHUyMDBjXFx1MjAwZVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdL2csZnVuY3Rpb24oYyxlLGYpe2Muc3RhdGUuc3BlY2lhbENoYXJzPW5ldyBSZWdFeHAoZS5zb3VyY2UrKGUudGVzdChcIlxcdFwiKT9cIlwiOlwifFxcdFwiKSxcImdcIik7ZiE9RmImJmMucmVmcmVzaCgpfSk7YihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIixMZyxmdW5jdGlvbihjKXtyZXR1cm4gYy5yZWZyZXNoKCl9LCEwKTtiKFwiZWxlY3RyaWNDaGFyc1wiLFxuITApO2IoXCJpbnB1dFN0eWxlXCIsWmI/XCJjb250ZW50ZWRpdGFibGVcIjpcInRleHRhcmVhXCIsZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcIik7fSwhMCk7YihcInNwZWxsY2hlY2tcIiwhMSxmdW5jdGlvbihjLGUpe3JldHVybiBjLmdldElucHV0RmllbGQoKS5zcGVsbGNoZWNrPWV9LCEwKTtiKFwiYXV0b2NvcnJlY3RcIiwhMSxmdW5jdGlvbihjLGUpe3JldHVybiBjLmdldElucHV0RmllbGQoKS5hdXRvY29ycmVjdD1lfSwhMCk7YihcImF1dG9jYXBpdGFsaXplXCIsITEsZnVuY3Rpb24oYyxlKXtyZXR1cm4gYy5nZXRJbnB1dEZpZWxkKCkuYXV0b2NhcGl0YWxpemU9ZX0sITApO2IoXCJydGxNb3ZlVmlzdWFsbHlcIiwhRmgpO2IoXCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmVcIiwhMCk7YihcInRoZW1lXCIsXCJkZWZhdWx0XCIsZnVuY3Rpb24oYyl7amcoYyk7WWIoYyl9LCEwKTtiKFwia2V5TWFwXCIsXCJkZWZhdWx0XCIsZnVuY3Rpb24oYyxcbmUsZil7ZT1XYyhlKTsoZj1mIT1GYiYmV2MoZikpJiZmLmRldGFjaCYmZi5kZXRhY2goYyxlKTtlLmF0dGFjaCYmZS5hdHRhY2goYyxmfHxudWxsKX0pO2IoXCJleHRyYUtleXNcIixudWxsKTtiKFwiY29uZmlndXJlTW91c2VcIixudWxsKTtiKFwibGluZVdyYXBwaW5nXCIsITEseWgsITApO2IoXCJndXR0ZXJzXCIsW10sZnVuY3Rpb24oYyxlKXtjLmRpc3BsYXkuZ3V0dGVyU3BlY3M9VWQoZSxjLm9wdGlvbnMubGluZU51bWJlcnMpO1liKGMpfSwhMCk7YihcImZpeGVkR3V0dGVyXCIsITAsZnVuY3Rpb24oYyxlKXtjLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0PWU/S2QoYy5kaXNwbGF5KStcInB4XCI6XCIwXCI7Yy5yZWZyZXNoKCl9LCEwKTtiKFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcIiwhMSxmdW5jdGlvbihjKXtyZXR1cm4gd2IoYyl9LCEwKTtiKFwic2Nyb2xsYmFyU3R5bGVcIixcIm5hdGl2ZVwiLGZ1bmN0aW9uKGMpe25mKGMpO3diKGMpO2MuZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjLmRvYy5zY3JvbGxUb3ApO1xuYy5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChjLmRvYy5zY3JvbGxMZWZ0KX0sITApO2IoXCJsaW5lTnVtYmVyc1wiLCExLGZ1bmN0aW9uKGMsZSl7Yy5kaXNwbGF5Lmd1dHRlclNwZWNzPVVkKGMub3B0aW9ucy5ndXR0ZXJzLGUpO1liKGMpfSwhMCk7YihcImZpcnN0TGluZU51bWJlclwiLDEsWWIsITApO2IoXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsZnVuY3Rpb24oYyl7cmV0dXJuIGN9LFliLCEwKTtiKFwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmdcIiwhMSxUYiwhMCk7YihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCEwKTtiKFwibGluZVdpc2VDb3B5Q3V0XCIsITApO2IoXCJwYXN0ZUxpbmVzUGVyU2VsZWN0aW9uXCIsITApO2IoXCJzZWxlY3Rpb25zTWF5VG91Y2hcIiwhMSk7YihcInJlYWRPbmx5XCIsITEsZnVuY3Rpb24oYyxlKXtcIm5vY3Vyc29yXCI9PWUmJih1YihjKSxjLmRpc3BsYXkuaW5wdXQuYmx1cigpKTtjLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKGUpfSk7YihcInNjcmVlblJlYWRlckxhYmVsXCIsXG5udWxsLGZ1bmN0aW9uKGMsZSl7Yy5kaXNwbGF5LmlucHV0LnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZChcIlwiPT09ZT9udWxsOmUpfSk7YihcImRpc2FibGVJbnB1dFwiLCExLGZ1bmN0aW9uKGMsZSl7ZXx8Yy5kaXNwbGF5LmlucHV0LnJlc2V0KCl9LCEwKTtiKFwiZHJhZ0Ryb3BcIiwhMCx4aCk7YihcImFsbG93RHJvcEZpbGVUeXBlc1wiLG51bGwpO2IoXCJjdXJzb3JCbGlua1JhdGVcIiw1MzApO2IoXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwwKTtiKFwiY3Vyc29ySGVpZ2h0XCIsMSxUYiwhMCk7YihcInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmVcIiwhMCxUYiwhMCk7YihcIndvcmtUaW1lXCIsMTAwKTtiKFwid29ya0RlbGF5XCIsMTAwKTtiKFwiZmxhdHRlblNwYW5zXCIsITAsJGIsITApO2IoXCJhZGRNb2RlQ2xhc3NcIiwhMSwkYiwhMCk7YihcInBvbGxJbnRlcnZhbFwiLDEwMCk7YihcInVuZG9EZXB0aFwiLDIwMCxmdW5jdGlvbihjLGUpe3JldHVybiBjLmRvYy5oaXN0b3J5LnVuZG9EZXB0aD1lfSk7YihcImhpc3RvcnlFdmVudERlbGF5XCIsXG4xMjUwKTtiKFwidmlld3BvcnRNYXJnaW5cIiwxMCxmdW5jdGlvbihjKXtyZXR1cm4gYy5yZWZyZXNoKCl9LCEwKTtiKFwibWF4SGlnaGxpZ2h0TGVuZ3RoXCIsMUU0LCRiLCEwKTtiKFwibW92ZUlucHV0V2l0aEN1cnNvclwiLCEwLGZ1bmN0aW9uKGMsZSl7ZXx8Yy5kaXNwbGF5LmlucHV0LnJlc2V0UG9zaXRpb24oKX0pO2IoXCJ0YWJpbmRleFwiLG51bGwsZnVuY3Rpb24oYyxlKXtyZXR1cm4gYy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXg9ZXx8XCJcIn0pO2IoXCJhdXRvZm9jdXNcIixudWxsKTtiKFwiZGlyZWN0aW9uXCIsXCJsdHJcIixmdW5jdGlvbihjLGUpe3JldHVybiBjLmRvYy5zZXREaXJlY3Rpb24oZSl9LCEwKTtiKFwicGhyYXNlc1wiLG51bGwpfSkoVik7KGZ1bmN0aW9uKGEpe3ZhciBiPWEub3B0aW9uSGFuZGxlcnMsZD1hLmhlbHBlcnM9e307YS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmEsZm9jdXM6ZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTt0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sXG5zZXRPcHRpb246ZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLm9wdGlvbnMsZz1mW2NdO2lmKGZbY10hPWV8fFwibW9kZVwiPT1jKWZbY109ZSxiLmhhc093blByb3BlcnR5KGMpJiZhYSh0aGlzLGJbY10pKHRoaXMsZSxnKSxYKHRoaXMsXCJvcHRpb25DaGFuZ2VcIix0aGlzLGMpfSxnZXRPcHRpb246ZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMub3B0aW9uc1tjXX0sZ2V0RG9jOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9jfSxhZGRLZXlNYXA6ZnVuY3Rpb24oYyxlKXt0aGlzLnN0YXRlLmtleU1hcHNbZT9cInB1c2hcIjpcInVuc2hpZnRcIl0oV2MoYykpfSxyZW1vdmVLZXlNYXA6ZnVuY3Rpb24oYyl7Zm9yKHZhciBlPXRoaXMuc3RhdGUua2V5TWFwcyxmPTA7ZjxlLmxlbmd0aDsrK2YpaWYoZVtmXT09Y3x8ZVtmXS5uYW1lPT1jKXJldHVybiBlLnNwbGljZShmLDEpLCEwfSxhZGRPdmVybGF5OmlhKGZ1bmN0aW9uKGMsZSl7dmFyIGY9Yy50b2tlbj9jOmEuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsYyk7aWYoZi5zdGFydFN0YXRlKXRocm93IEVycm9yKFwiT3ZlcmxheXMgbWF5IG5vdCBiZSBzdGF0ZWZ1bC5cIik7XG53Zyh0aGlzLnN0YXRlLm92ZXJsYXlzLHttb2RlOmYsbW9kZVNwZWM6YyxvcGFxdWU6ZSYmZS5vcGFxdWUscHJpb3JpdHk6ZSYmZS5wcmlvcml0eXx8MH0sZnVuY3Rpb24oZyl7cmV0dXJuIGcucHJpb3JpdHl9KTt0aGlzLnN0YXRlLm1vZGVHZW4rKzttYSh0aGlzKX0pLHJlbW92ZU92ZXJsYXk6aWEoZnVuY3Rpb24oYyl7Zm9yKHZhciBlPXRoaXMuc3RhdGUub3ZlcmxheXMsZj0wO2Y8ZS5sZW5ndGg7KytmKXt2YXIgZz1lW2ZdLm1vZGVTcGVjO2lmKGc9PWN8fFwic3RyaW5nXCI9PXR5cGVvZiBjJiZnLm5hbWU9PWMpe2Uuc3BsaWNlKGYsMSk7dGhpcy5zdGF0ZS5tb2RlR2VuKys7bWEodGhpcyk7YnJlYWt9fX0pLGluZGVudExpbmU6aWEoZnVuY3Rpb24oYyxlLGYpe1wic3RyaW5nXCIhPXR5cGVvZiBlJiZcIm51bWJlclwiIT10eXBlb2YgZSYmKGU9bnVsbD09ZT90aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQ/XCJzbWFydFwiOlwicHJldlwiOmU/XCJhZGRcIjpcInN1YnRyYWN0XCIpO0xiKHRoaXMuZG9jLGMpJiZcbmxjKHRoaXMsYyxlLGYpfSksaW5kZW50U2VsZWN0aW9uOmlhKGZ1bmN0aW9uKGMpe2Zvcih2YXIgZT10aGlzLmRvYy5zZWwucmFuZ2VzLGY9LTEsZz0wO2c8ZS5sZW5ndGg7ZysrKXt2YXIgaD1lW2ddO2lmKGguZW1wdHkoKSloLmhlYWQubGluZT5mJiYobGModGhpcyxoLmhlYWQubGluZSxjLCEwKSxmPWguaGVhZC5saW5lLGc9PXRoaXMuZG9jLnNlbC5wcmltSW5kZXgmJnZiKHRoaXMpKTtlbHNle3ZhciBrPWguZnJvbSgpO2g9aC50bygpO3ZhciBsPU1hdGgubWF4KGYsay5saW5lKTtmPU1hdGgubWluKHRoaXMubGFzdExpbmUoKSxoLmxpbmUtKGguY2g/MDoxKSkrMTtmb3IoaD1sO2g8ZjsrK2gpbGModGhpcyxoLGMpO2g9dGhpcy5kb2Muc2VsLnJhbmdlczswPT1rLmNoJiZlLmxlbmd0aD09aC5sZW5ndGgmJjA8aFtnXS5mcm9tKCkuY2gmJiRkKHRoaXMuZG9jLGcsbmV3IEooayxoW2ddLnRvKCkpLElhKX19fSksZ2V0VG9rZW5BdDpmdW5jdGlvbihjLGUpe3JldHVybiB6ZSh0aGlzLFxuYyxlKX0sZ2V0TGluZVRva2VuczpmdW5jdGlvbihjLGUpe3JldHVybiB6ZSh0aGlzLHQoYyksZSwhMCl9LGdldFRva2VuVHlwZUF0OmZ1bmN0aW9uKGMpe2M9Qyh0aGlzLmRvYyxjKTt2YXIgZT14ZSh0aGlzLHcodGhpcy5kb2MsYy5saW5lKSksZj0wLGc9KGUubGVuZ3RoLTEpLzI7Yz1jLmNoO2lmKDA9PWMpZT1lWzJdO2Vsc2UgZm9yKDs7KXt2YXIgaD1mK2c+PjE7aWYoKGg/ZVsyKmgtMV06MCk+PWMpZz1oO2Vsc2UgaWYoZVsyKmgrMV08YylmPWgrMTtlbHNle2U9ZVsyKmgrMl07YnJlYWt9fWY9ZT9lLmluZGV4T2YoXCJvdmVybGF5IFwiKTotMTtyZXR1cm4gMD5mP2U6MD09Zj9udWxsOmUuc2xpY2UoMCxmLTEpfSxnZXRNb2RlQXQ6ZnVuY3Rpb24oYyl7dmFyIGU9dGhpcy5kb2MubW9kZTtyZXR1cm4gZS5pbm5lck1vZGU/YS5pbm5lck1vZGUoZSx0aGlzLmdldFRva2VuQXQoYykuc3RhdGUpLm1vZGU6ZX0sZ2V0SGVscGVyOmZ1bmN0aW9uKGMsZSl7cmV0dXJuIHRoaXMuZ2V0SGVscGVycyhjLFxuZSlbMF19LGdldEhlbHBlcnM6ZnVuY3Rpb24oYyxlKXt2YXIgZj1bXTtpZighZC5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gZjt2YXIgZz1kW2VdO2M9dGhpcy5nZXRNb2RlQXQoYyk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGNbZV0pZ1tjW2VdXSYmZi5wdXNoKGdbY1tlXV0pO2Vsc2UgaWYoY1tlXSlmb3IodmFyIGg9MDtoPGNbZV0ubGVuZ3RoO2grKyl7dmFyIGs9Z1tjW2VdW2hdXTtrJiZmLnB1c2goayl9ZWxzZSBjLmhlbHBlclR5cGUmJmdbYy5oZWxwZXJUeXBlXT9mLnB1c2goZ1tjLmhlbHBlclR5cGVdKTpnW2MubmFtZV0mJmYucHVzaChnW2MubmFtZV0pO2ZvcihlPTA7ZTxnLl9nbG9iYWwubGVuZ3RoO2UrKyloPWcuX2dsb2JhbFtlXSxoLnByZWQoYyx0aGlzKSYmLTE9PWVhKGYsaC52YWwpJiZmLnB1c2goaC52YWwpO3JldHVybiBmfSxnZXRTdGF0ZUFmdGVyOmZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpcy5kb2M7Yz1NYXRoLm1heChmLmZpcnN0LE1hdGgubWluKG51bGw9PWM/Zi5maXJzdCtcbmYuc2l6ZS0xOmMsZi5maXJzdCtmLnNpemUtMSkpO3JldHVybiBNYih0aGlzLGMrMSxlKS5zdGF0ZX0sY3Vyc29yQ29vcmRzOmZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpcy5kb2Muc2VsLnByaW1hcnkoKTtjPW51bGw9PWM/Zi5oZWFkOlwib2JqZWN0XCI9PXR5cGVvZiBjP0ModGhpcy5kb2MsYyk6Yz9mLmZyb20oKTpmLnRvKCk7cmV0dXJuIEFhKHRoaXMsYyxlfHxcInBhZ2VcIil9LGNoYXJDb29yZHM6ZnVuY3Rpb24oYyxlKXtyZXR1cm4gR2QodGhpcyxDKHRoaXMuZG9jLGMpLGV8fFwicGFnZVwiKX0sY29vcmRzQ2hhcjpmdW5jdGlvbihjLGUpe2M9WWUodGhpcyxjLGV8fFwicGFnZVwiKTtyZXR1cm4gSWQodGhpcyxjLmxlZnQsYy50b3ApfSxsaW5lQXRIZWlnaHQ6ZnVuY3Rpb24oYyxlKXtjPVllKHRoaXMse3RvcDpjLGxlZnQ6MH0sZXx8XCJwYWdlXCIpLnRvcDtyZXR1cm4gJGEodGhpcy5kb2MsYyt0aGlzLmRpc3BsYXkudmlld09mZnNldCl9LGhlaWdodEF0TGluZTpmdW5jdGlvbihjLGUsZil7dmFyIGc9XG4hMTtpZihcIm51bWJlclwiPT10eXBlb2YgYyl7dmFyIGg9dGhpcy5kb2MuZmlyc3QrdGhpcy5kb2Muc2l6ZS0xO2M8dGhpcy5kb2MuZmlyc3Q/Yz10aGlzLmRvYy5maXJzdDpjPmgmJihjPWgsZz0hMCk7Yz13KHRoaXMuZG9jLGMpfXJldHVybiBIYyh0aGlzLGMse3RvcDowLGxlZnQ6MH0sZXx8XCJwYWdlXCIsZnx8ZykudG9wKyhnP3RoaXMuZG9jLmhlaWdodC1HYShjKTowKX0sZGVmYXVsdFRleHRIZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGIodGhpcy5kaXNwbGF5KX0sZGVmYXVsdENoYXJXaWR0aDpmdW5jdGlvbigpe3JldHVybiBzYih0aGlzLmRpc3BsYXkpfSxnZXRWaWV3cG9ydDpmdW5jdGlvbigpe3JldHVybntmcm9tOnRoaXMuZGlzcGxheS52aWV3RnJvbSx0bzp0aGlzLmRpc3BsYXkudmlld1RvfX0sYWRkV2lkZ2V0OmZ1bmN0aW9uKGMsZSxmLGcsaCl7dmFyIGs9dGhpcy5kaXNwbGF5O2M9QWEodGhpcyxDKHRoaXMuZG9jLGMpKTt2YXIgbD1jLmJvdHRvbSxtPWMubGVmdDtlLnN0eWxlLnBvc2l0aW9uPVxuXCJhYnNvbHV0ZVwiO2Uuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLFwidHJ1ZVwiKTt0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShlKTtrLnNpemVyLmFwcGVuZENoaWxkKGUpO2lmKFwib3ZlclwiPT1nKWw9Yy50b3A7ZWxzZSBpZihcImFib3ZlXCI9PWd8fFwibmVhclwiPT1nKXt2YXIgcT1NYXRoLm1heChrLndyYXBwZXIuY2xpZW50SGVpZ2h0LHRoaXMuZG9jLmhlaWdodCksbj1NYXRoLm1heChrLnNpemVyLmNsaWVudFdpZHRoLGsubGluZVNwYWNlLmNsaWVudFdpZHRoKTsoXCJhYm92ZVwiPT1nfHxjLmJvdHRvbStlLm9mZnNldEhlaWdodD5xKSYmYy50b3A+ZS5vZmZzZXRIZWlnaHQ/bD1jLnRvcC1lLm9mZnNldEhlaWdodDpjLmJvdHRvbStlLm9mZnNldEhlaWdodDw9cSYmKGw9Yy5ib3R0b20pO20rZS5vZmZzZXRXaWR0aD5uJiYobT1uLWUub2Zmc2V0V2lkdGgpfWUuc3R5bGUudG9wPWwrXCJweFwiO2Uuc3R5bGUubGVmdD1lLnN0eWxlLnJpZ2h0PVwiXCI7XCJyaWdodFwiPT1oPyhtPVxuay5zaXplci5jbGllbnRXaWR0aC1lLm9mZnNldFdpZHRoLGUuc3R5bGUucmlnaHQ9XCIwcHhcIik6KFwibGVmdFwiPT1oP209MDpcIm1pZGRsZVwiPT1oJiYobT0oay5zaXplci5jbGllbnRXaWR0aC1lLm9mZnNldFdpZHRoKS8yKSxlLnN0eWxlLmxlZnQ9bStcInB4XCIpO2YmJihjPVBkKHRoaXMse2xlZnQ6bSx0b3A6bCxyaWdodDptK2Uub2Zmc2V0V2lkdGgsYm90dG9tOmwrZS5vZmZzZXRIZWlnaHR9KSxudWxsIT1jLnNjcm9sbFRvcCYmVmIodGhpcyxjLnNjcm9sbFRvcCksbnVsbCE9Yy5zY3JvbGxMZWZ0JiZpYih0aGlzLGMuc2Nyb2xsTGVmdCkpfSx0cmlnZ2VyT25LZXlEb3duOmlhKGRnKSx0cmlnZ2VyT25LZXlQcmVzczppYShmZyksdHJpZ2dlck9uS2V5VXA6ZWcsdHJpZ2dlck9uTW91c2VEb3duOmlhKGdnKSxleGVjQ29tbWFuZDpmdW5jdGlvbihjKXtpZihoYy5oYXNPd25Qcm9wZXJ0eShjKSlyZXR1cm4gaGNbY10uY2FsbChudWxsLHRoaXMpfSx0cmlnZ2VyRWxlY3RyaWM6aWEoZnVuY3Rpb24oYyl7bWcodGhpcyxcbmMpfSksZmluZFBvc0g6ZnVuY3Rpb24oYyxlLGYsZyl7dmFyIGg9MTswPmUmJihoPS0xLGU9LWUpO2M9Qyh0aGlzLmRvYyxjKTtmb3IodmFyIGs9MDtrPGUmJihjPWxlKHRoaXMuZG9jLGMsaCxmLGcpLCFjLmhpdFNpZGUpOysrayk7cmV0dXJuIGN9LG1vdmVIOmlhKGZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpczt0aGlzLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihnKXtyZXR1cm4gZi5kaXNwbGF5LnNoaWZ0fHxmLmRvYy5leHRlbmR8fGcuZW1wdHkoKT9sZShmLmRvYyxnLmhlYWQsYyxlLGYub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpOjA+Yz9nLmZyb20oKTpnLnRvKCl9LHBjKX0pLGRlbGV0ZUg6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLmRvYzt0aGlzLmRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKT9mLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiK2RlbGV0ZVwiKTpFYih0aGlzLGZ1bmN0aW9uKGcpe3ZhciBoPWxlKGYsZy5oZWFkLGMsZSwhMSk7cmV0dXJuIDA+Yz9cbntmcm9tOmgsdG86Zy5oZWFkfTp7ZnJvbTpnLmhlYWQsdG86aH19KX0pLGZpbmRQb3NWOmZ1bmN0aW9uKGMsZSxmLGcpe3ZhciBoPTE7MD5lJiYoaD0tMSxlPS1lKTt2YXIgaz1DKHRoaXMuZG9jLGMpO2ZvcihjPTA7YzxlJiYoaz1BYSh0aGlzLGssXCJkaXZcIiksbnVsbD09Zz9nPWsubGVmdDprLmxlZnQ9ZyxrPXJnKHRoaXMsayxoLGYpLCFrLmhpdFNpZGUpOysrYyk7cmV0dXJuIGt9LG1vdmVWOmlhKGZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpcyxnPXRoaXMuZG9jLGg9W10saz0hdGhpcy5kaXNwbGF5LnNoaWZ0JiYhZy5leHRlbmQmJmcuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7Zy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24obSl7aWYoaylyZXR1cm4gMD5jP20uZnJvbSgpOm0udG8oKTt2YXIgcT1BYShmLG0uaGVhZCxcImRpdlwiKTtudWxsIT1tLmdvYWxDb2x1bW4mJihxLmxlZnQ9bS5nb2FsQ29sdW1uKTtoLnB1c2gocS5sZWZ0KTt2YXIgbj1yZyhmLHEsYyxlKTtcInBhZ2VcIj09ZSYmXG5tPT1nLnNlbC5wcmltYXJ5KCkmJk1jKGYsR2QoZixuLFwiZGl2XCIpLnRvcC1xLnRvcCk7cmV0dXJuIG59LHBjKTtpZihoLmxlbmd0aClmb3IodmFyIGw9MDtsPGcuc2VsLnJhbmdlcy5sZW5ndGg7bCsrKWcuc2VsLnJhbmdlc1tsXS5nb2FsQ29sdW1uPWhbbF19KSxmaW5kV29yZEF0OmZ1bmN0aW9uKGMpe3ZhciBlPXcodGhpcy5kb2MsYy5saW5lKS50ZXh0LGY9Yy5jaCxnPWMuY2g7aWYoZSl7dmFyIGg9dGhpcy5nZXRIZWxwZXIoYyxcIndvcmRDaGFyc1wiKTtcImJlZm9yZVwiIT1jLnN0aWNreSYmZyE9ZS5sZW5ndGh8fCFmPysrZzotLWY7dmFyIGs9ZS5jaGFyQXQoZik7Zm9yKGs9d2MoayxoKT9mdW5jdGlvbihsKXtyZXR1cm4gd2MobCxoKX06L1xccy8udGVzdChrKT9mdW5jdGlvbihsKXtyZXR1cm4vXFxzLy50ZXN0KGwpfTpmdW5jdGlvbihsKXtyZXR1cm4hL1xccy8udGVzdChsKSYmIXdjKGwpfTswPGYmJmsoZS5jaGFyQXQoZi0xKSk7KS0tZjtmb3IoO2c8ZS5sZW5ndGgmJmsoZS5jaGFyQXQoZykpOykrK2d9cmV0dXJuIG5ldyBKKHQoYy5saW5lLFxuZiksdChjLmxpbmUsZykpfSx0b2dnbGVPdmVyd3JpdGU6ZnVuY3Rpb24oYyl7aWYobnVsbD09Y3x8YyE9dGhpcy5zdGF0ZS5vdmVyd3JpdGUpKHRoaXMuc3RhdGUub3ZlcndyaXRlPSF0aGlzLnN0YXRlLm92ZXJ3cml0ZSk/V2EodGhpcy5kaXNwbGF5LmN1cnNvckRpdixcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOmhiKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKSxYKHRoaXMsXCJvdmVyd3JpdGVUb2dnbGVcIix0aGlzLHRoaXMuc3RhdGUub3ZlcndyaXRlKX0saGFzRm9jdXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCk9PXZhKCl9LGlzUmVhZE9ubHk6ZnVuY3Rpb24oKXtyZXR1cm4hKCF0aGlzLm9wdGlvbnMucmVhZE9ubHkmJiF0aGlzLmRvYy5jYW50RWRpdCl9LHNjcm9sbFRvOmlhKGZ1bmN0aW9uKGMsZSl7VWIodGhpcyxjLGUpfSksZ2V0U2Nyb2xsSW5mbzpmdW5jdGlvbigpe3ZhciBjPXRoaXMuZGlzcGxheS5zY3JvbGxlcjtcbnJldHVybntsZWZ0OmMuc2Nyb2xsTGVmdCx0b3A6Yy5zY3JvbGxUb3AsaGVpZ2h0OmMuc2Nyb2xsSGVpZ2h0LUhhKHRoaXMpLXRoaXMuZGlzcGxheS5iYXJIZWlnaHQsd2lkdGg6Yy5zY3JvbGxXaWR0aC1IYSh0aGlzKS10aGlzLmRpc3BsYXkuYmFyV2lkdGgsY2xpZW50SGVpZ2h0OkJkKHRoaXMpLGNsaWVudFdpZHRoOmFiKHRoaXMpfX0sc2Nyb2xsSW50b1ZpZXc6aWEoZnVuY3Rpb24oYyxlKXtudWxsPT1jPyhjPXtmcm9tOnRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCx0bzpudWxsfSxudWxsPT1lJiYoZT10aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luKSk6XCJudW1iZXJcIj09dHlwZW9mIGM/Yz17ZnJvbTp0KGMsMCksdG86bnVsbH06bnVsbD09Yy5mcm9tJiYoYz17ZnJvbTpjLHRvOm51bGx9KTtjLnRvfHwoYy50bz1jLmZyb20pO2MubWFyZ2luPWV8fDA7bnVsbCE9Yy5mcm9tLmxpbmU/KE5jKHRoaXMpLHRoaXMuY3VyT3Auc2Nyb2xsVG9Qb3M9Yyk6amYodGhpcyxjLmZyb20sXG5jLnRvLGMubWFyZ2luKX0pLHNldFNpemU6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLGc9ZnVuY3Rpb24oayl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGt8fC9eXFxkKyQvLnRlc3QoU3RyaW5nKGspKT9rK1wicHhcIjprfTtudWxsIT1jJiYodGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGg9ZyhjKSk7bnVsbCE9ZSYmKHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodD1nKGUpKTt0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nJiZWZSh0aGlzKTt2YXIgaD10aGlzLmRpc3BsYXkudmlld0Zyb207dGhpcy5kb2MuaXRlcihoLHRoaXMuZGlzcGxheS52aWV3VG8sZnVuY3Rpb24oayl7aWYoay53aWRnZXRzKWZvcih2YXIgbD0wO2w8ay53aWRnZXRzLmxlbmd0aDtsKyspaWYoay53aWRnZXRzW2xdLm5vSFNjcm9sbCl7UWEoZixoLFwid2lkZ2V0XCIpO2JyZWFrfSsraH0pO3RoaXMuY3VyT3AuZm9yY2VVcGRhdGU9ITA7WCh0aGlzLFwicmVmcmVzaFwiLHRoaXMpfSksb3BlcmF0aW9uOmZ1bmN0aW9uKGMpe3JldHVybiBwYSh0aGlzLFxuYyl9LHN0YXJ0T3BlcmF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGpiKHRoaXMpfSxlbmRPcGVyYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4ga2IodGhpcyl9LHJlZnJlc2g6aWEoZnVuY3Rpb24oKXt2YXIgYz10aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDttYSh0aGlzKTt0aGlzLmN1ck9wLmZvcmNlVXBkYXRlPSEwO1NiKHRoaXMpO1ViKHRoaXMsdGhpcy5kb2Muc2Nyb2xsTGVmdCx0aGlzLmRvYy5zY3JvbGxUb3ApO1RkKHRoaXMuZGlzcGxheSk7KG51bGw9PWN8fC41PE1hdGguYWJzKGMtdGIodGhpcy5kaXNwbGF5KSl8fHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpJiZMZCh0aGlzKTtYKHRoaXMsXCJyZWZyZXNoXCIsdGhpcyl9KSxzd2FwRG9jOmlhKGZ1bmN0aW9uKGMpe3ZhciBlPXRoaXMuZG9jO2UuY209bnVsbDt0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQmJnRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCgpO3hmKHRoaXMsYyk7U2IodGhpcyk7dGhpcy5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG5VYih0aGlzLGMuc2Nyb2xsTGVmdCxjLnNjcm9sbFRvcCk7dGhpcy5jdXJPcC5mb3JjZVNjcm9sbD0hMDtjYSh0aGlzLFwic3dhcERvY1wiLHRoaXMsZSk7cmV0dXJuIGV9KSxwaHJhc2U6ZnVuY3Rpb24oYyl7dmFyIGU9dGhpcy5vcHRpb25zLnBocmFzZXM7cmV0dXJuIGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGMpP2VbY106Y30sZ2V0SW5wdXRGaWVsZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKX0sZ2V0V3JhcHBlckVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LndyYXBwZXJ9LGdldFNjcm9sbGVyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXJ9LGdldEd1dHRlckVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnN9fTtuYihhKTthLnJlZ2lzdGVySGVscGVyPWZ1bmN0aW9uKGMsZSxmKXtkLmhhc093blByb3BlcnR5KGMpfHxcbihkW2NdPWFbY109e19nbG9iYWw6W119KTtkW2NdW2VdPWZ9O2EucmVnaXN0ZXJHbG9iYWxIZWxwZXI9ZnVuY3Rpb24oYyxlLGYsZyl7YS5yZWdpc3RlckhlbHBlcihjLGUsZyk7ZFtjXS5fZ2xvYmFsLnB1c2goe3ByZWQ6Zix2YWw6Z30pfX0pKFYpO3ZhciBJaD1cIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvciBjb25zdHJ1Y3RvclwiLnNwbGl0KFwiIFwiKSx0Yztmb3IodGMgaW4gb2EucHJvdG90eXBlKW9hLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSh0YykmJjA+ZWEoSWgsdGMpJiYoVi5wcm90b3R5cGVbdGNdPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KHRoaXMuZG9jLGFyZ3VtZW50cyl9fShvYS5wcm90b3R5cGVbdGNdKSk7bmIob2EpO1YuaW5wdXRTdHlsZXM9e3RleHRhcmVhOlcsY29udGVudGVkaXRhYmxlOlB9O1YuZGVmaW5lTW9kZT1mdW5jdGlvbihhKXtWLmRlZmF1bHRzLm1vZGV8fFwibnVsbFwiPT1hfHwoVi5kZWZhdWx0cy5tb2RlPVxuYSk7Q2cuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtWLmRlZmluZU1JTUU9ZnVuY3Rpb24oYSxiKXtvYlthXT1ifTtWLmRlZmluZU1vZGUoXCJudWxsXCIsZnVuY3Rpb24oKXtyZXR1cm57dG9rZW46ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2tpcFRvRW5kKCl9fX0pO1YuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIixcIm51bGxcIik7Vi5kZWZpbmVFeHRlbnNpb249ZnVuY3Rpb24oYSxiKXtWLnByb3RvdHlwZVthXT1ifTtWLmRlZmluZURvY0V4dGVuc2lvbj1mdW5jdGlvbihhLGIpe29hLnByb3RvdHlwZVthXT1ifTtWLmZyb21UZXh0QXJlYT1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGQoKXthLnZhbHVlPWguZ2V0VmFsdWUoKX1iPWI/WGEoYik6e307Yi52YWx1ZT1hLnZhbHVlOyFiLnRhYmluZGV4JiZhLnRhYkluZGV4JiYoYi50YWJpbmRleD1hLnRhYkluZGV4KTshYi5wbGFjZWhvbGRlciYmYS5wbGFjZWhvbGRlciYmKGIucGxhY2Vob2xkZXI9YS5wbGFjZWhvbGRlcik7aWYobnVsbD09Yi5hdXRvZm9jdXMpe3ZhciBjPVxudmEoKTtiLmF1dG9mb2N1cz1jPT1hfHxudWxsIT1hLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSYmYz09ZG9jdW1lbnQuYm9keX1pZihhLmZvcm0mJih6KGEuZm9ybSxcInN1Ym1pdFwiLGQpLCFiLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpKXt2YXIgZT1hLmZvcm07dmFyIGY9ZS5zdWJtaXQ7dHJ5e3ZhciBnPWUuc3VibWl0PWZ1bmN0aW9uKCl7ZCgpO2Uuc3VibWl0PWY7ZS5zdWJtaXQoKTtlLnN1Ym1pdD1nfX1jYXRjaChrKXt9fWIuZmluaXNoSW5pdD1mdW5jdGlvbihrKXtrLnNhdmU9ZDtrLmdldFRleHRBcmVhPWZ1bmN0aW9uKCl7cmV0dXJuIGF9O2sudG9UZXh0QXJlYT1mdW5jdGlvbigpe2sudG9UZXh0QXJlYT1pc05hTjtkKCk7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGsuZ2V0V3JhcHBlckVsZW1lbnQoKSk7YS5zdHlsZS5kaXNwbGF5PVwiXCI7YS5mb3JtJiYocmEoYS5mb3JtLFwic3VibWl0XCIsZCksYi5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBhLmZvcm0uc3VibWl0fHxcbihhLmZvcm0uc3VibWl0PWYpKX19O2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt2YXIgaD1WKGZ1bmN0aW9uKGspe3JldHVybiBhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGssYS5uZXh0U2libGluZyl9LGIpO3JldHVybiBofTsoZnVuY3Rpb24oYSl7YS5vZmY9cmE7YS5vbj16O2Eud2hlZWxFdmVudFBpeGVscz1ZZzthLkRvYz1vYTthLnNwbGl0TGluZXM9a2U7YS5jb3VudENvbHVtbj13YTthLmZpbmRDb2x1bW49ZWQ7YS5pc1dvcmRDaGFyPWdkO2EuUGFzcz1ZYzthLnNpZ25hbD1YO2EuTGluZT14YjthLmNoYW5nZUVuZD1SYTthLnNjcm9sbGJhck1vZGVsPW9mO2EuUG9zPXQ7YS5jbXBQb3M9QjthLm1vZGVzPWtkO2EubWltZU1vZGVzPW9iO2EucmVzb2x2ZU1vZGU9eWM7YS5nZXRNb2RlPWxkO2EubW9kZUV4dGVuc2lvbnM9cGI7YS5leHRlbmRNb2RlPURnO2EuY29weVN0YXRlPVlhO2Euc3RhcnRTdGF0ZT10ZTthLmlubmVyTW9kZT1tZDthLmNvbW1hbmRzPWhjO2Eua2V5TWFwPWdjO1xuYS5rZXlOYW1lPVpmO2EuaXNNb2RpZmllcktleT1XZjthLmxvb2t1cEtleT1EYjthLm5vcm1hbGl6ZUtleU1hcD1qaDthLlN0cmluZ1N0cmVhbT1ZO2EuU2hhcmVkVGV4dE1hcmtlcj1mYzthLlRleHRNYXJrZXI9VGE7YS5MaW5lV2lkZ2V0PWVjO2EuZV9wcmV2ZW50RGVmYXVsdD1sYTthLmVfc3RvcFByb3BhZ2F0aW9uPXJlO2EuZV9zdG9wPUtiO2EuYWRkQ2xhc3M9V2E7YS5jb250YWlucz1rYTthLnJtQ2xhc3M9aGI7YS5rZXlOYW1lcz1VYX0pKFYpO1YudmVyc2lvbj1cIjUuNTguMVwiO3JldHVybiBWfSk7XG4iLCIvKiFcbiAqIGNvbGxlY3Rpb24tdmlzaXQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2NvbGxlY3Rpb24tdmlzaXQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2aXNpdCA9IHJlcXVpcmUoJ29iamVjdC12aXNpdCcpO1xudmFyIG1hcFZpc2l0ID0gcmVxdWlyZSgnbWFwLXZpc2l0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbWV0aG9kLCB2YWwpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgKG1ldGhvZCBpbiBjb2xsZWN0aW9uKSkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJlc3VsdCA9IGNvbGxlY3Rpb25bbWV0aG9kXS5hcHBseShjb2xsZWN0aW9uLCBhcmdzKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXN1bHQgPSBtYXBWaXNpdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHZpc2l0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXHJcbiAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxyXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgfVxyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiT19SRE9OTFlcIjogMCxcbiAgXCJPX1dST05MWVwiOiAxLFxuICBcIk9fUkRXUlwiOiAyLFxuICBcIlNfSUZNVFwiOiA2MTQ0MCxcbiAgXCJTX0lGUkVHXCI6IDMyNzY4LFxuICBcIlNfSUZESVJcIjogMTYzODQsXG4gIFwiU19JRkNIUlwiOiA4MTkyLFxuICBcIlNfSUZCTEtcIjogMjQ1NzYsXG4gIFwiU19JRklGT1wiOiA0MDk2LFxuICBcIlNfSUZMTktcIjogNDA5NjAsXG4gIFwiU19JRlNPQ0tcIjogNDkxNTIsXG4gIFwiT19DUkVBVFwiOiA1MTIsXG4gIFwiT19FWENMXCI6IDIwNDgsXG4gIFwiT19OT0NUVFlcIjogMTMxMDcyLFxuICBcIk9fVFJVTkNcIjogMTAyNCxcbiAgXCJPX0FQUEVORFwiOiA4LFxuICBcIk9fRElSRUNUT1JZXCI6IDEwNDg1NzYsXG4gIFwiT19OT0ZPTExPV1wiOiAyNTYsXG4gIFwiT19TWU5DXCI6IDEyOCxcbiAgXCJPX1NZTUxJTktcIjogMjA5NzE1MixcbiAgXCJPX05PTkJMT0NLXCI6IDQsXG4gIFwiU19JUldYVVwiOiA0NDgsXG4gIFwiU19JUlVTUlwiOiAyNTYsXG4gIFwiU19JV1VTUlwiOiAxMjgsXG4gIFwiU19JWFVTUlwiOiA2NCxcbiAgXCJTX0lSV1hHXCI6IDU2LFxuICBcIlNfSVJHUlBcIjogMzIsXG4gIFwiU19JV0dSUFwiOiAxNixcbiAgXCJTX0lYR1JQXCI6IDgsXG4gIFwiU19JUldYT1wiOiA3LFxuICBcIlNfSVJPVEhcIjogNCxcbiAgXCJTX0lXT1RIXCI6IDIsXG4gIFwiU19JWE9USFwiOiAxLFxuICBcIkUyQklHXCI6IDcsXG4gIFwiRUFDQ0VTXCI6IDEzLFxuICBcIkVBRERSSU5VU0VcIjogNDgsXG4gIFwiRUFERFJOT1RBVkFJTFwiOiA0OSxcbiAgXCJFQUZOT1NVUFBPUlRcIjogNDcsXG4gIFwiRUFHQUlOXCI6IDM1LFxuICBcIkVBTFJFQURZXCI6IDM3LFxuICBcIkVCQURGXCI6IDksXG4gIFwiRUJBRE1TR1wiOiA5NCxcbiAgXCJFQlVTWVwiOiAxNixcbiAgXCJFQ0FOQ0VMRURcIjogODksXG4gIFwiRUNISUxEXCI6IDEwLFxuICBcIkVDT05OQUJPUlRFRFwiOiA1MyxcbiAgXCJFQ09OTlJFRlVTRURcIjogNjEsXG4gIFwiRUNPTk5SRVNFVFwiOiA1NCxcbiAgXCJFREVBRExLXCI6IDExLFxuICBcIkVERVNUQUREUlJFUVwiOiAzOSxcbiAgXCJFRE9NXCI6IDMzLFxuICBcIkVEUVVPVFwiOiA2OSxcbiAgXCJFRVhJU1RcIjogMTcsXG4gIFwiRUZBVUxUXCI6IDE0LFxuICBcIkVGQklHXCI6IDI3LFxuICBcIkVIT1NUVU5SRUFDSFwiOiA2NSxcbiAgXCJFSURSTVwiOiA5MCxcbiAgXCJFSUxTRVFcIjogOTIsXG4gIFwiRUlOUFJPR1JFU1NcIjogMzYsXG4gIFwiRUlOVFJcIjogNCxcbiAgXCJFSU5WQUxcIjogMjIsXG4gIFwiRUlPXCI6IDUsXG4gIFwiRUlTQ09OTlwiOiA1NixcbiAgXCJFSVNESVJcIjogMjEsXG4gIFwiRUxPT1BcIjogNjIsXG4gIFwiRU1GSUxFXCI6IDI0LFxuICBcIkVNTElOS1wiOiAzMSxcbiAgXCJFTVNHU0laRVwiOiA0MCxcbiAgXCJFTVVMVElIT1BcIjogOTUsXG4gIFwiRU5BTUVUT09MT05HXCI6IDYzLFxuICBcIkVORVRET1dOXCI6IDUwLFxuICBcIkVORVRSRVNFVFwiOiA1MixcbiAgXCJFTkVUVU5SRUFDSFwiOiA1MSxcbiAgXCJFTkZJTEVcIjogMjMsXG4gIFwiRU5PQlVGU1wiOiA1NSxcbiAgXCJFTk9EQVRBXCI6IDk2LFxuICBcIkVOT0RFVlwiOiAxOSxcbiAgXCJFTk9FTlRcIjogMixcbiAgXCJFTk9FWEVDXCI6IDgsXG4gIFwiRU5PTENLXCI6IDc3LFxuICBcIkVOT0xJTktcIjogOTcsXG4gIFwiRU5PTUVNXCI6IDEyLFxuICBcIkVOT01TR1wiOiA5MSxcbiAgXCJFTk9QUk9UT09QVFwiOiA0MixcbiAgXCJFTk9TUENcIjogMjgsXG4gIFwiRU5PU1JcIjogOTgsXG4gIFwiRU5PU1RSXCI6IDk5LFxuICBcIkVOT1NZU1wiOiA3OCxcbiAgXCJFTk9UQ09OTlwiOiA1NyxcbiAgXCJFTk9URElSXCI6IDIwLFxuICBcIkVOT1RFTVBUWVwiOiA2NixcbiAgXCJFTk9UU09DS1wiOiAzOCxcbiAgXCJFTk9UU1VQXCI6IDQ1LFxuICBcIkVOT1RUWVwiOiAyNSxcbiAgXCJFTlhJT1wiOiA2LFxuICBcIkVPUE5PVFNVUFBcIjogMTAyLFxuICBcIkVPVkVSRkxPV1wiOiA4NCxcbiAgXCJFUEVSTVwiOiAxLFxuICBcIkVQSVBFXCI6IDMyLFxuICBcIkVQUk9UT1wiOiAxMDAsXG4gIFwiRVBST1RPTk9TVVBQT1JUXCI6IDQzLFxuICBcIkVQUk9UT1RZUEVcIjogNDEsXG4gIFwiRVJBTkdFXCI6IDM0LFxuICBcIkVST0ZTXCI6IDMwLFxuICBcIkVTUElQRVwiOiAyOSxcbiAgXCJFU1JDSFwiOiAzLFxuICBcIkVTVEFMRVwiOiA3MCxcbiAgXCJFVElNRVwiOiAxMDEsXG4gIFwiRVRJTUVET1VUXCI6IDYwLFxuICBcIkVUWFRCU1lcIjogMjYsXG4gIFwiRVdPVUxEQkxPQ0tcIjogMzUsXG4gIFwiRVhERVZcIjogMTgsXG4gIFwiU0lHSFVQXCI6IDEsXG4gIFwiU0lHSU5UXCI6IDIsXG4gIFwiU0lHUVVJVFwiOiAzLFxuICBcIlNJR0lMTFwiOiA0LFxuICBcIlNJR1RSQVBcIjogNSxcbiAgXCJTSUdBQlJUXCI6IDYsXG4gIFwiU0lHSU9UXCI6IDYsXG4gIFwiU0lHQlVTXCI6IDEwLFxuICBcIlNJR0ZQRVwiOiA4LFxuICBcIlNJR0tJTExcIjogOSxcbiAgXCJTSUdVU1IxXCI6IDMwLFxuICBcIlNJR1NFR1ZcIjogMTEsXG4gIFwiU0lHVVNSMlwiOiAzMSxcbiAgXCJTSUdQSVBFXCI6IDEzLFxuICBcIlNJR0FMUk1cIjogMTQsXG4gIFwiU0lHVEVSTVwiOiAxNSxcbiAgXCJTSUdDSExEXCI6IDIwLFxuICBcIlNJR0NPTlRcIjogMTksXG4gIFwiU0lHU1RPUFwiOiAxNyxcbiAgXCJTSUdUU1RQXCI6IDE4LFxuICBcIlNJR1RUSU5cIjogMjEsXG4gIFwiU0lHVFRPVVwiOiAyMixcbiAgXCJTSUdVUkdcIjogMTYsXG4gIFwiU0lHWENQVVwiOiAyNCxcbiAgXCJTSUdYRlNaXCI6IDI1LFxuICBcIlNJR1ZUQUxSTVwiOiAyNixcbiAgXCJTSUdQUk9GXCI6IDI3LFxuICBcIlNJR1dJTkNIXCI6IDI4LFxuICBcIlNJR0lPXCI6IDIzLFxuICBcIlNJR1NZU1wiOiAxMixcbiAgXCJTU0xfT1BfQUxMXCI6IDIxNDc0ODY3MTksXG4gIFwiU1NMX09QX0FMTE9XX1VOU0FGRV9MRUdBQ1lfUkVORUdPVElBVElPTlwiOiAyNjIxNDQsXG4gIFwiU1NMX09QX0NJUEhFUl9TRVJWRVJfUFJFRkVSRU5DRVwiOiA0MTk0MzA0LFxuICBcIlNTTF9PUF9DSVNDT19BTllDT05ORUNUXCI6IDMyNzY4LFxuICBcIlNTTF9PUF9DT09LSUVfRVhDSEFOR0VcIjogODE5MixcbiAgXCJTU0xfT1BfQ1JZUFRPUFJPX1RMU0VYVF9CVUdcIjogMjE0NzQ4MzY0OCxcbiAgXCJTU0xfT1BfRE9OVF9JTlNFUlRfRU1QVFlfRlJBR01FTlRTXCI6IDIwNDgsXG4gIFwiU1NMX09QX0VQSEVNRVJBTF9SU0FcIjogMCxcbiAgXCJTU0xfT1BfTEVHQUNZX1NFUlZFUl9DT05ORUNUXCI6IDQsXG4gIFwiU1NMX09QX01JQ1JPU09GVF9CSUdfU1NMVjNfQlVGRkVSXCI6IDMyLFxuICBcIlNTTF9PUF9NSUNST1NPRlRfU0VTU19JRF9CVUdcIjogMSxcbiAgXCJTU0xfT1BfTVNJRV9TU0xWMl9SU0FfUEFERElOR1wiOiAwLFxuICBcIlNTTF9PUF9ORVRTQ0FQRV9DQV9ETl9CVUdcIjogNTM2ODcwOTEyLFxuICBcIlNTTF9PUF9ORVRTQ0FQRV9DSEFMTEVOR0VfQlVHXCI6IDIsXG4gIFwiU1NMX09QX05FVFNDQVBFX0RFTU9fQ0lQSEVSX0NIQU5HRV9CVUdcIjogMTA3Mzc0MTgyNCxcbiAgXCJTU0xfT1BfTkVUU0NBUEVfUkVVU0VfQ0lQSEVSX0NIQU5HRV9CVUdcIjogOCxcbiAgXCJTU0xfT1BfTk9fQ09NUFJFU1NJT05cIjogMTMxMDcyLFxuICBcIlNTTF9PUF9OT19RVUVSWV9NVFVcIjogNDA5NixcbiAgXCJTU0xfT1BfTk9fU0VTU0lPTl9SRVNVTVBUSU9OX09OX1JFTkVHT1RJQVRJT05cIjogNjU1MzYsXG4gIFwiU1NMX09QX05PX1NTTHYyXCI6IDE2Nzc3MjE2LFxuICBcIlNTTF9PUF9OT19TU0x2M1wiOiAzMzU1NDQzMixcbiAgXCJTU0xfT1BfTk9fVElDS0VUXCI6IDE2Mzg0LFxuICBcIlNTTF9PUF9OT19UTFN2MVwiOiA2NzEwODg2NCxcbiAgXCJTU0xfT1BfTk9fVExTdjFfMVwiOiAyNjg0MzU0NTYsXG4gIFwiU1NMX09QX05PX1RMU3YxXzJcIjogMTM0MjE3NzI4LFxuICBcIlNTTF9PUF9QS0NTMV9DSEVDS18xXCI6IDAsXG4gIFwiU1NMX09QX1BLQ1MxX0NIRUNLXzJcIjogMCxcbiAgXCJTU0xfT1BfU0lOR0xFX0RIX1VTRVwiOiAxMDQ4NTc2LFxuICBcIlNTTF9PUF9TSU5HTEVfRUNESF9VU0VcIjogNTI0Mjg4LFxuICBcIlNTTF9PUF9TU0xFQVlfMDgwX0NMSUVOVF9ESF9CVUdcIjogMTI4LFxuICBcIlNTTF9PUF9TU0xSRUYyX1JFVVNFX0NFUlRfVFlQRV9CVUdcIjogMCxcbiAgXCJTU0xfT1BfVExTX0JMT0NLX1BBRERJTkdfQlVHXCI6IDUxMixcbiAgXCJTU0xfT1BfVExTX0Q1X0JVR1wiOiAyNTYsXG4gIFwiU1NMX09QX1RMU19ST0xMQkFDS19CVUdcIjogODM4ODYwOCxcbiAgXCJFTkdJTkVfTUVUSE9EX0RTQVwiOiAyLFxuICBcIkVOR0lORV9NRVRIT0RfREhcIjogNCxcbiAgXCJFTkdJTkVfTUVUSE9EX1JBTkRcIjogOCxcbiAgXCJFTkdJTkVfTUVUSE9EX0VDREhcIjogMTYsXG4gIFwiRU5HSU5FX01FVEhPRF9FQ0RTQVwiOiAzMixcbiAgXCJFTkdJTkVfTUVUSE9EX0NJUEhFUlNcIjogNjQsXG4gIFwiRU5HSU5FX01FVEhPRF9ESUdFU1RTXCI6IDEyOCxcbiAgXCJFTkdJTkVfTUVUSE9EX1NUT1JFXCI6IDI1NixcbiAgXCJFTkdJTkVfTUVUSE9EX1BLRVlfTUVUSFNcIjogNTEyLFxuICBcIkVOR0lORV9NRVRIT0RfUEtFWV9BU04xX01FVEhTXCI6IDEwMjQsXG4gIFwiRU5HSU5FX01FVEhPRF9BTExcIjogNjU1MzUsXG4gIFwiRU5HSU5FX01FVEhPRF9OT05FXCI6IDAsXG4gIFwiREhfQ0hFQ0tfUF9OT1RfU0FGRV9QUklNRVwiOiAyLFxuICBcIkRIX0NIRUNLX1BfTk9UX1BSSU1FXCI6IDEsXG4gIFwiREhfVU5BQkxFX1RPX0NIRUNLX0dFTkVSQVRPUlwiOiA0LFxuICBcIkRIX05PVF9TVUlUQUJMRV9HRU5FUkFUT1JcIjogOCxcbiAgXCJOUE5fRU5BQkxFRFwiOiAxLFxuICBcIlJTQV9QS0NTMV9QQURESU5HXCI6IDEsXG4gIFwiUlNBX1NTTFYyM19QQURESU5HXCI6IDIsXG4gIFwiUlNBX05PX1BBRERJTkdcIjogMyxcbiAgXCJSU0FfUEtDUzFfT0FFUF9QQURESU5HXCI6IDQsXG4gIFwiUlNBX1g5MzFfUEFERElOR1wiOiA1LFxuICBcIlJTQV9QS0NTMV9QU1NfUEFERElOR1wiOiA2LFxuICBcIlBPSU5UX0NPTlZFUlNJT05fQ09NUFJFU1NFRFwiOiAyLFxuICBcIlBPSU5UX0NPTlZFUlNJT05fVU5DT01QUkVTU0VEXCI6IDQsXG4gIFwiUE9JTlRfQ09OVkVSU0lPTl9IWUJSSURcIjogNixcbiAgXCJGX09LXCI6IDAsXG4gIFwiUl9PS1wiOiA0LFxuICBcIldfT0tcIjogMixcbiAgXCJYX09LXCI6IDEsXG4gIFwiVVZfVURQX1JFVVNFQUREUlwiOiA0XG59XG4iLCIvKiFcbiAqIGNvcHktZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvY29weS1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHkgYSBkZXNjcmlwdG9yIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHRoaXMuY2FjaGUgPSB7fTtcbiAqIH1cbiAqIEFwcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAqICAgdGhpcy5jYWNoZVtrZXldID0gdmFsO1xuICogICByZXR1cm4gdGhpcztcbiAqIH07XG4gKiBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwLnByb3RvdHlwZSwgJ2NvdW50Jywge1xuICogICBnZXQ6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKS5sZW5ndGg7XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvcHkoQXBwLnByb3RvdHlwZSwgJ2NvdW50JywgJ2xlbicpO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBpbnN0YW5jZVxuICogdmFyIGFwcCA9IG5ldyBBcHAoKTtcbiAqXG4gKiBhcHAuc2V0KCdhJywgdHJ1ZSk7XG4gKiBhcHAuc2V0KCdiJywgdHJ1ZSk7XG4gKiBhcHAuc2V0KCdjJywgdHJ1ZSk7XG4gKlxuICogY29uc29sZS5sb2coYXBwLmNvdW50KTtcbiAqIC8vPT4gM1xuICogY29uc29sZS5sb2coYXBwLmxlbik7XG4gKiAvLz0+IDNcbiAqIGBgYFxuICogQG5hbWUgY29weVxuICogQHBhcmFtIHtPYmplY3R9IGByZWNlaXZlcmAgVGhlIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgIFRoZSBwcm92aWRlciBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZnJvbWAgVGhlIGtleSB0byBjb3B5IG9uIHByb3ZpZGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IGB0b2AgT3B0aW9uYWxseSBzcGVjaWZ5IGEgbmV3IGtleSBuYW1lIHRvIHVzZS5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb3B5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvdmlkZXIsIGZyb20sIHRvKSB7XG4gIGlmICghaXNPYmplY3QocHJvdmlkZXIpICYmIHR5cGVvZiBwcm92aWRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRvID0gZnJvbTtcbiAgICBmcm9tID0gcHJvdmlkZXI7XG4gICAgcHJvdmlkZXIgPSByZWNlaXZlcjtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHJlY2VpdmVyKSAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgaWYgKCFpc09iamVjdChwcm92aWRlcikgJiYgdHlwZW9mIHByb3ZpZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcHJvdmlkZXIgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJykge1xuICAgIHRvID0gZnJvbTtcbiAgfVxuICBpZiAodHlwZW9mIGZyb20gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQga2V5IHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoIShmcm9tIGluIHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvcGVydHkgXCInICsgZnJvbSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xuICB9XG5cbiAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdmlkZXIsIGZyb20pO1xuICBpZiAodmFsKSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHRvLCB2YWwpO1xufTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyohXG4gKiBkZWZpbmUtcHJvcGVydHkgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2RlZmluZS1wcm9wZXJ0eT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxOCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNvYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIGlzRGVzY3JpcHRvciA9IHJlcXVpcmUoJ2lzLWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmUgPSAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkpXG4gID8gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eVxuICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsKSB7XG4gIGlmICghaXNvYmplY3Qob2JqKSAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nICYmICFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBvYmplY3QsIGZ1bmN0aW9uLCBvciBhcnJheScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgXCJrZXlcIiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGlzRGVzY3JpcHRvcih2YWwpKSB7XG4gICAgZGVmaW5lKG9iaiwga2V5LCB2YWwpO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBkZWZpbmUob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbFxuICB9KTtcblxuICByZXR1cm4gb2JqO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXJzJyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZXhwYW5kLWJyYWNrZXRzJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciBTbmFwZHJhZ29uID0gcmVxdWlyZSgnc25hcGRyYWdvbicpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gUE9TSVggY2hhcmFjdGVyIGNsYXNzIGBwYXR0ZXJuYCBhbmQgcmV0dXJucyBhXG4gKiBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBicmFja2V0cyhwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdpbml0aWFsaXppbmcgZnJvbSA8JXM+JywgX19maWxlbmFtZSk7XG4gIHZhciByZXMgPSBicmFja2V0cy5jcmVhdGUocGF0dGVybiwgb3B0aW9ucyk7XG4gIHJldHVybiByZXMub3V0cHV0O1xufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIGEgUE9TSVggY2hhcmFjdGVyIGNsYXNzIHBhdHRlcm4sIGFuZCByZXR1cm5zIGEgbmV3XG4gKiBhcnJheSB3aXRoIG9ubHkgdGhlIHN0cmluZ3MgdGhhdCBtYXRjaGVkIHRoZSBwYXR0ZXJuLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNrZXRzLm1hdGNoKFsnMScsICdhJywgJ2FiJ10sICdbWzphbHBoYTpdXScpKTtcbiAqIC8vPT4gWydhJ11cbiAqXG4gKiBjb25zb2xlLmxvZyhicmFja2V0cy5tYXRjaChbJzEnLCAnYScsICdhYiddLCAnW1s6YWxwaGE6XV0rJykpO1xuICogLy89PiBbJ2EnLCAnYWInXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgYXJyYCBBcnJheSBvZiBzdHJpbmdzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFBPU0lYIGNoYXJhY3RlciBjbGFzcyBwYXR0ZXJuKHMpXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMubWF0Y2ggPSBmdW5jdGlvbihhcnIsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgYXJyID0gW10uY29uY2F0KGFycik7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgdmFyIGlzTWF0Y2ggPSBicmFja2V0cy5tYXRjaGVyKHBhdHRlcm4sIG9wdHMpO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgcmVzID0gW107XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGVsZSA9IGFycltpZHhdO1xuICAgIGlmIChpc01hdGNoKGVsZSkpIHtcbiAgICAgIHJlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0cy5mYWlsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtYXRjaGVzIGZvdW5kIGZvciBcIicgKyBwYXR0ZXJuICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9udWxsID09PSB0cnVlIHx8IG9wdHMubnVsbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBbcGF0dGVybi5zcGxpdCgnXFxcXCcpLmpvaW4oJycpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AgbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAqIGJyYWNrZXRzIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG4gKlxuICogY29uc29sZS5sb2coYnJhY2tldHMuaXNNYXRjaCgnYS5hJywgJ1tbOmFscGhhOl1dLltbOmFscGhhOl1dJykpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhicmFja2V0cy5pc01hdGNoKCcxLjInLCAnW1s6YWxwaGE6XV0uW1s6YWxwaGE6XV0nKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgUG94aXMgcGF0dGVyblxuICogQHBhcmFtIHtTdHJpbmd9IGBvcHRpb25zYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMuaXNNYXRjaCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2tldHMubWF0Y2hlcihwYXR0ZXJuLCBvcHRpb25zKShzdHIpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIFBPU0lYIGNoYXJhY3RlciBjbGFzcyBwYXR0ZXJuIGFuZCByZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi4gVGhlIHJldHVybmVkXG4gKiBmdW5jdGlvbiB0YWtlcyB0aGUgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqIHZhciBpc01hdGNoID0gYnJhY2tldHMubWF0Y2hlcignW1s6bG93ZXI6XV0uW1s6dXBwZXI6XV0nKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLkEnKSk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBQb3hpcyBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFja2V0cy5tYXRjaGVyID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgcmUgPSBicmFja2V0cy5tYWtlUmUocGF0dGVybiwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqIHZhciByZSA9IGJyYWNrZXRzLm1ha2VSZSgnW1s6YWxwaGE6XV0nKTtcbiAqIGNvbnNvbGUubG9nKHJlKTtcbiAqIC8vPT4gL14oPzpbYS16QS1aXSkkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFRoZSBwYXR0ZXJuIHRvIGNvbnZlcnQgdG8gcmVnZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNrZXRzLm1ha2VSZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIHJlcyA9IGJyYWNrZXRzLmNyZWF0ZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe3N0cmljdEVycm9yczogZmFsc2V9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRvUmVnZXgocmVzLm91dHB1dCwgb3B0cyk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gUE9TSVggY2hhcmFjdGVyIGNsYXNzIGBwYXR0ZXJuYCBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGNvbXBpbGVkIGBvdXRwdXRgIGFuZCBvcHRpb25hbCBzb3VyY2UgYG1hcGAuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFja2V0cyA9IHJlcXVpcmUoJ2V4cGFuZC1icmFja2V0cycpO1xuICogY29uc29sZS5sb2coYnJhY2tldHMoJ1tbOmFscGhhOl1dJykpO1xuICogLy8geyBvcHRpb25zOiB7IHNvdXJjZTogJ3N0cmluZycgfSxcbiAqIC8vICAgaW5wdXQ6ICdbWzphbHBoYTpdXScsXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyBlb3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIG5vb3A6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgbm90OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBlc2NhcGU6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHRleHQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHBvc2l4OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBicmFja2V0OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2tldC5vcGVuJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNrZXQuaW5uZXInOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2tldC5saXRlcmFsJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNrZXQuY2xvc2UnOiBbRnVuY3Rpb25dIH0sXG4gKiAvLyAgIG91dHB1dDogJ1thLXpBLVpdJyxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyB0eXBlOiAncm9vdCcsXG4gKiAvLyAgICAgIGVycm9yczogW10sXG4gKiAvLyAgICAgIG5vZGVzOiBbIFtPYmplY3RdLCBbT2JqZWN0XSwgW09iamVjdF0gXSB9LFxuICogLy8gICBwYXJzaW5nRXJyb3JzOiBbXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMuY3JlYXRlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgc25hcGRyYWdvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuc25hcGRyYWdvbikgfHwgbmV3IFNuYXBkcmFnb24ob3B0aW9ucyk7XG4gIGNvbXBpbGVycyhzbmFwZHJhZ29uKTtcbiAgcGFyc2VycyhzbmFwZHJhZ29uKTtcblxuICB2YXIgYXN0ID0gc25hcGRyYWdvbi5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgYXN0LmlucHV0ID0gcGF0dGVybjtcbiAgdmFyIHJlcyA9IHNuYXBkcmFnb24uY29tcGlsZShhc3QsIG9wdGlvbnMpO1xuICByZXMuaW5wdXQgPSBwYXR0ZXJuO1xuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYGJyYWNrZXRzYCBjb25zdHJ1Y3RvciwgcGFyc2VycyBhbmQgY29tcGlsZXJzXG4gKi9cblxuYnJhY2tldHMuY29tcGlsZXJzID0gY29tcGlsZXJzO1xuYnJhY2tldHMucGFyc2VycyA9IHBhcnNlcnM7XG5cbi8qKlxuICogRXhwb3NlIGBicmFja2V0c2BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJyYWNrZXRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zaXggPSByZXF1aXJlKCdwb3NpeC1jaGFyYWN0ZXItY2xhc3NlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJyYWNrZXRzKSB7XG4gIGJyYWNrZXRzLmNvbXBpbGVyXG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2VzY2FwZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwucmVwbGFjZSgvXlxcXFwvLCAnJyksIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBUZXh0XG4gICAgICovXG5cbiAgICAuc2V0KCd0ZXh0JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbC5yZXBsYWNlKC8oW3t9XSkvZywgJ1xcXFwkMScpLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUE9TSVggY2hhcmFjdGVyIGNsYXNzZXNcbiAgICAgKi9cblxuICAgIC5zZXQoJ3Bvc2l4JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUudmFsID09PSAnWzo6XScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXFs6OlxcXFxdJywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWwgPSBwb3NpeFtub2RlLmlubmVyXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWwgPSAnWycgKyBub2RlLmlubmVyICsgJ10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBOb24tcG9zaXggYnJhY2tldHNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBWaXNpdChub2RlLm5vZGVzKTtcbiAgICB9KVxuICAgIC5zZXQoJ2JyYWNrZXQub3BlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG4gICAgLnNldCgnYnJhY2tldC5pbm5lcicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBpbm5lciA9IG5vZGUudmFsO1xuXG4gICAgICBpZiAoaW5uZXIgPT09ICdbJyB8fCBpbm5lciA9PT0gJ10nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyID09PSAnXl0nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ15cXFxcXScsIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyID09PSAnXicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXicsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoLy0vLnRlc3QoaW5uZXIpICYmICEvKFxcZC1cXGR8XFx3LVxcdykvLnRlc3QoaW5uZXIpKSB7XG4gICAgICAgIGlubmVyID0gaW5uZXIuc3BsaXQoJy0nKS5qb2luKCdcXFxcLScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNOZWdhdGVkID0gaW5uZXIuY2hhckF0KDApID09PSAnXic7XG4gICAgICAvLyBhZGQgc2xhc2hlcyB0byBuZWdhdGVkIGJyYWNrZXRzLCBwZXIgc3BlY1xuICAgICAgaWYgKGlzTmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcvJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcvJztcbiAgICAgIH1cbiAgICAgIGlmIChpc05lZ2F0ZWQgJiYgaW5uZXIuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICBpbm5lciArPSAnLic7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IHVuZXNjYXBlIGAwYCAob2N0YWwgbGl0ZXJhbClcbiAgICAgIGlubmVyID0gaW5uZXIucmVwbGFjZSgvXFxcXChbMS05XSkvZywgJyQxJyk7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGlubmVyLCBub2RlKTtcbiAgICB9KVxuICAgIC5zZXQoJ2JyYWNrZXQuY2xvc2UnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWwucmVwbGFjZSgvXlxcXFwvLCAnJyk7XG4gICAgICBpZiAobm9kZS5wYXJlbnQuZXNjYXBlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIHZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGV4dCByZWdleFxuICovXG5cbnZhciBURVhUX1JFR0VYID0gJyhcXFxcWyg/PS4qXFxcXF0pfFxcXFxdKSsnO1xudmFyIG5vdCA9IHV0aWxzLmNyZWF0ZVJlZ2V4KFRFWFRfUkVHRVgpO1xuXG4vKipcbiAqIEJyYWNrZXRzIHBhcnNlcnNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZXJzKGJyYWNrZXRzKSB7XG4gIGJyYWNrZXRzLnN0YXRlID0gYnJhY2tldHMuc3RhdGUgfHwge307XG4gIGJyYWNrZXRzLnBhcnNlci5zZXRzLmJyYWNrZXQgPSBicmFja2V0cy5wYXJzZXIuc2V0cy5icmFja2V0IHx8IFtdO1xuICBicmFja2V0cy5wYXJzZXJcblxuICAgIC5jYXB0dXJlKCdlc2NhcGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFxcKC4pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHBhcnNlclxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gobm90KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQT1NJWCBjaGFyYWN0ZXIgY2xhc3NlczogXCJbWzphbHBoYTpdWzpkaWdpdHM6XV1cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3Bvc2l4JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxbOiguKj8pOlxcXSg/PS4qXFxdKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBpbnNpZGUgPSB0aGlzLmlzSW5zaWRlKCdicmFja2V0Jyk7XG4gICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvc2l4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAncG9zaXgnLFxuICAgICAgICBpbnNpZGVCcmFja2V0OiBpbnNpZGUsXG4gICAgICAgIGlubmVyOiBtWzFdLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFja2V0IChub29wKVxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2JyYWNrZXQnLCBmdW5jdGlvbigpIHt9KVxuXG4gICAgLyoqXG4gICAgICogT3BlbjogJ1snXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldC5vcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxbKD89LipcXF0pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcblxuICAgICAgaWYgKHBhcnNlZC5zbGljZSgtMSkgPT09ICdcXFxcJyAmJiAhdGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSB7XG4gICAgICAgIGxhc3QudmFsID0gbGFzdC52YWwuc2xpY2UoMCwgbGFzdC52YWwubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgIHZhbDogbVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZW4gPSBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldC5vcGVuJyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcblxuICAgICAgaWYgKGxhc3QudHlwZSA9PT0gJ2JyYWNrZXQub3BlbicgfHwgdGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSB7XG4gICAgICAgIG9wZW4udmFsID0gJ1xcXFwnICsgb3Blbi52YWw7XG4gICAgICAgIG9wZW4udHlwZSA9ICdicmFja2V0LmlubmVyJztcbiAgICAgICAgb3Blbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQnLFxuICAgICAgICBub2RlczogW29wZW5dXG4gICAgICB9KTtcblxuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwcmV2KTtcbiAgICAgIGRlZmluZShvcGVuLCAncGFyZW50Jywgbm9kZSk7XG4gICAgICB0aGlzLnB1c2goJ2JyYWNrZXQnLCBub2RlKTtcbiAgICAgIHByZXYubm9kZXMucHVzaChub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQnJhY2tldCB0ZXh0XG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldC5pbm5lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gobm90KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KDApO1xuICAgICAgdmFyIHZhbCA9IG1bMF07XG5cbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQuaW5uZXInLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh2YWwgPT09ICdcXFxcXFxcXCcpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdCA9IHZhbC5jaGFyQXQoMCk7XG4gICAgICB2YXIgbGFzdCA9IHZhbC5zbGljZSgtMSk7XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJyEnKSB7XG4gICAgICAgIHZhbCA9ICdeJyArIHZhbC5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3QgPT09ICdcXFxcJyB8fCAodmFsID09PSAnXicgJiYgbmV4dCA9PT0gJ10nKSkge1xuICAgICAgICB2YWwgKz0gdGhpcy5pbnB1dFswXTtcbiAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnZhbCA9IHZhbDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZTogJ10nXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldC5jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcXS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG5cbiAgICAgIGlmIChwYXJzZWQuc2xpY2UoLTEpID09PSAnXFxcXCcgJiYgIXRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkge1xuICAgICAgICBsYXN0LnZhbCA9IGxhc3QudmFsLnNsaWNlKDAsIGxhc3QudmFsLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgIHZhbDogbVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldC5jbG9zZScsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXQsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsYXN0LnR5cGUgPT09ICdicmFja2V0Lm9wZW4nKSB7XG4gICAgICAgIG5vZGUudHlwZSA9ICdicmFja2V0LmlubmVyJztcbiAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBicmFja2V0ID0gdGhpcy5wb3AoJ2JyYWNrZXQnKTtcbiAgICAgIGlmICghdGhpcy5pc1R5cGUoYnJhY2tldCwgJ2JyYWNrZXQnKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVuaW5nIFwiW1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50eXBlID0gJ2JyYWNrZXQuaW5uZXInO1xuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgYnJhY2tldC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBicmFja2V0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBCcmFja2V0cyBwYXJzZXJzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXJzO1xuXG4vKipcbiAqIEV4cG9zZSB0ZXh0IHJlZ2V4XG4gKi9cblxubW9kdWxlLmV4cG9ydHMuVEVYVF9SRUdFWCA9IFRFWFRfUkVHRVg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciByZWdleE5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIGNhY2hlZDtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBmcm9tIGBhcnJheWBcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJheWBcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZXhwb3J0cy5sYXN0ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIGNhY2hlIHJlZ2V4IHRvIHVzZSBmb3IgdGV4dCBub2Rlc1xuICovXG5cbmV4cG9ydHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmNsdWRlKSB7XG4gIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gIHZhciBvcHRzID0ge2NvbnRhaW5zOiB0cnVlLCBzdHJpY3RDbG9zZTogZmFsc2V9O1xuICB2YXIgbm90ID0gcmVnZXhOb3QuY3JlYXRlKHBhdHRlcm4sIG9wdHMpO1xuICB2YXIgcmU7XG5cbiAgaWYgKHR5cGVvZiBpbmNsdWRlID09PSAnc3RyaW5nJykge1xuICAgIHJlID0gdG9SZWdleCgnXig/OicgKyBpbmNsdWRlICsgJ3wnICsgbm90ICsgJyknLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZSA9IHRvUmVnZXgobm90LCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiAoY2FjaGVkID0gcmUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzRXh0ZW5kYWJsZSA9IHJlcXVpcmUoJ2lzLWV4dGVuZGFibGUnKTtcbnZhciBhc3NpZ25TeW1ib2xzID0gcmVxdWlyZSgnYXNzaWduLXN5bWJvbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKG9iai8qLCBvYmplY3RzKi8pIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIG9iaiA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgdmFsID0gdG9PYmplY3QodmFsKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGFzc2lnbihvYmosIHZhbCk7XG4gICAgICBhc3NpZ25TeW1ib2xzKG9iaiwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbihhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhc093bihiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyk7XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGkgaW4gc3RyKSB7XG4gICAgb2JqW2ldID0gc3RyW2ldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JykgfHwgaXNFeHRlbmRhYmxlKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBga2V5YCBpcyBhbiBvd24gcHJvcGVydHkgb2YgYG9iamAuXG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBpc0VudW0ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSk7XG59XG4iLCIvKiFcbiAqIGlzLWV4dGVuZGFibGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGVuZGFibGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0V4dGVuZGFibGUodmFsKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHZhbCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciB1bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXJzJyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcbnZhciBFeHRnbG9iID0gcmVxdWlyZSgnLi9saWIvZXh0Z2xvYicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGBleHRnbG9iYCBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlIHN0cmluZy4gUmV0dXJuc1xuICogYW4gb2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdCBhbmQgdGhlIHBhcnNlZCBBU1QuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYignKi4hKCphKScpKTtcbiAqIC8vPT4gJyg/IVxcXFwuKVteL10qP1xcXFwuKD8hKD8hXFxcXC4pW14vXSo/YVxcXFxiKS4qPydcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBleHRnbG9iKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGV4dGdsb2IuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpLm91dHB1dDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBhbiBleHRnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYSBuZXdcbiAqIGFycmF5IHRoYXQgY29udGFpbnMgb25seSB0aGUgc3RyaW5ncyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IubWF0Y2goWydhLmEnLCAnYS5iJywgJ2EuYyddLCAnKi4hKCphKScpKTtcbiAqIC8vPT4gWydhLmInLCAnYS5jJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgRXh0Z2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4dGdsb2IubWF0Y2ggPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG4gIHZhciBpc01hdGNoID0gZXh0Z2xvYi5tYXRjaGVyKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgZWxlID0gbGlzdFtpZHhdO1xuXG4gICAgaWYgKGlzTWF0Y2goZWxlKSkge1xuICAgICAgbWF0Y2hlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbm8gb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdW5pcXVpZnkgcmVzdWx0cyBhbmQgcmV0dXJuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdW5pcXVlKG1hdGNoZXMpO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMuZmFpbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWF0Y2hlcyBmb3VuZCBmb3IgXCInICsgcGF0dGVybiArICdcIicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub251bGwgPT09IHRydWUgfHwgb3B0aW9ucy5udWxsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIFtwYXR0ZXJuLnNwbGl0KCdcXFxcJykuam9pbignJyldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLm5vZHVwZXMgIT09IGZhbHNlID8gdW5pcXVlKG1hdGNoZXMpIDogbWF0Y2hlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AgbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAqIGV4dGdsb2IgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhleHRnbG9iLmlzTWF0Y2goJ2EuYScsICcqLiEoKmEpJykpO1xuICogLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coZXh0Z2xvYi5pc01hdGNoKCdhLmInLCAnKi4hKCphKScpKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEV4dGdsb2IgcGF0dGVyblxuICogQHBhcmFtIHtTdHJpbmd9IGBvcHRpb25zYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4gPT09IHN0cikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4gPT09ICcnIHx8IHBhdHRlcm4gPT09ICcgJyB8fCBwYXR0ZXJuID09PSAnLicpIHtcbiAgICByZXR1cm4gcGF0dGVybiA9PT0gc3RyO1xuICB9XG5cbiAgdmFyIGlzTWF0Y2ggPSB1dGlscy5tZW1vaXplKCdpc01hdGNoJywgcGF0dGVybiwgb3B0aW9ucywgZXh0Z2xvYi5tYXRjaGVyKTtcbiAgcmV0dXJuIGlzTWF0Y2goc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyaW5nYCBjb250YWlucyB0aGUgZ2l2ZW4gcGF0dGVybi4gU2ltaWxhciB0byBgLmlzTWF0Y2hgIGJ1dFxuICogdGhlIHBhdHRlcm4gY2FuIG1hdGNoIGFueSBwYXJ0IG9mIHRoZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYi5jb250YWlucygnYWEvYmIvY2MnLCAnKmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IuY29udGFpbnMoJ2FhL2JiL2NjJywgJypkJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdHRlciBtYXRjaGVzIGFueSBwYXJ0IG9mIGBzdHJgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLmNvbnRhaW5zID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0dGVybiA9PT0gJycgfHwgcGF0dGVybiA9PT0gJyAnIHx8IHBhdHRlcm4gPT09ICcuJykge1xuICAgIHJldHVybiBwYXR0ZXJuID09PSBzdHI7XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2NvbnRhaW5zOiB0cnVlfSk7XG4gIG9wdHMuc3RyaWN0Q2xvc2UgPSBmYWxzZTtcbiAgb3B0cy5zdHJpY3RPcGVuID0gZmFsc2U7XG4gIHJldHVybiBleHRnbG9iLmlzTWF0Y2goc3RyLCBwYXR0ZXJuLCBvcHRzKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW4gZXh0Z2xvYiBwYXR0ZXJuIGFuZCByZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi4gVGhlIHJldHVybmVkXG4gKiBmdW5jdGlvbiB0YWtlcyB0aGUgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIHZhciBpc01hdGNoID0gZXh0Z2xvYi5tYXRjaGVyKCcqLiEoKmEpJyk7XG4gKlxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5hJykpO1xuICogLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgRXh0Z2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLm1hdGNoZXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVyKCkge1xuICAgIHZhciByZSA9IGV4dGdsb2IubWFrZVJlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5tZW1vaXplKCdtYXRjaGVyJywgcGF0dGVybiwgb3B0aW9ucywgbWF0Y2hlcik7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGBleHRnbG9iYCBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlIHN0cmluZy4gUmV0dXJuc1xuICogYW4gb2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdCBhbmQgdGhlIHBhcnNlZCBBU1QuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYi5jcmVhdGUoJyouISgqYSknKS5vdXRwdXQpO1xuICogLy89PiAnKD8hXFxcXC4pW14vXSo/XFxcXC4oPyEoPyFcXFxcLilbXi9dKj9hXFxcXGIpLio/J1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5jcmVhdGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIGV4dCA9IG5ldyBFeHRnbG9iKG9wdGlvbnMpO1xuICAgIHZhciBhc3QgPSBleHQucGFyc2UocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGV4dC5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdXRpbHMubWVtb2l6ZSgnY3JlYXRlJywgcGF0dGVybiwgb3B0aW9ucywgY3JlYXRlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzIGNhcHR1cmVkIGJ5IGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCwgb3IgYG51bGxgXG4gKiBpZiB0aGUgcGF0dGVybiBkaWQgbm90IG1hdGNoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIGV4dGdsb2IuY2FwdHVyZShwYXR0ZXJuLCBzdHJpbmdbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2coZXh0Z2xvYi5jYXB0dXJlKCd0ZXN0LyouanMnLCAndGVzdC9mb28uanMnKSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IuY2FwdHVyZSgndGVzdC8qLmpzJywgJ2Zvby9iYXIuY3NzJykpO1xuICogLy89PiBudWxsXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBhbiBhcnJheSBvZiBjYXB0dXJlcyBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybiwgb3RoZXJ3aXNlIGBudWxsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5jYXB0dXJlID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyLCBvcHRpb25zKSB7XG4gIHZhciByZSA9IGV4dGdsb2IubWFrZVJlKHBhdHRlcm4sIGV4dGVuZCh7Y2FwdHVyZTogdHJ1ZX0sIG9wdGlvbnMpKTtcblxuICBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0gdXRpbHMubWVtb2l6ZSgnY2FwdHVyZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1hdGNoKTtcbiAgcmV0dXJuIGNhcHR1cmUoc3RyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIHZhciByZSA9IGV4dGdsb2IubWFrZVJlKCcqLiEoKmEpJyk7XG4gKiBjb25zb2xlLmxvZyhyZSk7XG4gKiAvLz0+IC9eW15cXC9dKj9cXC4oPyFbXlxcL10qP2EpW15cXC9dKj8kL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFRoZSBwYXR0ZXJuIHRvIGNvbnZlcnQgdG8gcmVnZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4dGdsb2IubWFrZVJlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlUmUoKSB7XG4gICAgdmFyIG9wdHMgPSBleHRlbmQoe3N0cmljdEVycm9yczogZmFsc2V9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0cy5zdHJpY3RFcnJvcnMgPT09IHRydWUpIG9wdHMuc3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZXh0Z2xvYi5jcmVhdGUocGF0dGVybiwgb3B0cyk7XG4gICAgcmV0dXJuIHRvUmVnZXgocmVzLm91dHB1dCwgb3B0cyk7XG4gIH1cblxuICB2YXIgcmVnZXggPSB1dGlscy5tZW1vaXplKCdtYWtlUmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYWtlUmUpO1xuICBpZiAocmVnZXguc291cmNlLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ3BvdGVudGlhbGx5IG1hbGljaW91cyByZWdleCBkZXRlY3RlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBDYWNoZVxuICovXG5cbmV4dGdsb2IuY2FjaGUgPSB1dGlscy5jYWNoZTtcbmV4dGdsb2IuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBleHRnbG9iLmNhY2hlLl9fZGF0YV9fID0ge307XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgRXh0Z2xvYmAgY29uc3RydWN0b3IsIHBhcnNlcnMgYW5kIGNvbXBpbGVyc1xuICovXG5cbmV4dGdsb2IuRXh0Z2xvYiA9IEV4dGdsb2I7XG5leHRnbG9iLmNvbXBpbGVycyA9IGNvbXBpbGVycztcbmV4dGdsb2IucGFyc2VycyA9IHBhcnNlcnM7XG5cbi8qKlxuICogRXhwb3NlIGBleHRnbG9iYFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0Z2xvYjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG5cbi8qKlxuICogRXh0Z2xvYiBjb21waWxlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4dGdsb2IpIHtcbiAgZnVuY3Rpb24gc3RhcigpIHtcbiAgICBpZiAodHlwZW9mIGV4dGdsb2Iub3B0aW9ucy5zdGFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZXh0Z2xvYi5vcHRpb25zLnN0YXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHRnbG9iLm9wdGlvbnMuc3RhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBleHRnbG9iLm9wdGlvbnMuc3RhcjtcbiAgICB9XG4gICAgcmV0dXJuICcuKj8nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBgZXhwYW5kLWJyYWNrZXRzYCBjb21waWxlcnNcbiAgICovXG5cbiAgZXh0Z2xvYi51c2UoYnJhY2tldHMuY29tcGlsZXJzKTtcbiAgZXh0Z2xvYi5jb21waWxlclxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlZDogXCJcXFxcKlwiXG4gICAgICovXG5cbiAgICAuc2V0KCdlc2NhcGUnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRG90OiBcIi5cIlxuICAgICAqL1xuXG4gICAgLnNldCgnZG90JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcms6IFwiP1wiXG4gICAgICovXG5cbiAgICAuc2V0KCdxbWFyaycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWwgPSAnW15cXFxcXFxcXC8uXSc7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuXG4gICAgICBpZiAobm9kZS5wYXJzZWQuc2xpY2UoLTEpID09PSAnKCcpIHtcbiAgICAgICAgdmFyIGNoID0gbm9kZS5yZXN0LmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKGNoICE9PSAnIScgJiYgY2ggIT09ICc9JyAmJiBjaCAhPT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi50eXBlID09PSAndGV4dCcgJiYgcHJldi52YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS52YWwubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgKz0gJ3snICsgbm9kZS52YWwubGVuZ3RoICsgJ30nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQbHVzOiBcIitcIlxuICAgICAqL1xuXG4gICAgLnNldCgncGx1cycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5wYXJzZWQuc2xpY2UoLTEpO1xuICAgICAgaWYgKHByZXYgPT09ICddJyB8fCBwcmV2ID09PSAnKScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgY2ggPSB0aGlzLm91dHB1dC5zbGljZSgtMSk7XG4gICAgICBpZiAoIXRoaXMub3V0cHV0IHx8ICgvWz8qK10vLnRlc3QoY2gpICYmIG5vZGUucGFyZW50LnR5cGUgIT09ICdicmFja2V0JykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCsnLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSAmJiAhbm9kZS5pbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnK1xcXFwrPycsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnKycsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTdGFyOiBcIipcIlxuICAgICAqL1xuXG4gICAgLnNldCgnc3RhcicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgcHJlZml4ID0gcHJldi50eXBlICE9PSAndGV4dCcgJiYgcHJldi50eXBlICE9PSAnZXNjYXBlJ1xuICAgICAgICA/ICcoPyFcXFxcLiknXG4gICAgICAgIDogJyc7XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXQocHJlZml4ICsgc3Rhci5jYWxsKHRoaXMsIG5vZGUpLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUGFyZW5zXG4gICAgICovXG5cbiAgICAuc2V0KCdwYXJlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcFZpc2l0KG5vZGUubm9kZXMpO1xuICAgIH0pXG4gICAgLnNldCgncGFyZW4ub3BlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjYXB0dXJlID0gdGhpcy5vcHRpb25zLmNhcHR1cmUgPyAnKCcgOiAnJztcblxuICAgICAgc3dpdGNoIChub2RlLnBhcmVudC5wcmVmaXgpIHtcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoY2FwdHVyZSArICcoPzooPyEoPzonLCBub2RlKTtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChjYXB0dXJlICsgJyg/OicsIG5vZGUpO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdmFyIHZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFzaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsID0gJ1xcXFwnICsgdmFsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5jYXB0dXJlICYmIHZhbCA9PT0gJygnICYmIG5vZGUucGFyZW50LnJlc3RbMF0gIT09ICc/Jykge1xuICAgICAgICAgICAgdmFsICs9ICc/Oic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICAuc2V0KCdwYXJlbi5jbG9zZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjYXB0dXJlID0gdGhpcy5vcHRpb25zLmNhcHR1cmUgPyAnKScgOiAnJztcblxuICAgICAgc3dpdGNoIChub2RlLnByZWZpeCkge1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgdmFyIHByZWZpeCA9IC9eKFxcKXwkKS8udGVzdChub2RlLnJlc3QpID8gJyQnIDogJyc7XG4gICAgICAgICAgdmFyIHN0ciA9IHN0YXIuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBleHRnbG9iIGhhcyBhIHNsYXNoIGV4cGxpY2l0bHkgZGVmaW5lZCwgd2Uga25vdyB0aGUgdXNlciB3YW50c1xuICAgICAgICAgIC8vIHRvIG1hdGNoIHNsYXNoZXMsIHNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBcInN0YXJcIiByZWdleCBhbGxvd3MgZm9yIGl0XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50Lmhhc1NsYXNoICYmICF0aGlzLm9wdGlvbnMuc3RhciAmJiB0aGlzLm9wdGlvbnMuc2xhc2ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHIgPSAnLio/JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHByZWZpeCArICgnKSknICsgc3RyICsgJyknKSArIGNhcHR1cmUsIG5vZGUpO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJyknICsgbm9kZS5wcmVmaXggKyBjYXB0dXJlLCBub2RlKTtcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnKScgKyBjYXB0dXJlLCBub2RlKTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHZhciB2YWwgPSAodGhpcy5vcHRpb25zLmJhc2ggPT09IHRydWUgPyAnXFxcXCcgOiAnJykgKyAnKSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWwucmVwbGFjZSgvW1xcW1xcXV0vZywgJ1xcXFwkJicpO1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XG5cbi8qKlxuICogQ3VzdG9taXplIFNuYXBkcmFnb24gcGFyc2VyIGFuZCByZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIEV4dGdsb2Iob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe3NvdXJjZTogJ2V4dGdsb2InfSwgb3B0aW9ucyk7XG4gIHRoaXMuc25hcGRyYWdvbiA9IHRoaXMub3B0aW9ucy5zbmFwZHJhZ29uIHx8IG5ldyBTbmFwZHJhZ29uKHRoaXMub3B0aW9ucyk7XG4gIHRoaXMuc25hcGRyYWdvbi5wYXR0ZXJucyA9IHRoaXMuc25hcGRyYWdvbi5wYXR0ZXJucyB8fCB7fTtcbiAgdGhpcy5jb21waWxlciA9IHRoaXMuc25hcGRyYWdvbi5jb21waWxlcjtcbiAgdGhpcy5wYXJzZXIgPSB0aGlzLnNuYXBkcmFnb24ucGFyc2VyO1xuXG4gIGNvbXBpbGVycyh0aGlzLnNuYXBkcmFnb24pO1xuICBwYXJzZXJzKHRoaXMuc25hcGRyYWdvbik7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIFNuYXBkcmFnb24gYC5wYXJzZWAgbWV0aG9kXG4gICAqL1xuXG4gIGRlZmluZSh0aGlzLnNuYXBkcmFnb24sICdwYXJzZScsIGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWQgPSBTbmFwZHJhZ29uLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHBhcnNlZC5pbnB1dCA9IHN0cjtcblxuICAgIC8vIGVzY2FwZSB1bm1hdGNoZWQgYnJhY2UvYnJhY2tldC9wYXJlbnNcbiAgICB2YXIgbGFzdCA9IHRoaXMucGFyc2VyLnN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0ICYmIHRoaXMub3B0aW9ucy5zdHJpY3QgIT09IHRydWUpIHtcbiAgICAgIHZhciBub2RlID0gbGFzdC5ub2Rlc1swXTtcbiAgICAgIG5vZGUudmFsID0gJ1xcXFwnICsgbm9kZS52YWw7XG4gICAgICB2YXIgc2libGluZyA9IG5vZGUucGFyZW50Lm5vZGVzWzFdO1xuICAgICAgaWYgKHNpYmxpbmcudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICAgIHNpYmxpbmcubG9vc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gICAgZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcblxuICAvKipcbiAgICogRGVjb3JhdGUgYC5wYXJzZWAgbWV0aG9kXG4gICAqL1xuXG4gIGRlZmluZSh0aGlzLCAncGFyc2UnLCBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zbmFwZHJhZ29uLnBhcnNlLmFwcGx5KHRoaXMuc25hcGRyYWdvbiwgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlY29yYXRlIGAuY29tcGlsZWAgbWV0aG9kXG4gICAqL1xuXG4gIGRlZmluZSh0aGlzLCAnY29tcGlsZScsIGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNuYXBkcmFnb24uY29tcGlsZS5hcHBseSh0aGlzLnNuYXBkcmFnb24sIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG59XG5cbi8qKlxuICogRXhwb3NlIGBFeHRnbG9iYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXh0Z2xvYjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ2hhcmFjdGVycyB0byB1c2UgaW4gdGV4dCByZWdleCAod2Ugd2FudCB0byBcIm5vdFwiIG1hdGNoXG4gKiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1hdGNoZWQgYnkgb3RoZXIgcGFyc2VycylcbiAqL1xuXG52YXIgVEVYVF9SRUdFWCA9ICcoWyFAKj8rXT9cXFxcKHxcXFxcKXxbKj8uK1xcXFxcXFxcXXxcXFxcWzo/KD89LipcXFxcXSl8Oj9cXFxcXSkrJztcbnZhciBub3QgPSB1dGlscy5jcmVhdGVSZWdleChURVhUX1JFR0VYKTtcblxuLyoqXG4gKiBFeHRnbG9iIHBhcnNlcnNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZXJzKGV4dGdsb2IpIHtcbiAgZXh0Z2xvYi5zdGF0ZSA9IGV4dGdsb2Iuc3RhdGUgfHwge307XG5cbiAgLyoqXG4gICAqIFVzZSBgZXhwYW5kLWJyYWNrZXRzYCBwYXJzZXJzXG4gICAqL1xuXG4gIGV4dGdsb2IudXNlKGJyYWNrZXRzLnBhcnNlcnMpO1xuICBleHRnbG9iLnBhcnNlci5zZXRzLnBhcmVuID0gZXh0Z2xvYi5wYXJzZXIuc2V0cy5wYXJlbiB8fCBbXTtcbiAgZXh0Z2xvYi5wYXJzZXJcblxuICAgIC8qKlxuICAgICAqIEV4dGdsb2Igb3BlbjogXCIqKFwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncGFyZW4ub3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXihbIUAqPytdKT9cXCgvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIHByZWZpeCA9IG1bMV07XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgdmFyIG9wZW4gPSBwb3Moe1xuICAgICAgICB0eXBlOiAncGFyZW4ub3BlbicsXG4gICAgICAgIHBhcnNlZDogcGFyc2VkLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ3BhcmVuJyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIG5vZGVzOiBbb3Blbl1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBuZXN0ZWQgbmVnYXRpb24gZXh0Z2xvYnMsIGp1c3QgY2FuY2VsIHRoZW0gb3V0IHRvIHNpbXBsaWZ5XG4gICAgICBpZiAocHJlZml4ID09PSAnIScgJiYgcHJldi50eXBlID09PSAncGFyZW4nICYmIHByZXYucHJlZml4ID09PSAnIScpIHtcbiAgICAgICAgcHJldi5wcmVmaXggPSAnQCc7XG4gICAgICAgIG5vZGUucHJlZml4ID0gJ0AnO1xuICAgICAgfVxuXG4gICAgICBkZWZpbmUobm9kZSwgJ3Jlc3QnLCB0aGlzLmlucHV0KTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyc2VkJywgcGFyc2VkKTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcHJldik7XG4gICAgICBkZWZpbmUob3BlbiwgJ3BhcmVudCcsIG5vZGUpO1xuXG4gICAgICB0aGlzLnB1c2goJ3BhcmVuJywgbm9kZSk7XG4gICAgICBwcmV2Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEV4dGdsb2IgY2xvc2U6IFwiKVwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncGFyZW4uY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXCkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wb3AoJ3BhcmVuJyk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyh7XG4gICAgICAgIHR5cGU6ICdwYXJlbi5jbG9zZScsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXQsXG4gICAgICAgIHBhcnNlZDogcGFyc2VkLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuaXNUeXBlKHBhcmVudCwgJ3BhcmVuJykpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlbmluZyBwYXJlbjogXCIoXCInKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5wcmVmaXggPSBwYXJlbnQucHJlZml4O1xuICAgICAgcGFyZW50Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHBhcmVudCk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZTogXCJcXFxcLlwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnZXNjYXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxcXCguKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgdmFsOiBtWzBdLFxuICAgICAgICBjaDogbVsxXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcmtzOiBcIj9cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3FtYXJrJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFw/Kyg/IVxcKCkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuICAgICAgZXh0Z2xvYi5zdGF0ZS5tZXRhY2hhciA9IHRydWU7XG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3FtYXJrJyxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dCxcbiAgICAgICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBwYXJzZXJzXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnc3RhcicsIC9eXFwqKD8hXFwoKS8pXG4gICAgLmNhcHR1cmUoJ3BsdXMnLCAvXlxcKyg/IVxcKCkvKVxuICAgIC5jYXB0dXJlKCdkb3QnLCAvXlxcLi8pXG4gICAgLmNhcHR1cmUoJ3RleHQnLCBub3QpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgdGV4dCByZWdleCBzdHJpbmdcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5URVhUX1JFR0VYID0gVEVYVF9SRUdFWDtcblxuLyoqXG4gKiBFeHRnbG9iIHBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIENhY2hlID0gcmVxdWlyZSgnZnJhZ21lbnQtY2FjaGUnKTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG5cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzO1xudmFyIGNhY2hlID0gdXRpbHMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG51dGlscy5hcnJheWlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdmFsXTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBNZW1vaXplIGEgZ2VuZXJhdGVkIHJlZ2V4IG9yIGZ1bmN0aW9uXG4gKi9cblxudXRpbHMubWVtb2l6ZSA9IGZ1bmN0aW9uKHR5cGUsIHBhdHRlcm4sIG9wdGlvbnMsIGZuKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkodHlwZSArIHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gIGlmIChjYWNoZS5oYXModHlwZSwga2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQodHlwZSwga2V5KTtcbiAgfVxuXG4gIHZhciB2YWwgPSBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY2FjaGUuc2V0KHR5cGUsIGtleSwgdmFsKTtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBrZXkgdG8gdXNlIGZvciBtZW1vaXphdGlvbi4gVGhlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbnV0aWxzLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IHBhdHRlcm47XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIGtleSArPSAnOycgKyBwcm9wICsgJz0nICsgU3RyaW5nKG9wdGlvbnNbcHJvcF0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVnZXggdG8gdXNlIGZvciBtYXRjaGluZyB0ZXh0XG4gKi9cblxudXRpbHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIG9wdHMgPSB7Y29udGFpbnM6IHRydWUsIHN0cmljdENsb3NlOiBmYWxzZX07XG4gIHJldHVybiByZWdleChzdHIsIG9wdHMpO1xufTtcbiIsIi8qIVxuICogZmlsbC1yYW5nZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZmlsbC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlcicpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LXN0cmluZycpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleC1yYW5nZScpO1xuXG4vKipcbiAqIFJldHVybiBhIHJhbmdlIG9mIG51bWJlcnMgb3IgbGV0dGVycy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdGFydGAgU3RhcnQgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdG9wYCBFbmQgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdGVwYCBJbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRvIHVzZS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBgZm5gIEN1c3RvbSBmdW5jdGlvbiB0byBtb2RpZnkgZWFjaCBlbGVtZW50IGluIHRoZSByYW5nZS5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGZpbGxSYW5nZShzdGFydCwgc3RvcCwgc3RlcCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RvcCA9PT0gJ3VuZGVmaW5lZCcgfHwgc3RhcnQgPT09IHN0b3ApIHtcbiAgICAvLyBzcGVjaWFsIGNhc2UsIGZvciBoYW5kbGluZyBuZWdhdGl2ZSB6ZXJvXG4gICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJztcbiAgICBpZiAoaXNOdW1iZXIoc3RhcnQpICYmICF0b051bWJlcihzdGFydCkpIHtcbiAgICAgIHJldHVybiBbaXNTdHJpbmcgPyAnMCcgOiAwXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydF07XG4gIH1cblxuICBpZiAodHlwZW9mIHN0ZXAgIT09ICdudW1iZXInICYmIHR5cGVvZiBzdGVwICE9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSBzdGVwO1xuICAgIHN0ZXAgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0geyB0cmFuc2Zvcm06IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHtzdGVwOiBzdGVwfSwgb3B0aW9ucyk7XG4gIGlmIChvcHRzLnN0ZXAgJiYgIWlzVmFsaWROdW1iZXIob3B0cy5zdGVwKSkge1xuICAgIGlmIChvcHRzLnN0cmljdFJhbmdlcyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgb3B0aW9ucy5zdGVwIHRvIGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIG9wdHMuaXNOdW1iZXIgPSBpc1ZhbGlkTnVtYmVyKHN0YXJ0KSAmJiBpc1ZhbGlkTnVtYmVyKHN0b3ApO1xuICBpZiAoIW9wdHMuaXNOdW1iZXIgJiYgIWlzVmFsaWQoc3RhcnQsIHN0b3ApKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW52YWxpZCByYW5nZSBhcmd1bWVudHM6ICcgKyB1dGlsLmluc3BlY3QoW3N0YXJ0LCBzdG9wXSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBvcHRzLmlzUGFkZGVkID0gaXNQYWRkZWQoc3RhcnQpIHx8IGlzUGFkZGVkKHN0b3ApO1xuICBvcHRzLnRvU3RyaW5nID0gb3B0cy5zdHJpbmdpZnlcbiAgICB8fCB0eXBlb2Ygb3B0cy5zdGVwID09PSAnc3RyaW5nJ1xuICAgIHx8IHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZydcbiAgICB8fCB0eXBlb2Ygc3RvcCA9PT0gJ3N0cmluZydcbiAgICB8fCAhb3B0cy5pc051bWJlcjtcblxuICBpZiAob3B0cy5pc1BhZGRlZCkge1xuICAgIG9wdHMubWF4TGVuZ3RoID0gTWF0aC5tYXgoU3RyaW5nKHN0YXJ0KS5sZW5ndGgsIFN0cmluZyhzdG9wKS5sZW5ndGgpO1xuICB9XG5cbiAgLy8gc3VwcG9ydCBsZWdhY3kgbWluaW1hdGNoL2ZpbGwtcmFuZ2Ugb3B0aW9uc1xuICBpZiAodHlwZW9mIG9wdHMub3B0aW1pemUgPT09ICdib29sZWFuJykgb3B0cy50b1JlZ2V4ID0gb3B0cy5vcHRpbWl6ZTtcbiAgaWYgKHR5cGVvZiBvcHRzLm1ha2VSZSA9PT0gJ2Jvb2xlYW4nKSBvcHRzLnRvUmVnZXggPSBvcHRzLm1ha2VSZTtcbiAgcmV0dXJuIGV4cGFuZChzdGFydCwgc3RvcCwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdGFydCwgc3RvcCwgb3B0aW9ucykge1xuICB2YXIgYSA9IG9wdGlvbnMuaXNOdW1iZXIgPyB0b051bWJlcihzdGFydCkgOiBzdGFydC5jaGFyQ29kZUF0KDApO1xuICB2YXIgYiA9IG9wdGlvbnMuaXNOdW1iZXIgPyB0b051bWJlcihzdG9wKSA6IHN0b3AuY2hhckNvZGVBdCgwKTtcblxuICB2YXIgc3RlcCA9IE1hdGguYWJzKHRvTnVtYmVyKG9wdGlvbnMuc3RlcCkpIHx8IDE7XG4gIGlmIChvcHRpb25zLnRvUmVnZXggJiYgc3RlcCA9PT0gMSkge1xuICAgIHJldHVybiB0b1JhbmdlKGEsIGIsIHN0YXJ0LCBzdG9wLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciB6ZXJvID0ge2dyZWF0ZXI6IFtdLCBsZXNzZXI6IFtdfTtcbiAgdmFyIGFzYyA9IGEgPCBiO1xuICB2YXIgYXJyID0gbmV3IEFycmF5KE1hdGgucm91bmQoKGFzYyA/IGIgLSBhIDogYSAtIGIpIC8gc3RlcCkpO1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoYXNjID8gYSA8PSBiIDogYSA+PSBiKSB7XG4gICAgdmFyIHZhbCA9IG9wdGlvbnMuaXNOdW1iZXIgPyBhIDogU3RyaW5nLmZyb21DaGFyQ29kZShhKTtcbiAgICBpZiAob3B0aW9ucy50b1JlZ2V4ICYmICh2YWwgPj0gMCB8fCAhb3B0aW9ucy5pc051bWJlcikpIHtcbiAgICAgIHplcm8uZ3JlYXRlci5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHplcm8ubGVzc2VyLnB1c2goTWF0aC5hYnModmFsKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaXNQYWRkZWQpIHtcbiAgICAgIHZhbCA9IHplcm9zKHZhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudG9TdHJpbmcpIHtcbiAgICAgIHZhbCA9IFN0cmluZyh2YWwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFycltpZHgrK10gPSBvcHRpb25zLnRyYW5zZm9ybSh2YWwsIGEsIGIsIHN0ZXAsIGlkeCwgYXJyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyW2lkeCsrXSA9IHZhbDtcbiAgICB9XG5cbiAgICBpZiAoYXNjKSB7XG4gICAgICBhICs9IHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgLT0gc3RlcDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy50b1JlZ2V4ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRvU2VxdWVuY2UoYXJyLCB6ZXJvLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b1JhbmdlKGEsIGIsIHN0YXJ0LCBzdG9wLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlzUGFkZGVkKSB7XG4gICAgcmV0dXJuIHRvUmVnZXgoc3RhcnQsIHN0b3AsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaXNOdW1iZXIpIHtcbiAgICByZXR1cm4gdG9SZWdleChNYXRoLm1pbihhLCBiKSwgTWF0aC5tYXgoYSwgYiksIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLm1pbihhLCBiKSk7XG4gIHZhciBzdG9wID0gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLm1heChhLCBiKSk7XG4gIHJldHVybiAnWycgKyBzdGFydCArICctJyArIHN0b3AgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHRvU2VxdWVuY2UoYXJyLCB6ZXJvcywgb3B0aW9ucykge1xuICB2YXIgZ3JlYXRlciA9ICcnLCBsZXNzZXIgPSAnJztcbiAgaWYgKHplcm9zLmdyZWF0ZXIubGVuZ3RoKSB7XG4gICAgZ3JlYXRlciA9IHplcm9zLmdyZWF0ZXIuam9pbignfCcpO1xuICB9XG4gIGlmICh6ZXJvcy5sZXNzZXIubGVuZ3RoKSB7XG4gICAgbGVzc2VyID0gJy0oJyArIHplcm9zLmxlc3Nlci5qb2luKCd8JykgKyAnKSc7XG4gIH1cbiAgdmFyIHJlcyA9IGdyZWF0ZXIgJiYgbGVzc2VyXG4gICAgPyBncmVhdGVyICsgJ3wnICsgbGVzc2VyXG4gICAgOiBncmVhdGVyIHx8IGxlc3NlcjtcblxuICBpZiAob3B0aW9ucy5jYXB0dXJlKSB7XG4gICAgcmV0dXJuICcoJyArIHJlcyArICcpJztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB6ZXJvcyh2YWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaXNQYWRkZWQpIHtcbiAgICB2YXIgc3RyID0gU3RyaW5nKHZhbCk7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGRhc2ggPSAnJztcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICBkYXNoID0gJy0nO1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgIH1cbiAgICB2YXIgZGlmZiA9IG9wdGlvbnMubWF4TGVuZ3RoIC0gbGVuO1xuICAgIHZhciBwYWQgPSByZXBlYXQoJzAnLCBkaWZmKTtcbiAgICB2YWwgPSAoZGFzaCArIHBhZCArIHN0cik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaW5naWZ5KSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbCkge1xuICByZXR1cm4gTnVtYmVyKHZhbCkgfHwgMDtcbn1cblxuZnVuY3Rpb24gaXNQYWRkZWQoc3RyKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkKG1pbiwgbWF4KSB7XG4gIHJldHVybiAoaXNWYWxpZE51bWJlcihtaW4pIHx8IGlzVmFsaWRMZXR0ZXIobWluKSlcbiAgICAgICYmIChpc1ZhbGlkTnVtYmVyKG1heCkgfHwgaXNWYWxpZExldHRlcihtYXgpKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZExldHRlcihjaCkge1xuICByZXR1cm4gdHlwZW9mIGNoID09PSAnc3RyaW5nJyAmJiBjaC5sZW5ndGggPT09IDEgJiYgL15cXHcrJC8udGVzdChjaCk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWROdW1iZXIobikge1xuICByZXR1cm4gaXNOdW1iZXIobikgJiYgIS9cXC4vLnRlc3Qobik7XG59XG5cbi8qKlxuICogRXhwb3NlIGBmaWxsUmFuZ2VgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmaWxsUmFuZ2U7XG4iLCIvKiFcbiAqIGZvci1pbiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZm9yLWluPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ySW4ob2JqLCBmbiwgdGhpc0FyZykge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGZuLmNhbGwodGhpc0FyZywgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIVxuICogZnJhZ21lbnQtY2FjaGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2ZyYWdtZW50LWNhY2hlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJ21hcC1jYWNoZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgRnJhZ21lbnRDYWNoZWAgd2l0aCBhbiBvcHRpb25hbCBvYmplY3QgdG8gdXNlIGZvciBgY2FjaGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZyYWdtZW50ID0gbmV3IEZyYWdtZW50Q2FjaGUoKTtcbiAqIGBgYFxuICogQG5hbWUgRnJhZ21lbnRDYWNoZVxuICogQHBhcmFtIHtTdHJpbmd9IGBjYWNoZU5hbWVgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIFttYXAtY2FjaGVdW10gaW5zdGFuY2UuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEZyYWdtZW50Q2FjaGUoY2FjaGVzKSB7XG4gIHRoaXMuY2FjaGVzID0gY2FjaGVzIHx8IHt9O1xufVxuXG4vKipcbiAqIFByb3RvdHlwZVxuICovXG5cbkZyYWdtZW50Q2FjaGUucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBHZXQgY2FjaGUgYG5hbWVgIGZyb20gdGhlIGBmcmFnbWVudC5jYWNoZXNgIG9iamVjdC4gQ3JlYXRlcyBhIG5ld1xuICAgKiBgTWFwQ2FjaGVgIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNhY2hlID0gZnJhZ21lbnQuY2FjaGUoJ2ZpbGVzJyk7XG4gICAqIGNvbnNvbGUubG9nKGZyYWdtZW50LmNhY2hlcy5oYXNPd25Qcm9wZXJ0eSgnZmlsZXMnKSk7XG4gICAqIC8vPT4gdHJ1ZVxuICAgKiBgYGBcbiAgICogQG5hbWUgLmNhY2hlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgY2FjaGVOYW1lYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIFttYXAtY2FjaGVdW10gaW5zdGFuY2UuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGNhY2hlOiBmdW5jdGlvbihjYWNoZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZXNbY2FjaGVOYW1lXSB8fCAodGhpcy5jYWNoZXNbY2FjaGVOYW1lXSA9IG5ldyBNYXBDYWNoZSgpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgZm9yIHByb3BlcnR5IGBrZXlgIG9uIGNhY2hlIGBuYW1lYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBmcmFnbWVudC5zZXQoJ2ZpbGVzJywgJ3NvbWVmaWxlLmpzJywgbmV3IEZpbGUoe3BhdGg6ICdzb21lZmlsZS5qcyd9KSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7YW55fSBgdmFsYCBUaGUgdmFsdWUgb2YgYGtleWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2FjaGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHNldDogZnVuY3Rpb24oY2FjaGVOYW1lLCBrZXksIHZhbCkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUoY2FjaGVOYW1lKTtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWwpO1xuICAgIHJldHVybiBjYWNoZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbm9uLXVuZGVmaW5lZCB2YWx1ZSBpcyBzZXQgZm9yIGBrZXlgIG9uIGZyYWdtZW50IGNhY2hlIGBuYW1lYC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNhY2hlID0gZnJhZ21lbnQuY2FjaGUoJ2ZpbGVzJyk7XG4gICAqIGNhY2hlLnNldCgnc29tZWZpbGUuanMnKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coY2FjaGUuaGFzKCdzb21lZmlsZS5qcycpKTtcbiAgICogLy89PiB0cnVlXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGNhY2hlLmhhcygnc29tZS1vdGhlci1maWxlLmpzJykpO1xuICAgKiAvLz0+IGZhbHNlXG4gICAqIGBgYFxuICAgKiBAbmFtZSAuaGFzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWAgQ2FjaGUgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgT3B0aW9uYWxseSBzcGVjaWZ5IGEgcHJvcGVydHkgdG8gY2hlY2sgZm9yIG9uIGNhY2hlIGBuYW1lYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBoYXM6IGZ1bmN0aW9uKGNhY2hlTmFtZSwga2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmdldChjYWNoZU5hbWUsIGtleSkgIT09ICd1bmRlZmluZWQnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYG5hbWVgLCBvciBpZiBzcGVjaWZpZWQsIHRoZSB2YWx1ZSBvZiBga2V5YC4gSW52b2tlcyB0aGUgW2NhY2hlXSgpIG1ldGhvZCxcbiAgICogc28gdGhhdCBjYWNoZSBgbmFtZWAgd2lsbCBiZSBjcmVhdGVkIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC4gSWYgYGtleWAgaXMgbm90IHBhc3NlZCxcbiAgICogdGhlIGVudGlyZSBjYWNoZSAoYG5hbWVgKSBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIFZpbnlsID0gcmVxdWlyZSgndmlueWwnKTtcbiAgICogdmFyIGNhY2hlID0gZnJhZ21lbnQuY2FjaGUoJ2ZpbGVzJyk7XG4gICAqIGNhY2hlLnNldCgnc29tZWZpbGUuanMnLCBuZXcgVmlueWwoe3BhdGg6ICdzb21lZmlsZS5qcyd9KSk7XG4gICAqIGNvbnNvbGUubG9nKGNhY2hlLmdldCgnc29tZWZpbGUuanMnKSk7XG4gICAqIC8vPT4gPEZpbGUgXCJzb21lZmlsZS5qc1wiPlxuICAgKiBgYGBcbiAgICogQG5hbWUgLmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjYWNoZSBgbmFtZWAsIG9yIHRoZSB2YWx1ZSBvZiBga2V5YCBpZiBzcGVjaWZpZWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZ2V0OiBmdW5jdGlvbihuYW1lLCBrZXkpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlKG5hbWUpO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlIGBGcmFnbWVudENhY2hlYFxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZyYWdtZW50Q2FjaGU7XG4iLCIvKiFcbiAqIGdldC12YWx1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZ2V0LXZhbHVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgYSwgYiwgYykge1xuICBpZiAoIWlzT2JqZWN0KG9iaikgfHwgIXByb3ApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcHJvcCA9IHRvU3RyaW5nKHByb3ApO1xuXG4gIC8vIGFsbG93aW5nIGZvciBtdWx0aXBsZSBwcm9wZXJ0aWVzIHRvIGJlIHBhc3NlZCBhc1xuICAvLyBhIHN0cmluZyBvciBhcnJheSwgYnV0IG11Y2ggZmFzdGVyICgzLTR4KSB0aGFuIGRvaW5nXG4gIC8vIGBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylgXG4gIGlmIChhKSBwcm9wICs9ICcuJyArIHRvU3RyaW5nKGEpO1xuICBpZiAoYikgcHJvcCArPSAnLicgKyB0b1N0cmluZyhiKTtcbiAgaWYgKGMpIHByb3AgKz0gJy4nICsgdG9TdHJpbmcoYyk7XG5cbiAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgfVxuXG4gIHZhciBzZWdzID0gcHJvcC5zcGxpdCgnLicpO1xuICB2YXIgbGVuID0gc2Vncy5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG5cbiAgd2hpbGUgKG9iaiAmJiAoKytpIDwgbGVuKSkge1xuICAgIHZhciBrZXkgPSBzZWdzW2ldO1xuICAgIHdoaWxlIChrZXlba2V5Lmxlbmd0aCAtIDFdID09PSAnXFxcXCcpIHtcbiAgICAgIGtleSA9IGtleS5zbGljZSgwLCAtMSkgKyAnLicgKyBzZWdzWysraV07XG4gICAgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICBpZiAoIXZhbCkgcmV0dXJuICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNnbG9iID0gcmVxdWlyZSgnaXMtZ2xvYicpO1xudmFyIHBhdGhEaXJuYW1lID0gcmVxdWlyZSgncGF0aC1kaXJuYW1lJyk7XG52YXIgaXNXaW4zMiA9IHJlcXVpcmUoJ29zJykucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnbG9iUGFyZW50KHN0cikge1xuXHQvLyBmbGlwIHdpbmRvd3MgcGF0aCBzZXBhcmF0b3JzXG5cdGlmIChpc1dpbjMyICYmIHN0ci5pbmRleE9mKCcvJykgPCAwKSBzdHIgPSBzdHIuc3BsaXQoJ1xcXFwnKS5qb2luKCcvJyk7XG5cblx0Ly8gc3BlY2lhbCBjYXNlIGZvciBzdHJpbmdzIGVuZGluZyBpbiBlbmNsb3N1cmUgY29udGFpbmluZyBwYXRoIHNlcGFyYXRvclxuXHRpZiAoL1tcXHtcXFtdLipbXFwvXSouKltcXH1cXF1dJC8udGVzdChzdHIpKSBzdHIgKz0gJy8nO1xuXG5cdC8vIHByZXNlcnZlcyBmdWxsIHBhdGggaW4gY2FzZSBvZiB0cmFpbGluZyBwYXRoIHNlcGFyYXRvclxuXHRzdHIgKz0gJ2EnO1xuXG5cdC8vIHJlbW92ZSBwYXRoIHBhcnRzIHRoYXQgYXJlIGdsb2JieVxuXHRkbyB7c3RyID0gcGF0aERpcm5hbWUucG9zaXgoc3RyKX1cblx0d2hpbGUgKGlzZ2xvYihzdHIpIHx8IC8oXnxbXlxcXFxdKShbXFx7XFxbXXxcXChbXlxcKV0rJCkvLnRlc3Qoc3RyKSk7XG5cblx0Ly8gcmVtb3ZlIGVzY2FwZSBjaGFycyBhbmQgcmV0dXJuIHJlc3VsdFxuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwoW1xcKlxcP1xcfFxcW1xcXVxcKFxcKVxce1xcfV0pL2csICckMScpO1xufTtcbiIsIi8qIVxuICogaXMtZ2xvYiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZ2xvYj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxudmFyIGlzRXh0Z2xvYiA9IHJlcXVpcmUoJ2lzLWV4dGdsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dsb2Ioc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCBzdHIgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRXh0Z2xvYihzdHIpKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgcmVnZXggPSAvKFxcXFwpLnwoWyo/XXxcXFsuKlxcXXxcXHsuKlxcfXxcXCguKlxcfC4qXFwpfF4hKS87XG4gIHZhciBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhzdHIpKSkge1xuICAgIGlmIChtYXRjaFsyXSkgcmV0dXJuIHRydWU7XG4gICAgc3RyID0gc3RyLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgIHJldHVybiBvYmpcblxuICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgIHZhciBjb3B5ID0geyBfX3Byb3RvX186IG9iai5fX3Byb3RvX18gfVxuICBlbHNlXG4gICAgdmFyIGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29weSwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSlcbiAgfSlcblxuICByZXR1cm4gY29weVxufVxuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHBvbHlmaWxscyA9IHJlcXVpcmUoJy4vcG9seWZpbGxzLmpzJylcbnZhciBsZWdhY3kgPSByZXF1aXJlKCcuL2xlZ2FjeS1zdHJlYW1zLmpzJylcbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIG5vZGUgMC54IHBvbHlmaWxsICovXG52YXIgZ3JhY2VmdWxRdWV1ZVxudmFyIHByZXZpb3VzU3ltYm9sXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGdyYWNlZnVsUXVldWUgPSBTeW1ib2wuZm9yKCdncmFjZWZ1bC1mcy5xdWV1ZScpXG4gIC8vIFRoaXMgaXMgdXNlZCBpbiB0ZXN0aW5nIGJ5IGZ1dHVyZSB2ZXJzaW9uc1xuICBwcmV2aW91c1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnByZXZpb3VzJylcbn0gZWxzZSB7XG4gIGdyYWNlZnVsUXVldWUgPSAnX19fZ3JhY2VmdWwtZnMucXVldWUnXG4gIHByZXZpb3VzU3ltYm9sID0gJ19fX2dyYWNlZnVsLWZzLnByZXZpb3VzJ1xufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIHB1Ymxpc2hRdWV1ZShjb250ZXh0LCBxdWV1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dCwgZ3JhY2VmdWxRdWV1ZSwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcXVldWVcbiAgICB9XG4gIH0pXG59XG5cbnZhciBkZWJ1ZyA9IG5vb3BcbmlmICh1dGlsLmRlYnVnbG9nKVxuICBkZWJ1ZyA9IHV0aWwuZGVidWdsb2coJ2dmczQnKVxuZWxzZSBpZiAoL1xcYmdmczRcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJycpKVxuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKVxuICAgIG0gPSAnR0ZTNDogJyArIG0uc3BsaXQoL1xcbi8pLmpvaW4oJ1xcbkdGUzQ6ICcpXG4gICAgY29uc29sZS5lcnJvcihtKVxuICB9XG5cbi8vIE9uY2UgdGltZSBpbml0aWFsaXphdGlvblxuaWYgKCFmc1tncmFjZWZ1bFF1ZXVlXSkge1xuICAvLyBUaGlzIHF1ZXVlIGNhbiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgbG9hZGVkIGluc3RhbmNlc1xuICB2YXIgcXVldWUgPSBnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0gfHwgW11cbiAgcHVibGlzaFF1ZXVlKGZzLCBxdWV1ZSlcblxuICAvLyBQYXRjaCBmcy5jbG9zZS9jbG9zZVN5bmMgdG8gc2hhcmVkIHF1ZXVlIHZlcnNpb24sIGJlY2F1c2Ugd2UgbmVlZFxuICAvLyB0byByZXRyeSgpIHdoZW5ldmVyIGEgY2xvc2UgaGFwcGVucyAqYW55d2hlcmUqIGluIHRoZSBwcm9ncmFtLlxuICAvLyBUaGlzIGlzIGVzc2VudGlhbCB3aGVuIG11bHRpcGxlIGdyYWNlZnVsLWZzIGluc3RhbmNlcyBhcmVcbiAgLy8gaW4gcGxheSBhdCB0aGUgc2FtZSB0aW1lLlxuICBmcy5jbG9zZSA9IChmdW5jdGlvbiAoZnMkY2xvc2UpIHtcbiAgICBmdW5jdGlvbiBjbG9zZSAoZmQsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkY2xvc2UuY2FsbChmcywgZmQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXRyeSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkRmlsZSwgW3BhdGgsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRhcHBlbmRGaWxlID0gZnMuYXBwZW5kRmlsZVxuICBpZiAoZnMkYXBwZW5kRmlsZSlcbiAgICBmcy5hcHBlbmRGaWxlID0gYXBwZW5kRmlsZVxuICBmdW5jdGlvbiBhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBhcmdzID0gW3BhdGhdXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBvcHRpb25zXG4gICAgfVxuICAgIGFyZ3MucHVzaChnbyRyZWFkZGlyJGNiKVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIoYXJncylcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRkaXIkY2IgKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgIGVucXVldWUoW2dvJHJlYWRkaXIsIFthcmdzXV0pXG5cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgcmV0cnkoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvJHJlYWRkaXIgKGFyZ3MpIHtcbiAgICByZXR1cm4gZnMkcmVhZGRpci5hcHBseShmcywgYXJncylcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkb3BlbihwYXRoLCBmbGFncywgbW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kb3BlbiwgW3BhdGgsIGZsYWdzLCBtb2RlLCBjYl1dKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxufVxuXG5mdW5jdGlvbiByZXRyeSAoKSB7XG4gIHZhciBlbGVtID0gZnNbZ3JhY2VmdWxRdWV1ZV0uc2hpZnQoKVxuICBpZiAoZWxlbSkge1xuICAgIGRlYnVnKCdSRVRSWScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgICBlbGVtWzBdLmFwcGx5KG51bGwsIGVsZW1bMV0pXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJylcblxudmFyIG9yaWdDd2QgPSBwcm9jZXNzLmN3ZFxudmFyIGN3ZCA9IG51bGxcblxudmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuR1JBQ0VGVUxfRlNfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWN3ZClcbiAgICBjd2QgPSBvcmlnQ3dkLmNhbGwocHJvY2VzcylcbiAgcmV0dXJuIGN3ZFxufVxudHJ5IHtcbiAgcHJvY2Vzcy5jd2QoKVxufSBjYXRjaCAoZXIpIHt9XG5cbnZhciBjaGRpciA9IHByb2Nlc3MuY2hkaXJcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbihkKSB7XG4gIGN3ZCA9IG51bGxcbiAgY2hkaXIuY2FsbChwcm9jZXNzLCBkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyAocmUtKWltcGxlbWVudCBzb21lIHRoaW5ncyB0aGF0IGFyZSBrbm93biBidXN0ZWQgb3IgbWlzc2luZy5cblxuICAvLyBsY2htb2QsIGJyb2tlbiBwcmlvciB0byAwLjYuMlxuICAvLyBiYWNrLXBvcnQgdGhlIGZpeCBoZXJlLlxuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KCdPX1NZTUxJTksnKSAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9edjBcXC42XFwuWzAtMl18XnYwXFwuNVxcLi8pKSB7XG4gICAgcGF0Y2hMY2htb2QoZnMpXG4gIH1cblxuICAvLyBsdXRpbWVzIGltcGxlbWVudGF0aW9uLCBvciBuby1vcFxuICBpZiAoIWZzLmx1dGltZXMpIHtcbiAgICBwYXRjaEx1dGltZXMoZnMpXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvaXNzdWVzLzRcbiAgLy8gQ2hvd24gc2hvdWxkIG5vdCBmYWlsIG9uIGVpbnZhbCBvciBlcGVybSBpZiBub24tcm9vdC5cbiAgLy8gSXQgc2hvdWxkIG5vdCBmYWlsIG9uIGVub3N5cyBldmVyLCBhcyB0aGlzIGp1c3QgaW5kaWNhdGVzXG4gIC8vIHRoYXQgYSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIGludGVuZGVkIG9wZXJhdGlvbi5cblxuICBmcy5jaG93biA9IGNob3duRml4KGZzLmNob3duKVxuICBmcy5mY2hvd24gPSBjaG93bkZpeChmcy5mY2hvd24pXG4gIGZzLmxjaG93biA9IGNob3duRml4KGZzLmxjaG93bilcblxuICBmcy5jaG1vZCA9IGNobW9kRml4KGZzLmNobW9kKVxuICBmcy5mY2htb2QgPSBjaG1vZEZpeChmcy5mY2htb2QpXG4gIGZzLmxjaG1vZCA9IGNobW9kRml4KGZzLmxjaG1vZClcblxuICBmcy5jaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuY2hvd25TeW5jKVxuICBmcy5mY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmZjaG93blN5bmMpXG4gIGZzLmxjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMubGNob3duU3luYylcblxuICBmcy5jaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuY2htb2RTeW5jKVxuICBmcy5mY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmZjaG1vZFN5bmMpXG4gIGZzLmxjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMubGNobW9kU3luYylcblxuICBmcy5zdGF0ID0gc3RhdEZpeChmcy5zdGF0KVxuICBmcy5mc3RhdCA9IHN0YXRGaXgoZnMuZnN0YXQpXG4gIGZzLmxzdGF0ID0gc3RhdEZpeChmcy5sc3RhdClcblxuICBmcy5zdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLnN0YXRTeW5jKVxuICBmcy5mc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5mc3RhdFN5bmMpXG4gIGZzLmxzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmxzdGF0U3luYylcblxuICAvLyBpZiBsY2htb2QvbGNob3duIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIHRoZW0gbm8tb3BzXG4gIGlmICghZnMubGNobW9kKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG4gIGlmICghZnMubGNob3duKSB7XG4gICAgZnMubGNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2hvd25TeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIC8vIG9uIFdpbmRvd3MsIEEvViBzb2Z0d2FyZSBjYW4gbG9jayB0aGUgZGlyZWN0b3J5LCBjYXVzaW5nIHRoaXNcbiAgLy8gdG8gZmFpbCB3aXRoIGFuIEVBQ0NFUyBvciBFUEVSTSBpZiB0aGUgZGlyZWN0b3J5IGNvbnRhaW5zIG5ld2x5XG4gIC8vIGNyZWF0ZWQgZmlsZXMuICBUcnkgYWdhaW4gb24gZmFpbHVyZSwgZm9yIHVwIHRvIDYwIHNlY29uZHMuXG5cbiAgLy8gU2V0IHRoZSB0aW1lb3V0IHRoaXMgbG9uZyBiZWNhdXNlIHNvbWUgV2luZG93cyBBbnRpLVZpcnVzLCBzdWNoIGFzIFBhcml0eVxuICAvLyBiaXQ5LCBtYXkgbG9jayBmaWxlcyBmb3IgdXAgdG8gYSBtaW51dGUsIGNhdXNpbmcgbnBtIHBhY2thZ2UgaW5zdGFsbFxuICAvLyBmYWlsdXJlcy4gQWxzbywgdGFrZSBjYXJlIHRvIHlpZWxkIHRoZSBzY2hlZHVsZXIuIFdpbmRvd3Mgc2NoZWR1bGluZyBnaXZlc1xuICAvLyBDUFUgdG8gYSBidXN5IGxvb3BpbmcgcHJvY2Vzcywgd2hpY2ggY2FuIGNhdXNlIHRoZSBwcm9ncmFtIGNhdXNpbmcgdGhlIGxvY2tcbiAgLy8gY29udGVudGlvbiB0byBiZSBzdGFydmVkIG9mIENQVSBieSBub2RlLCBzbyB0aGUgY29udGVudGlvbiBkb2Vzbid0IHJlc29sdmUuXG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgZnMucmVuYW1lID0gKGZ1bmN0aW9uIChmcyRyZW5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmcm9tLCB0bywgY2IpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgIGlmIChlclxuICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnMuc3RhdCh0bywgZnVuY3Rpb24gKHN0YXRlciwgc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBiYWNrb2ZmKVxuICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgIH0pXG4gICAgfX0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIHJlYWQuX19wcm90b19fID0gZnMkcmVhZFxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSkge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgICAgaWYgKGNiKSBjYihlciB8fCBlcjIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LKVxuICAgICAgICB2YXIgcmV0XG4gICAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsIi8qIVxuICogaGFzLXZhbHVlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9oYXMtdmFsdWU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBoYXNWYWx1ZXMgPSByZXF1aXJlKCdoYXMtdmFsdWVzJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnZ2V0LXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gIHJldHVybiBoYXNWYWx1ZXMoaXNPYmplY3QodmFsKSAmJiBwcm9wID8gZ2V0KHZhbCwgcHJvcCkgOiB2YWwpO1xufTtcbiIsIi8qIVxuICogaGFzLXZhbHVlcyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaGFzLXZhbHVlcz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVmFsdWUodmFsKSB7XG4gIC8vIGlzLW51bWJlciBjaGVja3MgZm9yIE5hTiBhbmQgb3RoZXIgZWRnZSBjYXNlc1xuICBpZiAoaXNOdW1iZXIodmFsKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlT2YodmFsKSkge1xuICAgIGNhc2UgJ251bGwnOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnYXJndW1lbnRzJzpcbiAgICAgIHJldHVybiB2YWwubGVuZ3RoICE9PSAwO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiB2YWwubWVzc2FnZSAhPT0gJyc7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG4gICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc1ZhbHVlKHZhbFtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIGNhc2UgJ21hcCc6XG4gICAgY2FzZSAnc2V0JzpcbiAgICAgIHJldHVybiB2YWwuc2l6ZSAhPT0gMDtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGhhc1ZhbHVlKHZhbFtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbiIsInZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgdHlwZW9mYCBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAgeyp9IGB2YWxgXG4gKiBAcmV0dXJuIHsqfSBOYXRpdmUgamF2YXNjcmlwdCB0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIC8vIHByaW1pdGl2aWVzXG4gIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBpZiAodmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgIHJldHVybiAnYm9vbGVhbic7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbic7XG4gIH1cblxuICAvLyBhcnJheVxuICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiBSZWdFeHAgYW5kIERhdGUgYmVmb3JlIGNhbGxpbmcgYHRvU3RyaW5nYFxuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuICdkYXRlJztcbiAgfVxuXG4gIC8vIG90aGVyIG9iamVjdHNcbiAgdmFyIHR5cGUgPSB0b1N0cmluZy5jYWxsKHZhbCk7XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgIHJldHVybiAnYXJndW1lbnRzJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBQcm9taXNlXScpIHtcbiAgICByZXR1cm4gJ3Byb21pc2UnO1xuICB9XG5cbiAgLy8gYnVmZmVyXG4gIGlmIChpc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuICdidWZmZXInO1xuICB9XG5cbiAgLy8gZXM2OiBNYXAsIFdlYWtNYXAsIFNldCwgV2Vha1NldFxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU2V0XScpIHtcbiAgICByZXR1cm4gJ3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtTZXRdJykge1xuICAgIHJldHVybiAnd2Vha3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgcmV0dXJuICdtYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrTWFwXScpIHtcbiAgICByZXR1cm4gJ3dlYWttYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTeW1ib2xdJykge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuXG4gIC8vIHR5cGVkIGFycmF5c1xuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAndWludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICdpbnQxNmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDE2QXJyYXldJykge1xuICAgIHJldHVybiAndWludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgIHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIC8vIG11c3QgYmUgYSBwbGFpbiBvYmplY3RcbiAgcmV0dXJuICdvYmplY3QnO1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogaXMtYWNjZXNzb3ItZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtYWNjZXNzb3ItZGVzY3JpcHRvcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxuLy8gYWNjZXNzb3IgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG52YXIgYWNjZXNzb3IgPSB7XG4gIGdldDogJ2Z1bmN0aW9uJyxcbiAgc2V0OiAnZnVuY3Rpb24nLFxuICBjb25maWd1cmFibGU6ICdib29sZWFuJyxcbiAgZW51bWVyYWJsZTogJ2Jvb2xlYW4nXG59O1xuXG5mdW5jdGlvbiBpc0FjY2Vzc29yRGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2YWwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKHR5cGVPZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXMob2JqLCAndmFsdWUnKSB8fCBoYXMob2JqLCAnd3JpdGFibGUnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaGFzKG9iaiwgJ2dldCcpIHx8IHR5cGVvZiBvYmouZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdGxkcjogaXQncyB2YWxpZCB0byBoYXZlIFwic2V0XCIgYmUgdW5kZWZpbmVkXG4gIC8vIFwic2V0XCIgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYFxuICAvLyB3YXMgdXNlZCB0byBnZXQgdGhlIHZhbHVlLCBhbmQgb25seSBgZ2V0YCB3YXMgZGVmaW5lZCBieSB0aGUgdXNlclxuICBpZiAoaGFzKG9iaiwgJ3NldCcpICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmICghYWNjZXNzb3IuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZihvYmpba2V5XSkgPT09IGFjY2Vzc29yW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgaXNBY2Nlc3NvckRlc2NyaXB0b3JgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FjY2Vzc29yRGVzY3JpcHRvcjtcbiIsInZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgdHlwZW9mYCBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAgeyp9IGB2YWxgXG4gKiBAcmV0dXJuIHsqfSBOYXRpdmUgamF2YXNjcmlwdCB0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIC8vIHByaW1pdGl2aWVzXG4gIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBpZiAodmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgIHJldHVybiAnYm9vbGVhbic7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbic7XG4gIH1cblxuICAvLyBhcnJheVxuICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiBSZWdFeHAgYW5kIERhdGUgYmVmb3JlIGNhbGxpbmcgYHRvU3RyaW5nYFxuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuICdkYXRlJztcbiAgfVxuXG4gIC8vIG90aGVyIG9iamVjdHNcbiAgdmFyIHR5cGUgPSB0b1N0cmluZy5jYWxsKHZhbCk7XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgIHJldHVybiAnYXJndW1lbnRzJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgLy8gYnVmZmVyXG4gIGlmIChpc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuICdidWZmZXInO1xuICB9XG5cbiAgLy8gZXM2OiBNYXAsIFdlYWtNYXAsIFNldCwgV2Vha1NldFxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU2V0XScpIHtcbiAgICByZXR1cm4gJ3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtTZXRdJykge1xuICAgIHJldHVybiAnd2Vha3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgcmV0dXJuICdtYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrTWFwXScpIHtcbiAgICByZXR1cm4gJ3dlYWttYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTeW1ib2xdJykge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuXG4gIC8vIHR5cGVkIGFycmF5c1xuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAndWludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICdpbnQxNmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDE2QXJyYXldJykge1xuICAgIHJldHVybiAndWludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgIHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIC8vIG11c3QgYmUgYSBwbGFpbiBvYmplY3RcbiAgcmV0dXJuICdvYmplY3QnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGJpbmFyeUV4dGVuc2lvbnMgPSByZXF1aXJlKCdiaW5hcnktZXh0ZW5zaW9ucycpO1xudmFyIGV4dHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5iaW5hcnlFeHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdGV4dHNbZWxdID0gdHJ1ZTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuXHRyZXR1cm4gcGF0aC5leHRuYW1lKGZpbGVwYXRoKS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpIGluIGV4dHM7XG59O1xuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvKiFcbiAqIGlzLWRhdGEtZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZGF0YS1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG4vLyBkYXRhIGRlc2NyaXB0b3IgcHJvcGVydGllc1xudmFyIGRhdGEgPSB7XG4gIGNvbmZpZ3VyYWJsZTogJ2Jvb2xlYW4nLFxuICBlbnVtZXJhYmxlOiAnYm9vbGVhbicsXG4gIHdyaXRhYmxlOiAnYm9vbGVhbidcbn07XG5cbmZ1bmN0aW9uIGlzRGF0YURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gIGlmICh0eXBlT2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAoISgndmFsdWUnIGluIG9iaikgJiYgISgnd3JpdGFibGUnIGluIG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykgY29udGludWU7XG5cbiAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZihvYmpba2V5XSkgPT09IGRhdGFba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRXhwb3NlIGBpc0RhdGFEZXNjcmlwdG9yYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNEYXRhRGVzY3JpcHRvcjtcbiIsInZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogR2V0IHRoZSBuYXRpdmUgYHR5cGVvZmAgYSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gIHsqfSBgdmFsYFxuICogQHJldHVybiB7Kn0gTmF0aXZlIGphdmFzY3JpcHQgdHlwZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgLy8gcHJpbWl0aXZpZXNcbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgcmV0dXJuICdib29sZWFuJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICAvLyBmdW5jdGlvbnNcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5uYW1lICE9PSAndW5kZWZpbmVkJyAmJiB2YWwuY29uc3RydWN0b3IubmFtZS5zbGljZSgwLCA5KSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgIHJldHVybiAnZ2VuZXJhdG9yZnVuY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIFJlZ0V4cCBhbmQgRGF0ZSBiZWZvcmUgY2FsbGluZyBgdG9TdHJpbmdgXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG5cbiAgLy8gb3RoZXIgb2JqZWN0c1xuICB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiAncmVnZXhwJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgcmV0dXJuICdkYXRlJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScpIHtcbiAgICByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nKSB7XG4gICAgcmV0dXJuICdwcm9taXNlJztcbiAgfVxuXG4gIC8vIGJ1ZmZlclxuICBpZiAoaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiAnYnVmZmVyJztcbiAgfVxuXG4gIC8vIGVzNjogTWFwLCBXZWFrTWFwLCBTZXQsIFdlYWtTZXRcbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFNldF0nKSB7XG4gICAgcmV0dXJuICdzZXQnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrU2V0XScpIHtcbiAgICByZXR1cm4gJ3dlYWtzZXQnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBNYXBdJykge1xuICAgIHJldHVybiAnbWFwJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nKSB7XG4gICAgcmV0dXJuICd3ZWFrbWFwJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJykge1xuICAgIHJldHVybiAnbWFwaXRlcmF0b3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJykge1xuICAgIHJldHVybiAnc2V0aXRlcmF0b3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJykge1xuICAgIHJldHVybiAnc3RyaW5naXRlcmF0b3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nKSB7XG4gICAgcmV0dXJuICdhcnJheWl0ZXJhdG9yJztcbiAgfVxuICBcbiAgLy8gdHlwZWQgYXJyYXlzXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAnaW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgIHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MTZhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgIHJldHVybiAnaW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgLy8gbXVzdCBiZSBhIHBsYWluIG9iamVjdFxuICByZXR1cm4gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU2FmYXJpIDUtNyAoOC0xMCB5ci1vbGQgYnJvd3NlciksXG4gKiB0YWtlIGEgbG9vayBhdCBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2lzLWJ1ZmZlclxuICovXG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuIiwiLyohXG4gKiBpcy1leHRlbmRhYmxlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1leHRlbmRhYmxlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXh0ZW5kYWJsZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbFxuICAgICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKTtcbn07XG4iLCIvKiFcbiAqIGlzLWV4dGdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRnbG9iKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IC8oXFxcXCkufChbQD8hKypdXFwoLipcXCkpL2cuZXhlYyhzdHIpKSkge1xuICAgIGlmIChtYXRjaFsyXSkgcmV0dXJuIHRydWU7XG4gICAgc3RyID0gc3RyLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKiFcbiAqIGlzLWdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbnZhciBpc0V4dGdsb2IgPSByZXF1aXJlKCdpcy1leHRnbG9iJyk7XG52YXIgY2hhcnMgPSB7ICd7JzogJ30nLCAnKCc6ICcpJywgJ1snOiAnXSd9O1xudmFyIHN0cmljdFJlZ2V4ID0gL1xcXFwoLil8KF4hfFxcKnxbXFxdLispXVxcP3xcXFtbXlxcXFxcXF1dK1xcXXxcXHtbXlxcXFx9XStcXH18XFwoXFw/WzohPV1bXlxcXFwpXStcXCl8XFwoW158XStcXHxbXlxcXFwpXStcXCkpLztcbnZhciByZWxheGVkUmVnZXggPSAvXFxcXCguKXwoXiF8Wyo/e30oKVtcXF1dfFxcKFxcPykvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2xvYihzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IHN0ciA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNFeHRnbG9iKHN0cikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZWdleCA9IHN0cmljdFJlZ2V4O1xuICB2YXIgbWF0Y2g7XG5cbiAgLy8gb3B0aW9uYWxseSByZWxheCByZWdleFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICByZWdleCA9IHJlbGF4ZWRSZWdleDtcbiAgfVxuXG4gIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHN0cikpKSB7XG4gICAgaWYgKG1hdGNoWzJdKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgaWR4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBpZiBhbiBvcGVuIGJyYWNrZXQvYnJhY2UvcGFyZW4gaXMgZXNjYXBlZCxcbiAgICAvLyBzZXQgdGhlIGluZGV4IHRvIHRoZSBuZXh0IGNsb3NpbmcgY2hhcmFjdGVyXG4gICAgdmFyIG9wZW4gPSBtYXRjaFsxXTtcbiAgICB2YXIgY2xvc2UgPSBvcGVuID8gY2hhcnNbb3Blbl0gOiBudWxsO1xuICAgIGlmIChvcGVuICYmIGNsb3NlKSB7XG4gICAgICB2YXIgbiA9IHN0ci5pbmRleE9mKGNsb3NlLCBpZHgpO1xuICAgICAgaWYgKG4gIT09IC0xKSB7XG4gICAgICAgIGlkeCA9IG4gKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0ciA9IHN0ci5zbGljZShpZHgpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKiFcbiAqIGlzLW51bWJlciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtbnVtYmVyPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gIHZhciB0eXBlID0gdHlwZU9mKG51bSk7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFudW0udHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAodHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gKG51bSAtIG51bSArIDEpID49IDA7XG59O1xuIiwiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG5mdW5jdGlvbiBpc09iamVjdE9iamVjdChvKSB7XG4gIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZVxuICAgICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIGlzLXdpbmRvd3MgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXdpbmRvd3M+XG4gKlxuICogQ29weXJpZ2h0IMKpIDIwMTUtMjAxOCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgaWYgKGV4cG9ydHMgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5pc1dpbmRvd3MgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWwuaXNXaW5kb3dzID0gZmFjdG9yeSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNlbGYuaXNXaW5kb3dzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNXaW5kb3dzID0gZmFjdG9yeSgpO1xuICB9XG59KShmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICByZXR1cm4gZnVuY3Rpb24gaXNXaW5kb3dzKCkge1xuICAgIHJldHVybiBwcm9jZXNzICYmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInIHx8IC9eKG1zeXN8Y3lnd2luKSQvLnRlc3QocHJvY2Vzcy5lbnYuT1NUWVBFKSk7XG4gIH07XG59KTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiBpc29iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXNvYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkpTT041ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0XHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG5cdH1cblxuXHR2YXIgX2dsb2JhbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcblx0dmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG5cdCAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblx0ICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdGlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSB7IF9fZyA9IGdsb2JhbDsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdH0pO1xuXG5cdHZhciBfY29yZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi41JyB9O1xuXHRpZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgeyBfX2UgPSBjb3JlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0fSk7XG5cdHZhciBfY29yZV8xID0gX2NvcmUudmVyc2lvbjtcblxuXHR2YXIgX2lzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHR2YXIgX2FuT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKCFfaXNPYmplY3QoaXQpKSB7IHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTsgfVxuXHQgIHJldHVybiBpdDtcblx0fTtcblxuXHR2YXIgX2ZhaWxzID0gZnVuY3Rpb24gKGV4ZWMpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuICEhZXhlYygpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0fTtcblxuXHQvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5cdHZhciBfZGVzY3JpcHRvcnMgPSAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcblx0fSk7XG5cblx0dmFyIGRvY3VtZW50ID0gX2dsb2JhbC5kb2N1bWVudDtcblx0Ly8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cdHZhciBpcyA9IF9pc09iamVjdChkb2N1bWVudCkgJiYgX2lzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXHR2YXIgX2RvbUNyZWF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG5cdH07XG5cblx0dmFyIF9pZThEb21EZWZpbmUgPSAhX2Rlc2NyaXB0b3JzICYmICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RvbUNyZWF0ZSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xuXHR9KTtcblxuXHQvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcblxuXHQvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuXHQvLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xuXHR2YXIgX3RvUHJpbWl0aXZlID0gZnVuY3Rpb24gKGl0LCBTKSB7XG5cdCAgaWYgKCFfaXNPYmplY3QoaXQpKSB7IHJldHVybiBpdDsgfVxuXHQgIHZhciBmbiwgdmFsO1xuXHQgIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgeyByZXR1cm4gdmFsOyB9XG5cdCAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSB7IHJldHVybiB2YWw7IH1cblx0ICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSB7IHJldHVybiB2YWw7IH1cblx0ICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG5cdH07XG5cblx0dmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdHZhciBmID0gX2Rlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuXHQgIF9hbk9iamVjdChPKTtcblx0ICBQID0gX3RvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIF9hbk9iamVjdChBdHRyaWJ1dGVzKTtcblx0ICBpZiAoX2llOERvbURlZmluZSkgeyB0cnkge1xuXHQgICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuXHQgIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfSB9XG5cdCAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgeyB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpOyB9XG5cdCAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgeyBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTsgfVxuXHQgIHJldHVybiBPO1xuXHR9O1xuXG5cdHZhciBfb2JqZWN0RHAgPSB7XG5cdFx0ZjogZlxuXHR9O1xuXG5cdHZhciBfcHJvcGVydHlEZXNjID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcblx0ICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcblx0ICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuXHQgICAgdmFsdWU6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuXHR2YXIgX2hpZGUgPSBfZGVzY3JpcHRvcnMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgcmV0dXJuIF9vYmplY3REcC5mKG9iamVjdCwga2V5LCBfcHJvcGVydHlEZXNjKDEsIHZhbHVlKSk7XG5cdH0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICByZXR1cm4gb2JqZWN0O1xuXHR9O1xuXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXHR2YXIgX2hhcyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG5cdH07XG5cblx0dmFyIGlkID0gMDtcblx0dmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcblx0dmFyIF91aWQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcblx0fTtcblxuXHR2YXIgX2xpYnJhcnkgPSBmYWxzZTtcblxuXHR2YXIgX3NoYXJlZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0dmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xuXHR2YXIgc3RvcmUgPSBfZ2xvYmFsW1NIQVJFRF0gfHwgKF9nbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuXHQobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xuXHR9KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG5cdCAgdmVyc2lvbjogX2NvcmUudmVyc2lvbixcblx0ICBtb2RlOiBfbGlicmFyeSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuXHQgIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG5cdH0pO1xuXHR9KTtcblxuXHR2YXIgX2Z1bmN0aW9uVG9TdHJpbmcgPSBfc2hhcmVkKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuXG5cdHZhciBfcmVkZWZpbmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdHZhciBTUkMgPSBfdWlkKCdzcmMnKTtcblxuXHR2YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcblx0dmFyIFRQTCA9ICgnJyArIF9mdW5jdGlvblRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5cdF9jb3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gX2Z1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG5cdH07XG5cblx0KG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG5cdCAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG5cdCAgaWYgKGlzRnVuY3Rpb24pIHsgX2hhcyh2YWwsICduYW1lJykgfHwgX2hpZGUodmFsLCAnbmFtZScsIGtleSk7IH1cblx0ICBpZiAoT1trZXldID09PSB2YWwpIHsgcmV0dXJuOyB9XG5cdCAgaWYgKGlzRnVuY3Rpb24pIHsgX2hhcyh2YWwsIFNSQykgfHwgX2hpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTsgfVxuXHQgIGlmIChPID09PSBfZ2xvYmFsKSB7XG5cdCAgICBPW2tleV0gPSB2YWw7XG5cdCAgfSBlbHNlIGlmICghc2FmZSkge1xuXHQgICAgZGVsZXRlIE9ba2V5XTtcblx0ICAgIF9oaWRlKE8sIGtleSwgdmFsKTtcblx0ICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuXHQgICAgT1trZXldID0gdmFsO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBfaGlkZShPLCBrZXksIHZhbCk7XG5cdCAgfVxuXHQvLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcblx0fSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCBfZnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9KTtcblx0fSk7XG5cblx0dmFyIF9hRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXQpIHtcblx0ICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHsgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTsgfVxuXHQgIHJldHVybiBpdDtcblx0fTtcblxuXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblxuXHR2YXIgX2N0eCA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG5cdCAgX2FGdW5jdGlvbihmbik7XG5cdCAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZm47IH1cblx0ICBzd2l0Y2ggKGxlbmd0aCkge1xuXHQgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG5cdCAgICB9O1xuXHQgIH1cblx0ICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdH07XG5cblx0dmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG5cdHZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuXHQgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuXHQgIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuXHQgIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuXHQgIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG5cdCAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuXHQgIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBfZ2xvYmFsIDogSVNfU1RBVElDID8gX2dsb2JhbFtuYW1lXSB8fCAoX2dsb2JhbFtuYW1lXSA9IHt9KSA6IChfZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuXHQgIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gX2NvcmUgOiBfY29yZVtuYW1lXSB8fCAoX2NvcmVbbmFtZV0gPSB7fSk7XG5cdCAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG5cdCAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcblx0ICBpZiAoSVNfR0xPQkFMKSB7IHNvdXJjZSA9IG5hbWU7IH1cblx0ICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0ICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuXHQgICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcblx0ICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG5cdCAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuXHQgICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblx0ICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gX2N0eChvdXQsIF9nbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gX2N0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuXHQgICAgLy8gZXh0ZW5kIGdsb2JhbFxuXHQgICAgaWYgKHRhcmdldCkgeyBfcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7IH1cblx0ICAgIC8vIGV4cG9ydFxuXHQgICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIHsgX2hpZGUoZXhwb3J0cywga2V5LCBleHApOyB9XG5cdCAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIHsgZXhwUHJvdG9ba2V5XSA9IG91dDsgfVxuXHQgIH1cblx0fTtcblx0X2dsb2JhbC5jb3JlID0gX2NvcmU7XG5cdC8vIHR5cGUgYml0bWFwXG5cdCRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG5cdCRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG5cdCRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG5cdCRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cblx0JGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG5cdCRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuXHQkZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcblx0JGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5cdHZhciBfZXhwb3J0ID0gJGV4cG9ydDtcblxuXHQvLyA3LjEuNCBUb0ludGVnZXJcblx0dmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5cdHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cdHZhciBfdG9JbnRlZ2VyID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG5cdH07XG5cblx0Ly8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcblx0dmFyIF9kZWZpbmVkID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGl0ID09IHVuZGVmaW5lZCkgeyB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7IH1cblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cblx0Ly8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG5cdC8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxuXHR2YXIgX3N0cmluZ0F0ID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuXHQgIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG5cdCAgICB2YXIgcyA9IFN0cmluZyhfZGVmaW5lZCh0aGF0KSk7XG5cdCAgICB2YXIgaSA9IF90b0ludGVnZXIocG9zKTtcblx0ICAgIHZhciBsID0gcy5sZW5ndGg7XG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHsgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkOyB9XG5cdCAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuXHQgICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcblx0ICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcblx0ICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgJGF0ID0gX3N0cmluZ0F0KGZhbHNlKTtcblx0X2V4cG9ydChfZXhwb3J0LlAsICdTdHJpbmcnLCB7XG5cdCAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG5cdCAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuXHQgICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGNvZGVQb2ludEF0ID0gX2NvcmUuU3RyaW5nLmNvZGVQb2ludEF0O1xuXG5cdHZhciBtYXggPSBNYXRoLm1heDtcblx0dmFyIG1pbiA9IE1hdGgubWluO1xuXHR2YXIgX3RvQWJzb2x1dGVJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG5cdCAgaW5kZXggPSBfdG9JbnRlZ2VyKGluZGV4KTtcblx0ICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcblx0fTtcblxuXHR2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0dmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cblx0Ly8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuXHRfZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcblx0ICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuXHQgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkge1xuXHQgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXHQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHQgICAgdmFyIHJlcyA9IFtdO1xuXHQgICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgdmFyIGNvZGU7XG5cdCAgICB3aGlsZSAoYUxlbiA+IGkpIHtcblx0ICAgICAgY29kZSA9ICthcmd1bWVudHMkMVtpKytdO1xuXHQgICAgICBpZiAoX3RvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHsgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7IH1cblx0ICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcblx0ICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuXHQgICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcblx0ICAgICAgKTtcblx0ICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBmcm9tQ29kZVBvaW50ID0gX2NvcmUuU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cblx0Ly8gVGhpcyBpcyBhIGdlbmVyYXRlZCBmaWxlLiBEbyBub3QgZWRpdC5cblx0dmFyIFNwYWNlX1NlcGFyYXRvciA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuXHR2YXIgSURfU3RhcnQgPSAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZBXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRVxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFQVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTgzXFx1REU4Ni1cXHVERTg5XFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZcXHVERDAwLVxcdUREMDZcXHVERDA4XFx1REQwOVxcdUREMEItXFx1REQzMFxcdURENDZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzldW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1REQwMC1cXHVERDQzXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLztcblx0dmFyIElEX0NvbnRpbnVlID0gL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTA5RkNcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOS1cXHUwQUZGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAwLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjlcXHUxRDAwLVxcdTFERjlcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRVxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFQVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNVxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTNFXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMDAtXFx1REM0QVxcdURDNTAtXFx1REM1OVxcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERTAwLVxcdURFM0VcXHVERTQ3XFx1REU1MC1cXHVERTgzXFx1REU4Ni1cXHVERTk5XFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMzNlxcdURDMzgtXFx1REM0MFxcdURDNTAtXFx1REM1OVxcdURDNzItXFx1REM4RlxcdURDOTItXFx1RENBN1xcdURDQTktXFx1RENCNlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ3XFx1REQ1MC1cXHVERDU5XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXFx1REZFMFxcdURGRTFdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XFx1REQwMC1cXHVERDRBXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS87XG5cblx0dmFyIHVuaWNvZGUgPSB7XG5cdFx0U3BhY2VfU2VwYXJhdG9yOiBTcGFjZV9TZXBhcmF0b3IsXG5cdFx0SURfU3RhcnQ6IElEX1N0YXJ0LFxuXHRcdElEX0NvbnRpbnVlOiBJRF9Db250aW51ZVxuXHR9O1xuXG5cdHZhciB1dGlsID0ge1xuXHQgICAgaXNTcGFjZVNlcGFyYXRvcjogZnVuY3Rpb24gaXNTcGFjZVNlcGFyYXRvciAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgdW5pY29kZS5TcGFjZV9TZXBhcmF0b3IudGVzdChjKVxuXHQgICAgfSxcblxuXHQgICAgaXNJZFN0YXJ0Q2hhcjogZnVuY3Rpb24gaXNJZFN0YXJ0Q2hhciAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgKFxuXHQgICAgICAgICAgICAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8XG5cdCAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuXHQgICAgICAgIChjID09PSAnJCcpIHx8IChjID09PSAnXycpIHx8XG5cdCAgICAgICAgdW5pY29kZS5JRF9TdGFydC50ZXN0KGMpXG5cdCAgICAgICAgKVxuXHQgICAgfSxcblxuXHQgICAgaXNJZENvbnRpbnVlQ2hhcjogZnVuY3Rpb24gaXNJZENvbnRpbnVlQ2hhciAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgKFxuXHQgICAgICAgICAgICAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8XG5cdCAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuXHQgICAgICAgIChjID49ICcwJyAmJiBjIDw9ICc5JykgfHxcblx0ICAgICAgICAoYyA9PT0gJyQnKSB8fCAoYyA9PT0gJ18nKSB8fFxuXHQgICAgICAgIChjID09PSAnXFx1MjAwQycpIHx8IChjID09PSAnXFx1MjAwRCcpIHx8XG5cdCAgICAgICAgdW5pY29kZS5JRF9Db250aW51ZS50ZXN0KGMpXG5cdCAgICAgICAgKVxuXHQgICAgfSxcblxuXHQgICAgaXNEaWdpdDogZnVuY3Rpb24gaXNEaWdpdCAoYykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgJiYgL1swLTldLy50ZXN0KGMpXG5cdCAgICB9LFxuXG5cdCAgICBpc0hleERpZ2l0OiBmdW5jdGlvbiBpc0hleERpZ2l0IChjKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyAmJiAvWzAtOUEtRmEtZl0vLnRlc3QoYylcblx0ICAgIH0sXG5cdH07XG5cblx0dmFyIHNvdXJjZTtcblx0dmFyIHBhcnNlU3RhdGU7XG5cdHZhciBzdGFjaztcblx0dmFyIHBvcztcblx0dmFyIGxpbmU7XG5cdHZhciBjb2x1bW47XG5cdHZhciB0b2tlbjtcblx0dmFyIGtleTtcblx0dmFyIHJvb3Q7XG5cblx0dmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRleHQsIHJldml2ZXIpIHtcblx0ICAgIHNvdXJjZSA9IFN0cmluZyh0ZXh0KTtcblx0ICAgIHBhcnNlU3RhdGUgPSAnc3RhcnQnO1xuXHQgICAgc3RhY2sgPSBbXTtcblx0ICAgIHBvcyA9IDA7XG5cdCAgICBsaW5lID0gMTtcblx0ICAgIGNvbHVtbiA9IDA7XG5cdCAgICB0b2tlbiA9IHVuZGVmaW5lZDtcblx0ICAgIGtleSA9IHVuZGVmaW5lZDtcblx0ICAgIHJvb3QgPSB1bmRlZmluZWQ7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlLlxuXHQgICAgICAgIC8vIGlmICghcGFyc2VTdGF0ZXNbcGFyc2VTdGF0ZV0pIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZFBhcnNlU3RhdGUoKVxuXHQgICAgICAgIC8vIH1cblxuXHQgICAgICAgIHBhcnNlU3RhdGVzW3BhcnNlU3RhdGVdKCk7XG5cdCAgICB9IHdoaWxlICh0b2tlbi50eXBlICE9PSAnZW9mJylcblxuXHQgICAgaWYgKHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIGludGVybmFsaXplKHsnJzogcm9vdH0sICcnLCByZXZpdmVyKVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcm9vdFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGludGVybmFsaXplIChob2xkZXIsIG5hbWUsIHJldml2ZXIpIHtcblx0ICAgIHZhciB2YWx1ZSA9IGhvbGRlcltuYW1lXTtcblx0ICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gaW50ZXJuYWxpemUodmFsdWUsIGtleSwgcmV2aXZlcik7XG5cdCAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIG5hbWUsIHZhbHVlKVxuXHR9XG5cblx0dmFyIGxleFN0YXRlO1xuXHR2YXIgYnVmZmVyO1xuXHR2YXIgZG91YmxlUXVvdGU7XG5cdHZhciBzaWduO1xuXHR2YXIgYztcblxuXHRmdW5jdGlvbiBsZXggKCkge1xuXHQgICAgbGV4U3RhdGUgPSAnZGVmYXVsdCc7XG5cdCAgICBidWZmZXIgPSAnJztcblx0ICAgIGRvdWJsZVF1b3RlID0gZmFsc2U7XG5cdCAgICBzaWduID0gMTtcblxuXHQgICAgZm9yICg7Oykge1xuXHQgICAgICAgIGMgPSBwZWVrKCk7XG5cblx0ICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG5cdCAgICAgICAgLy8gaWYgKCFsZXhTdGF0ZXNbbGV4U3RhdGVdKSB7XG5cdCAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRMZXhTdGF0ZShsZXhTdGF0ZSlcblx0ICAgICAgICAvLyB9XG5cblx0ICAgICAgICB2YXIgdG9rZW4gPSBsZXhTdGF0ZXNbbGV4U3RhdGVdKCk7XG5cdCAgICAgICAgaWYgKHRva2VuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0b2tlblxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBlZWsgKCkge1xuXHQgICAgaWYgKHNvdXJjZVtwb3NdKSB7XG5cdCAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHNvdXJjZS5jb2RlUG9pbnRBdChwb3MpKVxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdCAgICB2YXIgYyA9IHBlZWsoKTtcblxuXHQgICAgaWYgKGMgPT09ICdcXG4nKSB7XG5cdCAgICAgICAgbGluZSsrO1xuXHQgICAgICAgIGNvbHVtbiA9IDA7XG5cdCAgICB9IGVsc2UgaWYgKGMpIHtcblx0ICAgICAgICBjb2x1bW4gKz0gYy5sZW5ndGg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNvbHVtbisrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYykge1xuXHQgICAgICAgIHBvcyArPSBjLmxlbmd0aDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNcblx0fVxuXG5cdHZhciBsZXhTdGF0ZXMgPSB7XG5cdCAgICBkZWZhdWx0OiBmdW5jdGlvbiBkZWZhdWx0JDEgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJ1xcdCc6XG5cdCAgICAgICAgY2FzZSAnXFx2Jzpcblx0ICAgICAgICBjYXNlICdcXGYnOlxuXHQgICAgICAgIGNhc2UgJyAnOlxuXHQgICAgICAgIGNhc2UgJ1xcdTAwQTAnOlxuXHQgICAgICAgIGNhc2UgJ1xcdUZFRkYnOlxuXHQgICAgICAgIGNhc2UgJ1xcbic6XG5cdCAgICAgICAgY2FzZSAnXFxyJzpcblx0ICAgICAgICBjYXNlICdcXHUyMDI4Jzpcblx0ICAgICAgICBjYXNlICdcXHUyMDI5Jzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJy8nOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2NvbW1lbnQnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignZW9mJylcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodXRpbC5pc1NwYWNlU2VwYXJhdG9yKGMpKSB7XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlLlxuXHQgICAgICAgIC8vIGlmICghbGV4U3RhdGVzW3BhcnNlU3RhdGVdKSB7XG5cdCAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRMZXhTdGF0ZShwYXJzZVN0YXRlKVxuXHQgICAgICAgIC8vIH1cblxuXHQgICAgICAgIHJldHVybiBsZXhTdGF0ZXNbcGFyc2VTdGF0ZV0oKVxuXHQgICAgfSxcblxuXHQgICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnKic6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnbXVsdGlMaW5lQ29tbWVudCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnLyc6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnc2luZ2xlTGluZUNvbW1lbnQnO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBtdWx0aUxpbmVDb21tZW50OiBmdW5jdGlvbiBtdWx0aUxpbmVDb21tZW50ICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcqJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdtdWx0aUxpbmVDb21tZW50QXN0ZXJpc2snO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgfSxcblxuXHQgICAgbXVsdGlMaW5lQ29tbWVudEFzdGVyaXNrOiBmdW5jdGlvbiBtdWx0aUxpbmVDb21tZW50QXN0ZXJpc2sgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJyonOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnLyc6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVmYXVsdCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgbGV4U3RhdGUgPSAnbXVsdGlMaW5lQ29tbWVudCc7XG5cdCAgICB9LFxuXG5cdCAgICBzaW5nbGVMaW5lQ29tbWVudDogZnVuY3Rpb24gc2luZ2xlTGluZUNvbW1lbnQgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJ1xcbic6XG5cdCAgICAgICAgY2FzZSAnXFxyJzpcblx0ICAgICAgICBjYXNlICdcXHUyMDI4Jzpcblx0ICAgICAgICBjYXNlICdcXHUyMDI5Jzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWZhdWx0Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlIHVuZGVmaW5lZDpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2VvZicpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgfSxcblxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICd7Jzpcblx0ICAgICAgICBjYXNlICdbJzpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdwdW5jdHVhdG9yJywgcmVhZCgpKVxuXG5cdCAgICAgICAgY2FzZSAnbic6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGl0ZXJhbCgndWxsJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVsbCcsIG51bGwpXG5cblx0ICAgICAgICBjYXNlICd0Jzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsaXRlcmFsKCdydWUnKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdib29sZWFuJywgdHJ1ZSlcblxuXHQgICAgICAgIGNhc2UgJ2YnOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxpdGVyYWwoJ2Fsc2UnKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdib29sZWFuJywgZmFsc2UpXG5cblx0ICAgICAgICBjYXNlICctJzpcblx0ICAgICAgICBjYXNlICcrJzpcblx0ICAgICAgICAgICAgaWYgKHJlYWQoKSA9PT0gJy0nKSB7XG5cdCAgICAgICAgICAgICAgICBzaWduID0gLTE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdzaWduJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICcuJzpcblx0ICAgICAgICAgICAgYnVmZmVyID0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsUG9pbnRMZWFkaW5nJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICcwJzpcblx0ICAgICAgICAgICAgYnVmZmVyID0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICd6ZXJvJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICcxJzpcblx0ICAgICAgICBjYXNlICcyJzpcblx0ICAgICAgICBjYXNlICczJzpcblx0ICAgICAgICBjYXNlICc0Jzpcblx0ICAgICAgICBjYXNlICc1Jzpcblx0ICAgICAgICBjYXNlICc2Jzpcblx0ICAgICAgICBjYXNlICc3Jzpcblx0ICAgICAgICBjYXNlICc4Jzpcblx0ICAgICAgICBjYXNlICc5Jzpcblx0ICAgICAgICAgICAgYnVmZmVyID0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsSW50ZWdlcic7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnSSc6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGl0ZXJhbCgnbmZpbml0eScpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBJbmZpbml0eSlcblxuXHQgICAgICAgIGNhc2UgJ04nOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxpdGVyYWwoJ2FOJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIE5hTilcblxuXHQgICAgICAgIGNhc2UgJ1wiJzpcblx0ICAgICAgICBjYXNlIFwiJ1wiOlxuXHQgICAgICAgICAgICBkb3VibGVRdW90ZSA9IChyZWFkKCkgPT09ICdcIicpO1xuXHQgICAgICAgICAgICBidWZmZXIgPSAnJztcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnc3RyaW5nJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfSxcblxuXHQgICAgaWRlbnRpZmllck5hbWVTdGFydEVzY2FwZTogZnVuY3Rpb24gaWRlbnRpZmllck5hbWVTdGFydEVzY2FwZSAoKSB7XG5cdCAgICAgICAgaWYgKGMgIT09ICd1Jykge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHZhciB1ID0gdW5pY29kZUVzY2FwZSgpO1xuXHQgICAgICAgIHN3aXRjaCAodSkge1xuXHQgICAgICAgIGNhc2UgJyQnOlxuXHQgICAgICAgIGNhc2UgJ18nOlxuXHQgICAgICAgICAgICBicmVha1xuXG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgaWYgKCF1dGlsLmlzSWRTdGFydENoYXIodSkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRJZGVudGlmaWVyKClcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJyZWFrXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnVmZmVyICs9IHU7XG5cdCAgICAgICAgbGV4U3RhdGUgPSAnaWRlbnRpZmllck5hbWUnO1xuXHQgICAgfSxcblxuXHQgICAgaWRlbnRpZmllck5hbWU6IGZ1bmN0aW9uIGlkZW50aWZpZXJOYW1lICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICckJzpcblx0ICAgICAgICBjYXNlICdfJzpcblx0ICAgICAgICBjYXNlICdcXHUyMDBDJzpcblx0ICAgICAgICBjYXNlICdcXHUyMDBEJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdcXFxcJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZUVzY2FwZSc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzSWRDb250aW51ZUNoYXIoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdpZGVudGlmaWVyJywgYnVmZmVyKVxuXHQgICAgfSxcblxuXHQgICAgaWRlbnRpZmllck5hbWVFc2NhcGU6IGZ1bmN0aW9uIGlkZW50aWZpZXJOYW1lRXNjYXBlICgpIHtcblx0ICAgICAgICBpZiAoYyAhPT0gJ3UnKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgdmFyIHUgPSB1bmljb2RlRXNjYXBlKCk7XG5cdCAgICAgICAgc3dpdGNoICh1KSB7XG5cdCAgICAgICAgY2FzZSAnJCc6XG5cdCAgICAgICAgY2FzZSAnXyc6XG5cdCAgICAgICAgY2FzZSAnXFx1MjAwQyc6XG5cdCAgICAgICAgY2FzZSAnXFx1MjAwRCc6XG5cdCAgICAgICAgICAgIGJyZWFrXG5cblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICBpZiAoIXV0aWwuaXNJZENvbnRpbnVlQ2hhcih1KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgaW52YWxpZElkZW50aWZpZXIoKVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBidWZmZXIgKz0gdTtcblx0ICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZSc7XG5cdCAgICB9LFxuXG5cdCAgICBzaWduOiBmdW5jdGlvbiBzaWduJDEgKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJy4nOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxQb2ludExlYWRpbmcnO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJzAnOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ3plcm8nO1xuXHQgICAgICAgICAgICByZXR1cm5cblxuXHQgICAgICAgIGNhc2UgJzEnOlxuXHQgICAgICAgIGNhc2UgJzInOlxuXHQgICAgICAgIGNhc2UgJzMnOlxuXHQgICAgICAgIGNhc2UgJzQnOlxuXHQgICAgICAgIGNhc2UgJzUnOlxuXHQgICAgICAgIGNhc2UgJzYnOlxuXHQgICAgICAgIGNhc2UgJzcnOlxuXHQgICAgICAgIGNhc2UgJzgnOlxuXHQgICAgICAgIGNhc2UgJzknOlxuXHQgICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxJbnRlZ2VyJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdJJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBsaXRlcmFsKCduZmluaXR5Jyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiBJbmZpbml0eSlcblxuXHQgICAgICAgIGNhc2UgJ04nOlxuXHQgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgIGxpdGVyYWwoJ2FOJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIE5hTilcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICB6ZXJvOiBmdW5jdGlvbiB6ZXJvICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcuJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbFBvaW50Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdlJzpcblx0ICAgICAgICBjYXNlICdFJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50Jztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICd4Jzpcblx0ICAgICAgICBjYXNlICdYJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnaGV4YWRlY2ltYWwnO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogMClcblx0ICAgIH0sXG5cblx0ICAgIGRlY2ltYWxJbnRlZ2VyOiBmdW5jdGlvbiBkZWNpbWFsSW50ZWdlciAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnLic6XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxQb2ludCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnZSc6XG5cdCAgICAgICAgY2FzZSAnRSc6XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxFeHBvbmVudCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIE51bWJlcihidWZmZXIpKVxuXHQgICAgfSxcblxuXHQgICAgZGVjaW1hbFBvaW50TGVhZGluZzogZnVuY3Rpb24gZGVjaW1hbFBvaW50TGVhZGluZyAoKSB7XG5cdCAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRnJhY3Rpb24nO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBkZWNpbWFsUG9pbnQ6IGZ1bmN0aW9uIGRlY2ltYWxQb2ludCAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnZSc6XG5cdCAgICAgICAgY2FzZSAnRSc6XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxFeHBvbmVudCc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEZyYWN0aW9uJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIE51bWJlcihidWZmZXIpKVxuXHQgICAgfSxcblxuXHQgICAgZGVjaW1hbEZyYWN0aW9uOiBmdW5jdGlvbiBkZWNpbWFsRnJhY3Rpb24gKCkge1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgIGNhc2UgJ2UnOlxuXHQgICAgICAgIGNhc2UgJ0UnOlxuXHQgICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnQnO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodXRpbC5pc0RpZ2l0KGMpKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiBOdW1iZXIoYnVmZmVyKSlcblx0ICAgIH0sXG5cblx0ICAgIGRlY2ltYWxFeHBvbmVudDogZnVuY3Rpb24gZGVjaW1hbEV4cG9uZW50ICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICcrJzpcblx0ICAgICAgICBjYXNlICctJzpcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50U2lnbic7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50SW50ZWdlcic7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGRlY2ltYWxFeHBvbmVudFNpZ246IGZ1bmN0aW9uIGRlY2ltYWxFeHBvbmVudFNpZ24gKCkge1xuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50SW50ZWdlcic7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGRlY2ltYWxFeHBvbmVudEludGVnZXI6IGZ1bmN0aW9uIGRlY2ltYWxFeHBvbmVudEludGVnZXIgKCkge1xuXHQgICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIE51bWJlcihidWZmZXIpKVxuXHQgICAgfSxcblxuXHQgICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIGhleGFkZWNpbWFsICgpIHtcblx0ICAgICAgICBpZiAodXRpbC5pc0hleERpZ2l0KGMpKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2hleGFkZWNpbWFsSW50ZWdlcic7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH0sXG5cblx0ICAgIGhleGFkZWNpbWFsSW50ZWdlcjogZnVuY3Rpb24gaGV4YWRlY2ltYWxJbnRlZ2VyICgpIHtcblx0ICAgICAgICBpZiAodXRpbC5pc0hleERpZ2l0KGMpKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiBOdW1iZXIoYnVmZmVyKSlcblx0ICAgIH0sXG5cblx0ICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICdcXFxcJzpcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgICAgICBidWZmZXIgKz0gZXNjYXBlKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnXCInOlxuXHQgICAgICAgICAgICBpZiAoZG91YmxlUXVvdGUpIHtcblx0ICAgICAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignc3RyaW5nJywgYnVmZmVyKVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlIFwiJ1wiOlxuXHQgICAgICAgICAgICBpZiAoIWRvdWJsZVF1b3RlKSB7XG5cdCAgICAgICAgICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ3N0cmluZycsIGJ1ZmZlcilcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnXFxuJzpcblx0ICAgICAgICBjYXNlICdcXHInOlxuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cblx0ICAgICAgICBjYXNlICdcXHUyMDI4Jzpcblx0ICAgICAgICBjYXNlICdcXHUyMDI5Jzpcblx0ICAgICAgICAgICAgc2VwYXJhdG9yQ2hhcihjKTtcblx0ICAgICAgICAgICAgYnJlYWtcblxuXHQgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgIH0sXG5cblx0ICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAneyc6XG5cdCAgICAgICAgY2FzZSAnWyc6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblxuXHQgICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSB0aGUgZGVmYXVsdCBsZXhTdGF0ZSBoYW5kbGVzIGVvZi5cblx0ICAgICAgICAvLyBjYXNlIHVuZGVmaW5lZDpcblx0ICAgICAgICAvLyAgICAgcmV0dXJuIG5ld1Rva2VuKCdlb2YnKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGxleFN0YXRlID0gJ3ZhbHVlJztcblx0ICAgIH0sXG5cblx0ICAgIGJlZm9yZVByb3BlcnR5TmFtZTogZnVuY3Rpb24gYmVmb3JlUHJvcGVydHlOYW1lICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICBjYXNlICckJzpcblx0ICAgICAgICBjYXNlICdfJzpcblx0ICAgICAgICAgICAgYnVmZmVyID0gcmVhZCgpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZSc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnXFxcXCc6XG5cdCAgICAgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICAgICAgbGV4U3RhdGUgPSAnaWRlbnRpZmllck5hbWVTdGFydEVzY2FwZSc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnfSc6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblxuXHQgICAgICAgIGNhc2UgJ1wiJzpcblx0ICAgICAgICBjYXNlIFwiJ1wiOlxuXHQgICAgICAgICAgICBkb3VibGVRdW90ZSA9IChyZWFkKCkgPT09ICdcIicpO1xuXHQgICAgICAgICAgICBsZXhTdGF0ZSA9ICdzdHJpbmcnO1xuXHQgICAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodXRpbC5pc0lkU3RhcnRDaGFyKGMpKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cdCAgICAgICAgICAgIGxleFN0YXRlID0gJ2lkZW50aWZpZXJOYW1lJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfSxcblxuXHQgICAgYWZ0ZXJQcm9wZXJ0eU5hbWU6IGZ1bmN0aW9uIGFmdGVyUHJvcGVydHlOYW1lICgpIHtcblx0ICAgICAgICBpZiAoYyA9PT0gJzonKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBiZWZvcmVQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiBiZWZvcmVQcm9wZXJ0eVZhbHVlICgpIHtcblx0ICAgICAgICBsZXhTdGF0ZSA9ICd2YWx1ZSc7XG5cdCAgICB9LFxuXG5cdCAgICBhZnRlclByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIGFmdGVyUHJvcGVydHlWYWx1ZSAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnLCc6XG5cdCAgICAgICAgY2FzZSAnfSc6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBiZWZvcmVBcnJheVZhbHVlOiBmdW5jdGlvbiBiZWZvcmVBcnJheVZhbHVlICgpIHtcblx0ICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBsZXhTdGF0ZSA9ICd2YWx1ZSc7XG5cdCAgICB9LFxuXG5cdCAgICBhZnRlckFycmF5VmFsdWU6IGZ1bmN0aW9uIGFmdGVyQXJyYXlWYWx1ZSAoKSB7XG5cdCAgICAgICAgc3dpdGNoIChjKSB7XG5cdCAgICAgICAgY2FzZSAnLCc6XG5cdCAgICAgICAgY2FzZSAnXSc6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9LFxuXG5cdCAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgZGVmYXVsdCBsZXhTdGF0ZS5cblx0ICAgICAgICAvLyBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgLy8gICAgIHJlYWQoKVxuXHQgICAgICAgIC8vICAgICByZXR1cm4gbmV3VG9rZW4oJ2VvZicpXG5cdCAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgfSxcblx0fTtcblxuXHRmdW5jdGlvbiBuZXdUb2tlbiAodHlwZSwgdmFsdWUpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgICAgbGluZTogbGluZSxcblx0ICAgICAgICBjb2x1bW46IGNvbHVtbixcblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxpdGVyYWwgKHMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgYyA9IGxpc3RbaV07XG5cblx0ICAgICAgICB2YXIgcCA9IHBlZWsoKTtcblxuXHQgICAgICAgIGlmIChwICE9PSBjKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZWFkKCk7XG5cdCAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiBlc2NhcGUgKCkge1xuXHQgICAgdmFyIGMgPSBwZWVrKCk7XG5cdCAgICBzd2l0Y2ggKGMpIHtcblx0ICAgIGNhc2UgJ2InOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gJ1xcYidcblxuXHQgICAgY2FzZSAnZic6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHJldHVybiAnXFxmJ1xuXG5cdCAgICBjYXNlICduJzpcblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgcmV0dXJuICdcXG4nXG5cblx0ICAgIGNhc2UgJ3InOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gJ1xccidcblxuXHQgICAgY2FzZSAndCc6XG5cdCAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIHJldHVybiAnXFx0J1xuXG5cdCAgICBjYXNlICd2Jzpcblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgcmV0dXJuICdcXHYnXG5cblx0ICAgIGNhc2UgJzAnOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICBpZiAodXRpbC5pc0RpZ2l0KHBlZWsoKSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiAnXFwwJ1xuXG5cdCAgICBjYXNlICd4Jzpcblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgcmV0dXJuIGhleEVzY2FwZSgpXG5cblx0ICAgIGNhc2UgJ3UnOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gdW5pY29kZUVzY2FwZSgpXG5cblx0ICAgIGNhc2UgJ1xcbic6XG5cdCAgICBjYXNlICdcXHUyMDI4Jzpcblx0ICAgIGNhc2UgJ1xcdTIwMjknOlxuXHQgICAgICAgIHJlYWQoKTtcblx0ICAgICAgICByZXR1cm4gJydcblxuXHQgICAgY2FzZSAnXFxyJzpcblx0ICAgICAgICByZWFkKCk7XG5cdCAgICAgICAgaWYgKHBlZWsoKSA9PT0gJ1xcbicpIHtcblx0ICAgICAgICAgICAgcmVhZCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiAnJ1xuXG5cdCAgICBjYXNlICcxJzpcblx0ICAgIGNhc2UgJzInOlxuXHQgICAgY2FzZSAnMyc6XG5cdCAgICBjYXNlICc0Jzpcblx0ICAgIGNhc2UgJzUnOlxuXHQgICAgY2FzZSAnNic6XG5cdCAgICBjYXNlICc3Jzpcblx0ICAgIGNhc2UgJzgnOlxuXHQgICAgY2FzZSAnOSc6XG5cdCAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuXG5cdCAgICBjYXNlIHVuZGVmaW5lZDpcblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZWFkKClcblx0fVxuXG5cdGZ1bmN0aW9uIGhleEVzY2FwZSAoKSB7XG5cdCAgICB2YXIgYnVmZmVyID0gJyc7XG5cdCAgICB2YXIgYyA9IHBlZWsoKTtcblxuXHQgICAgaWYgKCF1dGlsLmlzSGV4RGlnaXQoYykpIHtcblx0ICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICB9XG5cblx0ICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cblx0ICAgIGMgPSBwZWVrKCk7XG5cdCAgICBpZiAoIXV0aWwuaXNIZXhEaWdpdChjKSkge1xuXHQgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcblx0ICAgIH1cblxuXHQgICAgYnVmZmVyICs9IHJlYWQoKTtcblxuXHQgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGJ1ZmZlciwgMTYpKVxuXHR9XG5cblx0ZnVuY3Rpb24gdW5pY29kZUVzY2FwZSAoKSB7XG5cdCAgICB2YXIgYnVmZmVyID0gJyc7XG5cdCAgICB2YXIgY291bnQgPSA0O1xuXG5cdCAgICB3aGlsZSAoY291bnQtLSA+IDApIHtcblx0ICAgICAgICB2YXIgYyA9IHBlZWsoKTtcblx0ICAgICAgICBpZiAoIXV0aWwuaXNIZXhEaWdpdChjKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGJ1ZmZlciwgMTYpKVxuXHR9XG5cblx0dmFyIHBhcnNlU3RhdGVzID0ge1xuXHQgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICgpIHtcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHVzaCgpO1xuXHQgICAgfSxcblxuXHQgICAgYmVmb3JlUHJvcGVydHlOYW1lOiBmdW5jdGlvbiBiZWZvcmVQcm9wZXJ0eU5hbWUgKCkge1xuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuXHQgICAgICAgIGNhc2UgJ2lkZW50aWZpZXInOlxuXHQgICAgICAgIGNhc2UgJ3N0cmluZyc6XG5cdCAgICAgICAgICAgIGtleSA9IHRva2VuLnZhbHVlO1xuXHQgICAgICAgICAgICBwYXJzZVN0YXRlID0gJ2FmdGVyUHJvcGVydHlOYW1lJztcblx0ICAgICAgICAgICAgcmV0dXJuXG5cblx0ICAgICAgICBjYXNlICdwdW5jdHVhdG9yJzpcblx0ICAgICAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgICAgIC8vIGlmICh0b2tlbi52YWx1ZSAhPT0gJ30nKSB7XG5cdCAgICAgICAgICAgIC8vICAgICB0aHJvdyBpbnZhbGlkVG9rZW4oKVxuXHQgICAgICAgICAgICAvLyB9XG5cblx0ICAgICAgICAgICAgcG9wKCk7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnZW9mJzpcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gdGhyb3cgaW52YWxpZFRva2VuKClcblx0ICAgIH0sXG5cblx0ICAgIGFmdGVyUHJvcGVydHlOYW1lOiBmdW5jdGlvbiBhZnRlclByb3BlcnR5TmFtZSAoKSB7XG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gaWYgKHRva2VuLnR5cGUgIT09ICdwdW5jdHVhdG9yJyB8fCB0b2tlbi52YWx1ZSAhPT0gJzonKSB7XG5cdCAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdlb2YnKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlUHJvcGVydHlWYWx1ZSc7XG5cdCAgICB9LFxuXG5cdCAgICBiZWZvcmVQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiBiZWZvcmVQcm9wZXJ0eVZhbHVlICgpIHtcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHVzaCgpO1xuXHQgICAgfSxcblxuXHQgICAgYmVmb3JlQXJyYXlWYWx1ZTogZnVuY3Rpb24gYmVmb3JlQXJyYXlWYWx1ZSAoKSB7XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdlb2YnKSB7XG5cdCAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAncHVuY3R1YXRvcicgJiYgdG9rZW4udmFsdWUgPT09ICddJykge1xuXHQgICAgICAgICAgICBwb3AoKTtcblx0ICAgICAgICAgICAgcmV0dXJuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHVzaCgpO1xuXHQgICAgfSxcblxuXHQgICAgYWZ0ZXJQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiBhZnRlclByb3BlcnR5VmFsdWUgKCkge1xuXHQgICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSBpdCdzIGhhbmRsZWQgYnkgdGhlIGxleFN0YXRlLlxuXHQgICAgICAgIC8vIGlmICh0b2tlbi50eXBlICE9PSAncHVuY3R1YXRvcicpIHtcblx0ICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZFRva2VuKClcblx0ICAgICAgICAvLyB9XG5cblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuXHQgICAgICAgIGNhc2UgJywnOlxuXHQgICAgICAgICAgICBwYXJzZVN0YXRlID0gJ2JlZm9yZVByb3BlcnR5TmFtZSc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnfSc6XG5cdCAgICAgICAgICAgIHBvcCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSBpdCdzIGhhbmRsZWQgYnkgdGhlIGxleFN0YXRlLlxuXHQgICAgICAgIC8vIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICB9LFxuXG5cdCAgICBhZnRlckFycmF5VmFsdWU6IGZ1bmN0aW9uIGFmdGVyQXJyYXlWYWx1ZSAoKSB7XG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gaWYgKHRva2VuLnR5cGUgIT09ICdwdW5jdHVhdG9yJykge1xuXHQgICAgICAgIC8vICAgICB0aHJvdyBpbnZhbGlkVG9rZW4oKVxuXHQgICAgICAgIC8vIH1cblxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZW9mJykge1xuXHQgICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG5cdCAgICAgICAgY2FzZSAnLCc6XG5cdCAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlQXJyYXlWYWx1ZSc7XG5cdCAgICAgICAgICAgIHJldHVyblxuXG5cdCAgICAgICAgY2FzZSAnXSc6XG5cdCAgICAgICAgICAgIHBvcCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSBpdCdzIGhhbmRsZWQgYnkgdGhlIGxleFN0YXRlLlxuXHQgICAgICAgIC8vIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICB9LFxuXG5cdCAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG5cdCAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG5cdCAgICAgICAgLy8gaWYgKHRva2VuLnR5cGUgIT09ICdlb2YnKSB7XG5cdCAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG5cdCAgICAgICAgLy8gfVxuXHQgICAgfSxcblx0fTtcblxuXHRmdW5jdGlvbiBwdXNoICgpIHtcblx0ICAgIHZhciB2YWx1ZTtcblxuXHQgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdCAgICBjYXNlICdwdW5jdHVhdG9yJzpcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG5cdCAgICAgICAgY2FzZSAneyc6XG5cdCAgICAgICAgICAgIHZhbHVlID0ge307XG5cdCAgICAgICAgICAgIGJyZWFrXG5cblx0ICAgICAgICBjYXNlICdbJzpcblx0ICAgICAgICAgICAgdmFsdWUgPSBbXTtcblx0ICAgICAgICAgICAgYnJlYWtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVha1xuXG5cdCAgICBjYXNlICdudWxsJzpcblx0ICAgIGNhc2UgJ2Jvb2xlYW4nOlxuXHQgICAgY2FzZSAnbnVtZXJpYyc6XG5cdCAgICBjYXNlICdzdHJpbmcnOlxuXHQgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdCAgICAgICAgYnJlYWtcblxuXHQgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlLlxuXHQgICAgLy8gZGVmYXVsdDpcblx0ICAgIC8vICAgICB0aHJvdyBpbnZhbGlkVG9rZW4oKVxuXHQgICAgfVxuXG5cdCAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcm9vdCA9IHZhbHVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuXHQgICAgICAgICAgICBwYXJlbnQucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcGFyZW50W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdiZWZvcmVBcnJheVZhbHVlJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBwYXJzZVN0YXRlID0gJ2JlZm9yZVByb3BlcnR5TmFtZSc7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgY3VycmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHQgICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdlbmQnO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuXHQgICAgICAgICAgICBwYXJzZVN0YXRlID0gJ2FmdGVyQXJyYXlWYWx1ZSc7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdhZnRlclByb3BlcnR5VmFsdWUnO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBvcCAoKSB7XG5cdCAgICBzdGFjay5wb3AoKTtcblxuXHQgICAgdmFyIGN1cnJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0ICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcblx0ICAgICAgICBwYXJzZVN0YXRlID0gJ2VuZCc7XG5cdCAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcblx0ICAgICAgICBwYXJzZVN0YXRlID0gJ2FmdGVyQXJyYXlWYWx1ZSc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJQcm9wZXJ0eVZhbHVlJztcblx0ICAgIH1cblx0fVxuXG5cdC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cblx0Ly8gZnVuY3Rpb24gaW52YWxpZFBhcnNlU3RhdGUgKCkge1xuXHQvLyAgICAgcmV0dXJuIG5ldyBFcnJvcihgSlNPTjU6IGludmFsaWQgcGFyc2Ugc3RhdGUgJyR7cGFyc2VTdGF0ZX0nYClcblx0Ly8gfVxuXG5cdC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cblx0Ly8gZnVuY3Rpb24gaW52YWxpZExleFN0YXRlIChzdGF0ZSkge1xuXHQvLyAgICAgcmV0dXJuIG5ldyBFcnJvcihgSlNPTjU6IGludmFsaWQgbGV4IHN0YXRlICcke3N0YXRlfSdgKVxuXHQvLyB9XG5cblx0ZnVuY3Rpb24gaW52YWxpZENoYXIgKGMpIHtcblx0ICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gc3ludGF4RXJyb3IoKFwiSlNPTjU6IGludmFsaWQgZW5kIG9mIGlucHV0IGF0IFwiICsgbGluZSArIFwiOlwiICsgY29sdW1uKSlcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN5bnRheEVycm9yKChcIkpTT041OiBpbnZhbGlkIGNoYXJhY3RlciAnXCIgKyAoZm9ybWF0Q2hhcihjKSkgKyBcIicgYXQgXCIgKyBsaW5lICsgXCI6XCIgKyBjb2x1bW4pKVxuXHR9XG5cblx0ZnVuY3Rpb24gaW52YWxpZEVPRiAoKSB7XG5cdCAgICByZXR1cm4gc3ludGF4RXJyb3IoKFwiSlNPTjU6IGludmFsaWQgZW5kIG9mIGlucHV0IGF0IFwiICsgbGluZSArIFwiOlwiICsgY29sdW1uKSlcblx0fVxuXG5cdC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cblx0Ly8gZnVuY3Rpb24gaW52YWxpZFRva2VuICgpIHtcblx0Ly8gICAgIGlmICh0b2tlbi50eXBlID09PSAnZW9mJykge1xuXHQvLyAgICAgICAgIHJldHVybiBzeW50YXhFcnJvcihgSlNPTjU6IGludmFsaWQgZW5kIG9mIGlucHV0IGF0ICR7bGluZX06JHtjb2x1bW59YClcblx0Ly8gICAgIH1cblxuXHQvLyAgICAgY29uc3QgYyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRva2VuLnZhbHVlLmNvZGVQb2ludEF0KDApKVxuXHQvLyAgICAgcmV0dXJuIHN5bnRheEVycm9yKGBKU09ONTogaW52YWxpZCBjaGFyYWN0ZXIgJyR7Zm9ybWF0Q2hhcihjKX0nIGF0ICR7bGluZX06JHtjb2x1bW59YClcblx0Ly8gfVxuXG5cdGZ1bmN0aW9uIGludmFsaWRJZGVudGlmaWVyICgpIHtcblx0ICAgIGNvbHVtbiAtPSA1O1xuXHQgICAgcmV0dXJuIHN5bnRheEVycm9yKChcIkpTT041OiBpbnZhbGlkIGlkZW50aWZpZXIgY2hhcmFjdGVyIGF0IFwiICsgbGluZSArIFwiOlwiICsgY29sdW1uKSlcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcGFyYXRvckNoYXIgKGMpIHtcblx0ICAgIGNvbnNvbGUud2FybigoXCJKU09ONTogJ1wiICsgKGZvcm1hdENoYXIoYykpICsgXCInIGluIHN0cmluZ3MgaXMgbm90IHZhbGlkIEVDTUFTY3JpcHQ7IGNvbnNpZGVyIGVzY2FwaW5nXCIpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdENoYXIgKGMpIHtcblx0ICAgIHZhciByZXBsYWNlbWVudHMgPSB7XG5cdCAgICAgICAgXCInXCI6IFwiXFxcXCdcIixcblx0ICAgICAgICAnXCInOiAnXFxcXFwiJyxcblx0ICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCcsXG5cdCAgICAgICAgJ1xcYic6ICdcXFxcYicsXG5cdCAgICAgICAgJ1xcZic6ICdcXFxcZicsXG5cdCAgICAgICAgJ1xcbic6ICdcXFxcbicsXG5cdCAgICAgICAgJ1xccic6ICdcXFxccicsXG5cdCAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG5cdCAgICAgICAgJ1xcdic6ICdcXFxcdicsXG5cdCAgICAgICAgJ1xcMCc6ICdcXFxcMCcsXG5cdCAgICAgICAgJ1xcdTIwMjgnOiAnXFxcXHUyMDI4Jyxcblx0ICAgICAgICAnXFx1MjAyOSc6ICdcXFxcdTIwMjknLFxuXHQgICAgfTtcblxuXHQgICAgaWYgKHJlcGxhY2VtZW50c1tjXSkge1xuXHQgICAgICAgIHJldHVybiByZXBsYWNlbWVudHNbY11cblx0ICAgIH1cblxuXHQgICAgaWYgKGMgPCAnICcpIHtcblx0ICAgICAgICB2YXIgaGV4U3RyaW5nID0gYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgaGV4U3RyaW5nKS5zdWJzdHJpbmcoaGV4U3RyaW5nLmxlbmd0aClcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNcblx0fVxuXG5cdGZ1bmN0aW9uIHN5bnRheEVycm9yIChtZXNzYWdlKSB7XG5cdCAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuXHQgICAgZXJyLmxpbmVOdW1iZXIgPSBsaW5lO1xuXHQgICAgZXJyLmNvbHVtbk51bWJlciA9IGNvbHVtbjtcblx0ICAgIHJldHVybiBlcnJcblx0fVxuXG5cdHZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkgKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblx0ICAgIHZhciBzdGFjayA9IFtdO1xuXHQgICAgdmFyIGluZGVudCA9ICcnO1xuXHQgICAgdmFyIHByb3BlcnR5TGlzdDtcblx0ICAgIHZhciByZXBsYWNlckZ1bmM7XG5cdCAgICB2YXIgZ2FwID0gJyc7XG5cdCAgICB2YXIgcXVvdGU7XG5cblx0ICAgIGlmIChcblx0ICAgICAgICByZXBsYWNlciAhPSBudWxsICYmXG5cdCAgICAgICAgdHlwZW9mIHJlcGxhY2VyID09PSAnb2JqZWN0JyAmJlxuXHQgICAgICAgICFBcnJheS5pc0FycmF5KHJlcGxhY2VyKVxuXHQgICAgKSB7XG5cdCAgICAgICAgc3BhY2UgPSByZXBsYWNlci5zcGFjZTtcblx0ICAgICAgICBxdW90ZSA9IHJlcGxhY2VyLnF1b3RlO1xuXHQgICAgICAgIHJlcGxhY2VyID0gcmVwbGFjZXIucmVwbGFjZXI7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXBsYWNlckZ1bmMgPSByZXBsYWNlcjtcblx0ICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcblx0ICAgICAgICBwcm9wZXJ0eUxpc3QgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHJlcGxhY2VyOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICB2YXIgdiA9IGxpc3RbaV07XG5cblx0ICAgICAgICAgICAgdmFyIGl0ZW0gPSAodm9pZCAwKTtcblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gdjtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChcblx0ICAgICAgICAgICAgICAgIHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fFxuXHQgICAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIFN0cmluZyB8fFxuXHQgICAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIE51bWJlclxuXHQgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0gPSBTdHJpbmcodik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5TGlzdC5pbmRleE9mKGl0ZW0pIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgcHJvcGVydHlMaXN0LnB1c2goaXRlbSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzcGFjZSBpbnN0YW5jZW9mIE51bWJlcikge1xuXHQgICAgICAgIHNwYWNlID0gTnVtYmVyKHNwYWNlKTtcblx0ICAgIH0gZWxzZSBpZiAoc3BhY2UgaW5zdGFuY2VvZiBTdHJpbmcpIHtcblx0ICAgICAgICBzcGFjZSA9IFN0cmluZyhzcGFjZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgaWYgKHNwYWNlID4gMCkge1xuXHQgICAgICAgICAgICBzcGFjZSA9IE1hdGgubWluKDEwLCBNYXRoLmZsb29yKHNwYWNlKSk7XG5cdCAgICAgICAgICAgIGdhcCA9ICcgICAgICAgICAgJy5zdWJzdHIoMCwgc3BhY2UpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGdhcCA9IHNwYWNlLnN1YnN0cigwLCAxMCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZXJpYWxpemVQcm9wZXJ0eSgnJywgeycnOiB2YWx1ZX0pXG5cblx0ICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVByb3BlcnR5IChrZXksIGhvbGRlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXHQgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09ONSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT041KGtleSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChyZXBsYWNlckZ1bmMpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlckZ1bmMuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuXHQgICAgICAgIGNhc2UgbnVsbDogcmV0dXJuICdudWxsJ1xuXHQgICAgICAgIGNhc2UgdHJ1ZTogcmV0dXJuICd0cnVlJ1xuXHQgICAgICAgIGNhc2UgZmFsc2U6IHJldHVybiAnZmFsc2UnXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHF1b3RlU3RyaW5nKHZhbHVlLCBmYWxzZSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHNlcmlhbGl6ZUFycmF5KHZhbHVlKSA6IHNlcmlhbGl6ZU9iamVjdCh2YWx1ZSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHF1b3RlU3RyaW5nICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBxdW90ZXMgPSB7XG5cdCAgICAgICAgICAgIFwiJ1wiOiAwLjEsXG5cdCAgICAgICAgICAgICdcIic6IDAuMixcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdmFyIHJlcGxhY2VtZW50cyA9IHtcblx0ICAgICAgICAgICAgXCInXCI6IFwiXFxcXCdcIixcblx0ICAgICAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG5cdCAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJyxcblx0ICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG5cdCAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuXHQgICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcblx0ICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG5cdCAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuXHQgICAgICAgICAgICAnXFx2JzogJ1xcXFx2Jyxcblx0ICAgICAgICAgICAgJ1xcMCc6ICdcXFxcMCcsXG5cdCAgICAgICAgICAgICdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG5cdCAgICAgICAgICAgICdcXHUyMDI5JzogJ1xcXFx1MjAyOScsXG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIHZhciBwcm9kdWN0ID0gJyc7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBjID0gdmFsdWVbaV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgICAgICBjYXNlIFwiJ1wiOlxuXHQgICAgICAgICAgICBjYXNlICdcIic6XG5cdCAgICAgICAgICAgICAgICBxdW90ZXNbY10rKztcblx0ICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gYztcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cblx0ICAgICAgICAgICAgY2FzZSAnXFwwJzpcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzRGlnaXQodmFsdWVbaSArIDFdKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gJ1xcXFx4MDAnO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRzW2NdKSB7XG5cdCAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IHJlcGxhY2VtZW50c1tjXTtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoYyA8ICcgJykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhleFN0cmluZyA9IGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG5cdCAgICAgICAgICAgICAgICBwcm9kdWN0ICs9ICdcXFxceCcgKyAoJzAwJyArIGhleFN0cmluZykuc3Vic3RyaW5nKGhleFN0cmluZy5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgY29udGludWVcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHByb2R1Y3QgKz0gYztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcXVvdGVDaGFyID0gcXVvdGUgfHwgT2JqZWN0LmtleXMocXVvdGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChxdW90ZXNbYV0gPCBxdW90ZXNbYl0pID8gYSA6IGI7IH0pO1xuXG5cdCAgICAgICAgcHJvZHVjdCA9IHByb2R1Y3QucmVwbGFjZShuZXcgUmVnRXhwKHF1b3RlQ2hhciwgJ2cnKSwgcmVwbGFjZW1lbnRzW3F1b3RlQ2hhcl0pO1xuXG5cdCAgICAgICAgcmV0dXJuIHF1b3RlQ2hhciArIHByb2R1Y3QgKyBxdW90ZUNoYXJcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0ICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTjUnKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG5cdCAgICAgICAgdmFyIHN0ZXBiYWNrID0gaW5kZW50O1xuXHQgICAgICAgIGluZGVudCA9IGluZGVudCArIGdhcDtcblxuXHQgICAgICAgIHZhciBrZXlzID0gcHJvcGVydHlMaXN0IHx8IE9iamVjdC5rZXlzKHZhbHVlKTtcblx0ICAgICAgICB2YXIgcGFydGlhbCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0ga2V5czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGtleSA9IGxpc3RbaV07XG5cblx0ICAgICAgICAgICAgdmFyIHByb3BlcnR5U3RyaW5nID0gc2VyaWFsaXplUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmIChwcm9wZXJ0eVN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWVtYmVyID0gc2VyaWFsaXplS2V5KGtleSkgKyAnOic7XG5cdCAgICAgICAgICAgICAgICBpZiAoZ2FwICE9PSAnJykge1xuXHQgICAgICAgICAgICAgICAgICAgIG1lbWJlciArPSAnICc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBtZW1iZXIgKz0gcHJvcGVydHlTdHJpbmc7XG5cdCAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gobWVtYmVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBmaW5hbDtcblx0ICAgICAgICBpZiAocGFydGlhbC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgZmluYWwgPSAne30nO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzO1xuXHQgICAgICAgICAgICBpZiAoZ2FwID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHBhcnRpYWwuam9pbignLCcpO1xuXHQgICAgICAgICAgICAgICAgZmluYWwgPSAneycgKyBwcm9wZXJ0aWVzICsgJ30nO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9ICcsXFxuJyArIGluZGVudDtcblx0ICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwYXJ0aWFsLmpvaW4oc2VwYXJhdG9yKTtcblx0ICAgICAgICAgICAgICAgIGZpbmFsID0gJ3tcXG4nICsgaW5kZW50ICsgcHJvcGVydGllcyArICcsXFxuJyArIHN0ZXBiYWNrICsgJ30nO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3RhY2sucG9wKCk7XG5cdCAgICAgICAgaW5kZW50ID0gc3RlcGJhY2s7XG5cdCAgICAgICAgcmV0dXJuIGZpbmFsXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUtleSAoa2V5KSB7XG5cdCAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHF1b3RlU3RyaW5nKGtleSwgdHJ1ZSlcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZmlyc3RDaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoa2V5LmNvZGVQb2ludEF0KDApKTtcblx0ICAgICAgICBpZiAoIXV0aWwuaXNJZFN0YXJ0Q2hhcihmaXJzdENoYXIpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBxdW90ZVN0cmluZyhrZXksIHRydWUpXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0Q2hhci5sZW5ndGg7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKCF1dGlsLmlzSWRDb250aW51ZUNoYXIoU3RyaW5nLmZyb21Db2RlUG9pbnQoa2V5LmNvZGVQb2ludEF0KGkpKSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZVN0cmluZyhrZXksIHRydWUpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ga2V5XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5ICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTjUnKVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG5cdCAgICAgICAgdmFyIHN0ZXBiYWNrID0gaW5kZW50O1xuXHQgICAgICAgIGluZGVudCA9IGluZGVudCArIGdhcDtcblxuXHQgICAgICAgIHZhciBwYXJ0aWFsID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgcHJvcGVydHlTdHJpbmcgPSBzZXJpYWxpemVQcm9wZXJ0eShTdHJpbmcoaSksIHZhbHVlKTtcblx0ICAgICAgICAgICAgcGFydGlhbC5wdXNoKChwcm9wZXJ0eVN0cmluZyAhPT0gdW5kZWZpbmVkKSA/IHByb3BlcnR5U3RyaW5nIDogJ251bGwnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZmluYWw7XG5cdCAgICAgICAgaWYgKHBhcnRpYWwubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGZpbmFsID0gJ1tdJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoZ2FwID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBwYXJ0aWFsLmpvaW4oJywnKTtcblx0ICAgICAgICAgICAgICAgIGZpbmFsID0gJ1snICsgcHJvcGVydGllcyArICddJztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLFxcbicgKyBpbmRlbnQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyQxID0gcGFydGlhbC5qb2luKHNlcGFyYXRvcik7XG5cdCAgICAgICAgICAgICAgICBmaW5hbCA9ICdbXFxuJyArIGluZGVudCArIHByb3BlcnRpZXMkMSArICcsXFxuJyArIHN0ZXBiYWNrICsgJ10nO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3RhY2sucG9wKCk7XG5cdCAgICAgICAgaW5kZW50ID0gc3RlcGJhY2s7XG5cdCAgICAgICAgcmV0dXJuIGZpbmFsXG5cdCAgICB9XG5cdH07XG5cblx0dmFyIEpTT041ID0ge1xuXHQgICAgcGFyc2U6IHBhcnNlLFxuXHQgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnksXG5cdH07XG5cblx0dmFyIGxpYiA9IEpTT041O1xuXG5cdHZhciBlczUgPSBsaWI7XG5cblx0cmV0dXJuIGVzNTtcblxufSkpKTtcbiIsInZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcblxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHJldHVybiAnYm9vbGVhbic7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykgcmV0dXJuICdzdHJpbmcnO1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHJldHVybiAnbnVtYmVyJztcbiAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSByZXR1cm4gJ3N5bWJvbCc7XG4gIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlzR2VuZXJhdG9yRm4odmFsKSA/ICdnZW5lcmF0b3JmdW5jdGlvbicgOiAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0J1ZmZlcih2YWwpKSByZXR1cm4gJ2J1ZmZlcic7XG4gIGlmIChpc0FyZ3VtZW50cyh2YWwpKSByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIGlmIChpc1JlZ2V4cCh2YWwpKSByZXR1cm4gJ3JlZ2V4cCc7XG5cbiAgc3dpdGNoIChjdG9yTmFtZSh2YWwpKSB7XG4gICAgY2FzZSAnU3ltYm9sJzogcmV0dXJuICdzeW1ib2wnO1xuICAgIGNhc2UgJ1Byb21pc2UnOiByZXR1cm4gJ3Byb21pc2UnO1xuXG4gICAgLy8gU2V0LCBNYXAsIFdlYWtTZXQsIFdlYWtNYXBcbiAgICBjYXNlICdXZWFrTWFwJzogcmV0dXJuICd3ZWFrbWFwJztcbiAgICBjYXNlICdXZWFrU2V0JzogcmV0dXJuICd3ZWFrc2V0JztcbiAgICBjYXNlICdNYXAnOiByZXR1cm4gJ21hcCc7XG4gICAgY2FzZSAnU2V0JzogcmV0dXJuICdzZXQnO1xuXG4gICAgLy8gOC1iaXQgdHlwZWQgYXJyYXlzXG4gICAgY2FzZSAnSW50OEFycmF5JzogcmV0dXJuICdpbnQ4YXJyYXknO1xuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOiByZXR1cm4gJ3VpbnQ4YXJyYXknO1xuICAgIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzogcmV0dXJuICd1aW50OGNsYW1wZWRhcnJheSc7XG5cbiAgICAvLyAxNi1iaXQgdHlwZWQgYXJyYXlzXG4gICAgY2FzZSAnSW50MTZBcnJheSc6IHJldHVybiAnaW50MTZhcnJheSc7XG4gICAgY2FzZSAnVWludDE2QXJyYXknOiByZXR1cm4gJ3VpbnQxNmFycmF5JztcblxuICAgIC8vIDMyLWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQzMkFycmF5JzogcmV0dXJuICdpbnQzMmFycmF5JztcbiAgICBjYXNlICdVaW50MzJBcnJheSc6IHJldHVybiAndWludDMyYXJyYXknO1xuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6IHJldHVybiAnZmxvYXQzMmFycmF5JztcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOiByZXR1cm4gJ2Zsb2F0NjRhcnJheSc7XG4gIH1cblxuICBpZiAoaXNHZW5lcmF0b3JPYmoodmFsKSkge1xuICAgIHJldHVybiAnZ2VuZXJhdG9yJztcbiAgfVxuXG4gIC8vIE5vbi1wbGFpbiBvYmplY3RzXG4gIHR5cGUgPSB0b1N0cmluZy5jYWxsKHZhbCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6IHJldHVybiAnb2JqZWN0JztcbiAgICAvLyBpdGVyYXRvcnNcbiAgICBjYXNlICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nOiByZXR1cm4gJ21hcGl0ZXJhdG9yJztcbiAgICBjYXNlICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nOiByZXR1cm4gJ3NldGl0ZXJhdG9yJztcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZyBJdGVyYXRvcl0nOiByZXR1cm4gJ3N0cmluZ2l0ZXJhdG9yJztcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXSc6IHJldHVybiAnYXJyYXlpdGVyYXRvcic7XG4gIH1cblxuICAvLyBvdGhlclxuICByZXR1cm4gdHlwZS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufTtcblxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSkgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgKHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0ID09PSAnbnVtYmVyJyk7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzUmVnZXhwKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuZmxhZ3MgPT09ICdzdHJpbmcnXG4gICAgJiYgdHlwZW9mIHZhbC5pZ25vcmVDYXNlID09PSAnYm9vbGVhbidcbiAgICAmJiB0eXBlb2YgdmFsLm11bHRpbGluZSA9PT0gJ2Jvb2xlYW4nXG4gICAgJiYgdHlwZW9mIHZhbC5nbG9iYWwgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JGbihuYW1lLCB2YWwpIHtcbiAgcmV0dXJuIGN0b3JOYW1lKG5hbWUpID09PSAnR2VuZXJhdG9yRnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iaih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB2YWwubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsLmNhbGxlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignY2FsbGVlJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU2FmYXJpIDUtNyAoOC0xMCB5ci1vbGQgYnJvd3NlciksXG4gKiB0YWtlIGEgbG9vayBhdCBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2lzLWJ1ZmZlclxuICovXG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICBpZiAodmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiLyohXG4gKiBtYXAtY2FjaGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L21hcC1jYWNoZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhwb3NlIGBNYXBDYWNoZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5L3ZhbHVlIHBhaXJzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgY2FjaGUgPSBuZXcgTWFwQ2FjaGUoKTtcbiAqIGBgYFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFwQ2FjaGUoZGF0YSkge1xuICB0aGlzLl9fZGF0YV9fID0gZGF0YSB8fCB7fTtcbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYGtleWAgb24gdGhlIGNhY2hlLlxuICpcbiAqIGBgYGpzXG4gKiBjYWNoZS5zZXQoJ2ZvbycsICdiYXInKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEBwYXJhbSB7Kn0gYHZhbHVlYCBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgQ2FjaGVgIG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBtYXBTZXQoa2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ICE9PSAnX19wcm90b19fJykge1xuICAgIHRoaXMuX19kYXRhX19ba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIGBgYGpzXG4gKiBjYWNoZS5nZXQoJ2ZvbycpO1xuICogLy89PiAnYmFyJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBtYXBHZXQoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdfX3Byb3RvX18nID8gdW5kZWZpbmVkIDogdGhpcy5fX2RhdGFfX1trZXldO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBgYGBqc1xuICogY2FjaGUuaGFzKCdmb28nKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIG1hcEhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXycgJiYgaGFzT3duLmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICpcbiAqIGBgYGpzXG4gKiBjYWNoZS5kZWwoJ2ZvbycpO1xuICogYGBgXG4gKiBAdGl0bGUgLmRlbFxuICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5LCBlbHNlIGBmYWxzZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hcENhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiBtYXBEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJ29iamVjdC12aXNpdCcpO1xuXG4vKipcbiAqIE1hcCBgdmlzaXRgIG92ZXIgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBjb2xsZWN0aW9uYCBUaGUgY29udGV4dCBpbiB3aGljaCB0byBpbnZva2UgYG1ldGhvZGBcbiAqIEBwYXJhbSAge1N0cmluZ30gYG1ldGhvZGAgTmFtZSBvZiB0aGUgbWV0aG9kIHRvIGNhbGwgb24gYGNvbGxlY3Rpb25gXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBhcnJgIEFycmF5IG9mIG9iamVjdHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXBWaXNpdChjb2xsZWN0aW9uLCBtZXRob2QsIHZhbCkge1xuICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIHJldHVybiB2aXNpdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBhcnJheTogJyArIHV0aWwuaW5zcGVjdCh2YWwpKTtcbiAgfVxuXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHZhbFtpXTtcbiAgICBpZiAoaXNPYmplY3QoZWxlKSkge1xuICAgICAgdmlzaXQuYXBwbHkobnVsbCwgW2NvbGxlY3Rpb24sIG1ldGhvZCwgZWxlXS5jb25jYXQoYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xsZWN0aW9uW21ldGhvZF0uYXBwbHkoY29sbGVjdGlvbiwgW2VsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8ICghQXJyYXkuaXNBcnJheSh2YWwpICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGNvbXBpbGVycyA9IHJlcXVpcmUoJy4vbGliL2NvbXBpbGVycycpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL2xpYi9wYXJzZXJzJyk7XG52YXIgY2FjaGUgPSByZXF1aXJlKCcuL2xpYi9jYWNoZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xuXG4vKipcbiAqIFRoZSBtYWluIGZ1bmN0aW9uIHRha2VzIGEgbGlzdCBvZiBzdHJpbmdzIGFuZCBvbmUgb3IgbW9yZVxuICogZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbShbJ2EuanMnLCAnYS50eHQnXSwgWycqLmpzJ10pKTtcbiAqIC8vPT4gWyAnYS5qcycgXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQSBsaXN0IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzXG4gKiBAc3VtbWFyeSBmYWxzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtaWNyb21hdGNoKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIHBhdHRlcm5zID0gdXRpbHMuYXJyYXlpZnkocGF0dGVybnMpO1xuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG5cbiAgdmFyIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwIHx8IGxlbiA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmIChsZW4gPT09IDEpIHtcbiAgICByZXR1cm4gbWljcm9tYXRjaC5tYXRjaChsaXN0LCBwYXR0ZXJuc1swXSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgb21pdCA9IFtdO1xuICB2YXIga2VlcCA9IFtdO1xuICB2YXIgaWR4ID0gLTE7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tpZHhdO1xuXG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoMCkgPT09IDMzIC8qICEgKi8pIHtcbiAgICAgIG9taXQucHVzaC5hcHBseShvbWl0LCBtaWNyb21hdGNoLm1hdGNoKGxpc3QsIHBhdHRlcm4uc2xpY2UoMSksIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2VlcC5wdXNoLmFwcGx5KGtlZXAsIG1pY3JvbWF0Y2gubWF0Y2gobGlzdCwgcGF0dGVybiwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaGVzID0gdXRpbHMuZGlmZihrZWVwLCBvbWl0KTtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubm9kdXBlcyAhPT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdXRpbHMudW5pcXVlKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byB0aGUgbWFpbiBmdW5jdGlvbiwgYnV0IGBwYXR0ZXJuYCBtdXN0IGJlIGEgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5tYXRjaChsaXN0LCBwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLm1hdGNoKFsnYS5hJywgJ2EuYWEnLCAnYS5iJywgJ2EuYyddLCAnKi5hJykpO1xuICogLy89PiBbJ2EuYScsICdhLmFhJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm1hdGNoID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgdmFyIGlzTWF0Y2ggPSBtZW1vaXplKCdtYXRjaCcsIHBhdHRlcm4sIG9wdGlvbnMsIG1pY3JvbWF0Y2gubWF0Y2hlcik7XG4gIHZhciBtYXRjaGVzID0gW107XG5cbiAgbGlzdCA9IHV0aWxzLmFycmF5aWZ5KGxpc3QpO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgZWxlID0gbGlzdFtpZHhdO1xuICAgIGlmIChlbGUgPT09IHBhdHRlcm4gfHwgaXNNYXRjaChlbGUpKSB7XG4gICAgICBtYXRjaGVzLnB1c2godXRpbHMudmFsdWUoZWxlLCB1bml4aWZ5LCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbm8gb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdW5pcXVpZnkgcmVzdWx0cyBhbmQgcmV0dXJuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdXRpbHMudW5pcXVlKG1hdGNoZXMpO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMuZmFpbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWF0Y2hlcyBmb3VuZCBmb3IgXCInICsgcGF0dGVybiArICdcIicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub251bGwgPT09IHRydWUgfHwgb3B0aW9ucy5udWxsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIFtvcHRpb25zLnVuZXNjYXBlID8gdXRpbHMudW5lc2NhcGUocGF0dGVybikgOiBwYXR0ZXJuXTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBgb3B0cy5pZ25vcmVgIHdhcyBkZWZpbmVkLCBkaWZmIGlnbm9yZWQgbGlzdFxuICBpZiAob3B0aW9ucy5pZ25vcmUpIHtcbiAgICBtYXRjaGVzID0gbWljcm9tYXRjaC5ub3QobWF0Y2hlcywgb3B0aW9ucy5pZ25vcmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMubm9kdXBlcyAhPT0gZmFsc2UgPyB1dGlscy51bmlxdWUobWF0Y2hlcykgOiBtYXRjaGVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgc3RyaW5nYCBtYXRjaGVzIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uaXNNYXRjaChzdHJpbmcsIHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uaXNNYXRjaCgnYS5hJywgJyouYScpKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uaXNNYXRjaCgnYS5iJywgJyouYScpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBtYXRjaGVzIHRoZSBnbG9iIHBhdHRlcm4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guaXNNYXRjaCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChpc0VtcHR5U3RyaW5nKHN0cikgfHwgaXNFbXB0eVN0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBlcXVhbHMgPSB1dGlscy5lcXVhbHNQYXR0ZXJuKG9wdGlvbnMpO1xuICBpZiAoZXF1YWxzKHN0cikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc01hdGNoID0gbWVtb2l6ZSgnaXNNYXRjaCcsIHBhdHRlcm4sIG9wdGlvbnMsIG1pY3JvbWF0Y2gubWF0Y2hlcik7XG4gIHJldHVybiBpc01hdGNoKHN0cik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzb21lIG9mIHRoZSBzdHJpbmdzIGluIHRoZSBnaXZlbiBgbGlzdGAgbWF0Y2ggYW55IG9mIHRoZVxuICogZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5zb21lKGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLnNvbWUoWydmb28uanMnLCAnYmFyLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLnNvbWUoWydmb28uanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgbGlzdGAgVGhlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIHRvIHRlc3QuIFJldHVybnMgYXMgc29vbiBhcyB0aGUgZmlyc3QgbWF0Y2ggaXMgZm91bmQuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLnNvbWUgPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbGlzdCA9IFtsaXN0XTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWljcm9tYXRjaChsaXN0W2ldLCBwYXR0ZXJucywgb3B0aW9ucykubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZXZlcnkgc3RyaW5nIGluIHRoZSBnaXZlbiBgbGlzdGAgbWF0Y2hlc1xuICogYW55IG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmV2ZXJ5KGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5ldmVyeShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogY29uc29sZS5sb2cobW0uZXZlcnkoWydmb28uanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgbGlzdGAgVGhlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmV2ZXJ5ID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgIGxpc3QgPSBbbGlzdF07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1pY3JvbWF0Y2gobGlzdFtpXSwgcGF0dGVybnMsIG9wdGlvbnMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmICoqYW55Kiogb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYFxuICogbWF0Y2ggdGhlIHNwZWNpZmllZCBgc3RyaW5nYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uYW55KHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uYW55KCdhLmEnLCBbJ2IuKicsICcqLmEnXSkpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5hbnkoJ2EuYScsICdiLionKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYHN0cmAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5hbnkgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKGlzRW1wdHlTdHJpbmcoc3RyKSB8fCBpc0VtcHR5U3RyaW5nKHBhdHRlcm5zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybnMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0dGVybnMgPSBbcGF0dGVybnNdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtaWNyb21hdGNoLmlzTWF0Y2goc3RyLCBwYXR0ZXJuc1tpXSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFsbCoqIG9mIHRoZSBnaXZlbiBgcGF0dGVybnNgIG1hdGNoXG4gKiB0aGUgc3BlY2lmaWVkIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uYWxsKHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnZionLCAnKm8qJywgJypvLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgc3RyYCBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmFsbCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXR0ZXJucyA9IFtwYXR0ZXJuc107XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbWljcm9tYXRjaC5pc01hdGNoKHN0ciwgcGF0dGVybnNbaV0sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBzdHJpbmdzIHRoYXQgXyoqZG8gbm90IG1hdGNoIGFueSoqXyBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0ubm90KGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLm5vdChbJ2EuYScsICdiLmInLCAnYy5jJ10sICcqLmEnKSk7XG4gKiAvLz0+IFsnYi5iJywgJ2MuYyddXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBsaXN0YCBBcnJheSBvZiBzdHJpbmdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0ICoqZG8gbm90IG1hdGNoKiogdGhlIGdpdmVuIHBhdHRlcm5zLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm5vdCA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgdmFyIGlnbm9yZSA9IG9wdHMuaWdub3JlO1xuICBkZWxldGUgb3B0cy5pZ25vcmU7XG5cbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdHMpO1xuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCkubWFwKHVuaXhpZnkpO1xuXG4gIHZhciBtYXRjaGVzID0gdXRpbHMuZGlmZihsaXN0LCBtaWNyb21hdGNoKGxpc3QsIHBhdHRlcm5zLCBvcHRzKSk7XG4gIGlmIChpZ25vcmUpIHtcbiAgICBtYXRjaGVzID0gdXRpbHMuZGlmZihtYXRjaGVzLCBtaWNyb21hdGNoKGxpc3QsIGlnbm9yZSkpO1xuICB9XG5cbiAgcmV0dXJuIG9wdHMubm9kdXBlcyAhPT0gZmFsc2UgPyB1dGlscy51bmlxdWUobWF0Y2hlcykgOiBtYXRjaGVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJpbmdgIGNvbnRhaW5zIHRoZSBnaXZlbiBwYXR0ZXJuLiBTaW1pbGFyXG4gKiB0byBbLmlzTWF0Y2hdKCNpc01hdGNoKSBidXQgdGhlIHBhdHRlcm4gY2FuIG1hdGNoIGFueSBwYXJ0IG9mIHRoZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmNvbnRhaW5zKHN0cmluZywgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5jb250YWlucygnYWEvYmIvY2MnLCAnKmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqZCcpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIFRoZSBzdHJpbmcgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdHRlciBtYXRjaGVzIGFueSBwYXJ0IG9mIGBzdHJgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNvbnRhaW5zID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybnMgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzRW1wdHlTdHJpbmcoc3RyKSB8fCBpc0VtcHR5U3RyaW5nKHBhdHRlcm5zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlcXVhbHMgPSB1dGlscy5lcXVhbHNQYXR0ZXJuKHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgICBpZiAoZXF1YWxzKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgY29udGFpbnMgPSB1dGlscy5jb250YWluc1BhdHRlcm4ocGF0dGVybnMsIG9wdGlvbnMpO1xuICAgIGlmIChjb250YWlucyhzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2NvbnRhaW5zOiB0cnVlfSk7XG4gIHJldHVybiBtaWNyb21hdGNoLmFueShzdHIsIHBhdHRlcm5zLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXR0ZXJuIGFuZCBvcHRpb25zIHNob3VsZCBlbmFibGVcbiAqIHRoZSBgbWF0Y2hCYXNlYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubWljcm9tYXRjaC5tYXRjaEJhc2UgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChwYXR0ZXJuICYmIHBhdHRlcm4uaW5kZXhPZignLycpICE9PSAtMSB8fCAhb3B0aW9ucykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0aW9ucy5iYXNlbmFtZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLm1hdGNoQmFzZSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRmlsdGVyIHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGdsb2JgIHBhdHRlcm5cbiAqIGFuZCBgb3B0aW9uc2AuIERvZXMgbm90IGF0dGVtcHQgdG8gbWF0Y2ggbmVzdGVkIGtleXMuIElmIHlvdSBuZWVkIHRoaXMgZmVhdHVyZSxcbiAqIHVzZSBbZ2xvYi1vYmplY3RdW10gaW5zdGVhZC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0ubWF0Y2hLZXlzKG9iamVjdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIG9iaiA9IHsgYWE6ICdhJywgYWI6ICdiJywgYWM6ICdjJyB9O1xuICogY29uc29sZS5sb2cobW0ubWF0Y2hLZXlzKG9iaiwgJypiJykpO1xuICogLy89PiB7IGFiOiAnYicgfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamVjdGAgVGhlIG9iamVjdCB3aXRoIGtleXMgdG8gZmlsdGVyLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBvbmx5IGtleXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2hLZXlzID0gZnVuY3Rpb24ob2JqLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBtaWNyb21hdGNoKE9iamVjdC5rZXlzKG9iaiksIHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHV0aWxzLnBpY2sob2JqLCBrZXlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG1lbW9pemVkIG1hdGNoZXIgZnVuY3Rpb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAgYW5kIGBvcHRpb25zYC5cbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB0byBtYXRjaCBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLm1hdGNoZXIocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgaXNNYXRjaCA9IG1tLm1hdGNoZXIoJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYicpKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBjb21wb3NlKHBhdHRlcm4sIG9wdGlvbnMsIG1hdGNoZXIpO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBhIHJlZ2V4XG4gIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHRlc3QocGF0dGVybik7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGludmFsaWRcbiAgaWYgKCF1dGlscy5pc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYW4gYXJyYXksIHN0cmluZyBvciByZWdleCcpO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBhIG5vbi1nbG9iIHN0cmluZ1xuICBpZiAoIXV0aWxzLmhhc1NwZWNpYWxDaGFycyhwYXR0ZXJuKSkge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9jYXNlID09PSB0cnVlKSB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMubWF0Y2hQYXRoKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBhIGdsb2Igc3RyaW5nXG4gIHZhciByZSA9IG1pY3JvbWF0Y2gubWFrZVJlKHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gIC8vIGlmIGBvcHRpb25zLm1hdGNoQmFzZWAgb3IgYG9wdGlvbnMuYmFzZW5hbWVgIGlzIGRlZmluZWRcbiAgaWYgKG1pY3JvbWF0Y2gubWF0Y2hCYXNlKHBhdHRlcm4sIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHV0aWxzLm1hdGNoQmFzZW5hbWUocmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdChyZWdleCkge1xuICAgIHZhciBlcXVhbHMgPSB1dGlscy5lcXVhbHNQYXR0ZXJuKG9wdGlvbnMpO1xuICAgIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChlcXVhbHMoc3RyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZ2V4LnRlc3QodW5peGlmeShzdHIpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZuID0gdGVzdChyZSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ3Jlc3VsdCcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHJlLnJlc3VsdFxuICB9KTtcbiAgcmV0dXJuIGZuO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXMgY2FwdHVyZWQgYnkgYHBhdHRlcm5gIGluIGBzdHJpbmcsIG9yIGBudWxsYCBpZiB0aGUgcGF0dGVybiBkaWQgbm90IG1hdGNoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5jYXB0dXJlKHBhdHRlcm4sIHN0cmluZ1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5jYXB0dXJlKCd0ZXN0LyouanMnLCAndGVzdC9mb28uanMnKSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGNvbnNvbGUubG9nKG1tLmNhcHR1cmUoJ3Rlc3QvKi5qcycsICdmb28vYmFyLmNzcycpKTtcbiAqIC8vPT4gbnVsbFxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYW4gYXJyYXkgb2YgY2FwdHVyZXMgaWYgdGhlIHN0cmluZyBtYXRjaGVzIHRoZSBnbG9iIHBhdHRlcm4sIG90aGVyd2lzZSBgbnVsbGAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guY2FwdHVyZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0ciwgb3B0aW9ucykge1xuICB2YXIgcmUgPSBtaWNyb21hdGNoLm1ha2VSZShwYXR0ZXJuLCBleHRlbmQoe2NhcHR1cmU6IHRydWV9LCBvcHRpb25zKSk7XG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcblxuICBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHVuaXhpZnkoc3RyaW5nKSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0gbWVtb2l6ZSgnY2FwdHVyZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1hdGNoKTtcbiAgcmV0dXJuIGNhcHR1cmUoc3RyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5tYWtlUmUocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5tYWtlUmUoJyouanMnKSk7XG4gKiAvLz0+IC9eKD86KFxcLltcXFxcXFwvXSk/KD8hXFwuKSg/PS4pW15cXC9dKj9cXC5qcykkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEEgZ2xvYiBwYXR0ZXJuIHRvIGNvbnZlcnQgdG8gcmVnZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZC5cbiAqIEByZXR1cm4ge1JlZ0V4cH0gUmV0dXJucyBhIHJlZ2V4IGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5tYWtlUmUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGxlc3MgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVJlKCkge1xuICAgIHZhciByZXN1bHQgPSBtaWNyb21hdGNoLmNyZWF0ZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICB2YXIgYXN0X2FycmF5ID0gW107XG4gICAgdmFyIG91dHB1dCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24ob2JqKSB7XG4gICAgICBvYmouYXN0LnN0YXRlID0gb2JqLnN0YXRlO1xuICAgICAgYXN0X2FycmF5LnB1c2gob2JqLmFzdCk7XG4gICAgICByZXR1cm4gb2JqLm91dHB1dDtcbiAgICB9KTtcblxuICAgIHZhciByZWdleCA9IHRvUmVnZXgob3V0cHV0LmpvaW4oJ3wnKSwgb3B0aW9ucyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZ2V4LCAncmVzdWx0Jywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogYXN0X2FycmF5XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZ2V4O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ21ha2VSZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1ha2VSZSk7XG59O1xuXG4vKipcbiAqIEV4cGFuZCB0aGUgZ2l2ZW4gYnJhY2UgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBjb25zb2xlLmxvZyhtbS5icmFjZXMoJ2Zvby97YSxifS9iYXInKSk7XG4gKiAvLz0+IFsnZm9vLyhhfGIpL2JhciddXG4gKlxuICogY29uc29sZS5sb2cobW0uYnJhY2VzKCdmb28ve2EsYn0vYmFyJywge2V4cGFuZDogdHJ1ZX0pKTtcbiAqIC8vPT4gWydmb28vKGF8YikvYmFyJ11cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBTdHJpbmcgd2l0aCBicmFjZSBwYXR0ZXJuIHRvIGV4cGFuZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgQW55IFtvcHRpb25zXSgjb3B0aW9ucykgdG8gY2hhbmdlIGhvdyBleHBhbnNpb24gaXMgcGVyZm9ybWVkLiBTZWUgdGhlIFticmFjZXNdW10gbGlicmFyeSBmb3IgYWxsIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYnJhY2VzID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhbiBhcnJheSBvciBzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZCgpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vYnJhY2UgPT09IHRydWUgfHwgIS9cXHsuKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLmFycmF5aWZ5KHBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gYnJhY2VzKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2JyYWNlcycsIHBhdHRlcm4sIG9wdGlvbnMsIGV4cGFuZCk7XG59O1xuXG4vKipcbiAqIFByb3h5IHRvIHRoZSBbbWljcm9tYXRjaC5icmFjZXNdKCNtZXRob2QpLCBmb3IgcGFyaXR5IHdpdGhcbiAqIG1pbmltYXRjaC5cbiAqL1xuXG5taWNyb21hdGNoLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2V4cGFuZDogdHJ1ZX0pO1xuICByZXR1cm4gbWljcm9tYXRjaC5icmFjZXMocGF0dGVybiwgb3B0cyk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWJzdHJhY3Qgc3ludGF4XG4gKiB0cmVlcyAoQVNUcyksIHdpdGggdGhlIGNvbXBpbGVkIGBvdXRwdXRgIGFuZCBvcHRpb25hbCBzb3VyY2UgYG1hcGAgb25cbiAqIGVhY2ggQVNULlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5jcmVhdGUocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5jcmVhdGUoJ2FiYy8qLmpzJykpO1xuICogLy8gW3sgb3B0aW9uczogeyBzb3VyY2U6ICdzdHJpbmcnLCBzb3VyY2VtYXA6IHRydWUgfSxcbiAqIC8vICAgc3RhdGU6IHt9LFxuICogLy8gICBjb21waWxlcnM6XG4gKiAvLyAgICB7IC4uLiB9LFxuICogLy8gICBvdXRwdXQ6ICcoXFxcXC5bXFxcXFxcXFxcXFxcL10pP2FiY1xcXFwvKD8hXFxcXC4pKD89LilbXlxcXFwvXSo/XFxcXC5qcycsXG4gKiAvLyAgIGFzdDpcbiAqIC8vICAgIHsgdHlwZTogJ3Jvb3QnLFxuICogLy8gICAgICBlcnJvcnM6IFtdLFxuICogLy8gICAgICBub2RlczpcbiAqIC8vICAgICAgIFsgLi4uIF0sXG4gKiAvLyAgICAgIGRvdDogZmFsc2UsXG4gKiAvLyAgICAgIGlucHV0OiAnYWJjLyouanMnIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdLFxuICogLy8gICBtYXA6XG4gKiAvLyAgICB7IHZlcnNpb246IDMsXG4gKiAvLyAgICAgIHNvdXJjZXM6IFsgJ3N0cmluZycgXSxcbiAqIC8vICAgICAgbmFtZXM6IFtdLFxuICogLy8gICAgICBtYXBwaW5nczogJ0FBQUEsR0FBRyxFQUFDLGtCQUFDLEVBQUMsRUFBRScsXG4gKiAvLyAgICAgIHNvdXJjZXNDb250ZW50OiBbICdhYmMvKi5qcycgXSB9LFxuICogLy8gICBwb3NpdGlvbjogeyBsaW5lOiAxLCBjb2x1bW46IDI4IH0sXG4gKiAvLyAgIGNvbnRlbnQ6IHt9LFxuICogLy8gICBmaWxlczoge30sXG4gKiAvLyAgIGlkeDogNiB9XVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byBwYXJzZSBhbmQgY29tcGlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgQW55IFtvcHRpb25zXSgjb3B0aW9ucykgdG8gY2hhbmdlIGhvdyBwYXJzaW5nIGFuZCBjb21waWxpbmcgaXMgcGVyZm9ybWVkLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgQVNULCBjb21waWxlZCBzdHJpbmcgYW5kIG9wdGlvbmFsIHNvdXJjZSBtYXAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guY3JlYXRlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gbWVtb2l6ZSgnY3JlYXRlJywgcGF0dGVybiwgb3B0aW9ucywgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHN0ciwgb3B0cykge1xuICAgICAgcmV0dXJuIG1pY3JvbWF0Y2guY29tcGlsZShtaWNyb21hdGNoLnBhcnNlKHN0ciwgb3B0cyksIG9wdHMpO1xuICAgIH1cblxuICAgIHBhdHRlcm4gPSBtaWNyb21hdGNoLmJyYWNlcyhwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICB2YXIgbGVuID0gcGF0dGVybi5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuICAgIHZhciByZXMgPSBbXTtcblxuICAgIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgICAgcmVzLnB1c2goY3JlYXRlKHBhdHRlcm5baWR4XSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9KTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0ucGFyc2UocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgYXN0ID0gbW0ucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYXN0KTtcbiAqIC8vIHsgdHlwZTogJ3Jvb3QnLFxuICogLy8gICBlcnJvcnM6IFtdLFxuICogLy8gICBpbnB1dDogJ2Eve2IsY30vZCcsXG4gKiAvLyAgIG5vZGVzOlxuICogLy8gICAgWyB7IHR5cGU6ICdib3MnLCB2YWw6ICcnIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICdhLycgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnYnJhY2UnLFxuICogLy8gICAgICAgIG5vZGVzOlxuICogLy8gICAgICAgICBbIHsgdHlwZTogJ2JyYWNlLm9wZW4nLCB2YWw6ICd7JyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICdiLGMnIH0sXG4gKiAvLyAgICAgICAgICAgeyB0eXBlOiAnYnJhY2UuY2xvc2UnLCB2YWw6ICd9JyB9IF0gfSxcbiAqIC8vICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJy9kJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICdlb3MnLCB2YWw6ICcnIH0gXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIEFTVFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLnBhcnNlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgIHZhciBzbmFwZHJhZ29uID0gdXRpbHMuaW5zdGFudGlhdGUobnVsbCwgb3B0aW9ucyk7XG4gICAgcGFyc2VycyhzbmFwZHJhZ29uLCBvcHRpb25zKTtcblxuICAgIHZhciBhc3QgPSBzbmFwZHJhZ29uLnBhcnNlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHV0aWxzLmRlZmluZShhc3QsICdzbmFwZHJhZ29uJywgc25hcGRyYWdvbik7XG4gICAgYXN0LmlucHV0ID0gcGF0dGVybjtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ3BhcnNlJywgcGF0dGVybiwgb3B0aW9ucywgcGFyc2UpO1xufTtcblxuLyoqXG4gKiBDb21waWxlIHRoZSBnaXZlbiBgYXN0YCBvciBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5jb21waWxlKGFzdFssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgYXN0ID0gbW0ucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2cobW0uY29tcGlsZShhc3QpKTtcbiAqIC8vIHsgb3B0aW9uczogeyBzb3VyY2U6ICdzdHJpbmcnIH0sXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyBlb3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIG5vb3A6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgYnJhY2U6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5vcGVuJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgdGV4dDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNlLmNsb3NlJzogW0Z1bmN0aW9uXSB9LFxuICogLy8gICBvdXRwdXQ6IFsgJ2EvKGJ8YykvZCcgXSxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyAuLi4gfSxcbiAqIC8vICAgcGFyc2luZ0Vycm9yczogW10gfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGBhc3RgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIGFuIGBvdXRwdXRgIHByb3BlcnR5IHdpdGggdGhlIGNvbXBpbGVkIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jb21waWxlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgYXN0ID09PSAnc3RyaW5nJykge1xuICAgIGFzdCA9IG1pY3JvbWF0Y2gucGFyc2UoYXN0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdjb21waWxlJywgYXN0LmlucHV0LCBvcHRpb25zLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgc25hcGRyYWdvbiA9IHV0aWxzLmluc3RhbnRpYXRlKGFzdCwgb3B0aW9ucyk7XG4gICAgY29tcGlsZXJzKHNuYXBkcmFnb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzbmFwZHJhZ29uLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSByZWdleCBjYWNoZS5cbiAqXG4gKiBgYGBqc1xuICogbW0uY2xlYXJDYWNoZSgpO1xuICogYGBgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBtaWNyb21hdGNoLmNhY2hlLmNhY2hlcyA9IHt9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGVmZmVjdGl2ZWx5IGFuIGVtcHR5IHN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGlzRW1wdHlTdHJpbmcodmFsKSB7XG4gIHJldHVybiBTdHJpbmcodmFsKSA9PT0gJycgfHwgU3RyaW5nKHZhbCkgPT09ICcuLyc7XG59XG5cbi8qKlxuICogQ29tcG9zZSBhIG1hdGNoZXIgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBUaGlzIGFsbG93cyBtYXRjaGVyIGZ1bmN0aW9ucyB0byBiZSBjb21waWxlZCBvbmNlIGFuZFxuICogY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UocGF0dGVybnMsIG9wdGlvbnMsIG1hdGNoZXIpIHtcbiAgdmFyIG1hdGNoZXJzO1xuXG4gIHJldHVybiBtZW1vaXplKCdjb21wb3NlJywgU3RyaW5nKHBhdHRlcm5zKSwgb3B0aW9ucywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIC8vIGRlbGF5IGNvbXBvc2l0aW9uIHVudGlsIGl0J3MgaW52b2tlZCB0aGUgZmlyc3QgdGltZSxcbiAgICAgIC8vIGFmdGVyIHRoYXQgaXQgd29uJ3QgYmUgY2FsbGVkIGFnYWluXG4gICAgICBpZiAoIW1hdGNoZXJzKSB7XG4gICAgICAgIG1hdGNoZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIocGF0dGVybnNbaV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gbWF0Y2hlcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGlmIChtYXRjaGVyc1tsZW5dKGZpbGUpID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBNZW1vaXplIGEgZ2VuZXJhdGVkIHJlZ2V4IG9yIGZ1bmN0aW9uLiBBIHVuaXF1ZSBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBmcm9tIHRoZSBgdHlwZWAgKHVzdWFsbHkgbWV0aG9kIG5hbWUpLCB0aGUgYHBhdHRlcm5gLCBhbmRcbiAqIHVzZXItZGVmaW5lZCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemUodHlwZSwgcGF0dGVybiwgb3B0aW9ucywgZm4pIHtcbiAgdmFyIGtleSA9IHV0aWxzLmNyZWF0ZUtleSh0eXBlICsgJz0nICsgcGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoY2FjaGUuaGFzKHR5cGUsIGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KHR5cGUsIGtleSk7XG4gIH1cblxuICB2YXIgdmFsID0gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIGNhY2hlLnNldCh0eXBlLCBrZXksIHZhbCk7XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRXhwb3NlIGNvbXBpbGVyLCBwYXJzZXIgYW5kIGNhY2hlIG9uIGBtaWNyb21hdGNoYFxuICovXG5cbm1pY3JvbWF0Y2guY29tcGlsZXJzID0gY29tcGlsZXJzO1xubWljcm9tYXRjaC5wYXJzZXJzID0gcGFyc2Vycztcbm1pY3JvbWF0Y2guY2FjaGVzID0gY2FjaGUuY2FjaGVzO1xuXG4vKipcbiAqIEV4cG9zZSBgbWljcm9tYXRjaGBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pY3JvbWF0Y2g7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5ldyAocmVxdWlyZSgnZnJhZ21lbnQtY2FjaGUnKSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5hbm9tYXRjaCA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xudmFyIGV4dGdsb2IgPSByZXF1aXJlKCdleHRnbG9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc25hcGRyYWdvbikge1xuICB2YXIgY29tcGlsZXJzID0gc25hcGRyYWdvbi5jb21waWxlci5jb21waWxlcnM7XG4gIHZhciBvcHRzID0gc25hcGRyYWdvbi5vcHRpb25zO1xuXG4gIC8vIHJlZ2lzdGVyIG5hbm9tYXRjaCBjb21waWxlcnNcbiAgc25hcGRyYWdvbi51c2UobmFub21hdGNoLmNvbXBpbGVycyk7XG5cbiAgLy8gZ2V0IHJlZmVyZW5jZXMgdG8gc29tZSBzcGVjaWZpYyBuYW5vbWF0Y2ggY29tcGlsZXJzIGJlZm9yZSB0aGV5XG4gIC8vIGFyZSBvdmVycmlkZGVuIGJ5IHRoZSBleHRnbG9iIGFuZC9vciBjdXN0b20gY29tcGlsZXJzXG4gIHZhciBlc2NhcGUgPSBjb21waWxlcnMuZXNjYXBlO1xuICB2YXIgcW1hcmsgPSBjb21waWxlcnMucW1hcms7XG4gIHZhciBzbGFzaCA9IGNvbXBpbGVycy5zbGFzaDtcbiAgdmFyIHN0YXIgPSBjb21waWxlcnMuc3RhcjtcbiAgdmFyIHRleHQgPSBjb21waWxlcnMudGV4dDtcbiAgdmFyIHBsdXMgPSBjb21waWxlcnMucGx1cztcbiAgdmFyIGRvdCA9IGNvbXBpbGVycy5kb3Q7XG5cbiAgLy8gcmVnaXN0ZXIgZXh0Z2xvYiBjb21waWxlcnMgb3IgZXNjYXBlIGV4Z2xvYnMgaWYgZGlzYWJsZWRcbiAgaWYgKG9wdHMuZXh0Z2xvYiA9PT0gZmFsc2UgfHwgb3B0cy5ub2V4dCA9PT0gdHJ1ZSkge1xuICAgIHNuYXBkcmFnb24uY29tcGlsZXIudXNlKGVzY2FwZUV4dGdsb2JzKTtcbiAgfSBlbHNlIHtcbiAgICBzbmFwZHJhZ29uLnVzZShleHRnbG9iLmNvbXBpbGVycyk7XG4gIH1cblxuICBzbmFwZHJhZ29uLnVzZShmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wdGlvbnMuc3RhciA9IHRoaXMub3B0aW9ucy5zdGFyIHx8IGZ1bmN0aW9uKC8qbm9kZSovKSB7XG4gICAgICByZXR1cm4gJ1teXFxcXFxcXFwvXSo/JztcbiAgICB9O1xuICB9KTtcblxuICAvLyBjdXN0b20gbWljcm9tYXRjaCBjb21waWxlcnNcbiAgc25hcGRyYWdvbi5jb21waWxlclxuXG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlZCBjb21waWxlclxuICAgIC5zZXQoJ2RvdCcsIGRvdClcbiAgICAuc2V0KCdlc2NhcGUnLCBlc2NhcGUpXG4gICAgLnNldCgncGx1cycsIHBsdXMpXG4gICAgLnNldCgnc2xhc2gnLCBzbGFzaClcbiAgICAuc2V0KCdxbWFyaycsIHFtYXJrKVxuICAgIC5zZXQoJ3N0YXInLCBzdGFyKVxuICAgIC5zZXQoJ3RleHQnLCB0ZXh0KTtcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZUV4dGdsb2JzKGNvbXBpbGVyKSB7XG4gIGNvbXBpbGVyLnNldCgncGFyZW4nLCBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHZhbCA9ICcnO1xuICAgIHZpc2l0KG5vZGUsIGZ1bmN0aW9uKHRvaykge1xuICAgICAgaWYgKHRvay52YWwpIHZhbCArPSAoL15cXFcvLnRlc3QodG9rLnZhbCkgPyAnXFxcXCcgOiAnJykgKyB0b2sudmFsO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFZpc2l0IGBub2RlYCB3aXRoIHRoZSBnaXZlbiBgZm5gXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGZuKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZXMgPyBtYXBWaXNpdChub2RlLm5vZGVzLCBmbikgOiBmbihub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgdmlzaXQgb3ZlciBhcnJheSBvZiBgbm9kZXNgLlxuICAgKi9cblxuICBmdW5jdGlvbiBtYXBWaXNpdChub2RlcywgZm4pIHtcbiAgICB2YXIgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIHZpc2l0KG5vZGVzW2lkeF0sIGZuKTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGdsb2IgPSByZXF1aXJlKCdleHRnbG9iJyk7XG52YXIgbmFub21hdGNoID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG52YXIgcmVnZXhOb3QgPSByZXF1aXJlKCdyZWdleC1ub3QnKTtcbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciBub3Q7XG5cbi8qKlxuICogQ2hhcmFjdGVycyB0byB1c2UgaW4gbmVnYXRpb24gcmVnZXggKHdlIHdhbnQgdG8gXCJub3RcIiBtYXRjaFxuICogY2hhcmFjdGVycyB0aGF0IGFyZSBtYXRjaGVkIGJ5IG90aGVyIHBhcnNlcnMpXG4gKi9cblxudmFyIFRFWFQgPSAnKFshQCo/K10/XFxcXCh8XFxcXCl8XFxcXFs6Pyg/PS4qPzo/XFxcXF0pfDo/XFxcXF18WyorPyFeJC5cXFxcXFxcXC9dKSsnO1xudmFyIGNyZWF0ZU5vdFJlZ2V4ID0gZnVuY3Rpb24ob3B0cykge1xuICByZXR1cm4gbm90IHx8IChub3QgPSB0ZXh0UmVnZXgoVEVYVCkpO1xufTtcblxuLyoqXG4gKiBQYXJzZXJzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzbmFwZHJhZ29uKSB7XG4gIHZhciBwYXJzZXJzID0gc25hcGRyYWdvbi5wYXJzZXIucGFyc2VycztcblxuICAvLyByZWdpc3RlciBuYW5vbWF0Y2ggcGFyc2Vyc1xuICBzbmFwZHJhZ29uLnVzZShuYW5vbWF0Y2gucGFyc2Vycyk7XG5cbiAgLy8gZ2V0IHJlZmVyZW5jZXMgdG8gc29tZSBzcGVjaWZpYyBuYW5vbWF0Y2ggcGFyc2VycyBiZWZvcmUgdGhleVxuICAvLyBhcmUgb3ZlcnJpZGRlbiBieSB0aGUgZXh0Z2xvYiBhbmQvb3IgcGFyc2Vyc1xuICB2YXIgZXNjYXBlID0gcGFyc2Vycy5lc2NhcGU7XG4gIHZhciBzbGFzaCA9IHBhcnNlcnMuc2xhc2g7XG4gIHZhciBxbWFyayA9IHBhcnNlcnMucW1hcms7XG4gIHZhciBwbHVzID0gcGFyc2Vycy5wbHVzO1xuICB2YXIgc3RhciA9IHBhcnNlcnMuc3RhcjtcbiAgdmFyIGRvdCA9IHBhcnNlcnMuZG90O1xuXG4gIC8vIHJlZ2lzdGVyIGV4dGdsb2IgcGFyc2Vyc1xuICBzbmFwZHJhZ29uLnVzZShleHRnbG9iLnBhcnNlcnMpO1xuXG4gIC8vIGN1c3RvbSBtaWNyb21hdGNoIHBhcnNlcnNcbiAgc25hcGRyYWdvbi5wYXJzZXJcbiAgICAudXNlKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gb3ZlcnJpZGUgXCJub3RSZWdleFwiIGNyZWF0ZWQgaW4gbmFub21hdGNoIHBhcnNlclxuICAgICAgdGhpcy5ub3RSZWdleCA9IC9eXFwhKyg/IVxcKCkvO1xuICAgIH0pXG4gICAgLy8gcmVzZXQgdGhlIHJlZmVyZW5jZWQgcGFyc2Vyc1xuICAgIC5jYXB0dXJlKCdlc2NhcGUnLCBlc2NhcGUpXG4gICAgLmNhcHR1cmUoJ3NsYXNoJywgc2xhc2gpXG4gICAgLmNhcHR1cmUoJ3FtYXJrJywgcW1hcmspXG4gICAgLmNhcHR1cmUoJ3N0YXInLCBzdGFyKVxuICAgIC5jYXB0dXJlKCdwbHVzJywgcGx1cylcbiAgICAuY2FwdHVyZSgnZG90JywgZG90KVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYHRleHRgIHBhcnNlclxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goY3JlYXRlTm90UmVnZXgodGhpcy5vcHRpb25zKSk7XG4gICAgICBpZiAoIW0gfHwgIW1bMF0pIHJldHVybjtcblxuICAgICAgLy8gZXNjYXBlIHJlZ2V4IGJvdW5kYXJ5IGNoYXJhY3RlcnMgYW5kIHNpbXBsZSBicmFja2V0c1xuICAgICAgdmFyIHZhbCA9IG1bMF0ucmVwbGFjZSgvKFtbXFxdXiRdKS9nLCAnXFxcXCQxJyk7XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRleHQgcmVnZXhcbiAqL1xuXG5mdW5jdGlvbiB0ZXh0UmVnZXgocGF0dGVybikge1xuICB2YXIgbm90U3RyID0gcmVnZXhOb3QuY3JlYXRlKHBhdHRlcm4sIHtjb250YWluczogdHJ1ZSwgc3RyaWN0Q2xvc2U6IGZhbHNlfSk7XG4gIHZhciBwcmVmaXggPSAnKD86W1xcXFxeXXxcXFxcXFxcXHwnO1xuICByZXR1cm4gdG9SZWdleChwcmVmaXggKyBub3RTdHIgKyAnKScsIHtzdHJpY3RDbG9zZTogZmFsc2V9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG51dGlscy5kZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnV0aWxzLmRpZmYgPSByZXF1aXJlKCdhcnItZGlmZicpO1xudXRpbHMuZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnV0aWxzLnBpY2sgPSByZXF1aXJlKCdvYmplY3QucGljaycpO1xudXRpbHMudHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudXRpbHMudW5pcXVlID0gcmVxdWlyZSgnYXJyYXktdW5pcXVlJyk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwbGF0Zm9ybSBpcyB3aW5kb3dzLCBvciBgcGF0aC5zZXBgIGlzIGBcXFxcYC5cbiAqIFRoaXMgaXMgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHRvIGFsbG93IGBwYXRoLnNlcGAgdG8gYmUgc2V0IGluIHVuaXQgdGVzdHMsXG4gKiBvciBieSB0aGUgdXNlciwgaWYgdGhlcmUgaXMgYSByZWFzb24gdG8gZG8gc28uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnV0aWxzLmlzV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcGF0aC5zZXAgPT09ICdcXFxcJyB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGBTbmFwZHJhZ29uYCBpbnN0YW5jZSB0byB1c2VcbiAqL1xuXG51dGlscy5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICB2YXIgc25hcGRyYWdvbjtcbiAgLy8gaWYgYW4gaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgYnkgYC5wYXJzZWAsIHVzZSB0aGF0IGluc3RhbmNlXG4gIGlmICh1dGlscy50eXBlT2YoYXN0KSA9PT0gJ29iamVjdCcgJiYgYXN0LnNuYXBkcmFnb24pIHtcbiAgICBzbmFwZHJhZ29uID0gYXN0LnNuYXBkcmFnb247XG4gIC8vIGlmIHRoZSB1c2VyIHN1cHBsaWVzIGFuIGluc3RhbmNlIG9uIG9wdGlvbnMsIHVzZSB0aGF0IGluc3RhbmNlXG4gIH0gZWxzZSBpZiAodXRpbHMudHlwZU9mKG9wdGlvbnMpID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLnNuYXBkcmFnb24pIHtcbiAgICBzbmFwZHJhZ29uID0gb3B0aW9ucy5zbmFwZHJhZ29uO1xuICAvLyBjcmVhdGUgYSBuZXcgaW5zdGFuY2VcbiAgfSBlbHNlIHtcbiAgICBzbmFwZHJhZ29uID0gbmV3IFNuYXBkcmFnb24ob3B0aW9ucyk7XG4gIH1cblxuICB1dGlscy5kZWZpbmUoc25hcGRyYWdvbiwgJ3BhcnNlJywgZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZCA9IFNuYXBkcmFnb24ucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcGFyc2VkLmlucHV0ID0gc3RyO1xuXG4gICAgLy8gZXNjYXBlIHVubWF0Y2hlZCBicmFjZS9icmFja2V0L3BhcmVuc1xuICAgIHZhciBsYXN0ID0gdGhpcy5wYXJzZXIuc3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3QgJiYgdGhpcy5vcHRpb25zLnN0cmljdEVycm9ycyAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIG9wZW4gPSBsYXN0Lm5vZGVzWzBdO1xuICAgICAgdmFyIGlubmVyID0gbGFzdC5ub2Rlc1sxXTtcbiAgICAgIGlmIChsYXN0LnR5cGUgPT09ICdicmFja2V0Jykge1xuICAgICAgICBpZiAoaW5uZXIudmFsLmNoYXJBdCgwKSA9PT0gJ1snKSB7XG4gICAgICAgICAgaW5uZXIudmFsID0gJ1xcXFwnICsgaW5uZXIudmFsO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZW4udmFsID0gJ1xcXFwnICsgb3Blbi52YWw7XG4gICAgICAgIHZhciBzaWJsaW5nID0gb3Blbi5wYXJlbnQubm9kZXNbMV07XG4gICAgICAgIGlmIChzaWJsaW5nLnR5cGUgPT09ICdzdGFyJykge1xuICAgICAgICAgIHNpYmxpbmcubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vbi1lbnVtZXJhYmxlIHBhcnNlciByZWZlcmVuY2VcbiAgICB1dGlscy5kZWZpbmUocGFyc2VkLCAncGFyc2VyJywgdGhpcy5wYXJzZXIpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0pO1xuXG4gIHJldHVybiBzbmFwZHJhZ29uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGtleSB0byB1c2UgZm9yIG1lbW9pemF0aW9uLiBUaGUga2V5IGlzIGdlbmVyYXRlZFxuICogYnkgaXRlcmF0aW5nIG92ZXIgdGhlIG9wdGlvbnMgYW5kIGNvbmNhdGVuYXRpbmcga2V5LXZhbHVlIHBhaXJzXG4gKiB0byB0aGUgcGF0dGVybiBzdHJpbmcuXG4gKi9cblxudXRpbHMuY3JlYXRlS2V5ID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodXRpbHMudHlwZU9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHZhciB2YWwgPSBwYXR0ZXJuO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YWwgKz0gJzsnICsga2V5ICsgJz0nICsgU3RyaW5nKG9wdGlvbnNba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQ2FzdCBgdmFsYCB0byBhbiBhcnJheVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxudXRpbHMuYXJyYXlpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gW3ZhbF07XG4gIHJldHVybiB2YWwgPyAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pIDogW107XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICovXG5cbnV0aWxzLmlzU3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbGAgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKi9cblxudXRpbHMuaXNPYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHV0aWxzLnR5cGVPZih2YWwpID09PSAnb2JqZWN0Jztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyYCBoYXMgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gKi9cblxudXRpbHMuaGFzU3BlY2lhbENoYXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAvKD86KD86KF58XFwvKVshLl0pfFsqPysoKXxcXFtcXF17fV18WytAXVxcKCkvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICovXG5cbnV0aWxzLmVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxde30oKV4kfCorPy5cXFxcXFwvXFxzXS9nLCAnXFxcXCQmJyk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBzbGFzaGVzIGluIHRoZSBnaXZlbiBmaWxlcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYGZpbGVwYXRoYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnRvUG9zaXhQYXRoID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXCsvZywgJy8nKTtcbn07XG5cbi8qKlxuICogU3RyaXAgYmFja3NsYXNoZXMgYmVmb3JlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy51bmVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdXRpbHMudG9Qb3NpeFBhdGgoc3RyLnJlcGxhY2UoL1xcXFwoPz1bKis/IS5dKS9nLCAnJykpO1xufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgcHJlZml4IGZyb20gYSBmaWxlcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IGBmcGBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy5zdHJpcFByZWZpeCA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXIgY2ggPSBzdHIuY2hhckF0KDEpO1xuICBpZiAodXRpbHMuaXNTbGFzaChjaCkpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyIGlzIGFuIGVzY2FwZWQgb3JcbiAqIHVuZXNjYXBlZCBwYXRoIGNoYXJhY3RlclxuICovXG5cbnV0aWxzLmlzU2xhc2ggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ciA9PT0gJy8nIHx8IHN0ciA9PT0gJ1xcXFwvJyB8fCBzdHIgPT09ICdcXFxcJyB8fCBzdHIgPT09ICdcXFxcXFxcXCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gbWF0Y2hlcyBvciBjb250YWlucyBhIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5tYXRjaFBhdGggPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5zKVxuICAgID8gdXRpbHMuY29udGFpbnNQYXR0ZXJuKHBhdHRlcm4sIG9wdGlvbnMpXG4gICAgOiB1dGlscy5lcXVhbHNQYXR0ZXJuKHBhdHRlcm4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIChvcmlnaW5hbCkgZmlsZXBhdGggb3IgdW5peGlmaWVkIHBhdGggYXJlIGVxdWFsXG4gKiB0byB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqL1xuXG51dGlscy5fZXF1YWxzID0gZnVuY3Rpb24oZmlsZXBhdGgsIHVuaXhQYXRoLCBwYXR0ZXJuKSB7XG4gIHJldHVybiBwYXR0ZXJuID09PSBmaWxlcGF0aCB8fCBwYXR0ZXJuID09PSB1bml4UGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiAob3JpZ2luYWwpIGZpbGVwYXRoIG9yIHVuaXhpZmllZCBwYXRoIGNvbnRhaW5cbiAqIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICovXG5cbnV0aWxzLl9jb250YWlucyA9IGZ1bmN0aW9uKGZpbGVwYXRoLCB1bml4UGF0aCwgcGF0dGVybikge1xuICByZXR1cm4gZmlsZXBhdGguaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTEgfHwgdW5peFBhdGguaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gaXMgdGhlIHNhbWUgYXMgYSBnaXZlbiBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMuZXF1YWxzUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24gZm4oZmlsZXBhdGgpIHtcbiAgICB2YXIgZXF1YWwgPSB1dGlscy5fZXF1YWxzKGZpbGVwYXRoLCB1bml4aWZ5KGZpbGVwYXRoKSwgcGF0dGVybik7XG4gICAgaWYgKGVxdWFsID09PSB0cnVlIHx8IG9wdGlvbnMubm9jYXNlICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuICAgIHZhciBsb3dlciA9IGZpbGVwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHV0aWxzLl9lcXVhbHMobG93ZXIsIHVuaXhpZnkobG93ZXIpLCBwYXR0ZXJuKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBjb250YWlucyBhIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5jb250YWluc1BhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gICAgdmFyIGNvbnRhaW5zID0gdXRpbHMuX2NvbnRhaW5zKGZpbGVwYXRoLCB1bml4aWZ5KGZpbGVwYXRoKSwgcGF0dGVybik7XG4gICAgaWYgKGNvbnRhaW5zID09PSB0cnVlIHx8IG9wdGlvbnMubm9jYXNlICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gY29udGFpbnM7XG4gICAgfVxuICAgIHZhciBsb3dlciA9IGZpbGVwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHV0aWxzLl9jb250YWlucyhsb3dlciwgdW5peGlmeShsb3dlciksIHBhdHRlcm4pO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiByZWdleCBtYXRjaGVzIHRoZSBgZmlsZW5hbWVgIG9mIGEgZmlsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBgcmVgIE1hdGNoaW5nIHJlZ2V4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5tYXRjaEJhc2VuYW1lID0gZnVuY3Rpb24ocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHJlLnRlc3QocGF0aC5iYXNlbmFtZShmaWxlcGF0aCkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBmaWxlcGF0aCB0byByZXR1cm4gYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cblxudXRpbHMudmFsdWUgPSBmdW5jdGlvbihzdHIsIHVuaXhpZnksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bml4aWZ5ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHVuaXhpZnkoc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbm9ybWFsaXplcyBzbGFzaGVzIGluIGEgc3RyaW5nIHRvIGZvcndhcmRcbiAqIHNsYXNoZXMsIHN0cmlwcyBgLi9gIGZyb20gYmVnaW5uaW5nIG9mIHBhdGhzLCBhbmQgb3B0aW9uYWxseSB1bmVzY2FwZXNcbiAqIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLnVuaXhpZnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNXaW5kb3dzKCkgfHwgb3B0aW9ucy51bml4aWZ5ID09PSB0cnVlKSB7XG4gICAgICBmaWxlcGF0aCA9IHV0aWxzLnRvUG9zaXhQYXRoKGZpbGVwYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBQcmVmaXggIT09IGZhbHNlKSB7XG4gICAgICBmaWxlcGF0aCA9IHV0aWxzLnN0cmlwUHJlZml4KGZpbGVwYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgIGZpbGVwYXRoID0gdXRpbHMudW5lc2NhcGUoZmlsZXBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNFeHRlbmRhYmxlID0gcmVxdWlyZSgnaXMtZXh0ZW5kYWJsZScpO1xudmFyIGZvckluID0gcmVxdWlyZSgnZm9yLWluJyk7XG5cbmZ1bmN0aW9uIG1peGluRGVlcCh0YXJnZXQsIG9iamVjdHMpIHtcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgZm9ySW4ob2JqLCBjb3B5LCB0YXJnZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIENvcHkgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0IHRvIHRoZVxuICogdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHsqfSBgdmFsYFxuICogQHBhcmFtICB7U3RyaW5nfSBga2V5YFxuICovXG5cbmZ1bmN0aW9uIGNvcHkodmFsLCBrZXkpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2JqID0gdGhpc1trZXldO1xuICBpZiAoaXNPYmplY3QodmFsKSAmJiBpc09iamVjdChvYmopKSB7XG4gICAgbWl4aW5EZWVwKG9iaiwgdmFsKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzW2tleV0gPSB2YWw7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbGAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge2FueX0gdmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gaXNFeHRlbmRhYmxlKHZhbCkgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYGtleWAgaXMgYSB2YWxpZCBrZXkgdG8gdXNlIHdoZW4gZXh0ZW5kaW5nIG9iamVjdHMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBga2V5YFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJyAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYga2V5ICE9PSAncHJvdG90eXBlJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBtaXhpbkRlZXBgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtaXhpbkRlZXA7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGNvbXBpbGVycyA9IHJlcXVpcmUoJy4vbGliL2NvbXBpbGVycycpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL2xpYi9wYXJzZXJzJyk7XG52YXIgY2FjaGUgPSByZXF1aXJlKCcuL2xpYi9jYWNoZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xuXG4vKipcbiAqIFRoZSBtYWluIGZ1bmN0aW9uIHRha2VzIGEgbGlzdCBvZiBzdHJpbmdzIGFuZCBvbmUgb3IgbW9yZVxuICogZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tKGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tKFsnYS5qcycsICdhLnR4dCddLCBbJyouanMnXSkpO1xuICogLy89PiBbICdhLmpzJyBdXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBsaXN0YCBBIGxpc3Qgb2Ygc3RyaW5ncyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXNcbiAqIEBzdW1tYXJ5IGZhbHNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG5hbm9tYXRjaChsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBwYXR0ZXJucyA9IHV0aWxzLmFycmF5aWZ5KHBhdHRlcm5zKTtcbiAgbGlzdCA9IHV0aWxzLmFycmF5aWZ5KGxpc3QpO1xuXG4gIHZhciBsZW4gPSBwYXR0ZXJucy5sZW5ndGg7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCB8fCBsZW4gPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobGVuID09PSAxKSB7XG4gICAgcmV0dXJuIG5hbm9tYXRjaC5tYXRjaChsaXN0LCBwYXR0ZXJuc1swXSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgbmVnYXRlZCA9IGZhbHNlO1xuICB2YXIgb21pdCA9IFtdO1xuICB2YXIga2VlcCA9IFtdO1xuICB2YXIgaWR4ID0gLTE7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tpZHhdO1xuXG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoMCkgPT09IDMzIC8qICEgKi8pIHtcbiAgICAgIG9taXQucHVzaC5hcHBseShvbWl0LCBuYW5vbWF0Y2gubWF0Y2gobGlzdCwgcGF0dGVybi5zbGljZSgxKSwgb3B0aW9ucykpO1xuICAgICAgbmVnYXRlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtlZXAucHVzaC5hcHBseShrZWVwLCBuYW5vbWF0Y2gubWF0Y2gobGlzdCwgcGF0dGVybiwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1pbmltYXRjaC5tYXRjaCBwYXJpdHlcbiAgaWYgKG5lZ2F0ZWQgJiYga2VlcC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXhpZnkgPT09IGZhbHNlKSB7XG4gICAgICBrZWVwID0gbGlzdC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2VlcC5wdXNoKHVuaXhpZnkobGlzdFtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaGVzID0gdXRpbHMuZGlmZihrZWVwLCBvbWl0KTtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubm9kdXBlcyAhPT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdXRpbHMudW5pcXVlKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byB0aGUgbWFpbiBmdW5jdGlvbiwgYnV0IGBwYXR0ZXJuYCBtdXN0IGJlIGEgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLm1hdGNoKGxpc3QsIHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0ubWF0Y2goWydhLmEnLCAnYS5hYScsICdhLmInLCAnYS5jJ10sICcqLmEnKSk7XG4gKiAvLz0+IFsnYS5hJywgJ2EuYWEnXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQXJyYXkgb2Ygc3RyaW5ncyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5tYXRjaCA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gIHZhciBpc01hdGNoID0gbWVtb2l6ZSgnbWF0Y2gnLCBwYXR0ZXJuLCBvcHRpb25zLCBuYW5vbWF0Y2gubWF0Y2hlcik7XG4gIHZhciBtYXRjaGVzID0gW107XG5cbiAgbGlzdCA9IHV0aWxzLmFycmF5aWZ5KGxpc3QpO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgZWxlID0gbGlzdFtpZHhdO1xuICAgIGlmIChlbGUgPT09IHBhdHRlcm4gfHwgaXNNYXRjaChlbGUpKSB7XG4gICAgICBtYXRjaGVzLnB1c2godXRpbHMudmFsdWUoZWxlLCB1bml4aWZ5LCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbm8gb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdW5pcXVpZnkgcmVzdWx0cyBhbmQgcmV0dXJuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdXRpbHMudW5pcXVlKG1hdGNoZXMpO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMuZmFpbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWF0Y2hlcyBmb3VuZCBmb3IgXCInICsgcGF0dGVybiArICdcIicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub251bGwgPT09IHRydWUgfHwgb3B0aW9ucy5udWxsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIFtvcHRpb25zLnVuZXNjYXBlID8gdXRpbHMudW5lc2NhcGUocGF0dGVybikgOiBwYXR0ZXJuXTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBgb3B0cy5pZ25vcmVgIHdhcyBkZWZpbmVkLCBkaWZmIGlnbm9yZWQgbGlzdFxuICBpZiAob3B0aW9ucy5pZ25vcmUpIHtcbiAgICBtYXRjaGVzID0gbmFub21hdGNoLm5vdChtYXRjaGVzLCBvcHRpb25zLmlnbm9yZSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy5ub2R1cGVzICE9PSBmYWxzZSA/IHV0aWxzLnVuaXF1ZShtYXRjaGVzKSA6IG1hdGNoZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgIG1hdGNoZXMgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmlzTWF0Y2goc3RyaW5nLCBwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmlzTWF0Y2goJ2EuYScsICcqLmEnKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG5tLmlzTWF0Y2goJ2EuYicsICcqLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2xvYiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guaXNNYXRjaCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHN0cikgfHwgdXRpbHMuaXNFbXB0eVN0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBlcXVhbHMgPSB1dGlscy5lcXVhbHNQYXR0ZXJuKG9wdGlvbnMpO1xuICBpZiAoZXF1YWxzKHN0cikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc01hdGNoID0gbWVtb2l6ZSgnaXNNYXRjaCcsIHBhdHRlcm4sIG9wdGlvbnMsIG5hbm9tYXRjaC5tYXRjaGVyKTtcbiAgcmV0dXJuIGlzTWF0Y2goc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHNvbWUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBgbGlzdGAgbWF0Y2ggYW55IG9mIHRoZVxuICogZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLnNvbWUobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uc29tZShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICogY29uc29sZS5sb2cobm0uc29tZShbJ2Zvby5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBsaXN0YCBUaGUgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gdGVzdC4gUmV0dXJucyBhcyBzb29uIGFzIHRoZSBmaXJzdCBtYXRjaCBpcyBmb3VuZC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5zb21lID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgIGxpc3QgPSBbbGlzdF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFub21hdGNoKGxpc3RbaV0sIHBhdHRlcm5zLCBvcHRpb25zKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGdpdmVuIGBsaXN0YCBtYXRjaGVzXG4gKiBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5ldmVyeShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5ldmVyeSgnZm9vLmpzJywgWydmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICogY29uc29sZS5sb2cobm0uZXZlcnkoWydmb28uanMnLCAnYmFyLmpzJ10sIFsnKi5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhubS5ldmVyeShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKG5tLmV2ZXJ5KFsnZm9vLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYGxpc3RgIFRoZSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmV2ZXJ5ID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgIGxpc3QgPSBbbGlzdF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFub21hdGNoKGxpc3RbaV0sIHBhdHRlcm5zLCBvcHRpb25zKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmICoqYW55Kiogb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYFxuICogbWF0Y2ggdGhlIHNwZWNpZmllZCBgc3RyaW5nYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5hbnkoc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5hbnkoJ2EuYScsIFsnYi4qJywgJyouYSddKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG5tLmFueSgnYS5hJywgJ2IuKicpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgc3RyYCBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guYW55ID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHN0cikgfHwgdXRpbHMuaXNFbXB0eVN0cmluZyhwYXR0ZXJucykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgIHBhdHRlcm5zID0gW3BhdHRlcm5zXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFub21hdGNoLmlzTWF0Y2goc3RyLCBwYXR0ZXJuc1tpXSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFsbCoqIG9mIHRoZSBnaXZlbiBgcGF0dGVybnNgXG4gKiBtYXRjaCB0aGUgc3BlY2lmaWVkIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5hbGwoc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5hbGwoJ2Zvby5qcycsIFsnZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5hbGwoJ2Zvby5qcycsIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKlxuICogY29uc29sZS5sb2cobm0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5hbGwoJ2Zvby5qcycsIFsnKi5qcycsICdmKicsICcqbyonLCAnKm8uanMnXSkpO1xuICogLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5hbGwgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXR0ZXJucyA9IFtwYXR0ZXJuc107XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFuYW5vbWF0Y2guaXNNYXRjaChzdHIsIHBhdHRlcm5zW2ldLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB0aGF0IF8qKmRvIG5vdCBtYXRjaCBhbnkqKl8gb2YgdGhlIGdpdmVuIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0ubm90KGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLm5vdChbJ2EuYScsICdiLmInLCAnYy5jJ10sICcqLmEnKSk7XG4gKiAvLz0+IFsnYi5iJywgJ2MuYyddXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBsaXN0YCBBcnJheSBvZiBzdHJpbmdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0ICoqZG8gbm90IG1hdGNoKiogdGhlIGdpdmVuIHBhdHRlcm5zLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2gubm90ID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICB2YXIgaWdub3JlID0gb3B0cy5pZ25vcmU7XG4gIGRlbGV0ZSBvcHRzLmlnbm9yZTtcblxuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG5cbiAgdmFyIG1hdGNoZXMgPSB1dGlscy5kaWZmKGxpc3QsIG5hbm9tYXRjaChsaXN0LCBwYXR0ZXJucywgb3B0cykpO1xuICBpZiAoaWdub3JlKSB7XG4gICAgbWF0Y2hlcyA9IHV0aWxzLmRpZmYobWF0Y2hlcywgbmFub21hdGNoKGxpc3QsIGlnbm9yZSkpO1xuICB9XG5cbiAgcmV0dXJuIG9wdHMubm9kdXBlcyAhPT0gZmFsc2UgPyB1dGlscy51bmlxdWUobWF0Y2hlcykgOiBtYXRjaGVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJpbmdgIGNvbnRhaW5zIHRoZSBnaXZlbiBwYXR0ZXJuLiBTaW1pbGFyXG4gKiB0byBbLmlzTWF0Y2hdKCNpc01hdGNoKSBidXQgdGhlIHBhdHRlcm4gY2FuIG1hdGNoIGFueSBwYXJ0IG9mIHRoZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uY29udGFpbnMoc3RyaW5nLCBwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqYicpKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobm0uY29udGFpbnMoJ2FhL2JiL2NjJywgJypkJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0dGVyIG1hdGNoZXMgYW55IHBhcnQgb2YgYHN0cmAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5jb250YWlucyA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHN0cikgfHwgdXRpbHMuaXNFbXB0eVN0cmluZyhwYXR0ZXJucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZXF1YWxzID0gdXRpbHMuZXF1YWxzUGF0dGVybihwYXR0ZXJucywgb3B0aW9ucyk7XG4gICAgaWYgKGVxdWFscyhzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zID0gdXRpbHMuY29udGFpbnNQYXR0ZXJuKHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgICBpZiAoY29udGFpbnMoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtjb250YWluczogdHJ1ZX0pO1xuICByZXR1cm4gbmFub21hdGNoLmFueShzdHIsIHBhdHRlcm5zLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXR0ZXJuIGFuZCBvcHRpb25zIHNob3VsZCBlbmFibGVcbiAqIHRoZSBgbWF0Y2hCYXNlYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubmFub21hdGNoLm1hdGNoQmFzZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHBhdHRlcm4gJiYgcGF0dGVybi5pbmRleE9mKCcvJykgIT09IC0xIHx8ICFvcHRpb25zKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRpb25zLmJhc2VuYW1lID09PSB0cnVlIHx8IG9wdGlvbnMubWF0Y2hCYXNlID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgZ2xvYmAgcGF0dGVyblxuICogYW5kIGBvcHRpb25zYC4gRG9lcyBub3QgYXR0ZW1wdCB0byBtYXRjaCBuZXN0ZWQga2V5cy4gSWYgeW91IG5lZWQgdGhpcyBmZWF0dXJlLFxuICogdXNlIFtnbG9iLW9iamVjdF1bXSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLm1hdGNoS2V5cyhvYmplY3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBvYmogPSB7IGFhOiAnYScsIGFiOiAnYicsIGFjOiAnYycgfTtcbiAqIGNvbnNvbGUubG9nKG5tLm1hdGNoS2V5cyhvYmosICcqYicpKTtcbiAqIC8vPT4geyBhYjogJ2InIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBvYmplY3RgIFRoZSBvYmplY3Qgd2l0aCBrZXlzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggb25seSBrZXlzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm5zLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2gubWF0Y2hLZXlzID0gZnVuY3Rpb24ob2JqLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBuYW5vbWF0Y2goT2JqZWN0LmtleXMob2JqKSwgcGF0dGVybnMsIG9wdGlvbnMpO1xuICByZXR1cm4gdXRpbHMucGljayhvYmosIGtleXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWVtb2l6ZWQgbWF0Y2hlciBmdW5jdGlvbiBmcm9tIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBtYXRjaC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5tYXRjaGVyKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIGlzTWF0Y2ggPSBubS5tYXRjaGVyKCcqLiEoKmEpJyk7XG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgYSBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2gubWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gY29tcG9zZShwYXR0ZXJuLCBvcHRpb25zLCBtYXRjaGVyKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgYSByZWdleFxuICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB0ZXN0KHBhdHRlcm4pO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBpbnZhbGlkXG4gIGlmICghdXRpbHMuaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGFuIGFycmF5LCBzdHJpbmcgb3IgcmVnZXgnKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgYSBub24tZ2xvYiBzdHJpbmdcbiAgaWYgKCF1dGlscy5oYXNTcGVjaWFsQ2hhcnMocGF0dGVybikpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vY2FzZSA9PT0gdHJ1ZSkge1xuICAgICAgcGF0dGVybiA9IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLm1hdGNoUGF0aChwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgYSBnbG9iIHN0cmluZ1xuICB2YXIgcmUgPSBuYW5vbWF0Y2gubWFrZVJlKHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gIC8vIGlmIGBvcHRpb25zLm1hdGNoQmFzZWAgb3IgYG9wdGlvbnMuYmFzZW5hbWVgIGlzIGRlZmluZWRcbiAgaWYgKG5hbm9tYXRjaC5tYXRjaEJhc2UocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gdXRpbHMubWF0Y2hCYXNlbmFtZShyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0KHJlZ2V4KSB7XG4gICAgdmFyIGVxdWFscyA9IHV0aWxzLmVxdWFsc1BhdHRlcm4ob3B0aW9ucyk7XG4gICAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKGVxdWFscyhzdHIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVnZXgudGVzdCh1bml4aWZ5KHN0cikpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBjcmVhdGUgbWF0Y2hlciBmdW5jdGlvblxuICB2YXIgbWF0Y2hlckZuID0gdGVzdChyZSk7XG4gIC8vIHNldCByZXN1bHQgb2JqZWN0IGZyb20gY29tcGlsZXIgb24gbWF0Y2hlciBmdW5jdGlvbixcbiAgLy8gYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS4gdXNlZnVsIGZvciBkZWJ1Z2dpbmdcbiAgdXRpbHMuZGVmaW5lKG1hdGNoZXJGbiwgJ3Jlc3VsdCcsIHJlLnJlc3VsdCk7XG4gIHJldHVybiBtYXRjaGVyRm47XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlcyBjYXB0dXJlZCBieSBgcGF0dGVybmAgaW4gYHN0cmluZywgb3JcbiAqIGBudWxsYCBpZiB0aGUgcGF0dGVybiBkaWQgbm90IG1hdGNoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmNhcHR1cmUocGF0dGVybiwgc3RyaW5nWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmNhcHR1cmUoJ3Rlc3QvKi5qcycsICd0ZXN0L2Zvby5qcycpKTtcbiAqIC8vPT4gWydmb28nXVxuICogY29uc29sZS5sb2cobm0uY2FwdHVyZSgndGVzdC8qLmpzJywgJ2Zvby9iYXIuY3NzJykpO1xuICogLy89PiBudWxsXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBhbiBhcnJheSBvZiBjYXB0dXJlcyBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybiwgb3RoZXJ3aXNlIGBudWxsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmNhcHR1cmUgPSBmdW5jdGlvbihwYXR0ZXJuLCBzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHJlID0gbmFub21hdGNoLm1ha2VSZShwYXR0ZXJuLCBleHRlbmQoe2NhcHR1cmU6IHRydWV9LCBvcHRpb25zKSk7XG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcblxuICBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHVuaXhpZnkoc3RyaW5nKSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0gbWVtb2l6ZSgnY2FwdHVyZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1hdGNoKTtcbiAgcmV0dXJuIGNhcHR1cmUoc3RyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLm1ha2VSZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLm1ha2VSZSgnKi5qcycpKTtcbiAqIC8vPT4gL14oPzooXFwuW1xcXFxcXC9dKT8oPyFcXC4pKD89LilbXlxcL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQSBnbG9iIHBhdHRlcm4gdG8gY29udmVydCB0byByZWdleC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkLlxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlUmUoKSB7XG4gICAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQoe3dyYXA6IGZhbHNlfSwgb3B0aW9ucyk7XG4gICAgdmFyIHJlc3VsdCA9IG5hbm9tYXRjaC5jcmVhdGUocGF0dGVybiwgb3B0cyk7XG4gICAgdmFyIHJlZ2V4ID0gdG9SZWdleChyZXN1bHQub3V0cHV0LCBvcHRzKTtcbiAgICB1dGlscy5kZWZpbmUocmVnZXgsICdyZXN1bHQnLCByZXN1bHQpO1xuICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdtYWtlUmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYWtlUmUpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjb21waWxlZCBgb3V0cHV0YFxuICogYW5kIG9wdGlvbmFsIHNvdXJjZSBgbWFwYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5jcmVhdGUocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5jcmVhdGUoJ2FiYy8qLmpzJykpO1xuICogLy8geyBvcHRpb25zOiB7IHNvdXJjZTogJ3N0cmluZycsIHNvdXJjZW1hcDogdHJ1ZSB9LFxuICogLy8gICBzdGF0ZToge30sXG4gKiAvLyAgIGNvbXBpbGVyczpcbiAqIC8vICAgIHsgLi4uIH0sXG4gKiAvLyAgIG91dHB1dDogJyhcXFxcLltcXFxcXFxcXFxcXFwvXSk/YWJjXFxcXC8oPyFcXFxcLikoPz0uKVteXFxcXC9dKj9cXFxcLmpzJyxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyB0eXBlOiAncm9vdCcsXG4gKiAvLyAgICAgIGVycm9yczogW10sXG4gKiAvLyAgICAgIG5vZGVzOlxuICogLy8gICAgICAgWyAuLi4gXSxcbiAqIC8vICAgICAgZG90OiBmYWxzZSxcbiAqIC8vICAgICAgaW5wdXQ6ICdhYmMvKi5qcycgfSxcbiAqIC8vICAgcGFyc2luZ0Vycm9yczogW10sXG4gKiAvLyAgIG1hcDpcbiAqIC8vICAgIHsgdmVyc2lvbjogMyxcbiAqIC8vICAgICAgc291cmNlczogWyAnc3RyaW5nJyBdLFxuICogLy8gICAgICBuYW1lczogW10sXG4gKiAvLyAgICAgIG1hcHBpbmdzOiAnQUFBQSxHQUFHLEVBQUMsa0JBQUMsRUFBQyxFQUFFJyxcbiAqIC8vICAgICAgc291cmNlc0NvbnRlbnQ6IFsgJ2FiYy8qLmpzJyBdIH0sXG4gKiAvLyAgIHBvc2l0aW9uOiB7IGxpbmU6IDEsIGNvbHVtbjogMjggfSxcbiAqIC8vICAgY29udGVudDoge30sXG4gKiAvLyAgIGZpbGVzOiB7fSxcbiAqIC8vICAgaWR4OiA2IH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gcGFyc2UgYW5kIGNvbXBpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIEFueSBbb3B0aW9uc10oI29wdGlvbnMpIHRvIGNoYW5nZSBob3cgcGFyc2luZyBhbmQgY29tcGlsaW5nIGlzIHBlcmZvcm1lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIEFTVCwgY29tcGlsZWQgc3RyaW5nIGFuZCBvcHRpb25hbCBzb3VyY2UgbWFwLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guY3JlYXRlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG5hbm9tYXRjaC5jb21waWxlKG5hbm9tYXRjaC5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG1lbW9pemUoJ2NyZWF0ZScsIHBhdHRlcm4sIG9wdGlvbnMsIGNyZWF0ZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0ucGFyc2UocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgYXN0ID0gbm0ucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYXN0KTtcbiAqIC8vIHsgdHlwZTogJ3Jvb3QnLFxuICogLy8gICBlcnJvcnM6IFtdLFxuICogLy8gICBpbnB1dDogJ2Eve2IsY30vZCcsXG4gKiAvLyAgIG5vZGVzOlxuICogLy8gICAgWyB7IHR5cGU6ICdib3MnLCB2YWw6ICcnIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICdhLycgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnYnJhY2UnLFxuICogLy8gICAgICAgIG5vZGVzOlxuICogLy8gICAgICAgICBbIHsgdHlwZTogJ2JyYWNlLm9wZW4nLCB2YWw6ICd7JyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICdiLGMnIH0sXG4gKiAvLyAgICAgICAgICAgeyB0eXBlOiAnYnJhY2UuY2xvc2UnLCB2YWw6ICd9JyB9IF0gfSxcbiAqIC8vICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJy9kJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICdlb3MnLCB2YWw6ICcnIH0gXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIEFTVFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2gucGFyc2UgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgdmFyIHNuYXBkcmFnb24gPSB1dGlscy5pbnN0YW50aWF0ZShudWxsLCBvcHRpb25zKTtcbiAgICBwYXJzZXJzKHNuYXBkcmFnb24sIG9wdGlvbnMpO1xuXG4gICAgdmFyIGFzdCA9IHNuYXBkcmFnb24ucGFyc2UocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgdXRpbHMuZGVmaW5lKGFzdCwgJ3NuYXBkcmFnb24nLCBzbmFwZHJhZ29uKTtcbiAgICBhc3QuaW5wdXQgPSBwYXR0ZXJuO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgncGFyc2UnLCBwYXR0ZXJuLCBvcHRpb25zLCBwYXJzZSk7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIGdpdmVuIGBhc3RgIG9yIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uY29tcGlsZShhc3RbLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIGFzdCA9IG5tLnBhcnNlKCdhL3tiLGN9L2QnKTtcbiAqIGNvbnNvbGUubG9nKG5tLmNvbXBpbGUoYXN0KSk7XG4gKiAvLyB7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJyB9LFxuICogLy8gICBzdGF0ZToge30sXG4gKiAvLyAgIGNvbXBpbGVyczpcbiAqIC8vICAgIHsgZW9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBub29wOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBib3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJyYWNlOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2Uub3Blbic6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHRleHQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5jbG9zZSc6IFtGdW5jdGlvbl0gfSxcbiAqIC8vICAgb3V0cHV0OiBbICdhLyhifGMpL2QnIF0sXG4gKiAvLyAgIGFzdDpcbiAqIC8vICAgIHsgLi4uIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBgYXN0YFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyBhbiBgb3V0cHV0YCBwcm9wZXJ0eSB3aXRoIHRoZSBjb21waWxlZCBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5jb21waWxlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgYXN0ID09PSAnc3RyaW5nJykge1xuICAgIGFzdCA9IG5hbm9tYXRjaC5wYXJzZShhc3QsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICB2YXIgc25hcGRyYWdvbiA9IHV0aWxzLmluc3RhbnRpYXRlKGFzdCwgb3B0aW9ucyk7XG4gICAgY29tcGlsZXJzKHNuYXBkcmFnb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzbmFwZHJhZ29uLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdjb21waWxlJywgYXN0LmlucHV0LCBvcHRpb25zLCBjb21waWxlKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHJlZ2V4IGNhY2hlLlxuICpcbiAqIGBgYGpzXG4gKiBubS5jbGVhckNhY2hlKCk7XG4gKiBgYGBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgbmFub21hdGNoLmNhY2hlLl9fZGF0YV9fID0ge307XG59O1xuXG4vKipcbiAqIENvbXBvc2UgYSBtYXRjaGVyIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIHBhdHRlcm5zLlxuICogVGhpcyBhbGxvd3MgbWF0Y2hlciBmdW5jdGlvbnMgdG8gYmUgY29tcGlsZWQgb25jZSBhbmRcbiAqIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKHBhdHRlcm5zLCBvcHRpb25zLCBtYXRjaGVyKSB7XG4gIHZhciBtYXRjaGVycztcblxuICByZXR1cm4gbWVtb2l6ZSgnY29tcG9zZScsIFN0cmluZyhwYXR0ZXJucyksIG9wdGlvbnMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAvLyBkZWxheSBjb21wb3NpdGlvbiB1bnRpbCBpdCdzIGludm9rZWQgdGhlIGZpcnN0IHRpbWUsXG4gICAgICAvLyBhZnRlciB0aGF0IGl0IHdvbid0IGJlIGNhbGxlZCBhZ2FpblxuICAgICAgaWYgKCFtYXRjaGVycykge1xuICAgICAgICBtYXRjaGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKHBhdHRlcm5zW2ldLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IG1hdGNoZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBpZiAobWF0Y2hlcnNbbGVuXShmaWxlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogTWVtb2l6ZSBhIGdlbmVyYXRlZCByZWdleCBvciBmdW5jdGlvbi4gQSB1bmlxdWUga2V5IGlzIGdlbmVyYXRlZFxuICogZnJvbSB0aGUgYHR5cGVgICh1c3VhbGx5IG1ldGhvZCBuYW1lKSwgdGhlIGBwYXR0ZXJuYCwgYW5kXG4gKiB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplKHR5cGUsIHBhdHRlcm4sIG9wdGlvbnMsIGZuKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkodHlwZSArICc9JyArIHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGNhY2hlLmhhcyh0eXBlLCBrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldCh0eXBlLCBrZXkpO1xuICB9XG5cbiAgdmFyIHZhbCA9IGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBjYWNoZS5zZXQodHlwZSwga2V5LCB2YWwpO1xuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEV4cG9zZSBjb21waWxlciwgcGFyc2VyIGFuZCBjYWNoZSBvbiBgbmFub21hdGNoYFxuICovXG5cbm5hbm9tYXRjaC5jb21waWxlcnMgPSBjb21waWxlcnM7XG5uYW5vbWF0Y2gucGFyc2VycyA9IHBhcnNlcnM7XG5uYW5vbWF0Y2guY2FjaGUgPSBjYWNoZTtcblxuLyoqXG4gKiBFeHBvc2UgYG5hbm9tYXRjaGBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hbm9tYXRjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIE5hbm9tYXRjaCBjb21waWxlcnNcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFub21hdGNoLCBvcHRpb25zKSB7XG4gIGZ1bmN0aW9uIHNsYXNoKCkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNsYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc2xhc2g7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNsYXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zbGFzaC5jYWxsKG5hbm9tYXRjaCk7XG4gICAgfVxuICAgIHJldHVybiAnXFxcXFxcXFwvJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXIoKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc3RhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0YXI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnN0YXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0YXIuY2FsbChuYW5vbWF0Y2gpO1xuICAgIH1cbiAgICByZXR1cm4gJ1teJyArIHNsYXNoKCkgKyAnXSo/JztcbiAgfVxuXG4gIHZhciBhc3QgPSBuYW5vbWF0Y2guYXN0ID0gbmFub21hdGNoLnBhcnNlci5hc3Q7XG4gIGFzdC5zdGF0ZSA9IG5hbm9tYXRjaC5wYXJzZXIuc3RhdGU7XG4gIG5hbm9tYXRjaC5jb21waWxlci5zdGF0ZSA9IGFzdC5zdGF0ZTtcbiAgbmFub21hdGNoLmNvbXBpbGVyXG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGlvbiAvIGVzY2FwaW5nXG4gICAgICovXG5cbiAgICAuc2V0KCdub3QnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub25lZ2F0ZSA9PT0gdHJ1ZSB8fCBwcmV2LnR5cGUgIT09ICdib3MnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcbiAgICAuc2V0KCdlc2NhcGUnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVuZXNjYXBlICYmIC9eWy1cXHdfLl0vLnRlc3Qobm9kZS52YWwpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcbiAgICAuc2V0KCdxdW90ZWQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUmVnZXhcbiAgICAgKi9cblxuICAgIC5zZXQoJ2RvbGxhcicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnYnJhY2tldCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRG90OiBcIi5cIlxuICAgICAqL1xuXG4gICAgLnNldCgnZG90JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuZG90ZmlsZXMgPT09IHRydWUpIHRoaXMuZG90ZmlsZXMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFNsYXNoZXM6IFwiL1wiIGFuZCBcIlxcXCJcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JhY2tzbGFzaCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG4gICAgLnNldCgnc2xhc2gnLCBmdW5jdGlvbihub2RlLCBub2RlcywgaSkge1xuICAgICAgdmFyIHZhbCA9ICdbJyArIHNsYXNoKCkgKyAnXSc7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuXG4gICAgICAvLyBzZXQgXCJub2RlLmhhc1NsYXNoXCIgdG8gdHJ1ZSBvbiBhbGwgYW5jZXN0b3IgcGFyZW5zIG5vZGVzXG4gICAgICB3aGlsZSAocGFyZW50LnR5cGUgPT09ICdwYXJlbicgJiYgIXBhcmVudC5oYXNTbGFzaCkge1xuICAgICAgICBwYXJlbnQuaGFzU2xhc2ggPSB0cnVlO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi5hZGRRbWFyaykge1xuICAgICAgICB2YWwgKz0gJz8nO1xuICAgICAgfVxuXG4gICAgICAvLyB3b3JkIGJvdW5kYXJ5XG4gICAgICBpZiAobm9kZS5yZXN0LnNsaWNlKDAsIDIpID09PSAnXFxcXGInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYnN0YXJzXG4gICAgICBpZiAobm9kZS5wYXJzZWQgPT09ICcqKicgfHwgbm9kZS5wYXJzZWQgPT09ICcuLyoqJykge1xuICAgICAgICB0aGlzLm91dHB1dCA9ICcoPzonICsgdGhpcy5vdXRwdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsICsgJyk/Jywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5lZ2F0aW9uXG4gICAgICBpZiAobm9kZS5wYXJzZWQgPT09ICchKionICYmIHRoaXMub3B0aW9ucy5ub25lZ2F0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCArICc/XFxcXGInLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlIGJyYWNrZXRzXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFja2V0JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNsb3NlID0gbm9kZS5jbG9zZTtcbiAgICAgIHZhciBvcGVuID0gIW5vZGUuZXNjYXBlZCA/ICdbJyA6ICdcXFxcWyc7XG4gICAgICB2YXIgbmVnYXRlZCA9IG5vZGUubmVnYXRlZDtcbiAgICAgIHZhciBpbm5lciA9IG5vZGUuaW5uZXI7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWw7XG5cbiAgICAgIGlmIChub2RlLmVzY2FwZWQgPT09IHRydWUpIHtcbiAgICAgICAgaW5uZXIgPSBpbm5lci5yZXBsYWNlKC9cXFxcPyhcXFcpL2csICdcXFxcJDEnKTtcbiAgICAgICAgbmVnYXRlZCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5uZXIgPT09ICddLScpIHtcbiAgICAgICAgaW5uZXIgPSAnXFxcXF1cXFxcLSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWdhdGVkICYmIGlubmVyLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgICAgaW5uZXIgKz0gJy4nO1xuICAgICAgfVxuICAgICAgaWYgKG5lZ2F0ZWQgJiYgaW5uZXIuaW5kZXhPZignLycpID09PSAtMSkge1xuICAgICAgICBpbm5lciArPSAnLyc7XG4gICAgICB9XG5cbiAgICAgIHZhbCA9IG9wZW4gKyBuZWdhdGVkICsgaW5uZXIgKyBjbG9zZTtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlOiBcIlsuXVwiIChvbmx5IG1hdGNoZXMgYSBzaW5nbGUgY2hhcmFjdGVyIGluIGJyYWNrZXRzKVxuICAgICAqL1xuXG4gICAgLnNldCgnc3F1YXJlJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHZhbCA9ICgvXlxcVy8udGVzdChub2RlLnZhbCkgPyAnXFxcXCcgOiAnJykgKyBub2RlLnZhbDtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFyazogXCI/XCJcbiAgICAgKi9cblxuICAgIC5zZXQoJ3FtYXJrJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIC8vIGRvbid0IHVzZSBcInNsYXNoXCIgdmFyaWFibGUgc28gdGhhdCB3ZSBhbHdheXMgYXZvaWRcbiAgICAgIC8vIG1hdGNoaW5nIGJhY2tzbGFzaGVzIGFuZCBzbGFzaGVzIHdpdGggYSBxbWFya1xuICAgICAgdmFyIHZhbCA9ICdbXi5cXFxcXFxcXC9dJztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG90IHx8IChwcmV2LnR5cGUgIT09ICdib3MnICYmIHByZXYudHlwZSAhPT0gJ3NsYXNoJykpIHtcbiAgICAgICAgdmFsID0gJ1teXFxcXFxcXFwvXSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnBhcnNlZC5zbGljZSgtMSkgPT09ICcoJykge1xuICAgICAgICB2YXIgY2ggPSBub2RlLnJlc3QuY2hhckF0KDApO1xuICAgICAgICBpZiAoY2ggPT09ICchJyB8fCBjaCA9PT0gJz0nIHx8IGNoID09PSAnOicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS52YWwubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgKz0gJ3snICsgbm9kZS52YWwubGVuZ3RoICsgJ30nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQbHVzXG4gICAgICovXG5cbiAgICAuc2V0KCdwbHVzJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByZXYgPSBub2RlLnBhcnNlZC5zbGljZSgtMSk7XG4gICAgICBpZiAocHJldiA9PT0gJ10nIHx8IHByZXYgPT09ICcpJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5vdXRwdXQgfHwgKC9bPyorXS8udGVzdChjaCkgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2JyYWNrZXQnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcKycsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGNoID0gdGhpcy5vdXRwdXQuc2xpY2UoLTEpO1xuICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpICYmICFub2RlLmluc2lkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCcrXFxcXCs/Jywgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCcrJywgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIGdsb2JzdGFyOiAnKionXG4gICAgICovXG5cbiAgICAuc2V0KCdnbG9ic3RhcicsIGZ1bmN0aW9uKG5vZGUsIG5vZGVzLCBpKSB7XG4gICAgICBpZiAoIXRoaXMub3V0cHV0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUubGVhZGluZ0dsb2JzdGFyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBiZWZvcmUgPSB0aGlzLnByZXYoMik7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dCgpO1xuICAgICAgdmFyIGFmdGVyID0gdGhpcy5uZXh0KDIpO1xuICAgICAgdmFyIHR5cGUgPSBwcmV2LnR5cGU7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWw7XG5cbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdzbGFzaCcgJiYgbmV4dC50eXBlID09PSAnc2xhc2gnKSB7XG4gICAgICAgIGlmIChiZWZvcmUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXQgKz0gJz8nO1xuXG4gICAgICAgICAgaWYgKGFmdGVyLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgKz0gJ1xcXFxiJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZCA9IG5vZGUucGFyc2VkO1xuICAgICAgaWYgKHBhcnNlZC5jaGFyQXQoMCkgPT09ICchJykge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZWQuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0luc2lkZSA9IG5vZGUuaXNJbnNpZGUucGFyZW4gfHwgbm9kZS5pc0luc2lkZS5icmFjZTtcbiAgICAgIGlmIChwYXJzZWQgJiYgdHlwZSAhPT0gJ3NsYXNoJyAmJiB0eXBlICE9PSAnYm9zJyAmJiAhaXNJbnNpZGUpIHtcbiAgICAgICAgdmFsID0gc3RhcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zLmRvdCAhPT0gdHJ1ZVxuICAgICAgICAgID8gJyg/Oig/ISg/OlsnICsgc2xhc2goKSArICddfF4pXFxcXC4pLikqPydcbiAgICAgICAgICA6ICcoPzooPyEoPzpbJyArIHNsYXNoKCkgKyAnXXxeKSg/OlxcXFwuezEsMn0pKCR8WycgKyBzbGFzaCgpICsgJ10pKSg/IVxcXFwuezJ9KS4pKj8nO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGUgPT09ICdzbGFzaCcgfHwgdHlwZSA9PT0gJ2JvcycpICYmIHRoaXMub3B0aW9ucy5kb3QgIT09IHRydWUpIHtcbiAgICAgICAgdmFsID0gJyg/IVxcXFwuKScgKyB2YWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdzbGFzaCcgJiYgbmV4dC50eXBlID09PSAnc2xhc2gnICYmIGJlZm9yZS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgaWYgKGFmdGVyLnR5cGUgPT09ICd0ZXh0JyB8fCBhZnRlci50eXBlID09PSAnc3RhcicpIHtcbiAgICAgICAgICBub2RlLmFkZFFtYXJrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNhcHR1cmUpIHtcbiAgICAgICAgdmFsID0gJygnICsgdmFsICsgJyknO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFN0YXI6IFwiKlwiXG4gICAgICovXG5cbiAgICAuc2V0KCdzdGFyJywgZnVuY3Rpb24obm9kZSwgbm9kZXMsIGkpIHtcbiAgICAgIHZhciBwcmlvciA9IG5vZGVzW2kgLSAyXSB8fCB7fTtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dCgpO1xuICAgICAgdmFyIHR5cGUgPSBwcmV2LnR5cGU7XG5cbiAgICAgIGZ1bmN0aW9uIGlzU3RhcnQobikge1xuICAgICAgICByZXR1cm4gbi50eXBlID09PSAnYm9zJyB8fCBuLnR5cGUgPT09ICdzbGFzaCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm91dHB1dCA9PT0gJycgJiYgdGhpcy5vcHRpb25zLmNvbnRhaW5zICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gJyg/IVsnICsgc2xhc2goKSArICddKSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAnYnJhY2tldCcgJiYgdGhpcy5vcHRpb25zLmJhc2ggPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBzdHIgPSBuZXh0ICYmIG5leHQudHlwZSA9PT0gJ2JyYWNrZXQnID8gc3RhcigpIDogJyo/JztcbiAgICAgICAgaWYgKCFwcmV2Lm5vZGVzIHx8IHByZXYubm9kZXNbMV0udHlwZSAhPT0gJ3Bvc2l4Jykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoc3RyLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcHJlZml4ID0gIXRoaXMuZG90ZmlsZXMgJiYgdHlwZSAhPT0gJ3RleHQnICYmIHR5cGUgIT09ICdlc2NhcGUnXG4gICAgICAgID8gKHRoaXMub3B0aW9ucy5kb3QgPyAnKD8hKD86XnxbJyArIHNsYXNoKCkgKyAnXSlcXFxcLnsxLDJ9KD86JHxbJyArIHNsYXNoKCkgKyAnXSkpJyA6ICcoPyFcXFxcLiknKVxuICAgICAgICA6ICcnO1xuXG4gICAgICBpZiAoaXNTdGFydChwcmV2KSB8fCAoaXNTdGFydChwcmlvcikgJiYgdHlwZSA9PT0gJ25vdCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09ICcoPyFcXFxcLiknKSB7XG4gICAgICAgICAgcHJlZml4ICs9ICcoPyEoXFxcXC57Mn18XFxcXC5bJyArIHNsYXNoKCkgKyAnXSkpKD89LiknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZWZpeCArPSAnKD89LiknO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJyg/IVxcXFwuKScpIHtcbiAgICAgICAgcHJlZml4ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdub3QnICYmIHByaW9yLnR5cGUgPT09ICdib3MnICYmIHRoaXMub3B0aW9ucy5kb3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSAnKD8hXFxcXC4pJyArIHRoaXMub3V0cHV0O1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gcHJlZml4ICsgc3RhcigpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYXB0dXJlKSB7XG4gICAgICAgIG91dHB1dCA9ICcoJyArIG91dHB1dCArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChvdXRwdXQsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBUZXh0XG4gICAgICovXG5cbiAgICAuc2V0KCd0ZXh0JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEVuZC1vZi1zdHJpbmdcbiAgICAgKi9cblxuICAgIC5zZXQoJ2VvcycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWw7XG5cbiAgICAgIHRoaXMub3V0cHV0ID0gJyg/OlxcXFwuWycgKyBzbGFzaCgpICsgJ10oPz0uKSk/JyArIHRoaXMub3V0cHV0O1xuICAgICAgaWYgKHRoaXMuc3RhdGUubWV0YWNoYXIgJiYgcHJldi50eXBlICE9PSAncW1hcmsnICYmIHByZXYudHlwZSAhPT0gJ3NsYXNoJykge1xuICAgICAgICB2YWwgKz0gKHRoaXMub3B0aW9ucy5jb250YWlucyA/ICdbJyArIHNsYXNoKCkgKyAnXT8nIDogJyg/OlsnICsgc2xhc2goKSArICddfCQpJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KTtcblxuICAvKipcbiAgICogQWxsb3cgY3VzdG9tIGNvbXBpbGVycyB0byBiZSBwYXNzZWQgb24gb3B0aW9uc1xuICAgKi9cblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5jb21waWxlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmNvbXBpbGVycyhuYW5vbWF0Y2guY29tcGlsZXIpO1xuICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleE5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xuXG4vKipcbiAqIENoYXJhY3RlcnMgdG8gdXNlIGluIG5lZ2F0aW9uIHJlZ2V4ICh3ZSB3YW50IHRvIFwibm90XCIgbWF0Y2hcbiAqIGNoYXJhY3RlcnMgdGhhdCBhcmUgbWF0Y2hlZCBieSBvdGhlciBwYXJzZXJzKVxuICovXG5cbnZhciBjYWNoZWQ7XG52YXIgTk9UX1JFR0VYID0gJ1tcXFxcWyEqKz8kXlwiXFwnLlxcXFxcXFxcL10rJztcbnZhciBub3QgPSBjcmVhdGVUZXh0UmVnZXgoTk9UX1JFR0VYKTtcblxuLyoqXG4gKiBOYW5vbWF0Y2ggcGFyc2Vyc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFub21hdGNoLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuYW5vbWF0Y2gucGFyc2VyO1xuICB2YXIgb3B0cyA9IHBhcnNlci5vcHRpb25zO1xuXG4gIHBhcnNlci5zdGF0ZSA9IHtcbiAgICBzbGFzaGVzOiAwLFxuICAgIHBhdGhzOiBbXVxuICB9O1xuXG4gIHBhcnNlci5hc3Quc3RhdGUgPSBwYXJzZXIuc3RhdGU7XG4gIHBhcnNlclxuXG4gICAgLyoqXG4gICAgICogQmVnaW5uaW5nLW9mLXN0cmluZ1xuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3ByZWZpeCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFyc2VkKSByZXR1cm47XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXC5bXFxcXC9dLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgIHRoaXMuc3RhdGUuc3RyaWN0T3BlbiA9ICEhdGhpcy5vcHRpb25zLnN0cmljdE9wZW47XG4gICAgICB0aGlzLnN0YXRlLmFkZFByZWZpeCA9IHRydWU7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZTogXCJcXFxcLlwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnZXNjYXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSByZXR1cm47XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKD86XFxcXCguKXwoWyReXSkpLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICB2YWw6IG1bMl0gfHwgbVsxXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFF1b3RlZCBzdHJpbmdzXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncXVvdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eW1wiJ10vKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcXVvdGUgPSBtWzBdO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuaW5kZXhPZihxdW90ZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgIHZhbDogcXVvdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2sgPSBhZHZhbmNlVG8odGhpcy5pbnB1dCwgcXVvdGUpO1xuICAgICAgdGhpcy5jb25zdW1lKHRvay5sZW4pO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3F1b3RlZCcsXG4gICAgICAgIHZhbDogdG9rLmVzY1xuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0aW9uczogXCIhXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdub3QnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2godGhpcy5ub3RSZWdleCB8fCAvXiErLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICB2YXIgaXNOZWdhdGVkID0gKHZhbC5sZW5ndGggJSAyKSA9PT0gMTtcbiAgICAgIGlmIChwYXJzZWQgPT09ICcnICYmICFpc05lZ2F0ZWQpIHtcbiAgICAgICAgdmFsID0gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIG5vdGhpbmcgaGFzIGJlZW4gcGFyc2VkLCB3ZSBrbm93IGAhYCBpcyBhdCB0aGUgc3RhcnQsXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdyYXAgdGhlIHJlc3VsdCBpbiBhIG5lZ2F0aW9uIHJlZ2V4XG4gICAgICBpZiAocGFyc2VkID09PSAnJyAmJiBpc05lZ2F0ZWQgJiYgdGhpcy5vcHRpb25zLm5vbmVnYXRlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9zLnZhbCA9ICcoPyFeKD86JztcbiAgICAgICAgdGhpcy5hcHBlbmQgPSAnKSQpLionO1xuICAgICAgICB2YWwgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnbm90JyxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBEb3Q6IFwiLlwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnZG90JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFwuKy8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuICAgICAgdGhpcy5zdGF0ZS5kb3QgPSB2YWwgPT09ICcuJyAmJiAocGFyc2VkID09PSAnJyB8fCBwYXJzZWQuc2xpY2UoLTEpID09PSAnLycpO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ2RvdCcsXG4gICAgICAgIGRvdGZpbGVzOiB0aGlzLnN0YXRlLmRvdCxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQbHVzOiBcIitcIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3BsdXMnLCAvXlxcKyg/IVxcKCkvKVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFyazogXCI/XCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdxbWFyaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcPysoPyFcXCgpLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdGhpcy5zdGF0ZS5tZXRhY2hhciA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlLnFtYXJrID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdxbWFyaycsXG4gICAgICAgIHBhcnNlZDogcGFyc2VkLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBHbG9ic3RhcjogXCIqKlwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnZ2xvYnN0YXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXCp7Mn0oPyFbKihdKSg/PVssKS9dfCQpLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHR5cGUgPSBvcHRzLm5vZ2xvYnN0YXIgIT09IHRydWUgPyAnZ2xvYnN0YXInIDogJ3N0YXInO1xuICAgICAgdmFyIG5vZGUgPSBwb3Moe3R5cGU6IHR5cGUsIHBhcnNlZDogcGFyc2VkfSk7XG4gICAgICB0aGlzLnN0YXRlLm1ldGFjaGFyID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKHRoaXMuaW5wdXQuc2xpY2UoMCwgNCkgPT09ICcvKiovJykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5pbnB1dC5zbGljZSgzKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5pc0luc2lkZSA9IHtcbiAgICAgICAgYnJhY2U6IHRoaXMuaXNJbnNpZGUoJ2JyYWNlJyksXG4gICAgICAgIHBhcmVuOiB0aGlzLmlzSW5zaWRlKCdwYXJlbicpXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2dsb2JzdGFyJykge1xuICAgICAgICB0aGlzLnN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgbm9kZS52YWwgPSAnKionO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLnN0YXIgPSB0cnVlO1xuICAgICAgICBub2RlLnZhbCA9ICcqJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFN0YXI6IFwiKlwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnc3RhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBzdGFyUmUgPSAvXig/OlxcKig/IVsqKF0pfFsqXXszLH0oPyFcXCgpfFsqXXsyfSg/IVsoL118JCl8XFwqKD89XFwqXFwoKSkvO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKHN0YXJSZSk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdGhpcy5zdGF0ZS5tZXRhY2hhciA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlLnN0YXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdzdGFyJyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU2xhc2g6IFwiL1wiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnc2xhc2gnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXC8vKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnN0YXRlLnNsYXNoZXMrKztcbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnc2xhc2gnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCYWNrc2xhc2g6IFwiXFxcXFwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYmFja3NsYXNoJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxcXCg/IVsqKz8oKXt9W1xcXSdcIl0pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHZhbCA9IG1bMF07XG5cbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHtcbiAgICAgICAgdmFsID0gJ1xcXFwnO1xuICAgICAgfSBlbHNlIGlmICh2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSAnXFxcXFxcXFwnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ2JhY2tzbGFzaCcsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlOiBcIlsuXVwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnc3F1YXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSByZXR1cm47XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxbKFteIV5cXFxcXSlcXF0vKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3NxdWFyZScsXG4gICAgICAgIHZhbDogbVsxXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEJyYWNrZXRzOiBcIlsuLi5dXCIgKGJhc2ljLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IG90aGVyIHBhcnNlcnMpXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXig/OlxcWyhbIV5dPykoW15cXF1dK3xcXF0tKShcXF18W14qKz9dKyl8XFxbKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuICAgICAgdmFyIG5lZ2F0ZWQgPSBtWzFdID8gJ14nIDogJyc7XG4gICAgICB2YXIgaW5uZXIgPSAobVsyXSB8fCAnJykucmVwbGFjZSgvXFxcXFxcXFwrLywgJ1xcXFxcXFxcJyk7XG4gICAgICB2YXIgY2xvc2UgPSBtWzNdIHx8ICcnO1xuXG4gICAgICBpZiAobVsyXSAmJiBpbm5lci5sZW5ndGggPCBtWzJdLmxlbmd0aCkge1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxcXFxcXFwrLywgJ1xcXFxcXFxcJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlc2MgPSB0aGlzLmlucHV0LnNsaWNlKDAsIDIpO1xuICAgICAgaWYgKGlubmVyID09PSAnJyAmJiBlc2MgPT09ICdcXFxcXScpIHtcbiAgICAgICAgaW5uZXIgKz0gZXNjO1xuICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHdoaWxlICgoY2ggPSBzdHJbKytpZHhdKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgY2xvc2UgPSBjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbm5lciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQnLFxuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgZXNjYXBlZDogY2xvc2UgIT09ICddJyxcbiAgICAgICAgbmVnYXRlZDogbmVnYXRlZCxcbiAgICAgICAgaW5uZXI6IGlubmVyLFxuICAgICAgICBjbG9zZTogY2xvc2VcbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBUZXh0XG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgndGV4dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChub3QpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgLyoqXG4gICAqIEFsbG93IGN1c3RvbSBwYXJzZXJzIHRvIGJlIHBhc3NlZCBvbiBvcHRpb25zXG4gICAqL1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnBhcnNlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLnBhcnNlcnMobmFub21hdGNoLnBhcnNlcik7XG4gIH1cbn07XG5cbi8qKlxuICogQWR2YW5jZSB0byB0aGUgbmV4dCBub24tZXNjYXBlZCBjaGFyYWN0ZXJcbiAqL1xuXG5mdW5jdGlvbiBhZHZhbmNlVG8oaW5wdXQsIGVuZENoYXIpIHtcbiAgdmFyIGNoID0gaW5wdXQuY2hhckF0KDApO1xuICB2YXIgdG9rID0geyBsZW46IDEsIHZhbDogJycsIGVzYzogJycgfTtcbiAgdmFyIGlkeCA9IDA7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICBpZiAoY2ggIT09ICdcXFxcJykge1xuICAgICAgdG9rLmVzYyArPSAnXFxcXCcgKyBjaDtcbiAgICAgIHRvay52YWwgKz0gY2g7XG4gICAgfVxuXG4gICAgY2ggPSBpbnB1dC5jaGFyQXQoKytpZHgpO1xuICAgIHRvay5sZW4rKztcblxuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBhZHZhbmNlKCk7XG4gICAgICBhZHZhbmNlKCk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICYmIGNoICE9PSBlbmRDaGFyKSB7XG4gICAgYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiB0b2s7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRleHQgcmVnZXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0UmVnZXgocGF0dGVybikge1xuICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICB2YXIgb3B0cyA9IHtjb250YWluczogdHJ1ZSwgc3RyaWN0Q2xvc2U6IGZhbHNlfTtcbiAgdmFyIG5vdCA9IHJlZ2V4Tm90LmNyZWF0ZShwYXR0ZXJuLCBvcHRzKTtcbiAgdmFyIHJlID0gdG9SZWdleCgnXig/OlsqXVxcXFwoKD89Lil8JyArIG5vdCArICcpJywgb3B0cyk7XG4gIHJldHVybiAoY2FjaGVkID0gcmUpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBuZWdhdGlvbiBzdHJpbmdcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ub3QgPSBOT1RfUkVHRVg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBpc1dpbmRvd3MgPSByZXF1aXJlKCdpcy13aW5kb3dzJykoKTtcbnZhciBTbmFwZHJhZ29uID0gcmVxdWlyZSgnc25hcGRyYWdvbicpO1xudXRpbHMuZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG51dGlscy5kaWZmID0gcmVxdWlyZSgnYXJyLWRpZmYnKTtcbnV0aWxzLmV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG51dGlscy5waWNrID0gcmVxdWlyZSgnb2JqZWN0LnBpY2snKTtcbnV0aWxzLnR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcbnV0aWxzLnVuaXF1ZSA9IHJlcXVpcmUoJ2FycmF5LXVuaXF1ZScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZWZmZWN0aXZlbHkgYW4gZW1wdHkgc3RyaW5nXG4gKi9cblxudXRpbHMuaXNFbXB0eVN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gU3RyaW5nKHZhbCkgPT09ICcnIHx8IFN0cmluZyh2YWwpID09PSAnLi8nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBsYXRmb3JtIGlzIHdpbmRvd3MsIG9yIGBwYXRoLnNlcGAgaXMgYFxcXFxgLlxuICogVGhpcyBpcyBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gdG8gYWxsb3cgYHBhdGguc2VwYCB0byBiZSBzZXQgaW4gdW5pdCB0ZXN0cyxcbiAqIG9yIGJ5IHRoZSB1c2VyLCBpZiB0aGVyZSBpcyBhIHJlYXNvbiB0byBkbyBzby5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwYXRoLnNlcCA9PT0gJ1xcXFwnIHx8IGlzV2luZG93cyA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheVxuICovXG5cbnV0aWxzLmxhc3QgPSBmdW5jdGlvbihhcnIsIG4pIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gKG4gfHwgMSldO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGBTbmFwZHJhZ29uYCBpbnN0YW5jZSB0byB1c2VcbiAqL1xuXG51dGlscy5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICB2YXIgc25hcGRyYWdvbjtcbiAgLy8gaWYgYW4gaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgYnkgYC5wYXJzZWAsIHVzZSB0aGF0IGluc3RhbmNlXG4gIGlmICh1dGlscy50eXBlT2YoYXN0KSA9PT0gJ29iamVjdCcgJiYgYXN0LnNuYXBkcmFnb24pIHtcbiAgICBzbmFwZHJhZ29uID0gYXN0LnNuYXBkcmFnb247XG4gIC8vIGlmIHRoZSB1c2VyIHN1cHBsaWVzIGFuIGluc3RhbmNlIG9uIG9wdGlvbnMsIHVzZSB0aGF0IGluc3RhbmNlXG4gIH0gZWxzZSBpZiAodXRpbHMudHlwZU9mKG9wdGlvbnMpID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLnNuYXBkcmFnb24pIHtcbiAgICBzbmFwZHJhZ29uID0gb3B0aW9ucy5zbmFwZHJhZ29uO1xuICAvLyBjcmVhdGUgYSBuZXcgaW5zdGFuY2VcbiAgfSBlbHNlIHtcbiAgICBzbmFwZHJhZ29uID0gbmV3IFNuYXBkcmFnb24ob3B0aW9ucyk7XG4gIH1cblxuICB1dGlscy5kZWZpbmUoc25hcGRyYWdvbiwgJ3BhcnNlJywgZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZCA9IFNuYXBkcmFnb24ucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc3RyLCBvcHRpb25zKTtcbiAgICBwYXJzZWQuaW5wdXQgPSBzdHI7XG5cbiAgICAvLyBlc2NhcGUgdW5tYXRjaGVkIGJyYWNlL2JyYWNrZXQvcGFyZW5zXG4gICAgdmFyIGxhc3QgPSB0aGlzLnBhcnNlci5zdGFjay5wb3AoKTtcbiAgICBpZiAobGFzdCAmJiB0aGlzLm9wdGlvbnMuc3RyaWN0RXJyb3JzICE9PSB0cnVlKSB7XG4gICAgICB2YXIgb3BlbiA9IGxhc3Qubm9kZXNbMF07XG4gICAgICB2YXIgaW5uZXIgPSBsYXN0Lm5vZGVzWzFdO1xuICAgICAgaWYgKGxhc3QudHlwZSA9PT0gJ2JyYWNrZXQnKSB7XG4gICAgICAgIGlmIChpbm5lci52YWwuY2hhckF0KDApID09PSAnWycpIHtcbiAgICAgICAgICBpbm5lci52YWwgPSAnXFxcXCcgKyBpbm5lci52YWw7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3Blbi52YWwgPSAnXFxcXCcgKyBvcGVuLnZhbDtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBvcGVuLnBhcmVudC5ub2Rlc1sxXTtcbiAgICAgICAgaWYgKHNpYmxpbmcudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICAgICAgc2libGluZy5sb29zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgbm9uLWVudW1lcmFibGUgcGFyc2VyIHJlZmVyZW5jZVxuICAgIHV0aWxzLmRlZmluZShwYXJzZWQsICdwYXJzZXInLCB0aGlzLnBhcnNlcik7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfSk7XG5cbiAgcmV0dXJuIHNuYXBkcmFnb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUga2V5IHRvIHVzZSBmb3IgbWVtb2l6YXRpb24uIFRoZSBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBieSBpdGVyYXRpbmcgb3ZlciB0aGUgb3B0aW9ucyBhbmQgY29uY2F0ZW5hdGluZyBrZXktdmFsdWUgcGFpcnNcbiAqIHRvIHRoZSBwYXR0ZXJuIHN0cmluZy5cbiAqL1xuXG51dGlscy5jcmVhdGVLZXkgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICB2YXIga2V5ID0gcGF0dGVybjtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGtleSArPSAnOycgKyBwcm9wICsgJz0nICsgU3RyaW5nKG9wdGlvbnNbcHJvcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG51dGlscy5hcnJheWlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiBbdmFsXTtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbGAgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKi9cblxudXRpbHMuaXNTdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqL1xuXG51dGlscy5pc1JlZ2V4ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB1dGlscy50eXBlT2YodmFsKSA9PT0gJ3JlZ2V4cCc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICovXG5cbnV0aWxzLmlzT2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB1dGlscy50eXBlT2YodmFsKSA9PT0gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIEVzY2FwZSByZWdleCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmdcbiAqL1xuXG51dGlscy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1stW1xcXXt9KCleJHwqKz8uXFxcXC9cXHNdL2csICdcXFxcJCYnKTtcbn07XG5cbi8qKlxuICogQ29tYmluZXMgZHVwbGljYXRlIGNoYXJhY3RlcnMgaW4gdGhlIHByb3ZpZGVkIGBpbnB1dGAgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGBcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblxudXRpbHMuY29tYmluZUR1cGVzID0gZnVuY3Rpb24oaW5wdXQsIHBhdHRlcm5zKSB7XG4gIHBhdHRlcm5zID0gdXRpbHMuYXJyYXlpZnkocGF0dGVybnMpLmpvaW4oJ3wnKS5zcGxpdCgnfCcpO1xuICBwYXR0ZXJucyA9IHBhdHRlcm5zLm1hcChmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXD8oWysqXFxcXC9dKS9nLCAnXFxcXCQxJyk7XG4gIH0pO1xuICB2YXIgc3Vic3RyID0gcGF0dGVybnMuam9pbignfCcpO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcoJyArIHN1YnN0ciArICcpKD89XFxcXDEpJywgJ2cnKTtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UocmVnZXgsICcnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyYCBoYXMgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gKi9cblxudXRpbHMuaGFzU3BlY2lhbENoYXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAvKD86KD86KF58XFwvKVshLl0pfFsqPysoKXxbXFxde31dfFsrQF1cXCgpLy50ZXN0KHN0cik7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBzbGFzaGVzIGluIHRoZSBnaXZlbiBmaWxlcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYGZpbGVwYXRoYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnRvUG9zaXhQYXRoID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXCsvZywgJy8nKTtcbn07XG5cbi8qKlxuICogU3RyaXAgYmFja3NsYXNoZXMgYmVmb3JlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy51bmVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdXRpbHMudG9Qb3NpeFBhdGgoc3RyLnJlcGxhY2UoL1xcXFwoPz1bKis/IS5dKS9nLCAnJykpO1xufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgZHJpdmUgbGV0dGVyIGZyb20gYSB3aW5kb3dzIGZpbGVwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gYGZwYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnN0cmlwRHJpdmUgPSBmdW5jdGlvbihmcCkge1xuICByZXR1cm4gdXRpbHMuaXNXaW5kb3dzKCkgPyBmcC5yZXBsYWNlKC9eW2Etel06W1xcXFwvXSs/L2ksICcvJykgOiBmcDtcbn07XG5cbi8qKlxuICogU3RyaXAgdGhlIHByZWZpeCBmcm9tIGEgZmlsZXBhdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZnBgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMuc3RyaXBQcmVmaXggPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcuJyAmJiAoc3RyLmNoYXJBdCgxKSA9PT0gJy8nIHx8IHN0ci5jaGFyQXQoMSkgPT09ICdcXFxcJykpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBpcyBhIGNvbW1vbiBjaGFyYWN0ZXIgdGhhdCBkb2Vzbid0IG5lZWRcbiAqIHRvIGJlIHByb2Nlc3NlZCB0byBiZSB1c2VkIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG51dGlscy5pc1NpbXBsZUNoYXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkgPT09ICcnIHx8IHN0ciA9PT0gJy4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0ciBpcyBhbiBlc2NhcGVkIG9yXG4gKiB1bmVzY2FwZWQgcGF0aCBjaGFyYWN0ZXJcbiAqL1xuXG51dGlscy5pc1NsYXNoID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIgPT09ICcvJyB8fCBzdHIgPT09ICdcXFxcLycgfHwgc3RyID09PSAnXFxcXCcgfHwgc3RyID09PSAnXFxcXFxcXFwnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiBwYXR0ZXJuIG1hdGNoZXMgb3IgY29udGFpbnMgYSBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMubWF0Y2hQYXRoID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWlucylcbiAgICA/IHV0aWxzLmNvbnRhaW5zUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKVxuICAgIDogdXRpbHMuZXF1YWxzUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiAob3JpZ2luYWwpIGZpbGVwYXRoIG9yIHVuaXhpZmllZCBwYXRoIGFyZSBlcXVhbFxuICogdG8gdGhlIGdpdmVuIHBhdHRlcm4uXG4gKi9cblxudXRpbHMuX2VxdWFscyA9IGZ1bmN0aW9uKGZpbGVwYXRoLCB1bml4UGF0aCwgcGF0dGVybikge1xuICByZXR1cm4gcGF0dGVybiA9PT0gZmlsZXBhdGggfHwgcGF0dGVybiA9PT0gdW5peFBhdGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gKG9yaWdpbmFsKSBmaWxlcGF0aCBvciB1bml4aWZpZWQgcGF0aCBjb250YWluXG4gKiB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqL1xuXG51dGlscy5fY29udGFpbnMgPSBmdW5jdGlvbihmaWxlcGF0aCwgdW5peFBhdGgsIHBhdHRlcm4pIHtcbiAgcmV0dXJuIGZpbGVwYXRoLmluZGV4T2YocGF0dGVybikgIT09IC0xIHx8IHVuaXhQYXRoLmluZGV4T2YocGF0dGVybikgIT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiBwYXR0ZXJuIGlzIHRoZSBzYW1lIGFzIGEgZ2l2ZW4gYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLmVxdWFsc1BhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGZuKGZpbGVwYXRoKSB7XG4gICAgdmFyIGVxdWFsID0gdXRpbHMuX2VxdWFscyhmaWxlcGF0aCwgdW5peGlmeShmaWxlcGF0aCksIHBhdHRlcm4pO1xuICAgIGlmIChlcXVhbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLm5vY2FzZSAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cbiAgICB2YXIgbG93ZXIgPSBmaWxlcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB1dGlscy5fZXF1YWxzKGxvd2VyLCB1bml4aWZ5KGxvd2VyKSwgcGF0dGVybik7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gY29udGFpbnMgYSBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMuY29udGFpbnNQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgIHZhciBjb250YWlucyA9IHV0aWxzLl9jb250YWlucyhmaWxlcGF0aCwgdW5peGlmeShmaWxlcGF0aCksIHBhdHRlcm4pO1xuICAgIGlmIChjb250YWlucyA9PT0gdHJ1ZSB8fCBvcHRpb25zLm5vY2FzZSAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgIH1cbiAgICB2YXIgbG93ZXIgPSBmaWxlcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB1dGlscy5fY29udGFpbnMobG93ZXIsIHVuaXhpZnkobG93ZXIpLCBwYXR0ZXJuKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcmVnZXggbWF0Y2hlcyB0aGUgYGZpbGVuYW1lYCBvZiBhIGZpbGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYHJlYCBNYXRjaGluZyByZWdleFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMubWF0Y2hCYXNlbmFtZSA9IGZ1bmN0aW9uKHJlKSB7XG4gIHJldHVybiBmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgIHJldHVybiByZS50ZXN0KGZpbGVwYXRoKSB8fCByZS50ZXN0KHBhdGguYmFzZW5hbWUoZmlsZXBhdGgpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgdW5jaGFuY2VkLlxuICogQHJldHVybiB7YW55fVxuICovXG5cbnV0aWxzLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGZpbGVwYXRoIHRvIHJldHVybiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuXG51dGlscy52YWx1ZSA9IGZ1bmN0aW9uKHN0ciwgdW5peGlmeSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXhpZnkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy51bml4aWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudW5peGlmeShzdHIpO1xuICB9XG4gIHJldHVybiB1bml4aWZ5KHN0cik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG5vcm1hbGl6ZXMgc2xhc2hlcyBpbiBhIHN0cmluZyB0byBmb3J3YXJkXG4gKiBzbGFzaGVzLCBzdHJpcHMgYC4vYCBmcm9tIGJlZ2lubmluZyBvZiBwYXRocywgYW5kIG9wdGlvbmFsbHkgdW5lc2NhcGVzXG4gKiBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy51bml4aWZ5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiBmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgIGlmIChvcHRzLnN0cmlwUHJlZml4ICE9PSBmYWxzZSkge1xuICAgICAgZmlsZXBhdGggPSB1dGlscy5zdHJpcFByZWZpeChmaWxlcGF0aCk7XG4gICAgfVxuICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICBmaWxlcGF0aCA9IHV0aWxzLnVuZXNjYXBlKGZpbGVwYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudW5peGlmeSA9PT0gdHJ1ZSB8fCB1dGlscy5pc1dpbmRvd3MoKSkge1xuICAgICAgZmlsZXBhdGggPSB1dGlscy50b1Bvc2l4UGF0aChmaWxlcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIG5vcm1hbGl6ZS1wYXRoIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9ub3JtYWxpemUtcGF0aD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxudmFyIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yID0gcmVxdWlyZSgncmVtb3ZlLXRyYWlsaW5nLXNlcGFyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgoc3RyLCBzdHJpcFRyYWlsaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1tcXFxcXFwvXSsvZywgJy8nKTtcbiAgaWYgKHN0cmlwVHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgc3RyID0gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3Ioc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG52YXIgY29weURlc2NyaXB0b3IgPSByZXF1aXJlKCdjb3B5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcblxuLyoqXG4gKiBDb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBwcm90b3R5cGUgcHJvcGVydGllcywgYW5kIGRlc2NyaXB0b3JzIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBBcHAoKSB7fVxuICogdmFyIHByb3RvID0gQXBwLnByb3RvdHlwZTtcbiAqIEFwcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7fTtcbiAqIEFwcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7fTtcbiAqXG4gKiB2YXIgb2JqID0ge307XG4gKiBjb3B5KG9iaiwgcHJvdG8pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHJlY2VpdmVyYFxuICogQHBhcmFtIHtPYmplY3R9IGBwcm92aWRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgb21pdGAgT25lIG9yIG1vcmUgcHJvcGVydGllcyB0byBvbWl0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvcHkocmVjZWl2ZXIsIHByb3ZpZGVyLCBvbWl0KSB7XG4gIGlmICghaXNPYmplY3QocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcmVjZWl2aW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKCFpc09iamVjdChwcm92aWRlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwcm92aWRpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IG5hdGl2ZUtleXMocHJvdmlkZXIpO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3ZpZGVyKTtcbiAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgb21pdCA9IGFycmF5aWZ5KG9taXQpO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tsZW5dO1xuXG4gICAgaWYgKGhhcyhrZXlzLCBrZXkpKSB7XG4gICAgICBkZWZpbmUocmVjZWl2ZXIsIGtleSwgcHJvdmlkZXJba2V5XSk7XG4gICAgfSBlbHNlIGlmICghKGtleSBpbiByZWNlaXZlcikgJiYgIWhhcyhvbWl0LCBrZXkpKSB7XG4gICAgICBjb3B5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvdmlkZXIsIGtleSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVPZih2YWwpID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhcnJheSBoYXMgYW55IG9mIHRoZSBnaXZlbiBlbGVtZW50cywgb3IgYW5cbiAqIG9iamVjdCBoYXMgYW55IG9mIHRoZSBnaXZlIGtleXMuXG4gKlxuICogYGBganNcbiAqIGhhcyhbJ2EnLCAnYicsICdjJ10sICdjJyk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBoYXMoWydhJywgJ2InLCAnYyddLCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGhhcyh7YTogJ2InLCBjOiAnZCd9LCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgdmFsYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXMob2JqLCB2YWwpIHtcbiAgdmFsID0gYXJyYXlpZnkodmFsKTtcbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodmFsLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gbmF0aXZlS2V5cyhvYmopO1xuICAgIHJldHVybiBoYXMoa2V5cywgdmFsKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICB2YXIgYXJyID0gb2JqO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHZhbFtsZW5dKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBhcnJheSBvciBvYmplY3QuJyk7XG59XG5cbi8qKlxuICogQ2FzdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gYW4gYXJyYXkuXG4gKlxuICogYGBganNcbiAqIGFycmF5aWZ5KCdmb28nKTtcbiAqIC8vPT4gWydmb28nXVxuICpcbiAqIGFycmF5aWZ5KFsnZm9vJ10pO1xuICogLy89PiBbJ2ZvbyddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHZhbGBcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGFycmF5aWZ5KHZhbCkge1xuICByZXR1cm4gdmFsID8gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKSA6IFtdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHZhbHVlIGhhcyBhIGBjb250cnVjdG9yYFxuICpcbiAqIGBgYGpzXG4gKiBoYXNDb25zdHJ1Y3Rvcih7fSk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBoYXNDb25zdHJ1Y3RvcihPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7T2JqZWN0fSBgdmFsdWVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0NvbnN0cnVjdG9yKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgb3duUHJvcGVydHlOYW1lc2AgZnJvbSB0aGUgY29uc3RydWN0b3Igb2YgdGhlXG4gKiBnaXZlbiBgb2JqZWN0YC4gQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlIG9iamVjdCBkb2VzXG4gKiBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBgYGpzXG4gKiBuYXRpdmVLZXlzKHthOiAnYicsIGI6ICdjJywgYzogJ2QnfSlcbiAqIC8vPT4gWydhJywgJ2InLCAnYyddXG4gKlxuICogbmF0aXZlS2V5cyhmdW5jdGlvbigpe30pXG4gKiAvLz0+IFsnbGVuZ3RoJywgJ2NhbGxlciddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvYmpgIE9iamVjdCB0aGF0IGhhcyBhIGBjb25zdHJ1Y3RvcmAuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2Yga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBuYXRpdmVLZXlzKHZhbCkge1xuICBpZiAoIWhhc0NvbnN0cnVjdG9yKHZhbCkpIHJldHVybiBbXTtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbCk7XG59XG5cbi8qKlxuICogRXhwb3NlIGBjb3B5YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gY29weTtcblxuLyoqXG4gKiBFeHBvc2UgYGNvcHkuaGFzYCBmb3IgdGVzdHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5oYXMgPSBoYXM7XG4iLCIvKiFcbiAqIG9iamVjdC12aXNpdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvb2JqZWN0LXZpc2l0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZpc2l0KHRoaXNBcmcsIG1ldGhvZCwgdGFyZ2V0LCB2YWwpIHtcbiAgaWYgKCFpc09iamVjdCh0aGlzQXJnKSAmJiB0eXBlb2YgdGhpc0FyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignb2JqZWN0LXZpc2l0IGV4cGVjdHMgYHRoaXNBcmdgIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignb2JqZWN0LXZpc2l0IGV4cGVjdHMgYG1ldGhvZGAgbmFtZSB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGlzQXJnW21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGhpc0FyZztcbiAgfVxuXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIHZhciBhcnIgPSBba2V5LCB0YXJnZXRba2V5XV0uY29uY2F0KGFyZ3MpO1xuICAgIHRoaXNBcmdbbWV0aG9kXS5hcHBseSh0aGlzQXJnLCBhcnIpO1xuICB9XG4gIHJldHVybiB0aGlzQXJnO1xufTtcbiIsIi8qIVxuICogb2JqZWN0LnBpY2sgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L29iamVjdC5waWNrPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgaWYgKCFpc09iamVjdChvYmopICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgcmVzID0ge307XG4gIGlmICh0eXBlb2Yga2V5cyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoa2V5cyBpbiBvYmopIHtcbiAgICAgIHJlc1trZXlzXSA9IG9ialtrZXlzXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBrZXkgPSBrZXlzW2lkeF07XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIHJlc1trZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcblxuZXhwb3J0cy5ob21lZGlyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJy8nXG59O1xuIiwiLyohXG4gKiBwYXNjYWxjYXNlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9wYXNjYWxjYXNlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gcGFzY2FsY2FzZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcuJyk7XG4gIH1cbiAgc3RyID0gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgJyAkMScpO1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkgeyByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7IH1cbiAgc3RyID0gc3RyLnJlcGxhY2UoL15bXFxXX10rfFtcXFdfXSskL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzdHIgPSBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcV19dKyhcXHd8JCkvZywgZnVuY3Rpb24gKF8sIGNoKSB7XG4gICAgcmV0dXJuIGNoLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhc2NhbGNhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdDtcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBpbnNwZWN0KHBhdGgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3NpeChwYXRoKSB7XG4gIGFzc2VydFBhdGgocGF0aCk7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSAoY29kZSA9PT0gNDcvKi8qLyk7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcvKi8qLykge1xuICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgZW5kID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSlcbiAgICByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKVxuICAgIHJldHVybiAnLy8nO1xuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufVxuXG5mdW5jdGlvbiB3aW4zMihwYXRoKSB7XG4gIGFzc2VydFBhdGgocGF0aCk7XG4gIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMClcbiAgICByZXR1cm4gJy4nO1xuICB2YXIgcm9vdEVuZCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG5cbiAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxuICBpZiAobGVuID4gMSkge1xuICAgIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKSB7XG4gICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxuXG4gICAgICByb290RW5kID0gb2Zmc2V0ID0gMTtcblxuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdCgxKTtcbiAgICAgIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKSB7XG4gICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xuICAgICAgICB2YXIgaiA9IDI7XG4gICAgICAgIHZhciBsYXN0ID0gajtcbiAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgZm9yICg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgZm9yICg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSA0Ny8qLyovICYmIGNvZGUgIT09IDkyLypcXCovKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XG4gICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzXG5cbiAgICAgICAgICAgICAgLy8gT2Zmc2V0IGJ5IDEgdG8gaW5jbHVkZSB0aGUgc2VwYXJhdG9yIGFmdGVyIHRoZSBVTkMgcm9vdCB0b1xuICAgICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIFwibm9ybWFsIHJvb3RcIiBvbiB0b3Agb2YgYSAoVU5DKSByb290XG4gICAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSBqICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChjb2RlID49IDY1LypBKi8gJiYgY29kZSA8PSA5MC8qWiovKSB8fFxuICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcvKmEqLyAmJiBjb2RlIDw9IDEyMi8qeiovKSkge1xuICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcblxuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdCgxKTtcbiAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoMSkgPT09IDU4Lyo6Ki8pIHtcbiAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IDI7XG4gICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdCgyKTtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLylcbiAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pIHtcbiAgICByZXR1cm4gcGF0aFswXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IG9mZnNldDsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLykge1xuICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgZW5kID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkge1xuICAgIGlmIChyb290RW5kID09PSAtMSlcbiAgICAgIHJldHVybiAnLic7XG4gICAgZWxzZVxuICAgICAgZW5kID0gcm9vdEVuZDtcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMucG9zaXggPSBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLndpbjMyID0gd2luMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcblx0cmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbmZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcblx0dmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL10rW15cXFxcXFwvXSspPyhbXFxcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuXHR2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuXHR2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuXHR2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG5cdC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG5cdHJldHVybiBCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy5wb3NpeCA9IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMud2luMzIgPSB3aW4zMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQT1NJWCBjaGFyYWN0ZXIgY2xhc3Nlc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhbG51bTogJ2EtekEtWjAtOScsXG4gIGFscGhhOiAnYS16QS1aJyxcbiAgYXNjaWk6ICdcXFxceDAwLVxcXFx4N0YnLFxuICBibGFuazogJyBcXFxcdCcsXG4gIGNudHJsOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3RicsXG4gIGRpZ2l0OiAnMC05JyxcbiAgZ3JhcGg6ICdcXFxceDIxLVxcXFx4N0UnLFxuICBsb3dlcjogJ2EteicsXG4gIHByaW50OiAnXFxcXHgyMC1cXFxceDdFICcsXG4gIHB1bmN0OiAnXFxcXC0hXCIjJCUmXFwnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9ficsXG4gIHNwYWNlOiAnIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLFxuICB1cHBlcjogJ0EtWicsXG4gIHdvcmQ6ICdBLVphLXowLTlfJyxcbiAgeGRpZ2l0OiAnQS1GYS1mMC05J1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzICAgICAgICA9ICByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG4gICwgcGF0aCAgICAgID0gIHJlcXVpcmUoJ3BhdGgnKVxuICAsIG1pY3JvbWF0Y2ggPSAgcmVxdWlyZSgnbWljcm9tYXRjaCcpLmlzTWF0Y2hcbiAgLCB0b1N0cmluZyAgPSAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICA7XG5cblxuLy8gU3RhbmRhcmQgaGVscGVyc1xuZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkIChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xufVxuXG4vKipcbiAqIE1haW4gZnVuY3Rpb24gd2hpY2ggZW5kcyB1cCBjYWxsaW5nIHJlYWRkaXJSZWMgYW5kIHJlYWRzIGFsbCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgaW4gZ2l2ZW4gcm9vdCByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7IE9iamVjdCB9ICAgb3B0cyAgICAgT3B0aW9ucyB0byBzcGVjaWZ5IHJvb3QgKHN0YXJ0IGRpcmVjdG9yeSksIGZpbHRlcnMgYW5kIHJlY3Vyc2lvbiBkZXB0aFxuICogQHBhcmFtIHsgZnVuY3Rpb24gfSBjYWxsYmFjazEgIFdoZW4gY2FsbGJhY2syIGlzIGdpdmVuIGNhbGxzIGJhY2sgZm9yIGVhY2ggcHJvY2Vzc2VkIGZpbGUgLSBmdW5jdGlvbiAoZmlsZUluZm8pIHsgLi4uIH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBjYWxsYmFjazIgaXMgbm90IGdpdmVuLCBpdCBiZWhhdmVzIGxpa2UgZXhwbGFpbmVkIGluIGNhbGxiYWNrMlxuICogQHBhcmFtIHsgZnVuY3Rpb24gfSBjYWxsYmFjazIgIENhbGxzIGJhY2sgb25jZSBhbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCB3aXRoIGFuIGFycmF5IG9mIGVycm9ycyBhbmQgZmlsZSBpbmZvc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGZpbGVJbmZvcykgeyAuLi4gfVxuICovXG5mdW5jdGlvbiByZWFkZGlyKG9wdHMsIGNhbGxiYWNrMSwgY2FsbGJhY2syKSB7XG4gIHZhciBzdHJlYW1cbiAgICAsIGhhbmRsZUVycm9yXG4gICAgLCBoYW5kbGVGYXRhbEVycm9yXG4gICAgLCBlcnJvcnMgPSBbXVxuICAgICwgcmVhZGRpclJlc3VsdCA9IHtcbiAgICAgICAgZGlyZWN0b3JpZXM6IFtdXG4gICAgICAsIGZpbGVzOiBbXVxuICAgIH1cbiAgICAsIGZpbGVQcm9jZXNzZWRcbiAgICAsIGFsbFByb2Nlc3NlZFxuICAgICwgcmVhbFJvb3RcbiAgICAsIGFib3J0ZWQgPSBmYWxzZVxuICAgICwgcGF1c2VkID0gZmFsc2VcbiAgICA7XG5cbiAgLy8gSWYgbm8gY2FsbGJhY2tzIHdlcmUgZ2l2ZW4gd2Ugd2lsbCB1c2UgYSBzdHJlYW1pbmcgaW50ZXJmYWNlXG4gIGlmIChpc1VuZGVmaW5lZChjYWxsYmFjazEpKSB7XG4gICAgdmFyIGFwaSAgICAgICAgICA9ICByZXF1aXJlKCcuL3N0cmVhbS1hcGknKSgpO1xuICAgIHN0cmVhbSAgICAgICAgICAgPSAgYXBpLnN0cmVhbTtcbiAgICBjYWxsYmFjazEgICAgICAgID0gIGFwaS5wcm9jZXNzRW50cnk7XG4gICAgY2FsbGJhY2syICAgICAgICA9ICBhcGkuZG9uZTtcbiAgICBoYW5kbGVFcnJvciAgICAgID0gIGFwaS5oYW5kbGVFcnJvcjtcbiAgICBoYW5kbGVGYXRhbEVycm9yID0gIGFwaS5oYW5kbGVGYXRhbEVycm9yO1xuXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsgYWJvcnRlZCA9IHRydWU7IH0pO1xuICAgIHN0cmVhbS5vbigncGF1c2UnLCBmdW5jdGlvbiAoKSB7IHBhdXNlZCA9IHRydWU7IH0pO1xuICAgIHN0cmVhbS5vbigncmVzdW1lJywgZnVuY3Rpb24gKCkgeyBwYXVzZWQgPSBmYWxzZTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlRXJyb3IgICAgICA9ICBmdW5jdGlvbiAoZXJyKSB7IGVycm9ycy5wdXNoKGVycik7IH07XG4gICAgaGFuZGxlRmF0YWxFcnJvciA9ICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgYWxsUHJvY2Vzc2VkKGVycm9ycywgbnVsbCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZChvcHRzKSl7XG4gICAgaGFuZGxlRmF0YWxFcnJvcihuZXcgRXJyb3IgKFxuICAgICAgJ05lZWQgdG8gcGFzcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ6IG9wdHMhIFxcbicgK1xuICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvcmVhZGRpcnAjb3B0aW9ucydcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICBvcHRzLnJvb3QgICAgICAgICAgICA9ICBvcHRzLnJvb3QgICAgICAgICAgICB8fCAnLic7XG4gIG9wdHMuZmlsZUZpbHRlciAgICAgID0gIG9wdHMuZmlsZUZpbHRlciAgICAgIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgb3B0cy5kaXJlY3RvcnlGaWx0ZXIgPSAgb3B0cy5kaXJlY3RvcnlGaWx0ZXIgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICBvcHRzLmRlcHRoICAgICAgICAgICA9ICB0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyA5OTk5OTk5OTkgOiBvcHRzLmRlcHRoO1xuICBvcHRzLmVudHJ5VHlwZSAgICAgICA9ICBvcHRzLmVudHJ5VHlwZSAgICAgICB8fCAnZmlsZXMnO1xuXG4gIHZhciBzdGF0Zm4gPSBvcHRzLmxzdGF0ID09PSB0cnVlID8gZnMubHN0YXQuYmluZChmcykgOiBmcy5zdGF0LmJpbmQoZnMpO1xuXG4gIGlmIChpc1VuZGVmaW5lZChjYWxsYmFjazIpKSB7XG4gICAgZmlsZVByb2Nlc3NlZCA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIGFsbFByb2Nlc3NlZCA9IGNhbGxiYWNrMTtcbiAgfSBlbHNlIHtcbiAgICBmaWxlUHJvY2Vzc2VkID0gY2FsbGJhY2sxO1xuICAgIGFsbFByb2Nlc3NlZCA9IGNhbGxiYWNrMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUZpbHRlciAoZmlsdGVyKSB7XG5cbiAgICBpZiAoaXNVbmRlZmluZWQoZmlsdGVyKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGZ1bmN0aW9uIGlzTmVnYXRlZCAoZmlsdGVycykge1xuXG4gICAgICBmdW5jdGlvbiBuZWdhdGVkKGYpIHtcbiAgICAgICAgcmV0dXJuIGYuaW5kZXhPZignIScpID09PSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc29tZSA9IGZpbHRlcnMuc29tZShuZWdhdGVkKTtcbiAgICAgIGlmICghc29tZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsdGVycy5ldmVyeShuZWdhdGVkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHdlIGRldGVjdCBpbGxlZ2FsIGZpbHRlcnMsIGJhaWwgb3V0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCBtaXggbmVnYXRlZCB3aXRoIG5vbiBuZWdhdGVkIGdsb2IgZmlsdGVyczogJyArIGZpbHRlcnMgKyAnXFxuJyArXG4gICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9yZWFkZGlycCNmaWx0ZXJzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUdXJuIGFsbCBmaWx0ZXJzIGludG8gYSBmdW5jdGlvblxuICAgIGlmIChpc0Z1bmN0aW9uKGZpbHRlcikpIHtcblxuICAgICAgcmV0dXJuIGZpbHRlcjtcblxuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoZmlsdGVyKSkge1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVudHJ5SW5mbykge1xuICAgICAgICByZXR1cm4gbWljcm9tYXRjaChlbnRyeUluZm8ubmFtZSwgZmlsdGVyLnRyaW0oKSk7XG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmIChmaWx0ZXIgJiYgQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG5cbiAgICAgIGlmIChmaWx0ZXIpIGZpbHRlciA9IGZpbHRlci5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYudHJpbSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpc05lZ2F0ZWQoZmlsdGVyKSA/XG4gICAgICAgIC8vIHVzZSBBTkQgdG8gY29uY2F0IG11bHRpcGxlIG5lZ2F0ZWQgZmlsdGVyc1xuICAgICAgICBmdW5jdGlvbiAoZW50cnlJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlci5ldmVyeShmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIG1pY3JvbWF0Y2goZW50cnlJbmZvLm5hbWUsIGYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIDpcbiAgICAgICAgLy8gdXNlIE9SIHRvIGNvbmNhdCBtdWx0aXBsZSBpbmNsdXNpdmUgZmlsdGVyc1xuICAgICAgICBmdW5jdGlvbiAoZW50cnlJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlci5zb21lKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gbWljcm9tYXRjaChlbnRyeUluZm8ubmFtZSwgZik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0RpcihjdXJyZW50RGlyLCBlbnRyaWVzLCBjYWxsUHJvY2Vzc2VkKSB7XG4gICAgaWYgKGFib3J0ZWQpIHJldHVybjtcbiAgICB2YXIgdG90YWwgPSBlbnRyaWVzLmxlbmd0aFxuICAgICAgLCBwcm9jZXNzZWQgPSAwXG4gICAgICAsIGVudHJ5SW5mb3MgPSBbXVxuICAgICAgO1xuXG4gICAgZnMucmVhbHBhdGgoY3VycmVudERpciwgZnVuY3Rpb24oZXJyLCByZWFsQ3VycmVudERpcikge1xuICAgICAgaWYgKGFib3J0ZWQpIHJldHVybjtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FsbFByb2Nlc3NlZChlbnRyeUluZm9zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVsRGlyID0gcGF0aC5yZWxhdGl2ZShyZWFsUm9vdCwgcmVhbEN1cnJlbnREaXIpO1xuXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FsbFByb2Nlc3NlZChbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG5cbiAgICAgICAgICB2YXIgZnVsbFBhdGggPSBwYXRoLmpvaW4ocmVhbEN1cnJlbnREaXIsIGVudHJ5KVxuICAgICAgICAgICAgLCByZWxQYXRoICA9IHBhdGguam9pbihyZWxEaXIsIGVudHJ5KTtcblxuICAgICAgICAgIHN0YXRmbihmdWxsUGF0aCwgZnVuY3Rpb24gKGVyciwgc3RhdCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW50cnlJbmZvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgICAgICAgICAgOiAgZW50cnlcbiAgICAgICAgICAgICAgICAsIHBhdGggICAgICAgICAgOiAgcmVsUGF0aCAgIC8vIHJlbGF0aXZlIHRvIHJvb3RcbiAgICAgICAgICAgICAgICAsIGZ1bGxQYXRoICAgICAgOiAgZnVsbFBhdGhcblxuICAgICAgICAgICAgICAgICwgcGFyZW50RGlyICAgICA6ICByZWxEaXIgICAgLy8gcmVsYXRpdmUgdG8gcm9vdFxuICAgICAgICAgICAgICAgICwgZnVsbFBhcmVudERpciA6ICByZWFsQ3VycmVudERpclxuXG4gICAgICAgICAgICAgICAgLCBzdGF0ICAgICAgICAgIDogIHN0YXRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzZWQrKztcbiAgICAgICAgICAgIGlmIChwcm9jZXNzZWQgPT09IHRvdGFsKSBjYWxsUHJvY2Vzc2VkKGVudHJ5SW5mb3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRkaXJSZWMoY3VycmVudERpciwgZGVwdGgsIGNhbGxDdXJyZW50RGlyUHJvY2Vzc2VkKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKGFib3J0ZWQpIHJldHVybjtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWFkZGlyUmVjLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSlcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5yZWFkZGlyKGN1cnJlbnREaXIsIGZ1bmN0aW9uIChlcnIsIGVudHJpZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FsbEN1cnJlbnREaXJQcm9jZXNzZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzRGlyKGN1cnJlbnREaXIsIGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5SW5mb3MpIHtcblxuICAgICAgICB2YXIgc3ViZGlycyA9IGVudHJ5SW5mb3NcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlaSkgeyByZXR1cm4gZWkuc3RhdC5pc0RpcmVjdG9yeSgpICYmIG9wdHMuZGlyZWN0b3J5RmlsdGVyKGVpKTsgfSk7XG5cbiAgICAgICAgc3ViZGlycy5mb3JFYWNoKGZ1bmN0aW9uIChkaSkge1xuICAgICAgICAgIGlmKG9wdHMuZW50cnlUeXBlID09PSAnZGlyZWN0b3JpZXMnIHx8IG9wdHMuZW50cnlUeXBlID09PSAnYm90aCcgfHwgb3B0cy5lbnRyeVR5cGUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICBmaWxlUHJvY2Vzc2VkKGRpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVhZGRpclJlc3VsdC5kaXJlY3Rvcmllcy5wdXNoKGRpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW50cnlJbmZvc1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZWkpIHtcbiAgICAgICAgICAgIHZhciBpc0NvcnJlY3RUeXBlID0gb3B0cy5lbnRyeVR5cGUgPT09ICdhbGwnID9cbiAgICAgICAgICAgICAgIWVpLnN0YXQuaXNEaXJlY3RvcnkoKSA6IGVpLnN0YXQuaXNGaWxlKCkgfHwgZWkuc3RhdC5pc1N5bWJvbGljTGluaygpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ycmVjdFR5cGUgJiYgb3B0cy5maWxlRmlsdGVyKGVpKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChmaSkge1xuICAgICAgICAgICAgaWYob3B0cy5lbnRyeVR5cGUgPT09ICdmaWxlcycgfHwgb3B0cy5lbnRyeVR5cGUgPT09ICdib3RoJyB8fCBvcHRzLmVudHJ5VHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgZmlsZVByb2Nlc3NlZChmaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZGlyUmVzdWx0LmZpbGVzLnB1c2goZmkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwZW5kaW5nU3ViZGlycyA9IHN1YmRpcnMubGVuZ3RoO1xuXG4gICAgICAgIC8vIEJlIGRvbmUgaWYgbm8gbW9yZSBzdWJmb2xkZXJzIGV4aXN0IG9yIHdlIHJlYWNoZWQgdGhlIG1heGltdW0gZGVzaXJlZCBkZXB0aFxuICAgICAgICBpZihwZW5kaW5nU3ViZGlycyA9PT0gMCB8fCBkZXB0aCA9PT0gb3B0cy5kZXB0aCkge1xuICAgICAgICAgIGNhbGxDdXJyZW50RGlyUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIHN1YmRpcnMsIGtlZXBpbmcgdHJhY2sgb2Ygd2hpY2ggb25lcyBhcmUgZG9uZVxuICAgICAgICAgIC8vIGFuZCBjYWxsIGJhY2sgb25jZSBhbGwgYXJlIHByb2Nlc3NlZFxuICAgICAgICAgIHN1YmRpcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViZGlyKSB7XG4gICAgICAgICAgICByZWFkZGlyUmVjKHN1YmRpci5mdWxsUGF0aCwgZGVwdGggKyAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdTdWJkaXJzID0gcGVuZGluZ1N1YmRpcnMgLSAxO1xuICAgICAgICAgICAgICBpZihwZW5kaW5nU3ViZGlycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNhbGxDdXJyZW50RGlyUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgZmlsdGVyc1xuICB0cnkge1xuICAgIG9wdHMuZmlsZUZpbHRlciA9IG5vcm1hbGl6ZUZpbHRlcihvcHRzLmZpbGVGaWx0ZXIpO1xuICAgIG9wdHMuZGlyZWN0b3J5RmlsdGVyID0gbm9ybWFsaXplRmlsdGVyKG9wdHMuZGlyZWN0b3J5RmlsdGVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgd2UgZGV0ZWN0IGlsbGVnYWwgZmlsdGVycywgYmFpbCBvdXQgaW1tZWRpYXRlbHlcbiAgICBoYW5kbGVGYXRhbEVycm9yKGVycik7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8vIElmIGZpbHRlcnMgd2VyZSB2YWxpZCBnZXQgb24gd2l0aCB0aGUgc2hvd1xuICBmcy5yZWFscGF0aChvcHRzLnJvb3QsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaGFuZGxlRmF0YWxFcnJvcihlcnIpO1xuICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG5cbiAgICByZWFsUm9vdCA9IHJlcztcbiAgICByZWFkZGlyUmVjKG9wdHMucm9vdCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQWxsIGVycm9ycyBhcmUgY29sbGVjdGVkIGludG8gdGhlIGVycm9ycyBhcnJheVxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFsbFByb2Nlc3NlZChlcnJvcnMsIHJlYWRkaXJSZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsUHJvY2Vzc2VkKG51bGwsIHJlYWRkaXJSZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWRkaXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgUmVhZGFibGUgPSBzdHJlYW0uUmVhZGFibGU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGRpcnBSZWFkYWJsZTtcblxudXRpbC5pbmhlcml0cyhSZWFkZGlycFJlYWRhYmxlLCBSZWFkYWJsZSk7XG5cbmZ1bmN0aW9uIFJlYWRkaXJwUmVhZGFibGUgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRkaXJwUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRkaXJwUmVhZGFibGUob3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5vYmplY3RNb2RlID0gdHJ1ZTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAvLyBiYWNrcHJlc3N1cmUgbm90IGltcGxlbWVudGVkIGF0IHRoaXMgcG9pbnRcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gSW5maW5pdHk7XG5cbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB0aGlzLl93YXJuaW5ncyA9IFtdO1xuICB0aGlzLl9lcnJvcnMgPSBbXTtcblxuICB0aGlzLl9wYXVzZVJlc3VtZUVycm9ycygpO1xufVxuXG52YXIgcHJvdG8gPSBSZWFkZGlycFJlYWRhYmxlLnByb3RvdHlwZTtcblxucHJvdG8uX3BhdXNlUmVzdW1lRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYub24oJ3BhdXNlJywgZnVuY3Rpb24gKCkgeyBzZWxmLl9wYXVzZWQgPSB0cnVlIH0pO1xuICBzZWxmLm9uKCdyZXN1bWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgIHNlbGYuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgc2VsZi5fd2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZXJyKSB7IHNlbGYuZW1pdCgnd2FybicsIGVycikgfSk7XG4gICAgc2VsZi5fd2FybmluZ3MubGVuZ3RoID0gMDtcblxuICAgIHNlbGYuX2Vycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5lbWl0KCdlcnJvcicsIGVycikgfSk7XG4gICAgc2VsZi5fZXJyb3JzLmxlbmd0aCA9IDA7XG4gIH0pXG59XG5cbi8vIGNhbGxlZCBmb3IgZWFjaCBlbnRyeVxucHJvdG8uX3Byb2Nlc3NFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm47XG4gIHRoaXMucHVzaChlbnRyeSk7XG59XG5cbnByb3RvLl9yZWFkID0gZnVuY3Rpb24gKCkgeyB9XG5cbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdoZW4gc3RyZWFtIGlzIGRlc3Ryb3llZCBpdCB3aWxsIGVtaXQgbm90aGluZyBmdXJ0aGVyLCBub3QgZXZlbiBlcnJvcnMgb3Igd2FybmluZ3NcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn1cblxucHJvdG8uX2RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbn1cblxuLy8gd2UgZW1pdCBlcnJvcnMgYW5kIHdhcm5pbmdzIGFzeW5jIHNpbmNlIHdlIG1heSBoYW5kbGUgZXJyb3JzIGxpa2UgaW52YWxpZCBhcmdzXG4vLyB3aXRoaW4gdGhlIGluaXRpYWwgZXZlbnQgbG9vcCBiZWZvcmUgYW55IGV2ZW50IGxpc3RlbmVycyBzdWJzY3JpYmVkXG5wcm90by5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fcGF1c2VkKSByZXR1cm4gc2VsZi5fd2FybmluZ3MucHVzaChlcnIpO1xuICAgIGlmICghc2VsZi5fZGVzdHJveWVkKSBzZWxmLmVtaXQoJ3dhcm4nLCBlcnIpO1xuICB9KTtcbn1cblxucHJvdG8uX2hhbmRsZUZhdGFsRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fcGF1c2VkKSByZXR1cm4gc2VsZi5fZXJyb3JzLnB1c2goZXJyKTtcbiAgICBpZiAoIXNlbGYuX2Rlc3Ryb3llZCkgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1BUEkgKCkge1xuICB2YXIgc3RyZWFtID0gbmV3IFJlYWRkaXJwUmVhZGFibGUoKTtcblxuICByZXR1cm4ge1xuICAgICAgc3RyZWFtICAgICAgICAgICA6ICBzdHJlYW1cbiAgICAsIHByb2Nlc3NFbnRyeSAgICAgOiAgc3RyZWFtLl9wcm9jZXNzRW50cnkuYmluZChzdHJlYW0pXG4gICAgLCBkb25lICAgICAgICAgICAgIDogIHN0cmVhbS5fZG9uZS5iaW5kKHN0cmVhbSlcbiAgICAsIGhhbmRsZUVycm9yICAgICAgOiAgc3RyZWFtLl9oYW5kbGVFcnJvci5iaW5kKHN0cmVhbSlcbiAgICAsIGhhbmRsZUZhdGFsRXJyb3IgOiAgc3RyZWFtLl9oYW5kbGVGYXRhbEVycm9yLmJpbmQoc3RyZWFtKVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVN0cmVhbUFQSTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgc2FmZSA9IHJlcXVpcmUoJ3NhZmUtcmVnZXgnKTtcblxuLyoqXG4gKiBUaGUgbWFpbiBleHBvcnQgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgYHBhdHRlcm5gIHN0cmluZyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cbiAqXG4gKiBgYGBqc1xuICYgdmFyIG5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xuICYgY29uc29sZS5sb2cobm90KCdmb28nKSk7XG4gJiAvLz0+IC9eKD86KD8hXig/OmZvbykkKS4pKiQvXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9IENvbnZlcnRzIHRoZSBnaXZlbiBgcGF0dGVybmAgdG8gYSByZWdleCB1c2luZyB0aGUgc3BlY2lmaWVkIGBvcHRpb25zYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdG9SZWdleChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKHRvUmVnZXguY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWdleC1jb21wYXRpYmxlIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBgcGF0dGVybmAgYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICYgdmFyIG5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xuICYgY29uc29sZS5sb2cobm90LmNyZWF0ZSgnZm9vJykpO1xuICYgLy89PiAnXig/Oig/IV4oPzpmb28pJCkuKSokJ1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnRvUmVnZXguY3JlYXRlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgaWYgKG9wdHMuY29udGFpbnMgPT09IHRydWUpIHtcbiAgICBvcHRzLnN0cmljdE5lZ2F0ZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIG9wZW4gPSBvcHRzLnN0cmljdE9wZW4gIT09IGZhbHNlID8gJ14nIDogJyc7XG4gIHZhciBjbG9zZSA9IG9wdHMuc3RyaWN0Q2xvc2UgIT09IGZhbHNlID8gJyQnIDogJyc7XG4gIHZhciBlbmRDaGFyID0gb3B0cy5lbmRDaGFyID8gb3B0cy5lbmRDaGFyIDogJysnO1xuICB2YXIgc3RyID0gcGF0dGVybjtcblxuICBpZiAob3B0cy5zdHJpY3ROZWdhdGUgPT09IGZhbHNlKSB7XG4gICAgc3RyID0gJyg/Oig/ISg/OicgKyBwYXR0ZXJuICsgJykpLiknICsgZW5kQ2hhcjtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSAnKD86KD8hXig/OicgKyBwYXR0ZXJuICsgJykkKS4pJyArIGVuZENoYXI7XG4gIH1cblxuICB2YXIgcmVzID0gb3BlbiArIHN0ciArIGNsb3NlO1xuICBpZiAob3B0cy5zYWZlID09PSB0cnVlICYmIHNhZmUocmVzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvdGVudGlhbGx5IHVuc2FmZSByZWd1bGFyIGV4cHJlc3Npb246ICcgKyByZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogRXhwb3NlIGB0b1JlZ2V4YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdG9SZWdleDtcbiIsInZhciBpc1dpbiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHR2YXIgaSA9IHN0ci5sZW5ndGggLSAxO1xuXHRpZiAoaSA8IDIpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cdHdoaWxlIChpc1NlcGFyYXRvcihzdHIsIGkpKSB7XG5cdFx0aS0tO1xuXHR9XG5cdHJldHVybiBzdHIuc3Vic3RyKDAsIGkgKyAxKTtcbn07XG5cbmZ1bmN0aW9uIGlzU2VwYXJhdG9yKHN0ciwgaSkge1xuXHR2YXIgY2hhciA9IHN0cltpXTtcblx0cmV0dXJuIGkgPiAwICYmIChjaGFyID09PSAnLycgfHwgKGlzV2luICYmIGNoYXIgPT09ICdcXFxcJykpO1xufVxuIiwiLyohXG4gKiByZXBlYXQtZWxlbWVudCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcmVwZWF0LWVsZW1lbnQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoZWxlLCBudW0pIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShudW0pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBhcnJbaV0gPSBlbGU7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcbiIsIi8qIVxuICogcmVwZWF0LXN0cmluZyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcmVwZWF0LXN0cmluZz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlc3VsdHMgY2FjaGVcbiAqL1xuXG52YXIgcmVzID0gJyc7XG52YXIgY2FjaGU7XG5cbi8qKlxuICogRXhwb3NlIGByZXBlYXRgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXBlYXQ7XG5cbi8qKlxuICogUmVwZWF0IHRoZSBnaXZlbiBgc3RyaW5nYCB0aGUgc3BlY2lmaWVkIGBudW1iZXJgXG4gKiBvZiB0aW1lcy5cbiAqXG4gKiAqKkV4YW1wbGU6KipcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1zdHJpbmcnKTtcbiAqIHJlcGVhdCgnQScsIDUpO1xuICogLy89PiBBQUFBQVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFRoZSBzdHJpbmcgdG8gcmVwZWF0XG4gKiBAcGFyYW0ge051bWJlcn0gYG51bWJlcmAgVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBSZXBlYXRlZCBzdHJpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgbnVtKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICAvLyBjb3ZlciBjb21tb24sIHF1aWNrIHVzZSBjYXNlc1xuICBpZiAobnVtID09PSAxKSByZXR1cm4gc3RyO1xuICBpZiAobnVtID09PSAyKSByZXR1cm4gc3RyICsgc3RyO1xuXG4gIHZhciBtYXggPSBzdHIubGVuZ3RoICogbnVtO1xuICBpZiAoY2FjaGUgIT09IHN0ciB8fCB0eXBlb2YgY2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2FjaGUgPSBzdHI7XG4gICAgcmVzID0gJyc7XG4gIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA+PSBtYXgpIHtcbiAgICByZXR1cm4gcmVzLnN1YnN0cigwLCBtYXgpO1xuICB9XG5cbiAgd2hpbGUgKG1heCA+IHJlcy5sZW5ndGggJiYgbnVtID4gMSkge1xuICAgIGlmIChudW0gJiAxKSB7XG4gICAgICByZXMgKz0gc3RyO1xuICAgIH1cblxuICAgIG51bSA+Pj0gMTtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG5cbiAgcmVzICs9IHN0cjtcbiAgcmVzID0gcmVzLnN1YnN0cigwLCBtYXgpO1xuICByZXR1cm4gcmVzO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXHJcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcclxuXHJcbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmYWN0b3J5KVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QucmVzb2x2ZVVybCA9IGZhY3RvcnkoKVxyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZVVybCgvKiAuLi51cmxzICovKSB7XHJcbiAgICB2YXIgbnVtVXJscyA9IGFyZ3VtZW50cy5sZW5ndGhcclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVXJsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDsgZ290IG5vbmUuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKVxyXG4gICAgYmFzZS5ocmVmID0gYXJndW1lbnRzWzBdXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGJhc2UuaHJlZlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdXHJcbiAgICBoZWFkLmluc2VydEJlZm9yZShiYXNlLCBoZWFkLmZpcnN0Q2hpbGQpXHJcblxyXG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKVxyXG4gICAgdmFyIHJlc29sdmVkXHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IG51bVVybHM7IGluZGV4KyspIHtcclxuICAgICAgYS5ocmVmID0gYXJndW1lbnRzW2luZGV4XVxyXG4gICAgICByZXNvbHZlZCA9IGEuaHJlZlxyXG4gICAgICBiYXNlLmhyZWYgPSByZXNvbHZlZFxyXG4gICAgfVxyXG5cclxuICAgIGhlYWQucmVtb3ZlQ2hpbGQoYmFzZSlcclxuXHJcbiAgICByZXR1cm4gcmVzb2x2ZWRcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNvbHZlVXJsXHJcblxyXG59KSk7XHJcbiIsInZhciB1dGlsICAgICAgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlcyAgICAgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG52YXIgc2V0cyAgICAgID0gcmVxdWlyZSgnLi9zZXRzJyk7XG52YXIgcG9zaXRpb25zID0gcmVxdWlyZSgnLi9wb3NpdGlvbnMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlZ2V4cFN0cikge1xuICB2YXIgaSA9IDAsIGwsIGMsXG4gICAgICBzdGFydCA9IHsgdHlwZTogdHlwZXMuUk9PVCwgc3RhY2s6IFtdfSxcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBsYXN0IGNsYXVzZS9ncm91cCBhbmQgc3RhY2suXG4gICAgICBsYXN0R3JvdXAgPSBzdGFydCxcbiAgICAgIGxhc3QgPSBzdGFydC5zdGFjayxcbiAgICAgIGdyb3VwU3RhY2sgPSBbXTtcblxuXG4gIHZhciByZXBlYXRFcnIgPSBmdW5jdGlvbihpKSB7XG4gICAgdXRpbC5lcnJvcihyZWdleHBTdHIsICdOb3RoaW5nIHRvIHJlcGVhdCBhdCBjb2x1bW4gJyArIChpIC0gMSkpO1xuICB9O1xuXG4gIC8vIERlY29kZSBhIGZldyBlc2NhcGVkIGNoYXJhY3RlcnMuXG4gIHZhciBzdHIgPSB1dGlsLnN0clRvQ2hhcnMocmVnZXhwU3RyKTtcbiAgbCA9IHN0ci5sZW5ndGg7XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIGluIHN0cmluZy5cbiAgd2hpbGUgKGkgPCBsKSB7XG4gICAgYyA9IHN0cltpKytdO1xuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgICAvLyBIYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJzLCBpbmNsdWVzIGEgZmV3IHNldHMuXG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgYyA9IHN0cltpKytdO1xuXG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHBvc2l0aW9ucy53b3JkQm91bmRhcnkoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHBvc2l0aW9ucy5ub25Xb3JkQm91bmRhcnkoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMud29yZHMoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMubm90V29yZHMoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMuaW50cygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5ub3RJbnRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLndoaXRlc3BhY2UoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMubm90V2hpdGVzcGFjZSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGMgaXMgaW50ZWdlci5cbiAgICAgICAgICAgIC8vIEluIHdoaWNoIGNhc2UgaXQncyBhIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIGlmICgvXFxkLy50ZXN0KGMpKSB7XG4gICAgICAgICAgICAgIGxhc3QucHVzaCh7IHR5cGU6IHR5cGVzLlJFRkVSRU5DRSwgdmFsdWU6IHBhcnNlSW50KGMsIDEwKSB9KTtcblxuICAgICAgICAgICAgLy8gRXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsYXN0LnB1c2goeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogYy5jaGFyQ29kZUF0KDApIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gUG9zaXRpb25hbHMuXG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLmJlZ2luKCkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJCc6XG4gICAgICAgICAgbGFzdC5wdXNoKHBvc2l0aW9ucy5lbmQoKSk7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIEhhbmRsZSBjdXN0b20gc2V0cy5cbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNsYXNzIGlzICdhbnRpJyBpLmUuIFteYWJjXS5cbiAgICAgICAgdmFyIG5vdDtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ14nKSB7XG4gICAgICAgICAgbm90ID0gdHJ1ZTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIGNsYXNzLlxuICAgICAgICB2YXIgY2xhc3NUb2tlbnMgPSB1dGlsLnRva2VuaXplQ2xhc3Moc3RyLnNsaWNlKGkpLCByZWdleHBTdHIpO1xuXG4gICAgICAgIC8vIEluY3JlYXNlIGluZGV4IGJ5IGxlbmd0aCBvZiBjbGFzcy5cbiAgICAgICAgaSArPSBjbGFzc1Rva2Vuc1sxXTtcbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5TRVQsXG4gICAgICAgICAgc2V0OiBjbGFzc1Rva2Vuc1swXSxcbiAgICAgICAgICBub3Q6IG5vdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gQ2xhc3Mgb2YgYW55IGNoYXJhY3RlciBleGNlcHQgXFxuLlxuICAgICAgY2FzZSAnLic6XG4gICAgICAgIGxhc3QucHVzaChzZXRzLmFueUNoYXIoKSk7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFB1c2ggZ3JvdXAgb250byBzdGFjay5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICAvLyBDcmVhdGUgZ3JvdXAuXG4gICAgICAgIHZhciBncm91cCA9IHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5HUk9VUCxcbiAgICAgICAgICBzdGFjazogW10sXG4gICAgICAgICAgcmVtZW1iZXI6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgYyA9IHN0cltpXTtcblxuICAgICAgICAvLyBJZiBpZiB0aGlzIGlzIGEgc3BlY2lhbCBraW5kIG9mIGdyb3VwLlxuICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgYyA9IHN0cltpICsgMV07XG4gICAgICAgICAgaSArPSAyO1xuXG4gICAgICAgICAgLy8gTWF0Y2ggaWYgZm9sbG93ZWQgYnkuXG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgZ3JvdXAuZm9sbG93ZWRCeSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBNYXRjaCBpZiBub3QgZm9sbG93ZWQgYnkuXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnIScpIHtcbiAgICAgICAgICAgIGdyb3VwLm5vdEZvbGxvd2VkQnkgPSB0cnVlO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChjICE9PSAnOicpIHtcbiAgICAgICAgICAgIHV0aWwuZXJyb3IocmVnZXhwU3RyLFxuICAgICAgICAgICAgICAnSW52YWxpZCBncm91cCwgY2hhcmFjdGVyIFxcJycgKyBjICtcbiAgICAgICAgICAgICAgJ1xcJyBhZnRlciBcXCc/XFwnIGF0IGNvbHVtbiAnICsgKGkgLSAxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JvdXAucmVtZW1iZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCBzdWJncm91cCBpbnRvIGN1cnJlbnQgZ3JvdXAgc3RhY2suXG4gICAgICAgIGxhc3QucHVzaChncm91cCk7XG5cbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgZ3JvdXAgZm9yIHdoZW4gdGhlIGdyb3VwIGNsb3Nlcy5cbiAgICAgICAgZ3JvdXBTdGFjay5wdXNoKGxhc3RHcm91cCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGlzIG5ldyBncm91cCB0aGUgY3VycmVudCBncm91cC5cbiAgICAgICAgbGFzdEdyb3VwID0gZ3JvdXA7XG4gICAgICAgIGxhc3QgPSBncm91cC5zdGFjaztcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gUG9wIGdyb3VwIG91dCBvZiBzdGFjay5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoZ3JvdXBTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB1dGlsLmVycm9yKHJlZ2V4cFN0ciwgJ1VubWF0Y2hlZCApIGF0IGNvbHVtbiAnICsgKGkgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEdyb3VwID0gZ3JvdXBTdGFjay5wb3AoKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGdyb3VwIGhhcyBhIFBJUEUuXG4gICAgICAgIC8vIFRvIGdldCBiYWNrIHRoZSBjb3JyZWN0IGxhc3Qgc3RhY2suXG4gICAgICAgIGxhc3QgPSBsYXN0R3JvdXAub3B0aW9ucyA/XG4gICAgICAgICAgbGFzdEdyb3VwLm9wdGlvbnNbbGFzdEdyb3VwLm9wdGlvbnMubGVuZ3RoIC0gMV0gOiBsYXN0R3JvdXAuc3RhY2s7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFVzZSBwaXBlIGNoYXJhY3RlciB0byBnaXZlIG1vcmUgY2hvaWNlcy5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAvLyBDcmVhdGUgYXJyYXkgd2hlcmUgb3B0aW9ucyBhcmUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgUElQRVxuICAgICAgICAvLyBpbiB0aGlzIGNsYXVzZS5cbiAgICAgICAgaWYgKCFsYXN0R3JvdXAub3B0aW9ucykge1xuICAgICAgICAgIGxhc3RHcm91cC5vcHRpb25zID0gW2xhc3RHcm91cC5zdGFja107XG4gICAgICAgICAgZGVsZXRlIGxhc3RHcm91cC5zdGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGFjayBhbmQgYWRkIHRvIG9wdGlvbnMgZm9yIHJlc3Qgb2YgY2xhdXNlLlxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgbGFzdEdyb3VwLm9wdGlvbnMucHVzaChzdGFjayk7XG4gICAgICAgIGxhc3QgPSBzdGFjaztcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gUmVwZXRpdGlvbi5cbiAgICAgIC8vIEZvciBldmVyeSByZXBldGl0aW9uLCByZW1vdmUgbGFzdCBlbGVtZW50IGZyb20gbGFzdCBzdGFja1xuICAgICAgLy8gdGhlbiBpbnNlcnQgYmFjayBhIFJBTkdFIG9iamVjdC5cbiAgICAgIC8vIFRoaXMgZGVzaWduIGlzIGNob3NlbiBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG1vcmUgdGhhblxuICAgICAgLy8gb25lIHJlcGV0aXRpb24gc3ltYm9scyBpbiBhIHJlZ2V4IGkuZS4gYGE/K3syLDN9YC5cbiAgICAgIGNhc2UgJ3snOlxuICAgICAgICB2YXIgcnMgPSAvXihcXGQrKSgsKFxcZCspPyk/XFx9Ly5leGVjKHN0ci5zbGljZShpKSksIG1pbiwgbWF4O1xuICAgICAgICBpZiAocnMgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcGVhdEVycihpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWluID0gcGFyc2VJbnQocnNbMV0sIDEwKTtcbiAgICAgICAgICBtYXggPSByc1syXSA/IHJzWzNdID8gcGFyc2VJbnQocnNbM10sIDEwKSA6IEluZmluaXR5IDogbWluO1xuICAgICAgICAgIGkgKz0gcnNbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLlJFUEVUSVRJT04sXG4gICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgICAgdmFsdWU6IGxhc3QucG9wKCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLkNIQVIsXG4gICAgICAgICAgICB2YWx1ZTogMTIzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc/JzpcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyonOlxuICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gRGVmYXVsdCBpcyBhIGNoYXJhY3RlciB0aGF0IGlzIG5vdCBgXFxbXSgpe30/KypeJGAuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLkNIQVIsXG4gICAgICAgICAgdmFsdWU6IGMuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgZ3JvdXBzIGhhdmUgbm90IGJlZW4gY2xvc2VkLlxuICBpZiAoZ3JvdXBTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICB1dGlsLmVycm9yKHJlZ2V4cFN0ciwgJ1VudGVybWluYXRlZCBncm91cCcpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0O1xufTtcblxubW9kdWxlLmV4cG9ydHMudHlwZXMgPSB0eXBlcztcbiIsInZhciB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuZXhwb3J0cy53b3JkQm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuUE9TSVRJT04sIHZhbHVlOiAnYicgfTtcbn07XG5cbmV4cG9ydHMubm9uV29yZEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJ0InIH07XG59O1xuXG5leHBvcnRzLmJlZ2luID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJ14nIH07XG59O1xuXG5leHBvcnRzLmVuZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICckJyB9O1xufTtcbiIsInZhciB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxudmFyIElOVFMgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gW3sgdHlwZTogdHlwZXMuUkFOR0UgLCBmcm9tOiA0OCwgdG86IDU3IH1dO1xufTtcblxudmFyIFdPUkRTID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIFtcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA5NSB9LFxuICAgIHsgdHlwZTogdHlwZXMuUkFOR0UsIGZyb206IDk3LCB0bzogMTIyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5SQU5HRSwgZnJvbTogNjUsIHRvOiA5MCB9XG4gIF0uY29uY2F0KElOVFMoKSk7XG59O1xuXG52YXIgV0hJVEVTUEFDRSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiBbXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogOSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEwIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTEgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEzIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMzIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxNjAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA1NzYwIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogNjE1OCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTkzIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5NCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTUgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTk2IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5NyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTggfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTk5IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIwMCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMDEgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjAyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzMgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjM5IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODI4NyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEyMjg4IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogNjUyNzkgfVxuICBdO1xufTtcblxudmFyIE5PVEFOWUNIQVIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEzIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzMgfSxcbiAgXTtcbn07XG5cbi8vIFByZWRlZmluZWQgY2xhc3Mgb2JqZWN0cy5cbmV4cG9ydHMud29yZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdPUkRTKCksIG5vdDogZmFsc2UgfTtcbn07XG5cbmV4cG9ydHMubm90V29yZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdPUkRTKCksIG5vdDogdHJ1ZSB9O1xufTtcblxuZXhwb3J0cy5pbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBJTlRTKCksIG5vdDogZmFsc2UgfTtcbn07XG5cbmV4cG9ydHMubm90SW50cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogSU5UUygpLCBub3Q6IHRydWUgfTtcbn07XG5cbmV4cG9ydHMud2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV0hJVEVTUEFDRSgpLCBub3Q6IGZhbHNlIH07XG59O1xuXG5leHBvcnRzLm5vdFdoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdISVRFU1BBQ0UoKSwgbm90OiB0cnVlIH07XG59O1xuXG5leHBvcnRzLmFueUNoYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IE5PVEFOWUNIQVIoKSwgbm90OiB0cnVlIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJPT1QgICAgICAgOiAwLFxuICBHUk9VUCAgICAgIDogMSxcbiAgUE9TSVRJT04gICA6IDIsXG4gIFNFVCAgICAgICAgOiAzLFxuICBSQU5HRSAgICAgIDogNCxcbiAgUkVQRVRJVElPTiA6IDUsXG4gIFJFRkVSRU5DRSAgOiA2LFxuICBDSEFSICAgICAgIDogNyxcbn07XG4iLCJ2YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG52YXIgc2V0cyAgPSByZXF1aXJlKCcuL3NldHMnKTtcblxuXG4vLyBBbGwgb2YgdGhlc2UgYXJlIHByaXZhdGUgYW5kIG9ubHkgdXNlZCBieSByYW5kZXhwLlxuLy8gSXQncyBhc3N1bWVkIHRoYXQgdGhleSB3aWxsIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCB0aGUgY29ycmVjdCBpbnB1dC5cblxudmFyIENUUkwgPSAnQEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXiA/JztcbnZhciBTTFNIID0geyAnMCc6IDAsICd0JzogOSwgJ24nOiAxMCwgJ3YnOiAxMSwgJ2YnOiAxMiwgJ3InOiAxMyB9O1xuXG4vKipcbiAqIEZpbmRzIGNoYXJhY3RlciByZXByZXNlbnRhdGlvbnMgaW4gc3RyIGFuZCBjb252ZXJ0IGFsbCB0b1xuICogdGhlaXIgcmVzcGVjdGl2ZSBjaGFyYWN0ZXJzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnN0clRvQ2hhcnMgPSBmdW5jdGlvbihzdHIpIHtcbiAgLyoganNoaW50IG1heGxlbjogZmFsc2UgKi9cbiAgdmFyIGNoYXJzX3JlZ2V4ID0gLyhcXFtcXFxcYlxcXSl8KFxcXFwpP1xcXFwoPzp1KFtBLUYwLTldezR9KXx4KFtBLUYwLTldezJ9KXwoMD9bMC03XXsyfSl8YyhbQEEtWlxcW1xcXFxcXF1cXF4/XSl8KFswdG52ZnJdKSkvZztcbiAgc3RyID0gc3RyLnJlcGxhY2UoY2hhcnNfcmVnZXgsIGZ1bmN0aW9uKHMsIGIsIGxicywgYTE2LCBiMTYsIGM4LCBkY3RybCwgZXNsc2gpIHtcbiAgICBpZiAobGJzKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGIgICAgID8gOCA6XG4gICAgICAgICAgICAgICBhMTYgICA/IHBhcnNlSW50KGExNiwgMTYpIDpcbiAgICAgICAgICAgICAgIGIxNiAgID8gcGFyc2VJbnQoYjE2LCAxNikgOlxuICAgICAgICAgICAgICAgYzggICAgPyBwYXJzZUludChjOCwgICA4KSA6XG4gICAgICAgICAgICAgICBkY3RybCA/IENUUkwuaW5kZXhPZihkY3RybCkgOlxuICAgICAgICAgICAgICAgU0xTSFtlc2xzaF07XG5cbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyYWN0ZXJzLlxuICAgIGlmICgvW1xcW1xcXXt9XFxeJC58PyorKCldLy50ZXN0KGMpKSB7XG4gICAgICBjID0gJ1xcXFwnICsgYztcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSk7XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiB0dXJucyBjbGFzcyBpbnRvIHRva2Vuc1xuICogcmVhZHMgc3RyIHVudGlsIGl0IGVuY291bnRlcnMgYSBdIG5vdCBwcmVjZWVkZWQgYnkgYSBcXFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWdleHBTdHJcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48T2JqZWN0PiwgTnVtYmVyPn1cbiAqL1xuZXhwb3J0cy50b2tlbml6ZUNsYXNzID0gZnVuY3Rpb24oc3RyLCByZWdleHBTdHIpIHtcbiAgLyoganNoaW50IG1heGxlbjogZmFsc2UgKi9cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmVnZXhwID0gL1xcXFwoPzoodyl8KGQpfChzKXwoVyl8KEQpfChTKSl8KCg/Oig/OlxcXFwpKC4pfChbXlxcXVxcXFxdKSktKD86XFxcXCk/KFteXFxdXSkpfChcXF0pfCg/OlxcXFwpPyguKS9nO1xuICB2YXIgcnMsIGM7XG5cblxuICB3aGlsZSAoKHJzID0gcmVnZXhwLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIGlmIChyc1sxXSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy53b3JkcygpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbMl0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMuaW50cygpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbM10pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMud2hpdGVzcGFjZSgpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbNF0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMubm90V29yZHMoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzVdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLm5vdEludHMoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzZdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLm5vdFdoaXRlc3BhY2UoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzddKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGVzLlJBTkdFLFxuICAgICAgICBmcm9tOiAocnNbOF0gfHwgcnNbOV0pLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgdG86IHJzWzEwXS5jaGFyQ29kZUF0KDApLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKGMgPSByc1sxMl0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZXMuQ0hBUixcbiAgICAgICAgdmFsdWU6IGMuY2hhckNvZGVBdCgwKSxcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdG9rZW5zLCByZWdleHAubGFzdEluZGV4XTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmVycm9yKHJlZ2V4cFN0ciwgJ1VudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3MnKTtcbn07XG5cblxuLyoqXG4gKiBTaG9ydGN1dCB0byB0aHJvdyBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlZ2V4cFxuICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICovXG5leHBvcnRzLmVycm9yID0gZnVuY3Rpb24ocmVnZXhwLCBtc2cpIHtcbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogLycgKyByZWdleHAgKyAnLzogJyArIG1zZyk7XG59O1xuIiwidmFyIHBhcnNlID0gcmVxdWlyZSgncmV0Jyk7XG52YXIgdHlwZXMgPSBwYXJzZS50eXBlcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmUsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICB2YXIgcmVwbGltaXQgPSBvcHRzLmxpbWl0ID09PSB1bmRlZmluZWQgPyAyNSA6IG9wdHMubGltaXQ7XG4gICAgXG4gICAgaWYgKGlzUmVnRXhwKHJlKSkgcmUgPSByZS5zb3VyY2U7XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlICE9PSAnc3RyaW5nJykgcmUgPSBTdHJpbmcocmUpO1xuICAgIFxuICAgIHRyeSB7IHJlID0gcGFyc2UocmUpIH1cbiAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBmYWxzZSB9XG4gICAgXG4gICAgdmFyIHJlcHMgPSAwO1xuICAgIHJldHVybiAoZnVuY3Rpb24gd2FsayAobm9kZSwgc3RhckhlaWdodCkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSB0eXBlcy5SRVBFVElUSU9OKSB7XG4gICAgICAgICAgICBzdGFySGVpZ2h0ICsrO1xuICAgICAgICAgICAgcmVwcyArKztcbiAgICAgICAgICAgIGlmIChzdGFySGVpZ2h0ID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHJlcHMgPiByZXBsaW1pdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobm9kZS5vcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZS5vcHRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9rID0gd2Fsayh7IHN0YWNrOiBub2RlLm9wdGlvbnNbaV0gfSwgc3RhckhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvaykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGUuc3RhY2sgfHwgKG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZS5zdGFjayk7XG4gICAgICAgIGlmICghc3RhY2spIHJldHVybiB0cnVlO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9rID0gd2FsayhzdGFja1tpXSwgc3RhckhlaWdodCk7XG4gICAgICAgICAgICBpZiAoIW9rKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKHJlLCAwKTtcbn07XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh4KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuIiwiLyohXG4gKiBzZXQtdmFsdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3NldC12YWx1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3BsaXQgPSByZXF1aXJlKCdzcGxpdC1zdHJpbmcnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzLWV4dGVuZGFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHByb3AsIHZhbCkge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICBwcm9wID0gW10uY29uY2F0LmFwcGx5KFtdLCBwcm9wKS5qb2luKCcuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBrZXlzID0gc3BsaXQocHJvcCwge3NlcDogJy4nLCBicmFja2V0czogdHJ1ZX0pLmZpbHRlcihpc1ZhbGlkS2V5KTtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBjdXJyZW50ID0gb2JqO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBrZXkgPSBrZXlzW2lkeF07XG4gICAgaWYgKGlkeCAhPT0gbGVuIC0gMSkge1xuICAgICAgaWYgKCFpc09iamVjdChjdXJyZW50W2tleV0pKSB7XG4gICAgICAgIGN1cnJlbnRba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnRba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc1BsYWluT2JqZWN0KGN1cnJlbnRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICBjdXJyZW50W2tleV0gPSBleHRlbmQoe30sIGN1cnJlbnRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJyAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYga2V5ICE9PSAncHJvdG90eXBlJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tdXRpbCcpO1xudmFyIG93bk5hbWVzO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBBU1QgYE5vZGVgIHdpdGggdGhlIGdpdmVuIGB2YWxgIGFuZCBgdHlwZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoJyonLCAnU3RhcicpO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ3N0YXInLCB2YWw6ICcqJ30pO1xuICogYGBgXG4gKiBAbmFtZSBOb2RlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGB2YWxgIFBhc3MgYSBtYXRjaGVkIHN1YnN0cmluZywgb3IgYW4gb2JqZWN0IHRvIG1lcmdlIG9udG8gdGhlIG5vZGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgIFRoZSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gYHZhbGAgaXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5vZGUgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTm9kZSh2YWwsIHR5cGUsIHBhcmVudCkge1xuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcGFyZW50ID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuXG4gIGRlZmluZSh0aGlzLCAncGFyZW50JywgcGFyZW50KTtcbiAgZGVmaW5lKHRoaXMsICdpc05vZGUnLCB0cnVlKTtcbiAgZGVmaW5lKHRoaXMsICdleHBlY3QnLCBudWxsKTtcblxuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnICYmIGlzT2JqZWN0KHZhbCkpIHtcbiAgICBsYXp5S2V5cygpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKG93bk5hbWVzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpc1trZXldID0gdmFsW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbm9kZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiBjb25zb2xlLmxvZyhOb2RlLmlzTm9kZShub2RlKSk7IC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2coTm9kZS5pc05vZGUoe30pKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5pc05vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiB1dGlscy5pc05vZGUobm9kZSk7XG59O1xuXG4vKipcbiAqIERlZmluZSBhIG5vbi1lbnVtYmVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgbm9kZSBpbnN0YW5jZS5cbiAqIFVzZWZ1bCBmb3IgYWRkaW5nIHByb3BlcnRpZXMgdGhhdCBzaG91bGRuJ3QgYmUgZXh0ZW5kZWRcbiAqIG9yIHZpc2libGUgZHVyaW5nIGRlYnVnZ2luZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSgpO1xuICogbm9kZS5kZWZpbmUoJ2ZvbycsICdzb21ldGhpbmcgbm9uLWVudW1lcmFibGUnKTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYFxuICogQHBhcmFtIHthbnl9IGB2YWxgXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIG5vZGUgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIGRlZmluZSh0aGlzLCBuYW1lLCB2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlLnZhbGAgaXMgYW4gZW1wdHkgc3RyaW5nLCBvciBgbm9kZS5ub2Rlc2AgZG9lc1xuICogbm90IGNvbnRhaW4gYW55IG5vbi1lbXB0eSB0ZXh0IG5vZGVzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAndGV4dCd9KTtcbiAqIG5vZGUuaXNFbXB0eSgpOyAvLz0+IHRydWVcbiAqIG5vZGUudmFsID0gJ2Zvbyc7XG4gKiBub2RlLmlzRW1wdHkoKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gIChvcHRpb25hbCkgRmlsdGVyIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGBub2RlYCBhbmQvb3IgY2hpbGQgbm9kZXMuIGBpc0VtcHR5YCB3aWxsIHJldHVybiBmYWxzZSBpbW1lZGlhdGVseSB3aGVuIHRoZSBmaWx0ZXIgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSBvbiBhbnkgbm9kZXMuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHV0aWxzLmlzRW1wdHkodGhpcywgZm4pO1xufTtcblxuLyoqXG4gKiBHaXZlbiBub2RlIGBmb29gIGFuZCBub2RlIGBiYXJgLCBwdXNoIG5vZGUgYGJhcmAgb250byBgZm9vLm5vZGVzYCwgYW5kXG4gKiBzZXQgYGZvb2AgYXMgYGJhci5wYXJlbnRgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGxlbmd0aCBvZiBgbm9kZS5ub2Rlc2BcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KE5vZGUuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGRlZmluZShub2RlLCAncGFyZW50JywgdGhpcyk7XG5cbiAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMgfHwgW107XG4gIHJldHVybiB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIG5vZGUgYGZvb2AgYW5kIG5vZGUgYGJhcmAsIHVuc2hpZnQgbm9kZSBgYmFyYCBvbnRvIGBmb28ubm9kZXNgLCBhbmRcbiAqIHNldCBgZm9vYCBhcyBgYmFyLnBhcmVudGAuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIGZvby51bnNoaWZ0KGJhcik7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWBcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGBub2RlLm5vZGVzYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQoTm9kZS5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCB0aGlzKTtcblxuICB0aGlzLm5vZGVzID0gdGhpcy5ub2RlcyB8fCBbXTtcbiAgcmV0dXJuIHRoaXMubm9kZXMudW5zaGlmdChub2RlKTtcbn07XG5cbi8qKlxuICogUG9wIGEgbm9kZSBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2EnfSkpO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnYid9KSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdjJ30pKTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2QnfSkpO1xuICogY29uc29sZS5sb2cobm9kZS5ub2Rlcy5sZW5ndGgpO1xuICogLy89PiA0XG4gKiBub2RlLnBvcCgpO1xuICogY29uc29sZS5sb2cobm9kZS5ub2Rlcy5sZW5ndGgpO1xuICogLy89PiAzXG4gKiBgYGBcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgcG9wcGVkIGBub2RlYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5wb3AoKTtcbn07XG5cbi8qKlxuICogU2hpZnQgYSBub2RlIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnYSd9KSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdiJ30pKTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2MnfSkpO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnZCd9KSk7XG4gKiBjb25zb2xlLmxvZyhub2RlLm5vZGVzLmxlbmd0aCk7XG4gKiAvLz0+IDRcbiAqIG5vZGUuc2hpZnQoKTtcbiAqIGNvbnNvbGUubG9nKG5vZGUubm9kZXMubGVuZ3RoKTtcbiAqIC8vPT4gM1xuICogYGBgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHNoaWZ0ZWQgYG5vZGVgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGBub2RlYCBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogbm9kZS5yZW1vdmUoY2hpbGROb2RlKTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSByZW1vdmVkIG5vZGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KE5vZGUuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIHRoaXMubm9kZXMgPSB0aGlzLm5vZGVzIHx8IFtdO1xuICB2YXIgaWR4ID0gbm9kZS5pbmRleDtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBub2RlLmluZGV4ID0gLTE7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgY2hpbGQgbm9kZSBmcm9tIGBub2RlLm5vZGVzYCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGB0eXBlYC5cbiAqIElmIGB0eXBlYCBpcyBhIG51bWJlciwgdGhlIGNoaWxkIG5vZGUgYXQgdGhhdCBpbmRleCBpcyByZXR1cm5lZC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGNoaWxkID0gbm9kZS5maW5kKDEpOyAvLzw9IGluZGV4IG9mIHRoZSBub2RlIHRvIGdldFxuICogdmFyIGNoaWxkID0gbm9kZS5maW5kKCdmb28nKTsgLy88PSBub2RlLnR5cGUgb2YgYSBjaGlsZCBub2RlXG4gKiB2YXIgY2hpbGQgPSBub2RlLmZpbmQoL14oZm9vfGJhcikkLyk7IC8vPD0gcmVnZXggdG8gbWF0Y2ggbm9kZS50eXBlXG4gKiB2YXIgY2hpbGQgPSBub2RlLmZpbmQoWydmb28nLCAnYmFyJ10pOyAvLzw9IGFycmF5IG9mIG5vZGUudHlwZShzKVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBjaGlsZCBub2RlIG9yIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgcmV0dXJuIHV0aWxzLmZpbmROb2RlKHRoaXMubm9kZXMsIHR5cGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyB0aGUgZ2l2ZW4gYHR5cGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogY29zb2xlLmxvZyhub2RlLmlzVHlwZSgnZm9vJykpOyAgICAgICAgICAvLyBmYWxzZVxuICogY29zb2xlLmxvZyhub2RlLmlzVHlwZSgvXihmb298YmFyKSQvKSk7ICAvLyB0cnVlXG4gKiBjb3NvbGUubG9nKG5vZGUuaXNUeXBlKFsnZm9vJywgJ2JhciddKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gdXRpbHMuaXNUeXBlKHRoaXMsIHR5cGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYG5vZGUubm9kZXNgIGhhcyB0aGUgZ2l2ZW4gYHR5cGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICpcbiAqIGNvc29sZS5sb2coZm9vLmhhc1R5cGUoJ3F1eCcpKTsgICAgICAgICAgLy8gZmFsc2VcbiAqIGNvc29sZS5sb2coZm9vLmhhc1R5cGUoL14ocXV4fGJhcikkLykpOyAgLy8gdHJ1ZVxuICogY29zb2xlLmxvZyhmb28uaGFzVHlwZShbJ3F1eCcsICdiYXInXSkpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLmhhc1R5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB1dGlscy5oYXNUeXBlKHRoaXMsIHR5cGUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpYmxpbmdzIGFycmF5LCBvciBgbnVsbGAgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKlxuICogY29uc29sZS5sb2coYmFyLnNpYmxpbmdzLmxlbmd0aCkgLy8gMlxuICogY29uc29sZS5sb2coYmF6LnNpYmxpbmdzLmxlbmd0aCkgLy8gMlxuICogYGBgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnc2libGluZ3MnLCB7XG4gIHNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub2RlLnNpYmxpbmdzIGlzIGEgZ2V0dGVyIGFuZCBjYW5ub3QgYmUgZGVmaW5lZCcpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Lm5vZGVzIDogbnVsbDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBub2RlJ3MgY3VycmVudCBpbmRleCBmcm9tIGBub2RlLnBhcmVudC5ub2Rlc2AuXG4gKiBUaGlzIHNob3VsZCBhbHdheXMgYmUgY29ycmVjdCwgZXZlbiB3aGVuIHRoZSBwYXJlbnQgYWRkcyBub2Rlcy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogdmFyIHF1eCA9IG5ldyBOb2RlKHt0eXBlOiAncXV4J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKiBmb28udW5zaGlmdChxdXgpO1xuICpcbiAqIGNvbnNvbGUubG9nKGJhci5pbmRleCkgLy8gMVxuICogY29uc29sZS5sb2coYmF6LmluZGV4KSAvLyAyXG4gKiBjb25zb2xlLmxvZyhxdXguaW5kZXgpIC8vIDBcbiAqIGBgYFxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICdpbmRleCcsIHtcbiAgc2V0OiBmdW5jdGlvbihpbmRleCkge1xuICAgIGRlZmluZSh0aGlzLCAnaWR4JywgaW5kZXgpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnNpYmxpbmdzKSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgdG9rID0gdGhpcy5pZHggIT09IC0xID8gdGhpcy5zaWJsaW5nc1t0aGlzLmlkeF0gOiBudWxsO1xuICAgIGlmICh0b2sgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuaWR4ID0gdGhpcy5zaWJsaW5ncy5pbmRleE9mKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZHg7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSBzaWJsaW5ncyBhcnJheSBvciBgbnVsbGAuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICpcbiAqIGNvbnNvbGUubG9nKGJhei5wcmV2LnR5cGUpIC8vICdiYXInXG4gKiBgYGBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAncHJldicsIHtcbiAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUucHJldiBpcyBhIGdldHRlciBhbmQgY2Fubm90IGJlIGRlZmluZWQnKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNpYmxpbmdzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3NbdGhpcy5pbmRleCAtIDFdIHx8IHRoaXMucGFyZW50LnByZXY7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpYmxpbmdzIGFycmF5LCBvciBgbnVsbGAgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKlxuICogY29uc29sZS5sb2coYmFyLnNpYmxpbmdzLmxlbmd0aCkgLy8gMlxuICogY29uc29sZS5sb2coYmF6LnNpYmxpbmdzLmxlbmd0aCkgLy8gMlxuICogYGBgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ25leHQnLCB7XG4gIHNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub2RlLm5leHQgaXMgYSBnZXR0ZXIgYW5kIGNhbm5vdCBiZSBkZWZpbmVkJyk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zaWJsaW5ncykpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpYmxpbmdzW3RoaXMuaW5kZXggKyAxXSB8fCB0aGlzLnBhcmVudC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBub2RlIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiB2YXIgcXV4ID0gbmV3IE5vZGUoe3R5cGU6ICdxdXgnfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqIGZvby5wdXNoKHF1eCk7XG4gKlxuICogY29uc29sZS5sb2coZm9vLmZpcnN0LnR5cGUpIC8vICdiYXInXG4gKiBgYGBcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZpcnN0IG5vZGUsIG9yIHVuZGVmaWVuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICdmaXJzdCcsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlcyA/IHRoaXMubm9kZXNbMF0gOiBudWxsO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3Qgbm9kZSBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogdmFyIHF1eCA9IG5ldyBOb2RlKHt0eXBlOiAncXV4J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKiBmb28ucHVzaChxdXgpO1xuICpcbiAqIGNvbnNvbGUubG9nKGZvby5sYXN0LnR5cGUpIC8vICdxdXgnXG4gKiBgYGBcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxhc3Qgbm9kZSwgb3IgdW5kZWZpZW5kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ2xhc3QnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMgPyB1dGlscy5sYXN0KHRoaXMubm9kZXMpIDogbnVsbDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIHZhciBxdXggPSBuZXcgTm9kZSh7dHlwZTogJ3F1eCd9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICogZm9vLnB1c2gocXV4KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhmb28ubGFzdC50eXBlKSAvLyAncXV4J1xuICogYGBgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsYXN0IG5vZGUsIG9yIHVuZGVmaWVuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICdzY29wZScsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1Njb3BlICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5zY29wZSA6IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgb3duIHByb3BlcnR5IG5hbWVzIGZyb20gTm9kZSBwcm90b3R5cGUsIGJ1dCBvbmx5IHRoZVxuICogZmlyc3QgdGltZSBgTm9kZWAgaXMgaW5zdGFudGlhdGVkXG4gKi9cblxuZnVuY3Rpb24gbGF6eUtleXMoKSB7XG4gIGlmICghb3duTmFtZXMpIHtcbiAgICBvd25OYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE5vZGUucHJvdG90eXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsaWZpZWQgYXNzZXJ0aW9uLiBUaHJvd3MgYW4gZXJyb3IgaXMgYHZhbGAgaXMgZmFsc2V5LlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYE5vZGVgXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBub2RlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzTm9kZShub2RlKSk7IC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2codXRpbHMuaXNOb2RlKHt9KSk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gdHlwZU9mKG5vZGUpID09PSAnb2JqZWN0JyAmJiBub2RlLmlzTm9kZSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRW1pdCBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gKlxuICogYGBganNcbiAqIC8vIGRvIG5vdGhpbmcgZm9yIGJlZ2lubmluZy1vZi1zdHJpbmdcbiAqIHNuYXBkcmFnb24uY29tcGlsZXIuc2V0KCdib3MnLCB1dGlscy5ub29wKTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5ub29wID0gZnVuY3Rpb24obm9kZSkge1xuICBhcHBlbmQodGhpcywgJycsIG5vZGUpO1xufTtcblxuLyoqXG4gKiBBcHBkZW5kIGBub2RlLnZhbGAgdG8gYGNvbXBpbGVyLm91dHB1dGAsIGV4YWN0bHkgYXMgaXQgd2FzIGNyZWF0ZWRcbiAqIGJ5IHRoZSBwYXJzZXIuXG4gKlxuICogYGBganNcbiAqIHNuYXBkcmFnb24uY29tcGlsZXIuc2V0KCd0ZXh0JywgdXRpbHMuaWRlbnRpdHkpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlkZW50aXR5ID0gZnVuY3Rpb24obm9kZSkge1xuICBhcHBlbmQodGhpcywgbm9kZS52YWwsIG5vZGUpO1xufTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IG5hbWVkIGAuZW1pdGAsIHRoaXMgbWV0aG9kIGFwcGVuZHMgdGhlIGdpdmVuIGB2YWxgXG4gKiB0byBgY29tcGlsZXIub3V0cHV0YCBmb3IgdGhlIGdpdmVuIG5vZGUuIFVzZWZ1bCB3aGVuIHlvdSBrbm93XG4gKiB3aGF0IHZhbHVlIHNob3VsZCBiZSBhcHBlbmRlZCBhZHZhbmNlLCByZWdhcmRsZXNzIG9mIHRoZSBhY3R1YWxcbiAqIHZhbHVlIG9mIGBub2RlLnZhbGAuXG4gKlxuICogYGBganNcbiAqIHNuYXBkcmFnb24uY29tcGlsZXJcbiAqICAgLnNldCgnaScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAqICAgICB0aGlzLm1hcFZpc2l0KG5vZGUpO1xuICogICB9KVxuICogICAuc2V0KCdpLm9wZW4nLCB1dGlscy5hcHBlbmQoJzxpPicpKVxuICogICAuc2V0KCdpLmNsb3NlJywgdXRpbHMuYXBwZW5kKCc8L2k+JykpXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY29tcGlsZXIgbWlkZGxld2FyZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuYXBwZW5kID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgYXBwZW5kKHRoaXMsIHZhbCwgbm9kZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFVzZWQgaW4gY29tcGlsZXIgbWlkZGxld2FyZSwgdGhpcyBvbnZlcnRzIGFuIEFTVCBub2RlIGludG9cbiAqIGFuIGVtcHR5IGB0ZXh0YCBub2RlIGFuZCBkZWxldGVzIGBub2RlLm5vZGVzYCBpZiBpdCBleGlzdHMuXG4gKiBUaGUgYWR2YW50YWdlIG9mIHRoaXMgbWV0aG9kIGlzIHRoYXQsIGFzIG9wcG9zZWQgdG8gY29tcGxldGVseVxuICogcmVtb3ZpbmcgdGhlIG5vZGUsIGluZGljZXMgd2lsbCBub3QgbmVlZCB0byBiZSByZS1jYWxjdWxhdGVkXG4gKiBpbiBzaWJsaW5nIG5vZGVzLCBhbmQgbm90aGluZyBpcyBhcHBlbmRlZCB0byB0aGUgb3V0cHV0LlxuICpcbiAqIGBgYGpzXG4gKiB1dGlscy50b05vb3Aobm9kZSk7XG4gKiAvLyBjb252ZXJ0IGBub2RlLm5vZGVzYCB0byB0aGUgZ2l2ZW4gdmFsdWUgaW5zdGVhZCBvZiBkZWxldGluZyBpdFxuICogdXRpbHMudG9Ob29wKG5vZGUsIFtdKTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge0FycmF5fSBgbm9kZXNgIE9wdGlvbmFsbHkgcGFzcyBhIG5ldyBgbm9kZXNgIHZhbHVlLCB0byByZXBsYWNlIHRoZSBleGlzdGluZyBgbm9kZS5ub2Rlc2AgYXJyYXkuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnRvTm9vcCA9IGZ1bmN0aW9uKG5vZGUsIG5vZGVzKSB7XG4gIGlmIChub2Rlcykge1xuICAgIG5vZGUubm9kZXMgPSBub2RlcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgbm9kZS5ub2RlcztcbiAgICBub2RlLnR5cGUgPSAndGV4dCc7XG4gICAgbm9kZS52YWwgPSAnJztcbiAgfVxufTtcblxuLyoqXG4gKiBWaXNpdCBgbm9kZWAgd2l0aCB0aGUgZ2l2ZW4gYGZuYC4gVGhlIGJ1aWx0LWluIGAudmlzaXRgIG1ldGhvZCBpbiBzbmFwZHJhZ29uXG4gKiBhdXRvbWF0aWNhbGx5IGNhbGxzIHJlZ2lzdGVyZWQgY29tcGlsZXJzLCB0aGlzIGFsbG93cyB5b3UgdG8gcGFzcyBhIHZpc2l0b3JcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBzbmFwZHJhZ29uLmNvbXBpbGVyLnNldCgnaScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAqICAgdXRpbHMudmlzaXQobm9kZSwgZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gKiAgICAgLy8gZG8gc3R1ZmYgd2l0aCBcImNoaWxkTm9kZVwiXG4gKiAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIG5vZGUgYWZ0ZXIgcmVjdXJzaXZlbHkgdmlzaXRpbmcgYWxsIGNoaWxkIG5vZGVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy52aXNpdCA9IGZ1bmN0aW9uKG5vZGUsIGZuKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oZm4pLCAnZXhwZWN0ZWQgYSB2aXNpdG9yIGZ1bmN0aW9uJyk7XG4gIGZuKG5vZGUpO1xuICByZXR1cm4gbm9kZS5ub2RlcyA/IHV0aWxzLm1hcFZpc2l0KG5vZGUsIGZuKSA6IG5vZGU7XG59O1xuXG4vKipcbiAqIE1hcCBbdmlzaXRdKCN2aXNpdCkgdGhlIGdpdmVuIGBmbmAgb3ZlciBgbm9kZS5ub2Rlc2AuIFRoaXMgaXMgY2FsbGVkIGJ5XG4gKiBbdmlzaXRdKCN2aXNpdCksIHVzZSB0aGlzIG1ldGhvZCBpZiB5b3UgZG8gbm90IHdhbnQgYGZuYCB0byBiZSBjYWxsZWQgb25cbiAqIHRoZSBmaXJzdCBub2RlLlxuICpcbiAqIGBgYGpzXG4gKiBzbmFwZHJhZ29uLmNvbXBpbGVyLnNldCgnaScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAqICAgdXRpbHMubWFwVmlzaXQobm9kZSwgZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gKiAgICAgLy8gZG8gc3R1ZmYgd2l0aCBcImNoaWxkTm9kZVwiXG4gKiAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIG5vZGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMubWFwVmlzaXQgPSBmdW5jdGlvbihub2RlLCBmbikge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc0FycmF5KG5vZGUubm9kZXMpLCAnZXhwZWN0ZWQgbm9kZS5ub2RlcyB0byBiZSBhbiBhcnJheScpO1xuICBhc3NlcnQoaXNGdW5jdGlvbihmbiksICdleHBlY3RlZCBhIHZpc2l0b3IgZnVuY3Rpb24nKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB1dGlscy52aXNpdChub2RlLm5vZGVzW2ldLCBmbik7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIFVuc2hpZnQgYW4gYCoub3BlbmAgbm9kZSBvbnRvIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHNuYXBkcmFnb24ucGFyc2VyLnNldCgnYnJhY2UnLCBmdW5jdGlvbihub2RlKSB7XG4gKiAgIHZhciBtYXRjaCA9IHRoaXMubWF0Y2goL157Lyk7XG4gKiAgIGlmIChtYXRjaCkge1xuICogICAgIHZhciBwYXJlbnQgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogICAgIHV0aWxzLmFkZE9wZW4ocGFyZW50LCBOb2RlKTtcbiAqICAgICBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXNbMF0pOlxuICogICAgIC8vIHsgdHlwZTogJ2JyYWNlLm9wZW4nLCB2YWw6ICcnIH07XG4gKlxuICogICAgIC8vIHB1c2ggdGhlIHBhcmVudCBcImJyYWNlXCIgbm9kZSBvbnRvIHRoZSBzdGFja1xuICogICAgIHRoaXMucHVzaChwYXJlbnQpO1xuICpcbiAqICAgICAvLyByZXR1cm4gdGhlIHBhcmVudCBub2RlLCBzbyBpdCdzIGFsc28gYWRkZWQgdG8gdGhlIEFTVFxuICogICAgIHJldHVybiBicmFjZTtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYE5vZGVgIChyZXF1aXJlZCkgTm9kZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmcm9tIFtzbmFwZHJhZ29uLW5vZGVdW10uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZmlsdGVyYCBPcHRpb25hbHkgc3BlY2lmeSBhIGZpbHRlciBmdW5jdGlvbiB0byBleGNsdWRlIHRoZSBub2RlLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIG9wZW5pbmcgbm9kZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuYWRkT3BlbiA9IGZ1bmN0aW9uKG5vZGUsIE5vZGUsIHZhbCwgZmlsdGVyKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oTm9kZSksICdleHBlY3RlZCBOb2RlIHRvIGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24nKTtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpbHRlciA9IHZhbDtcbiAgICB2YWwgPSAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nICYmICFmaWx0ZXIobm9kZSkpIHJldHVybjtcbiAgdmFyIG9wZW4gPSBuZXcgTm9kZSh7IHR5cGU6IG5vZGUudHlwZSArICcub3BlbicsIHZhbDogdmFsfSk7XG4gIHZhciB1bnNoaWZ0ID0gbm9kZS51bnNoaWZ0IHx8IG5vZGUudW5zaGlmdE5vZGU7XG4gIGlmICh0eXBlb2YgdW5zaGlmdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVuc2hpZnQuY2FsbChub2RlLCBvcGVuKTtcbiAgfSBlbHNlIHtcbiAgICB1dGlscy51bnNoaWZ0Tm9kZShub2RlLCBvcGVuKTtcbiAgfVxuICByZXR1cm4gb3Blbjtcbn07XG5cbi8qKlxuICogUHVzaCBhIGAqLmNsb3NlYCBub2RlIG9udG8gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogc25hcGRyYWdvbi5wYXJzZXIuc2V0KCdicmFjZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAqICAgdmFyIG1hdGNoID0gdGhpcy5tYXRjaCgvXn0vKTtcbiAqICAgaWYgKG1hdGNoKSB7XG4gKiAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gKiAgICAgaWYgKHBhcmVudC50eXBlICE9PSAnYnJhY2UnKSB7XG4gKiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlbmluZzogJyArICd9Jyk7XG4gKiAgICAgfVxuICpcbiAqICAgICB1dGlscy5hZGRDbG9zZShwYXJlbnQsIE5vZGUpO1xuICogICAgIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlc1twYXJlbnQubm9kZXMubGVuZ3RoIC0gMV0pOlxuICogICAgIC8vIHsgdHlwZTogJ2JyYWNlLmNsb3NlJywgdmFsOiAnJyB9O1xuICpcbiAqICAgICAvLyBubyBuZWVkIHRvIHJldHVybiBhIG5vZGUsIHNpbmNlIHRoZSBwYXJlbnRcbiAqICAgICAvLyB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgQVNUXG4gKiAgICAgcmV0dXJuO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgTm9kZWAgKHJlcXVpcmVkKSBOb2RlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZyb20gW3NuYXBkcmFnb24tbm9kZV1bXS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmaWx0ZXJgIE9wdGlvbmFseSBzcGVjaWZ5IGEgZmlsdGVyIGZ1bmN0aW9uIHRvIGV4Y2x1ZGUgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgY2xvc2luZyBub2RlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5hZGRDbG9zZSA9IGZ1bmN0aW9uKG5vZGUsIE5vZGUsIHZhbCwgZmlsdGVyKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oTm9kZSksICdleHBlY3RlZCBOb2RlIHRvIGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24nKTtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpbHRlciA9IHZhbDtcbiAgICB2YWwgPSAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nICYmICFmaWx0ZXIobm9kZSkpIHJldHVybjtcbiAgdmFyIGNsb3NlID0gbmV3IE5vZGUoeyB0eXBlOiBub2RlLnR5cGUgKyAnLmNsb3NlJywgdmFsOiB2YWx9KTtcbiAgdmFyIHB1c2ggPSBub2RlLnB1c2ggfHwgbm9kZS5wdXNoTm9kZTtcbiAgaWYgKHR5cGVvZiBwdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHVzaC5jYWxsKG5vZGUsIGNsb3NlKTtcbiAgfSBlbHNlIHtcbiAgICB1dGlscy5wdXNoTm9kZShub2RlLCBjbG9zZSk7XG4gIH1cbiAgcmV0dXJuIGNsb3NlO1xufTtcblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gYG5vZGVgIHdpdGggYCoub3BlbmAgYW5kIGAqLmNsb3NlYCBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBOb2RlYCAocmVxdWlyZWQpIE5vZGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZnJvbSBbc25hcGRyYWdvbi1ub2RlXVtdLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZpbHRlcmAgT3B0aW9uYWx5IHNwZWNpZnkgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gZXhjbHVkZSB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgbm9kZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy53cmFwTm9kZXMgPSBmdW5jdGlvbihub2RlLCBOb2RlLCBmaWx0ZXIpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNGdW5jdGlvbihOb2RlKSwgJ2V4cGVjdGVkIE5vZGUgdG8gYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbicpO1xuXG4gIHV0aWxzLmFkZE9wZW4obm9kZSwgTm9kZSwgZmlsdGVyKTtcbiAgdXRpbHMuYWRkQ2xvc2Uobm9kZSwgTm9kZSwgZmlsdGVyKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIFB1c2ggdGhlIGdpdmVuIGBub2RlYCBvbnRvIGBwYXJlbnQubm9kZXNgLCBhbmQgc2V0IGBwYXJlbnRgIGFzIGBub2RlLnBhcmVudC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbm9kZSk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXNbMF0udHlwZSkgLy8gJ2JhcidcbiAqIGNvbnNvbGUubG9nKG5vZGUucGFyZW50LnR5cGUpIC8vICdmb28nXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcGFyZW50YFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGNoaWxkIG5vZGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMucHVzaE5vZGUgPSBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShwYXJlbnQpLCAnZXhwZWN0ZWQgcGFyZW50IG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG5cbiAgbm9kZS5kZWZpbmUoJ3BhcmVudCcsIHBhcmVudCk7XG4gIHBhcmVudC5ub2RlcyA9IHBhcmVudC5ub2RlcyB8fCBbXTtcbiAgcGFyZW50Lm5vZGVzLnB1c2gobm9kZSk7XG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBVbnNoaWZ0IGBub2RlYCBvbnRvIGBwYXJlbnQubm9kZXNgLCBhbmQgc2V0IGBwYXJlbnRgIGFzIGBub2RlLnBhcmVudC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHV0aWxzLnVuc2hpZnROb2RlKHBhcmVudCwgbm9kZSk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXNbMF0udHlwZSkgLy8gJ2JhcidcbiAqIGNvbnNvbGUubG9nKG5vZGUucGFyZW50LnR5cGUpIC8vICdmb28nXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcGFyZW50YFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnVuc2hpZnROb2RlID0gZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUocGFyZW50KSwgJ2V4cGVjdGVkIHBhcmVudCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuXG4gIG5vZGUuZGVmaW5lKCdwYXJlbnQnLCBwYXJlbnQpO1xuICBwYXJlbnQubm9kZXMgPSBwYXJlbnQubm9kZXMgfHwgW107XG4gIHBhcmVudC5ub2Rlcy51bnNoaWZ0KG5vZGUpO1xufTtcblxuLyoqXG4gKiBQb3AgdGhlIGxhc3QgYG5vZGVgIG9mZiBvZiBgcGFyZW50Lm5vZGVzYC4gVGhlIGFkdmFudGFnZSBvZlxuICogdXNpbmcgdGhpcyBtZXRob2QgaXMgdGhhdCBpdCBjaGVja3MgZm9yIGBub2RlLm5vZGVzYCBhbmQgd29ya3NcbiAqIHdpdGggYW55IHZlcnNpb24gb2YgYHNuYXBkcmFnb24tbm9kZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBwYXJlbnQgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdmb28nfSkpO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pKTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlcy5sZW5ndGgpOyAvLz0+IDNcbiAqIHV0aWxzLnBvcE5vZGUocGFyZW50KTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlcy5sZW5ndGgpOyAvLz0+IDJcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBwYXJlbnRgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge051bWJlcnxVbmRlZmluZWR9IFJldHVybnMgdGhlIGxlbmd0aCBvZiBgbm9kZS5ub2Rlc2Agb3IgdW5kZWZpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5wb3BOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGlmICh0eXBlb2Ygbm9kZS5wb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbm9kZS5wb3AoKTtcbiAgfVxuICByZXR1cm4gbm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzLnBvcCgpO1xufTtcblxuLyoqXG4gKiBTaGlmdCB0aGUgZmlyc3QgYG5vZGVgIG9mZiBvZiBgcGFyZW50Lm5vZGVzYC4gVGhlIGFkdmFudGFnZSBvZlxuICogdXNpbmcgdGhpcyBtZXRob2QgaXMgdGhhdCBpdCBjaGVja3MgZm9yIGBub2RlLm5vZGVzYCBhbmQgd29ya3NcbiAqIHdpdGggYW55IHZlcnNpb24gb2YgYHNuYXBkcmFnb24tbm9kZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBwYXJlbnQgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdmb28nfSkpO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pKTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlcy5sZW5ndGgpOyAvLz0+IDNcbiAqIHV0aWxzLnNoaWZ0Tm9kZShwYXJlbnQpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzLmxlbmd0aCk7IC8vPT4gMlxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBhcmVudGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7TnVtYmVyfFVuZGVmaW5lZH0gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGBub2RlLm5vZGVzYCBvciB1bmRlZmluZWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBpZiAodHlwZW9mIG5vZGUuc2hpZnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbm9kZS5zaGlmdCgpO1xuICB9XG4gIHJldHVybiBub2RlLm5vZGVzICYmIG5vZGUubm9kZXMuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgYG5vZGVgIGZyb20gYHBhcmVudC5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBwYXJlbnQgPSBuZXcgTm9kZSh7dHlwZTogJ2FiYyd9KTtcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgZm9vKTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdiYXInfSkpO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KSk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXMubGVuZ3RoKTsgLy89PiAzXG4gKiB1dGlscy5yZW1vdmVOb2RlKHBhcmVudCwgZm9vKTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlcy5sZW5ndGgpOyAvLz0+IDJcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBwYXJlbnRgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFJldHVybnMgdGhlIHJlbW92ZWQgbm9kZSwgaWYgc3VjY2Vzc2Z1bCwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0IG9uIGBwYXJlbnQubm9kZXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5yZW1vdmVOb2RlID0gZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUocGFyZW50KSwgJ2V4cGVjdGVkIHBhcmVudC5ub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuXG4gIGlmICghcGFyZW50Lm5vZGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmVudC5yZW1vdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFyZW50LnJlbW92ZShub2RlKTtcbiAgfVxuXG4gIHZhciBpZHggPSBwYXJlbnQubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICByZXR1cm4gcGFyZW50Lm5vZGVzLnNwbGljZShpZHgsIDEpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZS50eXBlYCBtYXRjaGVzIHRoZSBnaXZlbiBgdHlwZWAuIFRocm93cyBhXG4gKiBgVHlwZUVycm9yYCBpZiBgbm9kZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBOb2RlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc1R5cGUobm9kZSwgJ2ZvbycpKTsgLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzVHlwZShub2RlLCAnYmFyJykpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNUeXBlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIHN3aXRjaCAodHlwZU9mKHR5cGUpKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgdmFyIHR5cGVzID0gdHlwZS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodXRpbHMuaXNUeXBlKG5vZGUsIHR5cGVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IHR5cGU7XG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIHJldHVybiB0eXBlLnRlc3Qobm9kZS50eXBlKTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBcInR5cGVcIiB0byBiZSBhbiBhcnJheSwgc3RyaW5nIG9yIHJlZ2V4cCcpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBoYXMgdGhlIGdpdmVuIGB0eXBlYCBpbiBgbm9kZS5ub2Rlc2AuXG4gKiBUaHJvd3MgYSBgVHlwZUVycm9yYCBpZiBgbm9kZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBOb2RlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe1xuICogICB0eXBlOiAnZm9vJyxcbiAqICAgbm9kZXM6IFtcbiAqICAgICBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KSxcbiAqICAgICBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KVxuICogICBdXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc1R5cGUobm9kZSwgJ3h5eicpKTsgLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc1R5cGUobm9kZSwgJ2JheicpKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmhhc1R5cGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUubm9kZXMpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh1dGlscy5pc1R5cGUobm9kZS5ub2Rlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2Agb2YgdGhlIGdpdmVuIGB0eXBlYFxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHtcbiAqICAgdHlwZTogJ2ZvbycsXG4gKiAgIG5vZGVzOiBbXG4gKiAgICAgbmV3IE5vZGUoe3R5cGU6ICd0ZXh0JywgdmFsOiAnYWJjJ30pLFxuICogICAgIG5ldyBOb2RlKHt0eXBlOiAndGV4dCcsIHZhbDogJ3h5eid9KVxuICogICBdXG4gKiB9KTtcbiAqXG4gKiB2YXIgdGV4dE5vZGUgPSB1dGlscy5maXJzdE9mVHlwZShub2RlLm5vZGVzLCAndGV4dCcpO1xuICogY29uc29sZS5sb2codGV4dE5vZGUudmFsKTtcbiAqIC8vPT4gJ2FiYydcbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYG5vZGVzYFxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSBvciB1bmRlZmluZWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmZpcnN0T2ZUeXBlID0gZnVuY3Rpb24obm9kZXMsIHR5cGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKHV0aWxzLmlzVHlwZShub2RlLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleCwgb3IgdGhlIGZpcnN0IG5vZGUgb2YgdGhlXG4gKiBnaXZlbiBgdHlwZWAgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe1xuICogICB0eXBlOiAnZm9vJyxcbiAqICAgbm9kZXM6IFtcbiAqICAgICBuZXcgTm9kZSh7dHlwZTogJ3RleHQnLCB2YWw6ICdhYmMnfSksXG4gKiAgICAgbmV3IE5vZGUoe3R5cGU6ICd0ZXh0JywgdmFsOiAneHl6J30pXG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIHZhciBub2RlT25lID0gdXRpbHMuZmluZE5vZGUobm9kZS5ub2RlcywgJ3RleHQnKTtcbiAqIGNvbnNvbGUubG9nKG5vZGVPbmUudmFsKTtcbiAqIC8vPT4gJ2FiYydcbiAqXG4gKiB2YXIgbm9kZVR3byA9IHV0aWxzLmZpbmROb2RlKG5vZGUubm9kZXMsIDEpO1xuICogY29uc29sZS5sb2cobm9kZVR3by52YWwpO1xuICogLy89PiAneHl6J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYG5vZGVzYFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBgdHlwZWAgTm9kZSB0eXBlIG9yIGluZGV4LlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgbm9kZSBvciB1bmRlZmluZWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmZpbmROb2RlID0gZnVuY3Rpb24obm9kZXMsIHR5cGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbm9kZXNbdHlwZV07XG4gIH1cbiAgcmV0dXJuIHV0aWxzLmZpcnN0T2ZUeXBlKG5vZGVzLCB0eXBlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBub2RlIGlzIGFuIFwiKi5vcGVuXCIgbm9kZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBicmFjZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiB2YXIgb3BlbiA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2Uub3Blbid9KTtcbiAqIHZhciBjbG9zZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UuY2xvc2UnfSk7XG4gKlxuICogY29uc29sZS5sb2codXRpbHMuaXNPcGVuKGJyYWNlKSk7IC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc09wZW4ob3BlbikpOyAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc09wZW4oY2xvc2UpKTsgLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc09wZW4gPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgcmV0dXJuIG5vZGUudHlwZS5zbGljZSgtNSkgPT09ICcub3Blbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9kZSBpcyBhIFwiKi5jbG9zZVwiIG5vZGUuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgYnJhY2UgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogdmFyIG9wZW4gPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLm9wZW4nfSk7XG4gKiB2YXIgY2xvc2UgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLmNsb3NlJ30pO1xuICpcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzQ2xvc2UoYnJhY2UpKTsgLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzQ2xvc2Uob3BlbikpOyAvLyBmYWxzZVxuICogY29uc29sZS5sb2codXRpbHMuaXNDbG9zZShjbG9zZSkpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNDbG9zZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICByZXR1cm4gbm9kZS50eXBlLnNsaWNlKC02KSA9PT0gJy5jbG9zZSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZS5ub2Rlc2AgKipoYXMqKiBhbiBgLm9wZW5gIG5vZGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBicmFjZSA9IG5ldyBOb2RlKHtcbiAqICAgdHlwZTogJ2JyYWNlJyxcbiAqICAgbm9kZXM6IFtdXG4gKiB9KTtcbiAqXG4gKiB2YXIgb3BlbiA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2Uub3Blbid9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc09wZW4oYnJhY2UpKTsgLy8gZmFsc2VcbiAqXG4gKiBicmFjZS5wdXNoTm9kZShvcGVuKTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc09wZW4oYnJhY2UpKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmhhc09wZW4gPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgdmFyIGZpcnN0ID0gbm9kZS5maXJzdCB8fCBub2RlLm5vZGVzID8gbm9kZS5ub2Rlc1swXSA6IG51bGw7XG4gIGlmICh1dGlscy5pc05vZGUoZmlyc3QpKSB7XG4gICAgcmV0dXJuIGZpcnN0LnR5cGUgPT09IG5vZGUudHlwZSArICcub3Blbic7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGUubm9kZXNgICoqaGFzKiogYSBgLmNsb3NlYCBub2RlXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgYnJhY2UgPSBuZXcgTm9kZSh7XG4gKiAgIHR5cGU6ICdicmFjZScsXG4gKiAgIG5vZGVzOiBbXVxuICogfSk7XG4gKlxuICogdmFyIGNsb3NlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5jbG9zZSd9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc0Nsb3NlKGJyYWNlKSk7IC8vIGZhbHNlXG4gKlxuICogYnJhY2UucHVzaE5vZGUoY2xvc2UpO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzQ2xvc2UoYnJhY2UpKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmhhc0Nsb3NlID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIHZhciBsYXN0ID0gbm9kZS5sYXN0IHx8IG5vZGUubm9kZXMgPyBub2RlLm5vZGVzW25vZGUubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICBpZiAodXRpbHMuaXNOb2RlKGxhc3QpKSB7XG4gICAgcmV0dXJuIGxhc3QudHlwZSA9PT0gbm9kZS50eXBlICsgJy5jbG9zZSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGUubm9kZXNgIGhhcyBib3RoIGAub3BlbmAgYW5kIGAuY2xvc2VgIG5vZGVzXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgYnJhY2UgPSBuZXcgTm9kZSh7XG4gKiAgIHR5cGU6ICdicmFjZScsXG4gKiAgIG5vZGVzOiBbXVxuICogfSk7XG4gKlxuICogdmFyIG9wZW4gPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLm9wZW4nfSk7XG4gKiB2YXIgY2xvc2UgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLmNsb3NlJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzT3BlbihicmFjZSkpOyAvLyBmYWxzZVxuICogY29uc29sZS5sb2codXRpbHMuaGFzQ2xvc2UoYnJhY2UpKTsgLy8gZmFsc2VcbiAqXG4gKiBicmFjZS5wdXNoTm9kZShvcGVuKTtcbiAqIGJyYWNlLnB1c2hOb2RlKGNsb3NlKTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc09wZW4oYnJhY2UpKTsgLy8gdHJ1ZVxuICogY29uc29sZS5sb2codXRpbHMuaGFzQ2xvc2UoYnJhY2UpKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmhhc09wZW5BbmRDbG9zZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHV0aWxzLmhhc09wZW4obm9kZSkgJiYgdXRpbHMuaGFzQ2xvc2Uobm9kZSk7XG59O1xuXG4vKipcbiAqIFB1c2ggdGhlIGdpdmVuIGBub2RlYCBvbnRvIHRoZSBgc3RhdGUuaW5zaWRlYCBhcnJheSBmb3IgdGhlXG4gKiBnaXZlbiB0eXBlLiBUaGlzIGFycmF5IGlzIHVzZWQgYXMgYSBzcGVjaWFsaXplZCBcInN0YWNrXCIgZm9yXG4gKiBvbmx5IHRoZSBnaXZlbiBgbm9kZS50eXBlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHN0YXRlID0geyBpbnNpZGU6IHt9fTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqIHV0aWxzLmFkZFR5cGUoc3RhdGUsIG5vZGUpO1xuICogY29uc29sZS5sb2coc3RhdGUuaW5zaWRlKTtcbiAqIC8vPT4geyBicmFjZTogW3t0eXBlOiAnYnJhY2UnfV0gfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHN0YXRlYCBUaGUgYGNvbXBpbGVyLnN0YXRlYCBvYmplY3Qgb3IgY3VzdG9tIHN0YXRlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIGBzdGF0ZS5pbnNpZGVgIHN0YWNrIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuYWRkVHlwZSA9IGZ1bmN0aW9uKHN0YXRlLCBub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzT2JqZWN0KHN0YXRlKSwgJ2V4cGVjdGVkIHN0YXRlIHRvIGJlIGFuIG9iamVjdCcpO1xuXG4gIHZhciB0eXBlID0gbm9kZS5wYXJlbnRcbiAgICA/IG5vZGUucGFyZW50LnR5cGVcbiAgICA6IG5vZGUudHlwZS5yZXBsYWNlKC9cXC5vcGVuJC8sICcnKTtcblxuICBpZiAoIXN0YXRlLmhhc093blByb3BlcnR5KCdpbnNpZGUnKSkge1xuICAgIHN0YXRlLmluc2lkZSA9IHt9O1xuICB9XG4gIGlmICghc3RhdGUuaW5zaWRlLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgc3RhdGUuaW5zaWRlW3R5cGVdID0gW107XG4gIH1cblxuICB2YXIgYXJyID0gc3RhdGUuaW5zaWRlW3R5cGVdO1xuICBhcnIucHVzaChub2RlKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBgbm9kZWAgZnJvbSB0aGUgYHN0YXRlLmluc2lkZWAgYXJyYXkgZm9yIHRoZVxuICogZ2l2ZW4gdHlwZS4gVGhpcyBhcnJheSBpcyB1c2VkIGFzIGEgc3BlY2lhbGl6ZWQgXCJzdGFja1wiIGZvclxuICogb25seSB0aGUgZ2l2ZW4gYG5vZGUudHlwZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBzdGF0ZSA9IHsgaW5zaWRlOiB7fX07XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiB1dGlscy5hZGRUeXBlKHN0YXRlLCBub2RlKTtcbiAqIGNvbnNvbGUubG9nKHN0YXRlLmluc2lkZSk7XG4gKiAvLz0+IHsgYnJhY2U6IFt7dHlwZTogJ2JyYWNlJ31dIH1cbiAqIHV0aWxzLnJlbW92ZVR5cGUoc3RhdGUsIG5vZGUpO1xuICogLy89PiB7IGJyYWNlOiBbXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgIFRoZSBgY29tcGlsZXIuc3RhdGVgIG9iamVjdCBvciBjdXN0b20gc3RhdGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgYHN0YXRlLmluc2lkZWAgc3RhY2sgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5yZW1vdmVUeXBlID0gZnVuY3Rpb24oc3RhdGUsIG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNPYmplY3Qoc3RhdGUpLCAnZXhwZWN0ZWQgc3RhdGUgdG8gYmUgYW4gb2JqZWN0Jyk7XG5cbiAgdmFyIHR5cGUgPSBub2RlLnBhcmVudFxuICAgID8gbm9kZS5wYXJlbnQudHlwZVxuICAgIDogbm9kZS50eXBlLnJlcGxhY2UoL1xcLmNsb3NlJC8sICcnKTtcblxuICBpZiAoc3RhdGUuaW5zaWRlLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgcmV0dXJuIHN0YXRlLmluc2lkZVt0eXBlXS5wb3AoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGUudmFsYCBpcyBhbiBlbXB0eSBzdHJpbmcsIG9yIGBub2RlLm5vZGVzYCBkb2VzXG4gKiBub3QgY29udGFpbiBhbnkgbm9uLWVtcHR5IHRleHQgbm9kZXMuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICd0ZXh0J30pO1xuICogdXRpbHMuaXNFbXB0eShub2RlKTsgLy89PiB0cnVlXG4gKiBub2RlLnZhbCA9ICdmb28nO1xuICogdXRpbHMuaXNFbXB0eShub2RlKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzRW1wdHkgPSBmdW5jdGlvbihub2RlLCBmbikge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUubm9kZXMpKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZuKG5vZGUsIG5vZGUucGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuICF1dGlscy50cmltKG5vZGUudmFsKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IG5vZGUubm9kZXNbaV07XG4gICAgaWYgKHV0aWxzLmlzT3BlbihjaGlsZCkgfHwgdXRpbHMuaXNDbG9zZShjaGlsZCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmlzRW1wdHkoY2hpbGQsIGZuKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBzdGF0ZS5pbnNpZGVgIHN0YWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBleGlzdHNcbiAqIGFuZCBoYXMgb25lIG9yIG1vcmUgbm9kZXMgb24gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBzdGF0ZSA9IHsgaW5zaWRlOiB7fX07XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0luc2lkZVR5cGUoc3RhdGUsICdicmFjZScpKTsgLy89PiBmYWxzZVxuICogdXRpbHMuYWRkVHlwZShzdGF0ZSwgbm9kZSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0luc2lkZVR5cGUoc3RhdGUsICdicmFjZScpKTsgLy89PiB0cnVlXG4gKiB1dGlscy5yZW1vdmVUeXBlKHN0YXRlLCBub2RlKTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzSW5zaWRlVHlwZShzdGF0ZSwgJ2JyYWNlJykpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc0luc2lkZVR5cGUgPSBmdW5jdGlvbihzdGF0ZSwgdHlwZSkge1xuICBhc3NlcnQoaXNPYmplY3Qoc3RhdGUpLCAnZXhwZWN0ZWQgc3RhdGUgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIGFzc2VydChpc1N0cmluZyh0eXBlKSwgJ2V4cGVjdGVkIHR5cGUgdG8gYmUgYSBzdHJpbmcnKTtcblxuICBpZiAoIXN0YXRlLmhhc093blByb3BlcnR5KCdpbnNpZGUnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghc3RhdGUuaW5zaWRlLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmluc2lkZVt0eXBlXS5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGVgIGlzIGVpdGhlciBhIGNoaWxkIG9yIGdyYW5kLWNoaWxkIG9mIHRoZSBnaXZlbiBgdHlwZWAsXG4gKiBvciBgc3RhdGUuaW5zaWRlW3R5cGVdYCBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHN0YXRlID0geyBpbnNpZGU6IHt9fTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqIHZhciBvcGVuID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5vcGVuJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaXNJbnNpZGUoc3RhdGUsIG9wZW4sICdicmFjZScpKTsgLy89PiBmYWxzZVxuICogdXRpbHMucHVzaE5vZGUobm9kZSwgb3Blbik7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0luc2lkZShzdGF0ZSwgb3BlbiwgJ2JyYWNlJykpOyAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBzdGF0ZWAgRWl0aGVyIHRoZSBgY29tcGlsZXIuc3RhdGVgIG9iamVjdCwgaWYgaXQgZXhpc3RzLCBvciBhIHVzZXItc3VwcGxpZWQgc3RhdGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgIFRoZSBgbm9kZS50eXBlYCB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc0luc2lkZSA9IGZ1bmN0aW9uKHN0YXRlLCBub2RlLCB0eXBlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzT2JqZWN0KHN0YXRlKSwgJ2V4cGVjdGVkIHN0YXRlIHRvIGJlIGFuIG9iamVjdCcpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodXRpbHMuaXNJbnNpZGUoc3RhdGUsIG5vZGUsIHR5cGVbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gdHlwZSkgfHwgdXRpbHMuaXNJbnNpZGVUeXBlKHN0YXRlLCB0eXBlKTtcbiAgfVxuXG4gIGlmICh0eXBlT2YodHlwZSkgPT09ICdyZWdleHAnKSB7XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSAmJiB0eXBlLnRlc3QocGFyZW50LnR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlLmluc2lkZSk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2lkeF07XG4gICAgICB2YXIgdmFsID0gc3RhdGUuaW5zaWRlW2tleV07XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gMCAmJiB0eXBlLnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgYG5gIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYGFycmF5YC4gVXNlZCBmb3IgZ2V0dGluZ1xuICogYSBub2RlIGZyb20gYG5vZGUubm9kZXMuYFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJheWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBgbmBcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMubGFzdCA9IGZ1bmN0aW9uKGFyciwgbikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAobiB8fCAxKV07XG59O1xuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIGB2YWxgIHRvIGFuIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zb2xlLmxvZyh1dGlscy5hcnJheWlmeSgnJykpO1xuICogLy89PiBbXVxuICogY29uc29sZS5sb2codXRpbHMuYXJyYXlpZnkoJ2ZvbycpKTtcbiAqIC8vPT4gWydmb28nXVxuICogY29uc29sZS5sb2codXRpbHMuYXJyYXlpZnkoWydmb28nXSkpO1xuICogLy89PiBbJ2ZvbyddXG4gKiBgYGBcbiAqIEBwYXJhbSB7YW55fSBgdmFsYFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmFycmF5aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwgIT09ICcnKSB7XG4gICAgcmV0dXJuIFt2YWxdO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGB2YWxgIHRvIGEgc3RyaW5nIGJ5IGpvaW5pbmcgd2l0aCBgLGAuIFVzZWZ1bFxuICogZm9yIGNyZWF0aW5nIGEgY2hlZXJpby9DU1MvRE9NLXN0eWxlIHNlbGVjdG9yIGZyb20gYSBsaXN0IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHthbnl9IGB2YWxgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB1dGlscy5hcnJheWlmeSh2YWwpLmpvaW4oJywnKTtcbn07XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nIGFuZCBjYWxsIGAudHJpbSgpYCBvbiBpdCxcbiAqIG9yIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnRyaW0gPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnRyaW0oKSA6ICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB0eXBlT2YodmFsKSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdmFsIGlzIGEgc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBhcnJheVxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG59XG5cbi8qKlxuICogU2hpbSB0byBlbnN1cmUgdGhlIGAuYXBwZW5kYCBtZXRob2RzIHdvcmsgd2l0aCBhbnkgdmVyc2lvbiBvZiBzbmFwZHJhZ29uXG4gKi9cblxuZnVuY3Rpb24gYXBwZW5kKGNvbXBpbGVyLCB2YWwsIG5vZGUpIHtcbiAgaWYgKHR5cGVvZiBjb21waWxlci5hcHBlbmQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29tcGlsZXIuZW1pdCh2YWwsIG5vZGUpO1xuICB9XG4gIHJldHVybiBjb21waWxlci5hcHBlbmQodmFsLCBub2RlKTtcbn1cblxuLyoqXG4gKiBTaW1wbGlmaWVkIGFzc2VydGlvbi4gVGhyb3dzIGFuIGVycm9yIGlzIGB2YWxgIGlzIGZhbHNleS5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnYmFzZScpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIENvbXBpbGVyID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXInKTtcbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL2xpYi9wYXJzZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJyk7XG52YXIgcmVnZXhDYWNoZSA9IHt9O1xudmFyIGNhY2hlID0ge307XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGBTbmFwZHJhZ29uYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBzbmFwZHJhZ29uID0gbmV3IFNuYXBkcmFnb24oKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU25hcGRyYWdvbihvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKHtzb3VyY2U6ICdzdHJpbmcnfSwgdGhpcy5vcHRpb25zKTtcbiAgdGhpcy5jb21waWxlciA9IG5ldyBDb21waWxlcih0aGlzLm9wdGlvbnMpO1xuICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIodGhpcy5vcHRpb25zKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbXBpbGVycycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZXIuY29tcGlsZXJzO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXJzZXJzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZXIucGFyc2VycztcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVnZXgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlci5yZWdleDtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaGVyaXQgQmFzZVxuICovXG5cbkJhc2UuZXh0ZW5kKFNuYXBkcmFnb24pO1xuXG4vKipcbiAqIEFkZCBhIHBhcnNlciB0byBgc25hcGRyYWdvbi5wYXJzZXJzYCBmb3IgY2FwdHVyaW5nIHRoZSBnaXZlbiBgdHlwZWAgdXNpbmdcbiAqIHRoZSBzcGVjaWZpZWQgcmVnZXggb3IgcGFyc2VyIGZ1bmN0aW9uLiBBIGZ1bmN0aW9uIGlzIHVzZWZ1bCBpZiB5b3UgbmVlZFxuICogdG8gY3VzdG9taXplIGhvdyB0aGUgdG9rZW4gaXMgY3JlYXRlZCBhbmQvb3IgaGF2ZSBhY2Nlc3MgdG8gdGhlIHBhcnNlclxuICogaW5zdGFuY2UgdG8gY2hlY2sgb3B0aW9ucywgZXRjLlxuICpcbiAqIGBgYGpzXG4gKiBzbmFwZHJhZ29uXG4gKiAgIC5jYXB0dXJlKCdzbGFzaCcsIC9eXFwvLylcbiAqICAgLmNhcHR1cmUoJ2RvdCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gKiAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFwuLyk7XG4gKiAgICAgaWYgKCFtKSByZXR1cm47XG4gKiAgICAgcmV0dXJuIHBvcyh7XG4gKiAgICAgICB0eXBlOiAnZG90JyxcbiAqICAgICAgIHZhbDogbVswXVxuICogICAgIH0pO1xuICogICB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHBhcmFtIHtSZWdFeHB8RnVuY3Rpb259IGByZWdleGBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgcGFyc2VyIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TbmFwZHJhZ29uLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlci5jYXB0dXJlLmFwcGx5KHRoaXMucGFyc2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHBsdWdpbiBgZm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc25hcGRyYWdvbiA9IG5ldyBTbmFwZGdyYWdvbihbb3B0aW9uc10pO1xuICogc25hcGRyYWdvbi51c2UoZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKHRoaXMpOyAgICAgICAgICAvLzw9IHNuYXBkcmFnb24gaW5zdGFuY2VcbiAqICAgY29uc29sZS5sb2codGhpcy5wYXJzZXIpOyAgIC8vPD0gcGFyc2VyIGluc3RhbmNlXG4gKiAgIGNvbnNvbGUubG9nKHRoaXMuY29tcGlsZXIpOyAvLzw9IGNvbXBpbGVyIGluc3RhbmNlXG4gKiB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU25hcGRyYWdvbi5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZm4pIHtcbiAgZm4uY2FsbCh0aGlzLCB0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHNuYXBkcmFnb24gPSBuZXcgU25hcGRncmFnb24oW29wdGlvbnNdKTtcbiAqIC8vIHJlZ2lzdGVyIHBhcnNlcnNcbiAqIHNuYXBkcmFnb24ucGFyc2VyLnVzZShmdW5jdGlvbigpIHt9KTtcbiAqXG4gKiAvLyBwYXJzZVxuICogdmFyIGFzdCA9IHNuYXBkcmFnb24ucGFyc2UoJ2Zvby9iYXInKTtcbiAqIGNvbnNvbGUubG9nKGFzdCk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZXQgYG9wdGlvbnMuc291cmNlbWFwYCB0byB0cnVlIHRvIGVuYWJsZSBzb3VyY2UgbWFwcy5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1QuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNuYXBkcmFnb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VyLnBhcnNlKHN0ciwgdGhpcy5vcHRpb25zKTtcblxuICAvLyBhZGQgbm9uLWVudW1lcmFibGUgcGFyc2VyIHJlZmVyZW5jZVxuICBkZWZpbmUocGFyc2VkLCAncGFyc2VyJywgdGhpcy5wYXJzZXIpO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLyoqXG4gKiBDb21waWxlIHRoZSBnaXZlbiBgQVNUYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHNuYXBkcmFnb24gPSBuZXcgU25hcGRncmFnb24oW29wdGlvbnNdKTtcbiAqIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAqIHNuYXBkcmFnb24udXNlKGZ1bmN0aW9uKCkge30pO1xuICogLy8gcmVnaXN0ZXIgcGFyc2VyIHBsdWdpbnNcbiAqIHNuYXBkcmFnb24ucGFyc2VyLnVzZShmdW5jdGlvbigpIHt9KTtcbiAqIC8vIHJlZ2lzdGVyIGNvbXBpbGVyIHBsdWdpbnNcbiAqIHNuYXBkcmFnb24uY29tcGlsZXIudXNlKGZ1bmN0aW9uKCkge30pO1xuICpcbiAqIC8vIHBhcnNlXG4gKiB2YXIgYXN0ID0gc25hcGRyYWdvbi5wYXJzZSgnZm9vL2JhcicpO1xuICpcbiAqIC8vIGNvbXBpbGVcbiAqIHZhciByZXMgPSBzbmFwZHJhZ29uLmNvbXBpbGUoYXN0KTtcbiAqIGNvbnNvbGUubG9nKHJlcy5vdXRwdXQpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYGFzdGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhbiBgb3V0cHV0YCBwcm9wZXJ0eSB3aXRoIHRoZSByZW5kZXJlZCBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNuYXBkcmFnb24ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWQgPSB0aGlzLmNvbXBpbGVyLmNvbXBpbGUoYXN0LCB0aGlzLm9wdGlvbnMpO1xuXG4gIC8vIGFkZCBub24tZW51bWVyYWJsZSBjb21waWxlciByZWZlcmVuY2VcbiAgZGVmaW5lKGNvbXBpbGVkLCAnY29tcGlsZXInLCB0aGlzLmNvbXBpbGVyKTtcbiAgcmV0dXJuIGNvbXBpbGVkO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFNuYXBkcmFnb25gXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTbmFwZHJhZ29uO1xuXG4vKipcbiAqIEV4cG9zZSBgUGFyc2VyYCBhbmQgYENvbXBpbGVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzLkNvbXBpbGVyID0gQ29tcGlsZXI7XG5tb2R1bGUuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1c2UgPSByZXF1aXJlKCd1c2UnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NuYXBkcmFnb246Y29tcGlsZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYENvbXBpbGVyYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKi9cblxuZnVuY3Rpb24gQ29tcGlsZXIob3B0aW9ucywgc3RhdGUpIHtcbiAgZGVidWcoJ2luaXRpYWxpemluZycsIF9fZmlsZW5hbWUpO1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe3NvdXJjZTogJ3N0cmluZyd9LCBvcHRpb25zKTtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlIHx8IHt9O1xuICB0aGlzLmNvbXBpbGVycyA9IHt9O1xuICB0aGlzLm91dHB1dCA9ICcnO1xuICB0aGlzLnNldCgnZW9zJywgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICB9KTtcbiAgdGhpcy5zZXQoJ25vb3AnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gIH0pO1xuICB0aGlzLnNldCgnYm9zJywgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICB9KTtcbiAgdXNlKHRoaXMpO1xufVxuXG4vKipcbiAqIFByb3RvdHlwZSBtZXRob2RzXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBUaHJvdyBhbiBlcnJvciBtZXNzYWdlIHdpdGggZGV0YWlscyBpbmNsdWRpbmcgdGhlIGN1cnNvciBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBtc2dgIE1lc3NhZ2UgdG8gdXNlIGluIHRoZSBFcnJvci5cbiAgICovXG5cbiAgZXJyb3I6IGZ1bmN0aW9uKG1zZywgbm9kZSkge1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uIHx8IHtzdGFydDoge2NvbHVtbjogMH19O1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5vcHRpb25zLnNvdXJjZSArICcgY29sdW1uOicgKyBwb3Muc3RhcnQuY29sdW1uICsgJzogJyArIG1zZztcblxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyLnJlYXNvbiA9IG1zZztcbiAgICBlcnIuY29sdW1uID0gcG9zLnN0YXJ0LmNvbHVtbjtcbiAgICBlcnIuc291cmNlID0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgbm9uLWVudW1iZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBgQ29tcGlsZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb21waWxlci5kZWZpbmUoJ2ZvbycsICdiYXInKTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5kZWZpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIHByb3BlcnkgbmFtZVxuICAgKiBAcGFyYW0ge2FueX0gYHZhbGAgcHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBDb21waWxlciBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZTogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBkZWZpbmUodGhpcywga2V5LCB2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbWl0IGBub2RlLnZhbGBcbiAgICovXG5cbiAgZW1pdDogZnVuY3Rpb24oc3RyLCBub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQgKz0gc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvbXBpbGVyIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgXG4gICAqL1xuXG4gIHNldDogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICB0aGlzLmNvbXBpbGVyc1tuYW1lXSA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29tcGlsZXIgYG5hbWVgLlxuICAgKi9cblxuICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlcnNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJldmlvdXMgQVNUIG5vZGUuXG4gICAqL1xuXG4gIHByZXY6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gdGhpcy5hc3Qubm9kZXNbdGhpcy5pZHggLSAobiB8fCAxKV0gfHwgeyB0eXBlOiAnYm9zJywgdmFsOiAnJyB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgQVNUIG5vZGUuXG4gICAqL1xuXG4gIG5leHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gdGhpcy5hc3Qubm9kZXNbdGhpcy5pZHggKyAobiB8fCAxKV0gfHwgeyB0eXBlOiAnZW9zJywgdmFsOiAnJyB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBWaXNpdCBgbm9kZWAuXG4gICAqL1xuXG4gIHZpc2l0OiBmdW5jdGlvbihub2RlLCBub2RlcywgaSkge1xuICAgIHZhciBmbiA9IHRoaXMuY29tcGlsZXJzW25vZGUudHlwZV07XG4gICAgdGhpcy5pZHggPSBpO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcignY29tcGlsZXIgXCInICsgbm9kZS50eXBlICsgJ1wiIGlzIG5vdCByZWdpc3RlcmVkJywgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIG5vZGUsIG5vZGVzLCBpKTtcbiAgfSxcblxuICAvKipcbiAgICogTWFwIHZpc2l0IG92ZXIgYXJyYXkgb2YgYG5vZGVzYC5cbiAgICovXG5cbiAgbWFwVmlzaXQ6IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICB0aGlzLnZpc2l0KG5vZGVzW2lkeF0sIG5vZGVzLCBpZHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29tcGlsZSBgYXN0YC5cbiAgICovXG5cbiAgY29tcGlsZTogZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gICAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgdGhpcy5wYXJzaW5nRXJyb3JzID0gdGhpcy5hc3QuZXJyb3JzO1xuICAgIHRoaXMub3V0cHV0ID0gJyc7XG5cbiAgICAvLyBzb3VyY2UgbWFwIHN1cHBvcnRcbiAgICBpZiAob3B0cy5zb3VyY2VtYXApIHtcbiAgICAgIHZhciBzb3VyY2VtYXBzID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwcycpO1xuICAgICAgc291cmNlbWFwcyh0aGlzKTtcbiAgICAgIHRoaXMubWFwVmlzaXQodGhpcy5hc3Qubm9kZXMpO1xuICAgICAgdGhpcy5hcHBseVNvdXJjZU1hcHMoKTtcbiAgICAgIHRoaXMubWFwID0gb3B0cy5zb3VyY2VtYXAgPT09ICdnZW5lcmF0b3InID8gdGhpcy5tYXAgOiB0aGlzLm1hcC50b0pTT04oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubWFwVmlzaXQodGhpcy5hc3Qubm9kZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgQ29tcGlsZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb21waWxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVzZSA9IHJlcXVpcmUoJ3VzZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQ2FjaGUgPSByZXF1aXJlKCdtYXAtY2FjaGUnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NuYXBkcmFnb246cGFyc2VyJyk7XG52YXIgUG9zaXRpb24gPSByZXF1aXJlKCcuL3Bvc2l0aW9uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBQYXJzZXJgIHdpdGggdGhlIGdpdmVuIGBpbnB1dGAgYW5kIGBvcHRpb25zYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIGRlYnVnKCdpbml0aWFsaXppbmcnLCBfX2ZpbGVuYW1lKTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKHtzb3VyY2U6ICdzdHJpbmcnfSwgb3B0aW9ucyk7XG4gIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICB1c2UodGhpcyk7XG59XG5cbi8qKlxuICogUHJvdG90eXBlIG1ldGhvZHNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFyc2VyLFxuXG4gIGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9yaWcgPSAnJztcbiAgICB0aGlzLmlucHV0ID0gJyc7XG4gICAgdGhpcy5wYXJzZWQgPSAnJztcblxuICAgIHRoaXMuY29sdW1uID0gMTtcbiAgICB0aGlzLmxpbmUgPSAxO1xuXG4gICAgdGhpcy5yZWdleCA9IG5ldyBDYWNoZSgpO1xuICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMgfHwgW107XG4gICAgdGhpcy5wYXJzZXJzID0gdGhpcy5wYXJzZXJzIHx8IHt9O1xuICAgIHRoaXMudHlwZXMgPSB0aGlzLnR5cGVzIHx8IFtdO1xuICAgIHRoaXMuc2V0cyA9IHRoaXMuc2V0cyB8fCB7fTtcbiAgICB0aGlzLmZucyA9IHRoaXMuZm5zIHx8IFtdO1xuICAgIHRoaXMuY3VycmVudFR5cGUgPSAncm9vdCc7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgIHRoaXMuYm9zID0gcG9zKHt0eXBlOiAnYm9zJywgdmFsOiAnJ30pO1xuXG4gICAgdGhpcy5hc3QgPSB7XG4gICAgICB0eXBlOiAncm9vdCcsXG4gICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgICAgbm9kZXM6IFt0aGlzLmJvc11cbiAgICB9O1xuXG4gICAgZGVmaW5lKHRoaXMuYm9zLCAncGFyZW50JywgdGhpcy5hc3QpO1xuICAgIHRoaXMubm9kZXMgPSBbdGhpcy5hc3RdO1xuXG4gICAgdGhpcy5jb3VudCA9IDA7XG4gICAgdGhpcy5zZXRDb3VudCA9IDA7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaHJvdyBhIGZvcm1hdHRlZCBlcnJvciB3aXRoIHRoZSBjdXJzb3IgY29sdW1uIGFuZCBgbXNnYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBtc2dgIE1lc3NhZ2UgdG8gdXNlIGluIHRoZSBFcnJvci5cbiAgICovXG5cbiAgZXJyb3I6IGZ1bmN0aW9uKG1zZywgbm9kZSkge1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uIHx8IHtzdGFydDoge2NvbHVtbjogMCwgbGluZTogMH19O1xuICAgIHZhciBsaW5lID0gcG9zLnN0YXJ0LmxpbmU7XG4gICAgdmFyIGNvbHVtbiA9IHBvcy5zdGFydC5jb2x1bW47XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cbiAgICB2YXIgbWVzc2FnZSA9IHNvdXJjZSArICcgPGxpbmU6JyArIGxpbmUgKyAnIGNvbHVtbjonICsgY29sdW1uICsgJz46ICcgKyBtc2c7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIuc291cmNlID0gc291cmNlO1xuICAgIGVyci5yZWFzb24gPSBtc2c7XG4gICAgZXJyLnBvcyA9IHBvcztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmluZSBhIG5vbi1lbnVtYmVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgYFBhcnNlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHBhcnNlci5kZWZpbmUoJ2ZvbycsICdiYXInKTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5kZWZpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIHByb3BlcnkgbmFtZVxuICAgKiBAcGFyYW0ge2FueX0gYHZhbGAgcHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBQYXJzZXIgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmU6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgZGVmaW5lKHRoaXMsIGtleSwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTWFyayBwb3NpdGlvbiBhbmQgcGF0Y2ggYG5vZGUucG9zaXRpb25gLlxuICAgKi9cblxuICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0geyBsaW5lOiB0aGlzLmxpbmUsIGNvbHVtbjogdGhpcy5jb2x1bW4gfTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgZGVmaW5lKG5vZGUsICdwb3NpdGlvbicsIG5ldyBQb3NpdGlvbihzdGFydCwgc2VsZikpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IHBhcnNlciBgbmFtZWAgd2l0aCB0aGUgZ2l2ZW4gYGZuYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2V0OiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgIGlmICh0aGlzLnR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICB0aGlzLnR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Vyc1t0eXBlXSA9IGZuLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwYXJzZXIgYG5hbWVgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2Vyc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUHVzaCBhIGB0b2tlbmAgb250byB0aGUgYHR5cGVgIHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gYHRva2VuYFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwdXNoOiBmdW5jdGlvbih0eXBlLCB0b2tlbikge1xuICAgIHRoaXMuc2V0c1t0eXBlXSA9IHRoaXMuc2V0c1t0eXBlXSB8fCBbXTtcbiAgICB0aGlzLmNvdW50Kys7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgICByZXR1cm4gdGhpcy5zZXRzW3R5cGVdLnB1c2godG9rZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3AgYSB0b2tlbiBvZmYgb2YgdGhlIGB0eXBlYCBzdGFja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSB0b2tlblxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwb3A6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLnNldHNbdHlwZV0gPSB0aGlzLnNldHNbdHlwZV0gfHwgW107XG4gICAgdGhpcy5jb3VudC0tO1xuICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0c1t0eXBlXS5wb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgaW5zaWRlIGEgYHN0YWNrYCBub2RlLiBUeXBlcyBhcmUgYGJyYWNlc2AsIGBwYXJlbnNgIG9yIGBicmFja2V0c2AuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgaXNJbnNpZGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLnNldHNbdHlwZV0gPSB0aGlzLnNldHNbdHlwZV0gfHwgW107XG4gICAgcmV0dXJuIHRoaXMuc2V0c1t0eXBlXS5sZW5ndGggPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbm9kZWAgaXMgdGhlIGdpdmVuIGB0eXBlYC5cbiAgICpcbiAgICogYGBganNcbiAgICogcGFyc2VyLmlzVHlwZShub2RlLCAnYnJhY2UnKTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBpc1R5cGU6IGZ1bmN0aW9uKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLnR5cGUgPT09IHR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJldmlvdXMgQVNUIG5vZGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBwcmV2OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoID4gMFxuICAgICAgPyB1dGlscy5sYXN0KHRoaXMuc3RhY2ssIG4pXG4gICAgICA6IHV0aWxzLmxhc3QodGhpcy5ub2Rlcywgbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBsaW5lIGFuZCBjb2x1bW4gYmFzZWQgb24gYHN0cmAuXG4gICAqL1xuXG4gIGNvbnN1bWU6IGZ1bmN0aW9uKGxlbikge1xuICAgIHRoaXMuaW5wdXQgPSB0aGlzLmlucHV0LnN1YnN0cihsZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY29sdW1uIGJhc2VkIG9uIGBzdHJgLlxuICAgKi9cblxuICB1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24oc3RyLCBsZW4pIHtcbiAgICB2YXIgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgICBpZiAobGluZXMpIHRoaXMubGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgdmFyIGkgPSBzdHIubGFzdEluZGV4T2YoJ1xcbicpO1xuICAgIHRoaXMuY29sdW1uID0gfmkgPyBsZW4gLSBpIDogdGhpcy5jb2x1bW4gKyBsZW47XG4gICAgdGhpcy5wYXJzZWQgKz0gc3RyO1xuICAgIHRoaXMuY29uc3VtZShsZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXRjaCBgcmVnZXhgLCByZXR1cm4gY2FwdHVyZXMsIGFuZCB1cGRhdGUgdGhlIGN1cnNvciBwb3NpdGlvbiBieSBgbWF0Y2hbMF1gIGxlbmd0aC5cbiAgICogQHBhcmFtIHtSZWdFeHB9IGByZWdleGBcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBtYXRjaDogZnVuY3Rpb24ocmVnZXgpIHtcbiAgICB2YXIgbSA9IHJlZ2V4LmV4ZWModGhpcy5pbnB1dCk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24obVswXSwgbVswXS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGB0eXBlYCB3aXRoIHRoZSBnaXZlbiByZWdleC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gYHJlZ2V4YFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgY2FwdHVyZTogZnVuY3Rpb24odHlwZSwgcmVnZXgpIHtcbiAgICBpZiAodHlwZW9mIHJlZ2V4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZ2V4LnNldCh0eXBlLCByZWdleCk7XG4gICAgdGhpcy5zZXQodHlwZSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKHJlZ2V4KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB2YWw6IG1bMF0sXG4gICAgICAgIHBhcnNlZDogcGFyc2VkLFxuICAgICAgICByZXN0OiB0aGlzLmlucHV0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1bMV0pIHtcbiAgICAgICAgbm9kZS5pbm5lciA9IG1bMV07XG4gICAgICB9XG5cbiAgICAgIGRlZmluZShub2RlLCAnaW5zaWRlJywgdGhpcy5zdGFjay5sZW5ndGggPiAwKTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcHJldik7XG4gICAgICBwcmV2Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGFyc2VyIHdpdGggb3BlbiBhbmQgY2xvc2UgZm9yIHBhcmVucyxcbiAgICogYnJhY2tldHMgb3IgYnJhY2VzXG4gICAqL1xuXG4gIGNhcHR1cmVQYWlyOiBmdW5jdGlvbih0eXBlLCBvcGVuUmVnZXgsIGNsb3NlUmVnZXgsIGZuKSB7XG4gICAgdGhpcy5zZXRzW3R5cGVdID0gdGhpcy5zZXRzW3R5cGVdIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogT3BlblxuICAgICAqL1xuXG4gICAgdGhpcy5zZXQodHlwZSArICcub3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChvcGVuUmVnZXgpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuICAgICAgdGhpcy5zZXRDb3VudCsrO1xuICAgICAgdGhpcy5zcGVjaWFsQ2hhcnMgPSB0cnVlO1xuICAgICAgdmFyIG9wZW4gPSBwb3Moe1xuICAgICAgICB0eXBlOiB0eXBlICsgJy5vcGVuJyxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIG1bMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wZW4uaW5uZXIgPSBtWzFdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBub2RlczogW29wZW5dXG4gICAgICB9KTtcblxuICAgICAgZGVmaW5lKG5vZGUsICdyZXN0JywgdGhpcy5pbnB1dCk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcnNlZCcsIHBhcnNlZCk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3ByZWZpeCcsIG1bMV0pO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwcmV2KTtcbiAgICAgIGRlZmluZShvcGVuLCAncGFyZW50Jywgbm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCBvcGVuLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoKHR5cGUsIG5vZGUpO1xuICAgICAgcHJldi5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2VcbiAgICAgKi9cblxuICAgIHRoaXMuc2V0KHR5cGUgKyAnLmNsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKGNsb3NlUmVnZXgpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBvcCh0eXBlKTtcbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogdHlwZSArICcuY2xvc2UnLFxuICAgICAgICByZXN0OiB0aGlzLmlucHV0LFxuICAgICAgICBzdWZmaXg6IG1bMV0sXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5pc1R5cGUocGFyZW50LCB0eXBlKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVuaW5nIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q291bnQtLTtcbiAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnN1ZmZpeCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHBhcmVudC5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHBhcmVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2FwdHVyZSBlbmQtb2Ytc3RyaW5nXG4gICAqL1xuXG4gIGVvczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy5pbnB1dCkgcmV0dXJuO1xuICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG5cbiAgICB3aGlsZSAocHJldi50eXBlICE9PSAncm9vdCcgJiYgIXByZXYudmlzaXRlZCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdpbnZhbGlkIHN5bnRheDonICsgdXRpbC5pbnNwZWN0KHByZXYsIG51bGwsIDIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNEZWxpbXMocHJldikpIHtcbiAgICAgICAgcHJldi5wYXJlbnQuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIHByZXYuZXNjYXBlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZpc2l0KHByZXYsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKCFoYXNEZWxpbXMobm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnQuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgdG9rID0gcG9zKHtcbiAgICAgIHR5cGU6ICdlb3MnLFxuICAgICAgdmFsOiB0aGlzLmFwcGVuZCB8fCAnJ1xuICAgIH0pO1xuXG4gICAgZGVmaW5lKHRvaywgJ3BhcmVudCcsIHRoaXMuYXN0KTtcbiAgICByZXR1cm4gdG9rO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSdW4gcGFyc2VycyB0byBhZHZhbmNlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICovXG5cbiAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgIHZhciBsZW4gPSB0aGlzLnR5cGVzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgdmFyIHRvaztcblxuICAgIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgICAgaWYgKCh0b2sgPSB0aGlzLnBhcnNlcnNbdGhpcy50eXBlc1tpZHhdXS5jYWxsKHRoaXMpKSkge1xuICAgICAgICBkZWZpbmUodG9rLCAncmVzdCcsIHRoaXMuaW5wdXQpO1xuICAgICAgICBkZWZpbmUodG9rLCAncGFyc2VkJywgcGFyc2VkKTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdG9rO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuXG4gIHBhcnNlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMub3JpZyA9IGlucHV0O1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgIC8vIGNoZWNrIGlucHV0IGJlZm9yZSBjYWxsaW5nIGAubmV4dCgpYFxuICAgICAgaW5wdXQgPSBzZWxmLmlucHV0O1xuXG4gICAgICAvLyBnZXQgdGhlIG5leHQgQVNUIG5kb2VcbiAgICAgIHZhciBub2RlID0gc2VsZi5uZXh0KCk7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICB2YXIgcHJldiA9IHNlbGYucHJldigpO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcHJldik7XG4gICAgICAgICAgaWYgKHByZXYubm9kZXMpIHtcbiAgICAgICAgICAgIHByZXYubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5zZXRzLmhhc093blByb3BlcnR5KHByZXYudHlwZSkpIHtcbiAgICAgICAgICBzZWxmLmN1cnJlbnRUeXBlID0gcHJldi50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGdvdCBoZXJlIGJ1dCBpbnB1dCBpcyBub3QgY2hhbmdlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICAgIGlmIChzZWxmLmlucHV0ICYmIGlucHV0ID09PSBzZWxmLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcGFyc2VycyByZWdpc3RlcmVkIGZvcjogXCInICsgc2VsZi5pbnB1dC5zbGljZSgwLCA1KSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmlucHV0KSBwYXJzZSgpO1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yKCdtaXNzaW5nIG9wZW5pbmcgJyArIG5vZGUudHlwZSArICc6IFwiJyArIHRoaXMub3JpZyArICdcIicpO1xuICAgIH1cblxuICAgIHZhciBlb3MgPSB0aGlzLmVvcygpO1xuICAgIHZhciB0b2sgPSB0aGlzLnByZXYoKTtcbiAgICBpZiAodG9rLnR5cGUgIT09ICdlb3MnKSB7XG4gICAgICB0aGlzLmFzdC5ub2Rlcy5wdXNoKGVvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXN0O1xuICB9XG59O1xuXG4vKipcbiAqIFZpc2l0IGBub2RlYCB3aXRoIHRoZSBnaXZlbiBgZm5gXG4gKi9cblxuZnVuY3Rpb24gdmlzaXQobm9kZSwgZm4pIHtcbiAgaWYgKCFub2RlLnZpc2l0ZWQpIHtcbiAgICBkZWZpbmUobm9kZSwgJ3Zpc2l0ZWQnLCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZS5ub2RlcyA/IG1hcFZpc2l0KG5vZGUubm9kZXMsIGZuKSA6IGZuKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIE1hcCB2aXNpdCBvdmVyIGFycmF5IG9mIGBub2Rlc2AuXG4gKi9cblxuZnVuY3Rpb24gbWFwVmlzaXQobm9kZXMsIGZuKSB7XG4gIHZhciBsZW4gPSBub2Rlcy5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmlzaXQobm9kZXNbaWR4XSwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc09wZW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzWzBdLnR5cGUgPT09IChub2RlLnR5cGUgKyAnLm9wZW4nKTtcbn1cblxuZnVuY3Rpb24gaGFzQ2xvc2Uobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlcyAmJiB1dGlscy5sYXN0KG5vZGUubm9kZXMpLnR5cGUgPT09IChub2RlLnR5cGUgKyAnLmNsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIGhhc0RlbGltcyhub2RlKSB7XG4gIHJldHVybiBoYXNPcGVuKG5vZGUpICYmIGhhc0Nsb3NlKG5vZGUpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgUGFyc2VyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG5cbi8qKlxuICogU3RvcmUgcG9zaXRpb24gZm9yIGEgbm9kZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUG9zaXRpb24oc3RhcnQsIHBhcnNlcikge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0geyBsaW5lOiBwYXJzZXIubGluZSwgY29sdW1uOiBwYXJzZXIuY29sdW1uIH07XG4gIGRlZmluZSh0aGlzLCAnY29udGVudCcsIHBhcnNlci5vcmlnKTtcbiAgZGVmaW5lKHRoaXMsICdzb3VyY2UnLCBwYXJzZXIub3B0aW9ucy5zb3VyY2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgbWl4aW4oKWAuXG4gKiBUaGlzIGNvZGUgaXMgYmFzZWQgb24gYHNvdXJjZS1tYXBzLXN1cHBvcnQuanNgIGluIHJld29ya2Nzcy9jc3NcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXdvcmtjc3MvY3NzL2Jsb2IvbWFzdGVyL2xpYi9zdHJpbmdpZnkvc291cmNlLW1hcC1zdXBwb3J0LmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1peGluO1xuXG4vKipcbiAqIE1peGluIHNvdXJjZSBtYXAgc3VwcG9ydCBpbnRvIGBjb21waWxlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBjb21waWxlcmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4oY29tcGlsZXIpIHtcbiAgZGVmaW5lKGNvbXBpbGVyLCAnX2NvbW1lbnQnLCBjb21waWxlci5jb21tZW50KTtcbiAgY29tcGlsZXIubWFwID0gbmV3IHV0aWxzLlNvdXJjZU1hcC5Tb3VyY2VNYXBHZW5lcmF0b3IoKTtcbiAgY29tcGlsZXIucG9zaXRpb24gPSB7IGxpbmU6IDEsIGNvbHVtbjogMSB9O1xuICBjb21waWxlci5jb250ZW50ID0ge307XG4gIGNvbXBpbGVyLmZpbGVzID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIGV4cG9ydHMpIHtcbiAgICBkZWZpbmUoY29tcGlsZXIsIGtleSwgZXhwb3J0c1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZXhwb3J0cy51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgaWYgKGxpbmVzKSB0aGlzLnBvc2l0aW9uLmxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICB2YXIgaSA9IHN0ci5sYXN0SW5kZXhPZignXFxuJyk7XG4gIHRoaXMucG9zaXRpb24uY29sdW1uID0gfmkgPyBzdHIubGVuZ3RoIC0gaSA6IHRoaXMucG9zaXRpb24uY29sdW1uICsgc3RyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogRW1pdCBgc3RyYCB3aXRoIGBwb3NpdGlvbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtPYmplY3R9IFtwb3NdXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZXhwb3J0cy5lbWl0ID0gZnVuY3Rpb24oc3RyLCBub2RlKSB7XG4gIHZhciBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb24gfHwge307XG4gIHZhciBzb3VyY2UgPSBwb3NpdGlvbi5zb3VyY2U7XG4gIGlmIChzb3VyY2UpIHtcbiAgICBpZiAocG9zaXRpb24uZmlsZXBhdGgpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWxzLnVuaXhpZnkocG9zaXRpb24uZmlsZXBhdGgpO1xuICAgIH1cblxuICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgbGluZTogdGhpcy5wb3NpdGlvbi5saW5lLFxuICAgICAgICBjb2x1bW46IE1hdGgubWF4KHRoaXMucG9zaXRpb24uY29sdW1uIC0gMSwgMClcbiAgICAgIH0sXG4gICAgICBvcmlnaW5hbDoge1xuICAgICAgICBsaW5lOiBwb3NpdGlvbi5zdGFydC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvc2l0aW9uLnN0YXJ0LmNvbHVtbiAtIDFcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwb3NpdGlvbi5jb250ZW50KSB7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoc291cmNlLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbi5maWxlcGF0aCkge1xuICAgICAgdGhpcy5hZGRGaWxlKHNvdXJjZSwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oc3RyKTtcbiAgICB0aGlzLm91dHB1dCArPSBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogQWRkcyBhIGZpbGUgdG8gdGhlIHNvdXJjZSBtYXAgb3V0cHV0IGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gYGZpbGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBvc2BcbiAqL1xuXG5leHBvcnRzLmFkZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBwb3NpdGlvbikge1xuICBpZiAodHlwZW9mIHBvc2l0aW9uLmNvbnRlbnQgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5maWxlcywgZmlsZSkpIHJldHVybjtcbiAgdGhpcy5maWxlc1tmaWxlXSA9IHBvc2l0aW9uLmNvbnRlbnQ7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb250ZW50IHNvdXJjZSB0byB0aGUgc291cmNlIG1hcCBvdXRwdXQgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc291cmNlYFxuICogQHBhcmFtIHtPYmplY3R9IGBwb3NpdGlvbmBcbiAqL1xuXG5leHBvcnRzLmFkZENvbnRlbnQgPSBmdW5jdGlvbihzb3VyY2UsIHBvc2l0aW9uKSB7XG4gIGlmICh0eXBlb2YgcG9zaXRpb24uY29udGVudCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRlbnQsIHNvdXJjZSkpIHJldHVybjtcbiAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChzb3VyY2UsIHBvc2l0aW9uLmNvbnRlbnQpO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGFueSBvcmlnaW5hbCBzb3VyY2UgbWFwcyB0byB0aGUgb3V0cHV0IGFuZCBlbWJlZHMgdGhlIHNvdXJjZSBmaWxlXG4gKiBjb250ZW50cyBpbiB0aGUgc291cmNlIG1hcC5cbiAqL1xuXG5leHBvcnRzLmFwcGx5U291cmNlTWFwcyA9IGZ1bmN0aW9uKCkge1xuICBPYmplY3Qua2V5cyh0aGlzLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICB2YXIgY29udGVudCA9IHRoaXMuZmlsZXNbZmlsZV07XG4gICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmaWxlLCBjb250ZW50KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5wdXRTb3VyY2VtYXBzID09PSB0cnVlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxNYXAgPSB1dGlscy5zb3VyY2VNYXBSZXNvbHZlLnJlc29sdmVTeW5jKGNvbnRlbnQsIGZpbGUsIGZzLnJlYWRGaWxlU3luYyk7XG4gICAgICBpZiAob3JpZ2luYWxNYXApIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyB1dGlscy5Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIob3JpZ2luYWxNYXAubWFwKTtcbiAgICAgICAgdmFyIHJlbGF0aXZlVG8gPSBvcmlnaW5hbE1hcC5zb3VyY2VzUmVsYXRpdmVUbztcbiAgICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmaWxlLCB1dGlscy51bml4aWZ5KHBhdGguZGlybmFtZShyZWxhdGl2ZVRvKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgY29tbWVudHMsIGRyb3BzIHNvdXJjZU1hcCBjb21tZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKi9cblxuZXhwb3J0cy5jb21tZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoL14jIHNvdXJjZU1hcHBpbmdVUkw9Ly50ZXN0KG5vZGUuY29tbWVudCkpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCcnLCBub2RlLnBvc2l0aW9uKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29tbWVudChub2RlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmV4cG9ydHMuZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbmV4cG9ydHMuU291cmNlTWFwID0gcmVxdWlyZSgnc291cmNlLW1hcCcpO1xuZXhwb3J0cy5zb3VyY2VNYXBSZXNvbHZlID0gcmVxdWlyZSgnc291cmNlLW1hcC1yZXNvbHZlJyk7XG5cbi8qKlxuICogQ29udmVydCBiYWNrc2xhc2ggaW4gdGhlIGdpdmVuIHN0cmluZyB0byBmb3J3YXJkIHNsYXNoZXNcbiAqL1xuXG5leHBvcnRzLnVuaXhpZnkgPSBmdW5jdGlvbihmcCkge1xuICByZXR1cm4gZnAuc3BsaXQoL1xcXFwrLykuam9pbignLycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyICYmIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5leHBvcnRzLmFycmF5aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIFt2YWxdO1xuICByZXR1cm4gdmFsID8gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKSA6IFtdO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgYG5gIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYGFycmF5YFxuICogQHBhcmFtIHtBcnJheX0gYGFycmF5YFxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLmxhc3QgPSBmdW5jdGlvbihhcnIsIG4pIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gKG4gfHwgMSldO1xufTtcbiIsIi8vIE5vdGU6IHNvdXJjZS1tYXAtcmVzb2x2ZS5qcyBpcyBnZW5lcmF0ZWQgZnJvbSBzb3VyY2UtbWFwLXJlc29sdmUtbm9kZS5qcyBhbmRcbi8vIHNvdXJjZS1tYXAtcmVzb2x2ZS10ZW1wbGF0ZS5qcy4gT25seSBlZGl0IHRoZSB0d28gbGF0dGVyIGZpbGVzLCBfbm90X1xuLy8gc291cmNlLW1hcC1yZXNvbHZlLmpzIVxuXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXCJzb3VyY2UtbWFwLXVybFwiLCBcInJlc29sdmUtdXJsXCJdLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdVUkwgPSByZXF1aXJlKFwic291cmNlLW1hcC11cmxcIilcbiAgICB2YXIgcmVzb2x2ZVVybCA9IHJlcXVpcmUoXCJyZXNvbHZlLXVybFwiKVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShzb3VyY2VNYXBwaW5nVVJMLCByZXNvbHZlVXJsKVxuICB9IGVsc2Uge1xuICAgIHJvb3Quc291cmNlTWFwUmVzb2x2ZSA9IGZhY3Rvcnkocm9vdC5zb3VyY2VNYXBwaW5nVVJMLCByb290LnJlc29sdmVVcmwpXG4gIH1cbn0odGhpcywgZnVuY3Rpb24oc291cmNlTWFwcGluZ1VSTCwgcmVzb2x2ZVVybCkge1xuXG4gIGZ1bmN0aW9uIGNhbGxiYWNrQXN5bmMoY2FsbGJhY2ssIGVycm9yLCByZXN1bHQpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycm9yLCByZXN1bHQpIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1hcFRvSlNPTihzdHJpbmcsIGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nLnJlcGxhY2UoL15cXClcXF1cXH0nLywgXCJcIikpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBkYXRhXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTeW5jKHJlYWQsIHVybCwgZGF0YSkge1xuICAgIHZhciByZWFkVXJsID0gdXJsXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBTdHJpbmcocmVhZChyZWFkVXJsKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VNYXAoY29kZSwgY29kZVVybCwgcmVhZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgbWFwRGF0YVxuICAgIHRyeSB7XG4gICAgICBtYXBEYXRhID0gcmVzb2x2ZVNvdXJjZU1hcEhlbHBlcihjb2RlLCBjb2RlVXJsKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgZXJyb3IpXG4gICAgfVxuICAgIGlmICghbWFwRGF0YSB8fCBtYXBEYXRhLm1hcCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrQXN5bmMoY2FsbGJhY2ssIG51bGwsIG1hcERhdGEpXG4gICAgfVxuICAgIHZhciByZWFkVXJsID0gbWFwRGF0YS51cmxcbiAgICByZWFkKHJlYWRVcmwsIGZ1bmN0aW9uKGVycm9yLCByZXN1bHQpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gbWFwRGF0YVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICB9XG4gICAgICBtYXBEYXRhLm1hcCA9IFN0cmluZyhyZXN1bHQpXG4gICAgICB0cnkge1xuICAgICAgICBtYXBEYXRhLm1hcCA9IHBhcnNlTWFwVG9KU09OKG1hcERhdGEubWFwLCBtYXBEYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgbWFwRGF0YSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZU1hcFN5bmMoY29kZSwgY29kZVVybCwgcmVhZCkge1xuICAgIHZhciBtYXBEYXRhID0gcmVzb2x2ZVNvdXJjZU1hcEhlbHBlcihjb2RlLCBjb2RlVXJsKVxuICAgIGlmICghbWFwRGF0YSB8fCBtYXBEYXRhLm1hcCkge1xuICAgICAgcmV0dXJuIG1hcERhdGFcbiAgICB9XG4gICAgbWFwRGF0YS5tYXAgPSByZWFkU3luYyhyZWFkLCBtYXBEYXRhLnVybCwgbWFwRGF0YSlcbiAgICBtYXBEYXRhLm1hcCA9IHBhcnNlTWFwVG9KU09OKG1hcERhdGEubWFwLCBtYXBEYXRhKVxuICAgIHJldHVybiBtYXBEYXRhXG4gIH1cblxuICB2YXIgZGF0YVVyaVJlZ2V4ID0gL15kYXRhOihbXiw7XSopKDtbXiw7XSopKig/OiwoLiopKT8kL1xuXG4gIC8qKlxuICAgKiBUaGUgbWVkaWEgdHlwZSBmb3IgSlNPTiB0ZXh0IGlzIGFwcGxpY2F0aW9uL2pzb24uXG4gICAqXG4gICAqIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODI1OSNzZWN0aW9uLTExIHwgSUFOQSBDb25zaWRlcmF0aW9ucyB9XG4gICAqXG4gICAqIGB0ZXh0L2pzb25gIGlzIG5vbi1zdGFuZGFyZCBtZWRpYSB0eXBlXG4gICAqL1xuICB2YXIganNvbk1pbWVUeXBlUmVnZXggPSAvXig/OmFwcGxpY2F0aW9ufHRleHQpXFwvanNvbiQvXG5cbiAgLyoqXG4gICAqIEpTT04gdGV4dCBleGNoYW5nZWQgYmV0d2VlbiBzeXN0ZW1zIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGEgY2xvc2VkIGVjb3N5c3RlbVxuICAgKiBNVVNUIGJlIGVuY29kZWQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODI1OSNzZWN0aW9uLTguMSB8IENoYXJhY3RlciBFbmNvZGluZ31cbiAgICovXG4gIHZhciBqc29uQ2hhcmFjdGVyRW5jb2RpbmcgPSBcInV0Zi04XCJcblxuICBmdW5jdGlvbiBiYXNlNjRUb0J1ZihiNjQpIHtcbiAgICB2YXIgYmluU3RyID0gYXRvYihiNjQpXG4gICAgdmFyIGxlbiA9IGJpblN0ci5sZW5ndGhcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycltpXSA9IGJpblN0ci5jaGFyQ29kZUF0KGkpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZUJhc2U2NFN0cmluZyhiNjQpIHtcbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gYXRvYihiNjQpXG4gICAgfVxuICAgIHZhciBidWYgPSBiYXNlNjRUb0J1ZihiNjQpO1xuICAgIC8vIE5vdGU6IGBkZWNvZGVyLmRlY29kZWAgbWV0aG9kIHdpbGwgdGhyb3cgYSBgRE9NRXhjZXB0aW9uYCB3aXRoIHRoZVxuICAgIC8vIGBcIkVuY29kaW5nRXJyb3JcImAgdmFsdWUgd2hlbiBhbiBjb2RpbmcgZXJyb3IgaXMgZm91bmQuXG4gICAgdmFyIGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoanNvbkNoYXJhY3RlckVuY29kaW5nLCB7ZmF0YWw6IHRydWV9KVxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWYpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZU1hcEhlbHBlcihjb2RlLCBjb2RlVXJsKSB7XG4gICAgdmFyIHVybCA9IHNvdXJjZU1hcHBpbmdVUkwuZ2V0RnJvbShjb2RlKVxuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBkYXRhVXJpID0gdXJsLm1hdGNoKGRhdGFVcmlSZWdleClcbiAgICBpZiAoZGF0YVVyaSkge1xuICAgICAgdmFyIG1pbWVUeXBlID0gZGF0YVVyaVsxXSB8fCBcInRleHQvcGxhaW5cIlxuICAgICAgdmFyIGxhc3RQYXJhbWV0ZXIgPSBkYXRhVXJpWzJdIHx8IFwiXCJcbiAgICAgIHZhciBlbmNvZGVkID0gZGF0YVVyaVszXSB8fCBcIlwiXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgc291cmNlTWFwcGluZ1VSTDogdXJsLFxuICAgICAgICB1cmw6IG51bGwsXG4gICAgICAgIHNvdXJjZXNSZWxhdGl2ZVRvOiBjb2RlVXJsLFxuICAgICAgICBtYXA6IGVuY29kZWRcbiAgICAgIH1cbiAgICAgIGlmICghanNvbk1pbWVUeXBlUmVnZXgudGVzdChtaW1lVHlwZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiVW51c2VmdWwgZGF0YSB1cmkgbWltZSB0eXBlOiBcIiArIG1pbWVUeXBlKVxuICAgICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YS5tYXAgPSBwYXJzZU1hcFRvSlNPTihcbiAgICAgICAgICBsYXN0UGFyYW1ldGVyID09PSBcIjtiYXNlNjRcIiA/IGRlY29kZUJhc2U2NFN0cmluZyhlbmNvZGVkKSA6IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKSxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBkYXRhXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIHZhciBtYXBVcmwgPSByZXNvbHZlVXJsKGNvZGVVcmwsIHVybClcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlTWFwcGluZ1VSTDogdXJsLFxuICAgICAgdXJsOiBtYXBVcmwsXG4gICAgICBzb3VyY2VzUmVsYXRpdmVUbzogbWFwVXJsLFxuICAgICAgbWFwOiBudWxsXG4gICAgfVxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzKG1hcCwgbWFwVXJsLCByZWFkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgICB2YXIgcGVuZGluZyA9IG1hcC5zb3VyY2VzID8gbWFwLnNvdXJjZXMubGVuZ3RoIDogMFxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzb3VyY2VzUmVzb2x2ZWQ6IFtdLFxuICAgICAgc291cmNlc0NvbnRlbnQ6ICBbXVxuICAgIH1cblxuICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICBjYWxsYmFja0FzeW5jKGNhbGxiYWNrLCBudWxsLCByZXN1bHQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGVuZGluZy0tXG4gICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzb2x2ZVNvdXJjZXNIZWxwZXIobWFwLCBtYXBVcmwsIG9wdGlvbnMsIGZ1bmN0aW9uKGZ1bGxVcmwsIHNvdXJjZUNvbnRlbnQsIGluZGV4KSB7XG4gICAgICByZXN1bHQuc291cmNlc1Jlc29sdmVkW2luZGV4XSA9IGZ1bGxVcmxcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlQ29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQuc291cmNlc0NvbnRlbnRbaW5kZXhdID0gc291cmNlQ29udGVudFxuICAgICAgICBjYWxsYmFja0FzeW5jKGRvbmUsIG51bGwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVhZFVybCA9IGZ1bGxVcmxcbiAgICAgICAgcmVhZChyZWFkVXJsLCBmdW5jdGlvbihlcnJvciwgc291cmNlKSB7XG4gICAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IGVycm9yID8gZXJyb3IgOiBTdHJpbmcoc291cmNlKVxuICAgICAgICAgIGRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlc1N5bmMobWFwLCBtYXBVcmwsIHJlYWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc291cmNlc1Jlc29sdmVkOiBbXSxcbiAgICAgIHNvdXJjZXNDb250ZW50OiAgW11cbiAgICB9XG5cbiAgICBpZiAoIW1hcC5zb3VyY2VzIHx8IG1hcC5zb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHJlc29sdmVTb3VyY2VzSGVscGVyKG1hcCwgbWFwVXJsLCBvcHRpb25zLCBmdW5jdGlvbihmdWxsVXJsLCBzb3VyY2VDb250ZW50LCBpbmRleCkge1xuICAgICAgcmVzdWx0LnNvdXJjZXNSZXNvbHZlZFtpbmRleF0gPSBmdWxsVXJsXG4gICAgICBpZiAocmVhZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXN1bHQuc291cmNlc0NvbnRlbnRbaW5kZXhdID0gc291cmNlQ29udGVudFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWFkVXJsID0gZnVsbFVybFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlc0NvbnRlbnRbaW5kZXhdID0gU3RyaW5nKHJlYWQocmVhZFVybCkpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zb3VyY2VzQ29udGVudFtpbmRleF0gPSBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB2YXIgZW5kaW5nU2xhc2ggPSAvXFwvPyQvXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXNIZWxwZXIobWFwLCBtYXBVcmwsIG9wdGlvbnMsIGZuKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgZnVsbFVybFxuICAgIHZhciBzb3VyY2VDb250ZW50XG4gICAgdmFyIHNvdXJjZVJvb3RcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbiA9IG1hcC5zb3VyY2VzLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgIHNvdXJjZVJvb3QgPSBudWxsXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc291cmNlUm9vdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzb3VyY2VSb290ID0gb3B0aW9ucy5zb3VyY2VSb290XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXAuc291cmNlUm9vdCA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLnNvdXJjZVJvb3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHNvdXJjZVJvb3QgPSBtYXAuc291cmNlUm9vdFxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIHNvdXJjZVJvb3QgaXMgdGhlIGVtcHR5IHN0cmluZywgaXQgaXMgZXF1aXZhbGVudCB0byBub3Qgc2V0dGluZ1xuICAgICAgLy8gdGhlIHByb3BlcnR5IGF0IGFsbC5cbiAgICAgIGlmIChzb3VyY2VSb290ID09PSBudWxsIHx8IHNvdXJjZVJvb3QgPT09ICcnKSB7XG4gICAgICAgIGZ1bGxVcmwgPSByZXNvbHZlVXJsKG1hcFVybCwgbWFwLnNvdXJjZXNbaW5kZXhdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHNvdXJjZVJvb3QgZW5kcyB3aXRoIGEgc2xhc2gsIHNvIHRoYXQgYC9zY3JpcHRzL3N1YmRpcmAgYmVjb21lc1xuICAgICAgICAvLyBgL3NjcmlwdHMvc3ViZGlyLzxzb3VyY2U+YCwgbm90IGAvc2NyaXB0cy88c291cmNlPmAuIFBvaW50aW5nIHRvIGEgZmlsZSBhcyBzb3VyY2Ugcm9vdFxuICAgICAgICAvLyBkb2VzIG5vdCBtYWtlIHNlbnNlLlxuICAgICAgICBmdWxsVXJsID0gcmVzb2x2ZVVybChtYXBVcmwsIHNvdXJjZVJvb3QucmVwbGFjZShlbmRpbmdTbGFzaCwgXCIvXCIpLCBtYXAuc291cmNlc1tpbmRleF0pXG4gICAgICB9XG4gICAgICBzb3VyY2VDb250ZW50ID0gKG1hcC5zb3VyY2VzQ29udGVudCB8fCBbXSlbaW5kZXhdXG4gICAgICBmbihmdWxsVXJsLCBzb3VyY2VDb250ZW50LCBpbmRleClcbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShjb2RlLCBjb2RlVXJsLCByZWFkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIG1hcFVybCA9IGNvZGVVcmxcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBzb3VyY2VNYXBwaW5nVVJMOiBudWxsLFxuICAgICAgICB1cmw6IG1hcFVybCxcbiAgICAgICAgc291cmNlc1JlbGF0aXZlVG86IG1hcFVybCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9XG4gICAgICB2YXIgcmVhZFVybCA9IG1hcFVybFxuICAgICAgcmVhZChyZWFkVXJsLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBkYXRhXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKVxuICAgICAgICB9XG4gICAgICAgIGRhdGEubWFwID0gU3RyaW5nKHJlc3VsdClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhLm1hcCA9IHBhcnNlTWFwVG9KU09OKGRhdGEubWFwLCBkYXRhKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBfcmVzb2x2ZVNvdXJjZXMoZGF0YSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVTb3VyY2VNYXAoY29kZSwgY29kZVVybCwgcmVhZCwgZnVuY3Rpb24oZXJyb3IsIG1hcERhdGEpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWFwRGF0YSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKVxuICAgICAgICB9XG4gICAgICAgIF9yZXNvbHZlU291cmNlcyhtYXBEYXRhKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVzb2x2ZVNvdXJjZXMobWFwRGF0YSkge1xuICAgICAgcmVzb2x2ZVNvdXJjZXMobWFwRGF0YS5tYXAsIG1hcERhdGEuc291cmNlc1JlbGF0aXZlVG8sIHJlYWQsIG9wdGlvbnMsIGZ1bmN0aW9uKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKVxuICAgICAgICB9XG4gICAgICAgIG1hcERhdGEuc291cmNlc1Jlc29sdmVkID0gcmVzdWx0LnNvdXJjZXNSZXNvbHZlZFxuICAgICAgICBtYXBEYXRhLnNvdXJjZXNDb250ZW50ICA9IHJlc3VsdC5zb3VyY2VzQ29udGVudFxuICAgICAgICBjYWxsYmFjayhudWxsLCBtYXBEYXRhKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU3luYyhjb2RlLCBjb2RlVXJsLCByZWFkLCBvcHRpb25zKSB7XG4gICAgdmFyIG1hcERhdGFcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIG1hcFVybCA9IGNvZGVVcmxcbiAgICAgIG1hcERhdGEgPSB7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdVUkw6IG51bGwsXG4gICAgICAgIHVybDogbWFwVXJsLFxuICAgICAgICBzb3VyY2VzUmVsYXRpdmVUbzogbWFwVXJsLFxuICAgICAgICBtYXA6IG51bGxcbiAgICAgIH1cbiAgICAgIG1hcERhdGEubWFwID0gcmVhZFN5bmMocmVhZCwgbWFwVXJsLCBtYXBEYXRhKVxuICAgICAgbWFwRGF0YS5tYXAgPSBwYXJzZU1hcFRvSlNPTihtYXBEYXRhLm1hcCwgbWFwRGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwRGF0YSA9IHJlc29sdmVTb3VyY2VNYXBTeW5jKGNvZGUsIGNvZGVVcmwsIHJlYWQpXG4gICAgICBpZiAoIW1hcERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHJlc29sdmVTb3VyY2VzU3luYyhtYXBEYXRhLm1hcCwgbWFwRGF0YS5zb3VyY2VzUmVsYXRpdmVUbywgcmVhZCwgb3B0aW9ucylcbiAgICBtYXBEYXRhLnNvdXJjZXNSZXNvbHZlZCA9IHJlc3VsdC5zb3VyY2VzUmVzb2x2ZWRcbiAgICBtYXBEYXRhLnNvdXJjZXNDb250ZW50ICA9IHJlc3VsdC5zb3VyY2VzQ29udGVudFxuICAgIHJldHVybiBtYXBEYXRhXG4gIH1cblxuXG5cbiAgcmV0dXJuIHtcbiAgICByZXNvbHZlU291cmNlTWFwOiAgICAgcmVzb2x2ZVNvdXJjZU1hcCxcbiAgICByZXNvbHZlU291cmNlTWFwU3luYzogcmVzb2x2ZVNvdXJjZU1hcFN5bmMsXG4gICAgcmVzb2x2ZVNvdXJjZXM6ICAgICAgIHJlc29sdmVTb3VyY2VzLFxuICAgIHJlc29sdmVTb3VyY2VzU3luYzogICByZXNvbHZlU291cmNlc1N5bmMsXG4gICAgcmVzb2x2ZTogICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgcmVzb2x2ZVN5bmM6ICAgICAgICAgIHJlc29sdmVTeW5jLFxuICAgIHBhcnNlTWFwVG9KU09OOiAgICAgICBwYXJzZU1hcFRvSlNPTlxuICB9XG5cbn0pKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxuLy8gWDExICjigJxNSVTigJ0pIExpY2Vuc2VkLiAoU2VlIExJQ0VOU0UuKVxuXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgfSBlbHNlIHtcbiAgICByb290LnNvdXJjZU1hcHBpbmdVUkwgPSBmYWN0b3J5KClcbiAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcblxuICB2YXIgaW5uZXJSZWdleCA9IC9bI0BdIHNvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSopL1xuXG4gIHZhciByZWdleCA9IFJlZ0V4cChcbiAgICBcIig/OlwiICtcbiAgICAgIFwiL1xcXFwqXCIgK1xuICAgICAgXCIoPzpcXFxccypcXHI/XFxuKD86Ly8pPyk/XCIgK1xuICAgICAgXCIoPzpcIiArIGlubmVyUmVnZXguc291cmNlICsgXCIpXCIgK1xuICAgICAgXCJcXFxccypcIiArXG4gICAgICBcIlxcXFwqL1wiICtcbiAgICAgIFwifFwiICtcbiAgICAgIFwiLy8oPzpcIiArIGlubmVyUmVnZXguc291cmNlICsgXCIpXCIgK1xuICAgIFwiKVwiICtcbiAgICBcIlxcXFxzKlwiXG4gIClcblxuICByZXR1cm4ge1xuXG4gICAgcmVnZXg6IHJlZ2V4LFxuICAgIF9pbm5lclJlZ2V4OiBpbm5lclJlZ2V4LFxuXG4gICAgZ2V0RnJvbTogZnVuY3Rpb24oY29kZSkge1xuICAgICAgdmFyIG1hdGNoID0gY29kZS5tYXRjaChyZWdleClcbiAgICAgIHJldHVybiAobWF0Y2ggPyBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBcIlwiIDogbnVsbClcbiAgICB9LFxuXG4gICAgZXhpc3RzSW46IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHJldHVybiByZWdleC50ZXN0KGNvZGUpXG4gICAgfSxcblxuICAgIHJlbW92ZUZyb206IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlLnJlcGxhY2UocmVnZXgsIFwiXCIpXG4gICAgfSxcblxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY29kZSwgc3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBjb2RlLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIHN0cmluZyArIGNvZGUuc2xpY2UobWF0Y2guaW5kZXgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29kZSArIHN0cmluZ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59KSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbmV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAvL1xuICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAvL1xuICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAvL1xuICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICpcbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKi9cbmV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAtLWluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIC8vIFdoZW4gYU9yaWdpbmFsIGlzIHRydXRoeSBidXQgaGFzIGVtcHR5IHZhbHVlcyBmb3IgLmxpbmUgYW5kIC5jb2x1bW4sXG4gICAgLy8gaXQgaXMgbW9zdCBsaWtlbHkgYSBwcm9ncmFtbWVyIGVycm9yLiBJbiB0aGlzIGNhc2Ugd2UgdGhyb3cgYSB2ZXJ5XG4gICAgLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuICAgIC8vIEZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyLWJ1bmRsZXIvcHVsbC81MTlcbiAgICBpZiAoYU9yaWdpbmFsICYmIHR5cGVvZiBhT3JpZ2luYWwubGluZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcgK1xuICAgICAgICAgICAgJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnICtcbiAgICAgICAgICAgICdudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XTtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgISFhUGF0aC5tYXRjaCh1cmxSZWdleHApO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiLyohXG4gKiBzcGxpdC1zdHJpbmcgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3NwbGl0LXN0cmluZz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICAvLyBhbGxvdyBzZXBhcmF0b3IgdG8gYmUgZGVmaW5lZCBhcyBhIHN0cmluZ1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgc2VwOiBvcHRpb25zIH07XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7c2VwOiAnLid9LCBvcHRpb25zKTtcbiAgdmFyIHF1b3RlcyA9IG9wdHMucXVvdGVzIHx8IFsnXCInLCBcIidcIiwgJ2AnXTtcbiAgdmFyIGJyYWNrZXRzO1xuXG4gIGlmIChvcHRzLmJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgYnJhY2tldHMgPSB7XG4gICAgICAnPCc6ICc+JyxcbiAgICAgICcoJzogJyknLFxuICAgICAgJ1snOiAnXScsXG4gICAgICAneyc6ICd9J1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3B0cy5icmFja2V0cykge1xuICAgIGJyYWNrZXRzID0gb3B0cy5icmFja2V0cztcbiAgfVxuXG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBhcnIgPSBbJyddO1xuICB2YXIgc2VwID0gb3B0cy5zZXA7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBjbG9zZUlkeDtcblxuICBmdW5jdGlvbiBleHBlY3RlZCgpIHtcbiAgICBpZiAoYnJhY2tldHMgJiYgc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYnJhY2tldHNbc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBjaCA9IHN0cltpZHhdO1xuICAgIHZhciBuZXh0ID0gc3RyW2lkeCArIDFdO1xuICAgIHZhciB0b2sgPSB7IHZhbDogY2gsIGlkeDogaWR4LCBhcnI6IGFyciwgc3RyOiBzdHIgfTtcbiAgICB0b2tlbnMucHVzaCh0b2spO1xuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgIHRvay52YWwgPSBrZWVwRXNjYXBpbmcob3B0cywgc3RyLCBpZHgpID09PSB0cnVlID8gKGNoICsgbmV4dCkgOiBuZXh0O1xuICAgICAgdG9rLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbih0b2spO1xuICAgICAgfVxuICAgICAgYXJyW2Fyci5sZW5ndGggLSAxXSArPSB0b2sudmFsO1xuICAgICAgaWR4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYnJhY2tldHMgJiYgYnJhY2tldHNbY2hdKSB7XG4gICAgICBzdGFjay5wdXNoKGNoKTtcbiAgICAgIHZhciBlID0gZXhwZWN0ZWQoKTtcbiAgICAgIHZhciBpID0gaWR4ICsgMTtcblxuICAgICAgaWYgKHN0ci5pbmRleE9mKGUsIGkgKyAxKSAhPT0gLTEpIHtcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgdmFyIHMgPSBzdHJbKytpXTtcbiAgICAgICAgICBpZiAocyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBzKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocXVvdGVzLmluZGV4T2YocykgIT09IC0xKSB7XG4gICAgICAgICAgICBpID0gZ2V0Q2xvc2luZ1F1b3RlKHN0ciwgcywgaSArIDEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZSA9IGV4cGVjdGVkKCk7XG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAmJiBzdHIuaW5kZXhPZihlLCBpICsgMSkgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnJhY2tldHNbc10pIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsb3NlSWR4ID0gaTtcbiAgICAgIGlmIChjbG9zZUlkeCA9PT0gLTEpIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGggLSAxXSArPSBjaDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RyLnNsaWNlKGlkeCwgY2xvc2VJZHggKyAxKTtcbiAgICAgIHRvay52YWwgPSBjaDtcbiAgICAgIHRvay5pZHggPSBpZHggPSBjbG9zZUlkeDtcbiAgICB9XG5cbiAgICBpZiAocXVvdGVzLmluZGV4T2YoY2gpICE9PSAtMSkge1xuICAgICAgY2xvc2VJZHggPSBnZXRDbG9zaW5nUXVvdGUoc3RyLCBjaCwgaWR4ICsgMSk7XG4gICAgICBpZiAoY2xvc2VJZHggPT09IC0xKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoIC0gMV0gKz0gY2g7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2VlcFF1b3RlcyhjaCwgb3B0cykgPT09IHRydWUpIHtcbiAgICAgICAgY2ggPSBzdHIuc2xpY2UoaWR4LCBjbG9zZUlkeCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2ggPSBzdHIuc2xpY2UoaWR4ICsgMSwgY2xvc2VJZHgpO1xuICAgICAgfVxuXG4gICAgICB0b2sudmFsID0gY2g7XG4gICAgICB0b2suaWR4ID0gaWR4ID0gY2xvc2VJZHg7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4odG9rLCB0b2tlbnMpO1xuICAgICAgY2ggPSB0b2sudmFsO1xuICAgICAgaWR4ID0gdG9rLmlkeDtcbiAgICB9XG5cbiAgICBpZiAodG9rLnZhbCA9PT0gc2VwICYmIHRvay5zcGxpdCAhPT0gZmFsc2UpIHtcbiAgICAgIGFyci5wdXNoKCcnKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFyclthcnIubGVuZ3RoIC0gMV0gKz0gdG9rLnZhbDtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuXG5mdW5jdGlvbiBnZXRDbG9zaW5nUXVvdGUoc3RyLCBjaCwgaSwgYnJhY2tldHMpIHtcbiAgdmFyIGlkeCA9IHN0ci5pbmRleE9mKGNoLCBpKTtcbiAgaWYgKHN0ci5jaGFyQXQoaWR4IC0gMSkgPT09ICdcXFxcJykge1xuICAgIHJldHVybiBnZXRDbG9zaW5nUXVvdGUoc3RyLCBjaCwgaWR4ICsgMSk7XG4gIH1cbiAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24ga2VlcFF1b3RlcyhjaCwgb3B0cykge1xuICBpZiAob3B0cy5rZWVwRG91YmxlUXVvdGVzID09PSB0cnVlICYmIGNoID09PSAnXCInKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9wdHMua2VlcFNpbmdsZVF1b3RlcyA9PT0gdHJ1ZSAmJiBjaCA9PT0gXCInXCIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gb3B0cy5rZWVwUXVvdGVzO1xufVxuXG5mdW5jdGlvbiBrZWVwRXNjYXBpbmcob3B0cywgc3RyLCBpZHgpIHtcbiAgaWYgKHR5cGVvZiBvcHRzLmtlZXBFc2NhcGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRzLmtlZXBFc2NhcGluZyhzdHIsIGlkeCk7XG4gIH1cbiAgcmV0dXJuIG9wdHMua2VlcEVzY2FwaW5nID09PSB0cnVlIHx8IHN0cltpZHggKyAxXSA9PT0gJ1xcXFwnO1xufVxuIiwiLyohXG4gKiBzdGF0aWMtZXh0ZW5kIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9zdGF0aWMtZXh0ZW5kPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29weSA9IHJlcXVpcmUoJ29iamVjdC1jb3B5Jyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGV4dGVuZGluZyB0aGUgc3RhdGljIHByb3BlcnRpZXMsXG4gKiBwcm90b3R5cGUgcHJvcGVydGllcywgYW5kIGRlc2NyaXB0b3JzIGZyb20gdGhlIGBQYXJlbnRgXG4gKiBjb25zdHJ1Y3RvciBvbnRvIGBDaGlsZGAgY29uc3RydWN0b3JzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0ZW5kID0gcmVxdWlyZSgnc3RhdGljLWV4dGVuZCcpO1xuICogUGFyZW50LmV4dGVuZCA9IGV4dGVuZChQYXJlbnQpO1xuICpcbiAqIC8vIG9wdGlvbmFsbHkgcGFzcyBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIGFyZ1xuICogUGFyZW50LmV4dGVuZCA9IGV4dGVuZChQYXJlbnQsIGZ1bmN0aW9uKENoaWxkKSB7XG4gKiAgIENoaWxkLnByb3RvdHlwZS5taXhpbiA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gKiAgICAgQ2hpbGQucHJvdG90eXBlW2tleV0gPSB2YWw7XG4gKiAgIH07XG4gKiB9KTtcbiAqXG4gKiAvLyBleHRlbmQgXCJjaGlsZFwiIGNvbnN0cnVjdG9yc1xuICogUGFyZW50LmV4dGVuZChDaGlsZCk7XG4gKlxuICogLy8gb3B0aW9uYWxseSBkZWZpbmUgcHJvdG90eXBlIG1ldGhvZHMgYXMgdGhlIHNlY29uZCBhcmdcbiAqIFBhcmVudC5leHRlbmQoQ2hpbGQsIHtcbiAqICAgZm9vOiBmdW5jdGlvbigpIHt9LFxuICogICBiYXI6IGZ1bmN0aW9uKCkge31cbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgUGFyZW50YCBQYXJlbnQgY3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGV4dGVuZEZuYCBPcHRpb25hbCBleHRlbmQgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFueSBuZWNlc3NhcnkgY3VzdG9tIG1lcmdpbmcuIFVzZWZ1bCB3aGVuIHVwZGF0aW5nIG1ldGhvZHMgdGhhdCByZXF1aXJlIGEgc3BlY2lmaWMgcHJvdG90eXBlLlxuICogICBAcGFyYW0ge0Z1bmN0aW9ufSBgQ2hpbGRgIENoaWxkIGN0b3JcbiAqICAgQHBhcmFtIHtPYmplY3R9IGBwcm90b2AgT3B0aW9uYWxseSBwYXNzIGFkZGl0aW9uYWwgcHJvdG90eXBlIHByb3BlcnRpZXMgdG8gaW5oZXJpdC5cbiAqICAgQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBleHRlbmQoUGFyZW50LCBleHRlbmRGbikge1xuICBpZiAodHlwZW9mIFBhcmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIFBhcmVudCB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKEN0b3IsIHByb3RvKSB7XG4gICAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBDdG9yIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdXRpbC5pbmhlcml0cyhDdG9yLCBQYXJlbnQpO1xuICAgIGNvcHkoQ3RvciwgUGFyZW50KTtcblxuICAgIC8vIHByb3RvIGNhbiBiZSBudWxsIG9yIGEgcGxhaW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBwcm90byA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgQ3Rvci5wcm90b3R5cGVba10gPSBvYmpba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHByb3RvdHlwZVxuICAgIGRlZmluZShDdG9yLnByb3RvdHlwZSwgJ19wYXJlbnRfJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiBmdW5jdGlvbigpIHt9LFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhcmVudC5wcm90b3R5cGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGV4dGVuZEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBleHRlbmRGbihDdG9yLCBQYXJlbnQpO1xuICAgIH1cblxuICAgIEN0b3IuZXh0ZW5kID0gZXh0ZW5kKEN0b3IsIGV4dGVuZEZuKTtcbiAgfTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBleHRlbmRgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiLyohXG4gKiB0by1vYmplY3QtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvdG8tb2JqZWN0LXBhdGg+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9QYXRoKGFyZ3MpIHtcbiAgaWYgKHR5cGVPZihhcmdzKSAhPT0gJ2FyZ3VtZW50cycpIHtcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICB9XG4gIHJldHVybiBmaWx0ZXIoYXJncykuam9pbignLicpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyKGFycikge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgcmVzID0gW107XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGVsZSA9IGFycltpZHhdO1xuICAgIGlmICh0eXBlT2YoZWxlKSA9PT0gJ2FyZ3VtZW50cycgfHwgQXJyYXkuaXNBcnJheShlbGUpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIGZpbHRlcihlbGUpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXMucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuIiwiLyohXG4gKiB0by1yZWdleC1yYW5nZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvdG8tcmVnZXgtcmFuZ2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCdpcy1udW1iZXInKTtcbnZhciBjYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB0b1JlZ2V4UmFuZ2UobWluLCBtYXgsIG9wdGlvbnMpIHtcbiAgaWYgKGlzTnVtYmVyKG1pbikgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RvUmVnZXhSYW5nZTogZmlyc3QgYXJndW1lbnQgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyB8fCBtaW4gPT09IG1heCkge1xuICAgIHJldHVybiBTdHJpbmcobWluKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihtYXgpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0b1JlZ2V4UmFuZ2U6IHNlY29uZCBhcmd1bWVudCBpcyBpbnZhbGlkLicpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciByZWxheCA9IFN0cmluZyhvcHRpb25zLnJlbGF4WmVyb3MpO1xuICB2YXIgc2hvcnRoYW5kID0gU3RyaW5nKG9wdGlvbnMuc2hvcnRoYW5kKTtcbiAgdmFyIGNhcHR1cmUgPSBTdHJpbmcob3B0aW9ucy5jYXB0dXJlKTtcbiAgdmFyIGtleSA9IG1pbiArICc6JyArIG1heCArICc9JyArIHJlbGF4ICsgc2hvcnRoYW5kICsgY2FwdHVyZTtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGVba2V5XS5yZXN1bHQ7XG4gIH1cblxuICB2YXIgYSA9IE1hdGgubWluKG1pbiwgbWF4KTtcbiAgdmFyIGIgPSBNYXRoLm1heChtaW4sIG1heCk7XG5cbiAgaWYgKE1hdGguYWJzKGEgLSBiKSA9PT0gMSkge1xuICAgIHZhciByZXN1bHQgPSBtaW4gKyAnfCcgKyBtYXg7XG4gICAgaWYgKG9wdGlvbnMuY2FwdHVyZSkge1xuICAgICAgcmV0dXJuICcoJyArIHJlc3VsdCArICcpJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1BhZGRlZCA9IHBhZGRpbmcobWluKSB8fCBwYWRkaW5nKG1heCk7XG4gIHZhciBwb3NpdGl2ZXMgPSBbXTtcbiAgdmFyIG5lZ2F0aXZlcyA9IFtdO1xuXG4gIHZhciB0b2sgPSB7bWluOiBtaW4sIG1heDogbWF4LCBhOiBhLCBiOiBifTtcbiAgaWYgKGlzUGFkZGVkKSB7XG4gICAgdG9rLmlzUGFkZGVkID0gaXNQYWRkZWQ7XG4gICAgdG9rLm1heExlbiA9IFN0cmluZyh0b2subWF4KS5sZW5ndGg7XG4gIH1cblxuICBpZiAoYSA8IDApIHtcbiAgICB2YXIgbmV3TWluID0gYiA8IDAgPyBNYXRoLmFicyhiKSA6IDE7XG4gICAgdmFyIG5ld01heCA9IE1hdGguYWJzKGEpO1xuICAgIG5lZ2F0aXZlcyA9IHNwbGl0VG9QYXR0ZXJucyhuZXdNaW4sIG5ld01heCwgdG9rLCBvcHRpb25zKTtcbiAgICBhID0gdG9rLmEgPSAwO1xuICB9XG5cbiAgaWYgKGIgPj0gMCkge1xuICAgIHBvc2l0aXZlcyA9IHNwbGl0VG9QYXR0ZXJucyhhLCBiLCB0b2ssIG9wdGlvbnMpO1xuICB9XG5cbiAgdG9rLm5lZ2F0aXZlcyA9IG5lZ2F0aXZlcztcbiAgdG9rLnBvc2l0aXZlcyA9IHBvc2l0aXZlcztcbiAgdG9rLnJlc3VsdCA9IHNpZnRQYXR0ZXJucyhuZWdhdGl2ZXMsIHBvc2l0aXZlcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMuY2FwdHVyZSAmJiAocG9zaXRpdmVzLmxlbmd0aCArIG5lZ2F0aXZlcy5sZW5ndGgpID4gMSkge1xuICAgIHRvay5yZXN1bHQgPSAnKCcgKyB0b2sucmVzdWx0ICsgJyknO1xuICB9XG5cbiAgY2FjaGVba2V5XSA9IHRvaztcbiAgcmV0dXJuIHRvay5yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNpZnRQYXR0ZXJucyhuZWcsIHBvcywgb3B0aW9ucykge1xuICB2YXIgb25seU5lZ2F0aXZlID0gZmlsdGVyUGF0dGVybnMobmVnLCBwb3MsICctJywgZmFsc2UsIG9wdGlvbnMpIHx8IFtdO1xuICB2YXIgb25seVBvc2l0aXZlID0gZmlsdGVyUGF0dGVybnMocG9zLCBuZWcsICcnLCBmYWxzZSwgb3B0aW9ucykgfHwgW107XG4gIHZhciBpbnRlcnNlY3RlZCA9IGZpbHRlclBhdHRlcm5zKG5lZywgcG9zLCAnLT8nLCB0cnVlLCBvcHRpb25zKSB8fCBbXTtcbiAgdmFyIHN1YnBhdHRlcm5zID0gb25seU5lZ2F0aXZlLmNvbmNhdChpbnRlcnNlY3RlZCkuY29uY2F0KG9ubHlQb3NpdGl2ZSk7XG4gIHJldHVybiBzdWJwYXR0ZXJucy5qb2luKCd8Jyk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0VG9SYW5nZXMobWluLCBtYXgpIHtcbiAgbWluID0gTnVtYmVyKG1pbik7XG4gIG1heCA9IE51bWJlcihtYXgpO1xuXG4gIHZhciBuaW5lcyA9IDE7XG4gIHZhciBzdG9wcyA9IFttYXhdO1xuICB2YXIgc3RvcCA9ICtjb3VudE5pbmVzKG1pbiwgbmluZXMpO1xuXG4gIHdoaWxlIChtaW4gPD0gc3RvcCAmJiBzdG9wIDw9IG1heCkge1xuICAgIHN0b3BzID0gcHVzaChzdG9wcywgc3RvcCk7XG4gICAgbmluZXMgKz0gMTtcbiAgICBzdG9wID0gK2NvdW50TmluZXMobWluLCBuaW5lcyk7XG4gIH1cblxuICB2YXIgemVyb3MgPSAxO1xuICBzdG9wID0gY291bnRaZXJvcyhtYXggKyAxLCB6ZXJvcykgLSAxO1xuXG4gIHdoaWxlIChtaW4gPCBzdG9wICYmIHN0b3AgPD0gbWF4KSB7XG4gICAgc3RvcHMgPSBwdXNoKHN0b3BzLCBzdG9wKTtcbiAgICB6ZXJvcyArPSAxO1xuICAgIHN0b3AgPSBjb3VudFplcm9zKG1heCArIDEsIHplcm9zKSAtIDE7XG4gIH1cblxuICBzdG9wcy5zb3J0KGNvbXBhcmUpO1xuICByZXR1cm4gc3RvcHM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHJhbmdlIHRvIGEgcmVnZXggcGF0dGVyblxuICogQHBhcmFtIHtOdW1iZXJ9IGBzdGFydGBcbiAqIEBwYXJhbSB7TnVtYmVyfSBgc3RvcGBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByYW5nZVRvUGF0dGVybihzdGFydCwgc3RvcCwgb3B0aW9ucykge1xuICBpZiAoc3RhcnQgPT09IHN0b3ApIHtcbiAgICByZXR1cm4ge3BhdHRlcm46IFN0cmluZyhzdGFydCksIGRpZ2l0czogW119O1xuICB9XG5cbiAgdmFyIHppcHBlZCA9IHppcChTdHJpbmcoc3RhcnQpLCBTdHJpbmcoc3RvcCkpO1xuICB2YXIgbGVuID0gemlwcGVkLmxlbmd0aCwgaSA9IC0xO1xuXG4gIHZhciBwYXR0ZXJuID0gJyc7XG4gIHZhciBkaWdpdHMgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICB2YXIgbnVtYmVycyA9IHppcHBlZFtpXTtcbiAgICB2YXIgc3RhcnREaWdpdCA9IG51bWJlcnNbMF07XG4gICAgdmFyIHN0b3BEaWdpdCA9IG51bWJlcnNbMV07XG5cbiAgICBpZiAoc3RhcnREaWdpdCA9PT0gc3RvcERpZ2l0KSB7XG4gICAgICBwYXR0ZXJuICs9IHN0YXJ0RGlnaXQ7XG5cbiAgICB9IGVsc2UgaWYgKHN0YXJ0RGlnaXQgIT09ICcwJyB8fCBzdG9wRGlnaXQgIT09ICc5Jykge1xuICAgICAgcGF0dGVybiArPSB0b0NoYXJhY3RlckNsYXNzKHN0YXJ0RGlnaXQsIHN0b3BEaWdpdCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRzICs9IDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpZ2l0cykge1xuICAgIHBhdHRlcm4gKz0gb3B0aW9ucy5zaG9ydGhhbmQgPyAnXFxcXGQnIDogJ1swLTldJztcbiAgfVxuXG4gIHJldHVybiB7IHBhdHRlcm46IHBhdHRlcm4sIGRpZ2l0czogW2RpZ2l0c10gfTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb1BhdHRlcm5zKG1pbiwgbWF4LCB0b2ssIG9wdGlvbnMpIHtcbiAgdmFyIHJhbmdlcyA9IHNwbGl0VG9SYW5nZXMobWluLCBtYXgpO1xuICB2YXIgbGVuID0gcmFuZ2VzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuXG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gbWluO1xuICB2YXIgcHJldjtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaWR4XTtcbiAgICB2YXIgb2JqID0gcmFuZ2VUb1BhdHRlcm4oc3RhcnQsIHJhbmdlLCBvcHRpb25zKTtcbiAgICB2YXIgemVyb3MgPSAnJztcblxuICAgIGlmICghdG9rLmlzUGFkZGVkICYmIHByZXYgJiYgcHJldi5wYXR0ZXJuID09PSBvYmoucGF0dGVybikge1xuICAgICAgaWYgKHByZXYuZGlnaXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcHJldi5kaWdpdHMucG9wKCk7XG4gICAgICB9XG4gICAgICBwcmV2LmRpZ2l0cy5wdXNoKG9iai5kaWdpdHNbMF0pO1xuICAgICAgcHJldi5zdHJpbmcgPSBwcmV2LnBhdHRlcm4gKyB0b1F1YW50aWZpZXIocHJldi5kaWdpdHMpO1xuICAgICAgc3RhcnQgPSByYW5nZSArIDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rLmlzUGFkZGVkKSB7XG4gICAgICB6ZXJvcyA9IHBhZFplcm9zKHJhbmdlLCB0b2spO1xuICAgIH1cblxuICAgIG9iai5zdHJpbmcgPSB6ZXJvcyArIG9iai5wYXR0ZXJuICsgdG9RdWFudGlmaWVyKG9iai5kaWdpdHMpO1xuICAgIHRva2Vucy5wdXNoKG9iaik7XG4gICAgc3RhcnQgPSByYW5nZSArIDE7XG4gICAgcHJldiA9IG9iajtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclBhdHRlcm5zKGFyciwgY29tcGFyaXNvbiwgcHJlZml4LCBpbnRlcnNlY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRvayA9IGFycltpXTtcbiAgICB2YXIgZWxlID0gdG9rLnN0cmluZztcblxuICAgIGlmIChvcHRpb25zLnJlbGF4WmVyb3MgIT09IGZhbHNlKSB7XG4gICAgICBpZiAocHJlZml4ID09PSAnLScgJiYgZWxlLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChlbGUuY2hhckF0KDEpID09PSAneycpIHtcbiAgICAgICAgICBlbGUgPSAnMConICsgZWxlLnJlcGxhY2UoL14wXFx7XFxkK1xcfS8sICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGUgPSAnMConICsgZWxlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnNlY3Rpb24gJiYgIWNvbnRhaW5zKGNvbXBhcmlzb24sICdzdHJpbmcnLCBlbGUpKSB7XG4gICAgICByZXMucHVzaChwcmVmaXggKyBlbGUpO1xuICAgIH1cblxuICAgIGlmIChpbnRlcnNlY3Rpb24gJiYgY29udGFpbnMoY29tcGFyaXNvbiwgJ3N0cmluZycsIGVsZSkpIHtcbiAgICAgIHJlcy5wdXNoKHByZWZpeCArIGVsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogWmlwIHN0cmluZ3MgKGBmb3IgaW5gIGNhbiBiZSB1c2VkIG9uIHN0cmluZyBjaGFyYWN0ZXJzKVxuICovXG5cbmZ1bmN0aW9uIHppcChhLCBiKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yICh2YXIgY2ggaW4gYSkgYXJyLnB1c2goW2FbY2hdLCBiW2NoXV0pO1xuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gMSA6IGIgPiBhID8gLTEgOiAwO1xufVxuXG5mdW5jdGlvbiBwdXNoKGFyciwgZWxlKSB7XG4gIGlmIChhcnIuaW5kZXhPZihlbGUpID09PSAtMSkgYXJyLnB1c2goZWxlKTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYXJyLCBrZXksIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV1ba2V5XSA9PT0gdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb3VudE5pbmVzKG1pbiwgbGVuKSB7XG4gIHJldHVybiBTdHJpbmcobWluKS5zbGljZSgwLCAtbGVuKSArIHJlcGVhdCgnOScsIGxlbik7XG59XG5cbmZ1bmN0aW9uIGNvdW50WmVyb3MoaW50ZWdlciwgemVyb3MpIHtcbiAgcmV0dXJuIGludGVnZXIgLSAoaW50ZWdlciAlIE1hdGgucG93KDEwLCB6ZXJvcykpO1xufVxuXG5mdW5jdGlvbiB0b1F1YW50aWZpZXIoZGlnaXRzKSB7XG4gIHZhciBzdGFydCA9IGRpZ2l0c1swXTtcbiAgdmFyIHN0b3AgPSBkaWdpdHNbMV0gPyAoJywnICsgZGlnaXRzWzFdKSA6ICcnO1xuICBpZiAoIXN0b3AgJiYgKCFzdGFydCB8fCBzdGFydCA9PT0gMSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuICd7JyArIHN0YXJ0ICsgc3RvcCArICd9Jztcbn1cblxuZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhhLCBiKSB7XG4gIHJldHVybiAnWycgKyBhICsgKChiIC0gYSA9PT0gMSkgPyAnJyA6ICctJykgKyBiICsgJ10nO1xufVxuXG5mdW5jdGlvbiBwYWRkaW5nKHN0cikge1xuICByZXR1cm4gL14tPygwKylcXGQvLmV4ZWMoc3RyKTtcbn1cblxuZnVuY3Rpb24gcGFkWmVyb3ModmFsLCB0b2spIHtcbiAgaWYgKHRvay5pc1BhZGRlZCkge1xuICAgIHZhciBkaWZmID0gTWF0aC5hYnModG9rLm1heExlbiAtIFN0cmluZyh2YWwpLmxlbmd0aCk7XG4gICAgc3dpdGNoIChkaWZmKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuICcweycgKyBkaWZmICsgJ30nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgdG9SZWdleFJhbmdlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdG9SZWdleFJhbmdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2FmZSA9IHJlcXVpcmUoJ3NhZmUtcmVnZXgnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIG5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIE1BWF9MRU5HVEggPSAxMDI0ICogNjQ7XG5cbi8qKlxuICogU2Vzc2lvbiBjYWNoZVxuICovXG5cbnZhciBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBgcGF0dGVybmAgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gYHBhdHRlcm5gIFBhdHRlcm4gY2FuIGJlIGEgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0dGVybnMpKSB7XG4gICAgcmV0dXJuIG1ha2VSZShwYXR0ZXJucywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG1ha2VSZShwYXR0ZXJucy5qb2luKCd8JyksIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gYHBhdHRlcm5gIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGBwYXR0ZXJuYCBQYXR0ZXJuIGNhbiBiZSBhIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1ha2VSZShwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICB2YXIga2V5ID0gcGF0dGVybjtcbiAgLy8gZG8gdGhpcyBiZWZvcmUgc2hhbGxvdyBjbG9uaW5nIG9wdGlvbnMsIGl0J3MgYSBsb3QgZmFzdGVyXG4gIGlmICghb3B0aW9ucyB8fCAob3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlICE9PSBmYWxzZSkpIHtcbiAgICBrZXkgPSBjcmVhdGVLZXkocGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBpZiAob3B0cy5jb250YWlucyA9PT0gdHJ1ZSkge1xuICAgIGlmIChvcHRzLm5lZ2F0ZSA9PT0gdHJ1ZSkge1xuICAgICAgb3B0cy5zdHJpY3ROZWdhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5zdHJpY3QgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5zdHJpY3QgPT09IGZhbHNlKSB7XG4gICAgb3B0cy5zdHJpY3RPcGVuID0gZmFsc2U7XG4gICAgb3B0cy5zdHJpY3RDbG9zZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIG9wZW4gPSBvcHRzLnN0cmljdE9wZW4gIT09IGZhbHNlID8gJ14nIDogJyc7XG4gIHZhciBjbG9zZSA9IG9wdHMuc3RyaWN0Q2xvc2UgIT09IGZhbHNlID8gJyQnIDogJyc7XG4gIHZhciBmbGFncyA9IG9wdHMuZmxhZ3MgfHwgJyc7XG4gIHZhciByZWdleDtcblxuICBpZiAob3B0cy5ub2Nhc2UgPT09IHRydWUgJiYgIS9pLy50ZXN0KGZsYWdzKSkge1xuICAgIGZsYWdzICs9ICdpJztcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKG9wdHMubmVnYXRlIHx8IHR5cGVvZiBvcHRzLnN0cmljdE5lZ2F0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBwYXR0ZXJuID0gbm90LmNyZWF0ZShwYXR0ZXJuLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyID0gb3BlbiArICcoPzonICsgcGF0dGVybiArICcpJyArIGNsb3NlO1xuICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcblxuICAgIGlmIChvcHRzLnNhZmUgPT09IHRydWUgJiYgc2FmZShyZWdleCkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvdGVudGlhbGx5IHVuc2FmZSByZWd1bGFyIGV4cHJlc3Npb246ICcgKyByZWdleC5zb3VyY2UpO1xuICAgIH1cblxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAob3B0cy5zdHJpY3RFcnJvcnMgPT09IHRydWUgfHwgb3B0cy5zYWZlID09PSB0cnVlKSB7XG4gICAgICBlcnIua2V5ID0ga2V5O1xuICAgICAgZXJyLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgZXJyLm9yaWdpbmFsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBlcnIuY3JlYXRlZE9wdGlvbnMgPSBvcHRzO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgcGF0dGVybi5yZXBsYWNlKC8oXFxXKS9nLCAnXFxcXCQxJykgKyAnJCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVnZXggPSAvLl4vOyAvLzw9IG1hdGNoIG5vdGhpbmdcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5jYWNoZSAhPT0gZmFsc2UpIHtcbiAgICBtZW1vaXplKHJlZ2V4LCBrZXksIHBhdHRlcm4sIG9wdHMpO1xuICB9XG4gIHJldHVybiByZWdleDtcbn1cblxuLyoqXG4gKiBNZW1vaXplIGdlbmVyYXRlZCByZWdleC4gVGhpcyBjYW4gcmVzdWx0IGluIGRyYW1hdGljIHNwZWVkIGltcHJvdmVtZW50c1xuICogYW5kIHNpbXBsaWZ5IGRlYnVnZ2luZyBieSBhZGRpbmcgb3B0aW9ucyBhbmQgcGF0dGVybiB0byB0aGUgcmVnZXguIEl0IGNhbiBiZVxuICogZGlzYWJsZWQgYnkgcGFzc2luZyBzZXR0aW5nIGBvcHRpb25zLmNhY2hlYCB0byBmYWxzZS5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplKHJlZ2V4LCBrZXksIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgZGVmaW5lKHJlZ2V4LCAnY2FjaGVkJywgdHJ1ZSk7XG4gIGRlZmluZShyZWdleCwgJ3BhdHRlcm4nLCBwYXR0ZXJuKTtcbiAgZGVmaW5lKHJlZ2V4LCAnb3B0aW9ucycsIG9wdGlvbnMpO1xuICBkZWZpbmUocmVnZXgsICdrZXknLCBrZXkpO1xuICBjYWNoZVtrZXldID0gcmVnZXg7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBrZXkgdG8gdXNlIGZvciBtZW1vaXphdGlvbi4gVGhlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgcmV0dXJuIHBhdHRlcm47XG4gIHZhciBrZXkgPSBwYXR0ZXJuO1xuICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAga2V5ICs9ICc7JyArIHByb3AgKyAnPScgKyBTdHJpbmcob3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbi8qKlxuICogRXhwb3NlIGBtYWtlUmVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMubWFrZVJlID0gbWFrZVJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpcy1leHRlbmRhYmxlJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCdhcnItdW5pb24nKTtcbnZhciBnZXQgPSByZXF1aXJlKCdnZXQtdmFsdWUnKTtcbnZhciBzZXQgPSByZXF1aXJlKCdzZXQtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bmlvblZhbHVlKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5pb24tdmFsdWUgZXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uLXZhbHVlIGV4cGVjdHMgYHByb3BgIHRvIGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIGFyciA9IGFycmF5aWZ5KGdldChvYmosIHByb3ApKTtcbiAgc2V0KG9iaiwgcHJvcCwgdW5pb24oYXJyLCBhcnJheWlmeSh2YWx1ZSkpKTtcbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIGFycmF5aWZ5KHZhbCkge1xuICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBbdmFsXTtcbn1cbiIsIi8qIVxuICogdW5zZXQtdmFsdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3Vuc2V0LXZhbHVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcy12YWx1ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuc2V0KG9iaiwgcHJvcCkge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzKG9iaiwgcHJvcCkpIHtcbiAgICB2YXIgc2VncyA9IHByb3Auc3BsaXQoJy4nKTtcbiAgICB2YXIgbGFzdCA9IHNlZ3MucG9wKCk7XG4gICAgd2hpbGUgKHNlZ3MubGVuZ3RoICYmIHNlZ3Nbc2Vncy5sZW5ndGggLSAxXS5zbGljZSgtMSkgPT09ICdcXFxcJykge1xuICAgICAgbGFzdCA9IHNlZ3MucG9wKCkuc2xpY2UoMCwgLTEpICsgJy4nICsgbGFzdDtcbiAgICB9XG4gICAgd2hpbGUgKHNlZ3MubGVuZ3RoKSBvYmogPSBvYmpbcHJvcCA9IHNlZ3Muc2hpZnQoKV07XG4gICAgcmV0dXJuIChkZWxldGUgb2JqW2xhc3RdKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIGhhcy12YWx1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaGFzLXZhbHVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE2LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgaGFzVmFsdWVzID0gcmVxdWlyZSgnaGFzLXZhbHVlcycpO1xudmFyIGdldCA9IHJlcXVpcmUoJ2dldC12YWx1ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgbm9aZXJvKSB7XG4gIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyhnZXQob2JqLCBwcm9wKSwgbm9aZXJvKTtcbiAgfVxuICByZXR1cm4gaGFzVmFsdWVzKG9iaiwgcHJvcCk7XG59O1xuIiwiLyohXG4gKiBpc29iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXNvYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBpc0FycmF5KHZhbCkgPT09IGZhbHNlO1xufTtcbiIsIi8qIVxuICogaGFzLXZhbHVlcyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaGFzLXZhbHVlcz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1ZhbHVlKG8sIG5vWmVybykge1xuICBpZiAobyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIG8gPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvID09PSAnbnVtYmVyJykge1xuICAgIGlmIChvID09PSAwICYmIG5vWmVybyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIi8qKlxuKiB1cGF0aCBodHRwOi8vZ2l0aHViLmNvbS9hbm9keW5vcy91cGF0aC9cbipcbiogQSBwcm94eSB0byBgcGF0aGAsIHJlcGxhY2luZyBgXFxgIHdpdGggYC9gIGZvciBhbGwgcmVzdWx0cyAmIG5ldyBtZXRob2RzIHRvIG5vcm1hbGl6ZSAmIGpvaW4ga2VlcGluZyBsZWFkaW5nIGAuL2AgYW5kIGFkZCwgY2hhbmdlLCBkZWZhdWx0LCB0cmltIGZpbGUgZXh0ZW5zaW9ucy5cbiogVmVyc2lvbiAxLjIuMCAtIENvbXBpbGVkIG9uIDIwMTktMDktMDIgMjM6MzM6NTdcbiogUmVwb3NpdG9yeSBnaXQ6Ly9naXRodWIuY29tL2Fub2R5bm9zL3VwYXRoXG4qIENvcHlyaWdodChjKSAyMDE5IEFuZ2Vsb3MgUGlrb3VsYXMgPGFnZWxvcy5waWtvdWxhc0BnbWFpbC5jb20+XG4qIExpY2Vuc2UgTUlUXG4qL1xuXG4vLyBHZW5lcmF0ZWQgYnkgdVJlcXVpcmUgdjAuNy4wLWJldGEuMzMgdGFyZ2V0OiAnbGliJyB0ZW1wbGF0ZTogJ25vZGVqcydcblxuXG52YXIgVkVSU0lPTiA9ICcxLjIuMCc7IC8vIGluamVjdGVkIGJ5IHVyZXF1aXJlLXJjLWluamVjdC12ZXJzaW9uXG5cbnZhciBleHRyYUZuLCBleHRyYUZ1bmN0aW9ucywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsaWRFeHQsIG5hbWUsIHBhdGgsIHByb3BOYW1lLCBwcm9wVmFsdWUsIHRvVW5peCwgdXBhdGgsIHNsaWNlID0gW10uc2xpY2UsIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5wYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRnVuY3Rpb247XG59O1xuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8ICEhdmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XG59O1xudXBhdGggPSBleHBvcnRzO1xudXBhdGguVkVSU0lPTiA9IHR5cGVvZiBWRVJTSU9OICE9PSBcInVuZGVmaW5lZFwiICYmIFZFUlNJT04gIT09IG51bGwgPyBWRVJTSU9OIDogXCJOTy1WRVJTSU9OXCI7XG50b1VuaXggPSBmdW5jdGlvbiAocCkge1xuICB2YXIgZG91YmxlO1xuICBwID0gcC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgZG91YmxlID0gL1xcL1xcLy87XG4gIHdoaWxlIChwLm1hdGNoKGRvdWJsZSkpIHtcbiAgICBwID0gcC5yZXBsYWNlKGRvdWJsZSwgXCIvXCIpO1xuICB9XG4gIHJldHVybiBwO1xufTtcbmZvciAocHJvcE5hbWUgaW4gcGF0aCkge1xuICBwcm9wVmFsdWUgPSBwYXRoW3Byb3BOYW1lXTtcbiAgaWYgKGlzRnVuY3Rpb24ocHJvcFZhbHVlKSkge1xuICAgIHVwYXRoW3Byb3BOYW1lXSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcbiAgICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcocCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1VuaXgocCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IHBhdGhbcHJvcE5hbWVdLmFwcGx5KHBhdGgsIGFyZ3MpO1xuICAgICAgICBpZiAoaXNTdHJpbmcocmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiB0b1VuaXgocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0ocHJvcE5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHVwYXRoW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgfVxufVxudXBhdGguc2VwID0gXCIvXCI7XG5leHRyYUZ1bmN0aW9ucyA9IHtcbiAgdG9Vbml4OiB0b1VuaXgsXG4gIG5vcm1hbGl6ZVNhZmU6IGZ1bmN0aW9uIChwKSB7XG4gICAgcCA9IHRvVW5peChwKTtcbiAgICBpZiAocC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgIGlmIChwLnN0YXJ0c1dpdGgoXCIuLy4uXCIpIHx8IHAgPT09IFwiLi9cIikge1xuICAgICAgICByZXR1cm4gdXBhdGgubm9ybWFsaXplKHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiLi9cIiArIHVwYXRoLm5vcm1hbGl6ZShwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVwYXRoLm5vcm1hbGl6ZShwKTtcbiAgICB9XG4gIH0sXG4gIG5vcm1hbGl6ZVRyaW06IGZ1bmN0aW9uIChwKSB7XG4gICAgcCA9IHVwYXRoLm5vcm1hbGl6ZVNhZmUocCk7XG4gICAgaWYgKHAuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICByZXR1cm4gcC5zbGljZSgwLCArKHAubGVuZ3RoIC0gMikgKyAxIHx8IDkwMDAwMDAwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH0sXG4gIGpvaW5TYWZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHAsIHJlc3VsdDtcbiAgICBwID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmVzdWx0ID0gdXBhdGguam9pbi5hcHBseShudWxsLCBwKTtcbiAgICBpZiAocFswXS5zdGFydHNXaXRoKFwiLi9cIikgJiYgIXJlc3VsdC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgIHJlc3VsdCA9IFwiLi9cIiArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgYWRkRXh0OiBmdW5jdGlvbiAoZmlsZSwgZXh0KSB7XG4gICAgaWYgKCFleHQpIHtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXh0WzBdICE9PSBcIi5cIikge1xuICAgICAgICBleHQgPSBcIi5cIiArIGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWxlICsgKGZpbGUuZW5kc1dpdGgoZXh0KSA/IFwiXCIgOiBleHQpO1xuICAgIH1cbiAgfSxcbiAgdHJpbUV4dDogZnVuY3Rpb24gKGZpbGVuYW1lLCBpZ25vcmVFeHRzLCBtYXhTaXplKSB7XG4gICAgdmFyIG9sZEV4dDtcbiAgICBpZiAobWF4U2l6ZSA9PSBudWxsKSB7XG4gICAgICBtYXhTaXplID0gNztcbiAgICB9XG4gICAgb2xkRXh0ID0gdXBhdGguZXh0bmFtZShmaWxlbmFtZSk7XG4gICAgaWYgKGlzVmFsaWRFeHQob2xkRXh0LCBpZ25vcmVFeHRzLCBtYXhTaXplKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lLnNsaWNlKDAsICsoZmlsZW5hbWUubGVuZ3RoIC0gb2xkRXh0Lmxlbmd0aCAtIDEpICsgMSB8fCA5MDAwMDAwMDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlRXh0OiBmdW5jdGlvbiAoZmlsZW5hbWUsIGV4dCkge1xuICAgIGlmICghZXh0KSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dCA9IGV4dFswXSA9PT0gXCIuXCIgPyBleHQgOiBcIi5cIiArIGV4dDtcbiAgICAgIGlmICh1cGF0aC5leHRuYW1lKGZpbGVuYW1lKSA9PT0gZXh0KSB7XG4gICAgICAgIHJldHVybiB1cGF0aC50cmltRXh0KGZpbGVuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoYW5nZUV4dDogZnVuY3Rpb24gKGZpbGVuYW1lLCBleHQsIGlnbm9yZUV4dHMsIG1heFNpemUpIHtcbiAgICBpZiAobWF4U2l6ZSA9PSBudWxsKSB7XG4gICAgICBtYXhTaXplID0gNztcbiAgICB9XG4gICAgcmV0dXJuIHVwYXRoLnRyaW1FeHQoZmlsZW5hbWUsIGlnbm9yZUV4dHMsIG1heFNpemUpICsgKCFleHQgPyBcIlwiIDogZXh0WzBdID09PSBcIi5cIiA/IGV4dCA6IFwiLlwiICsgZXh0KTtcbiAgfSxcbiAgZGVmYXVsdEV4dDogZnVuY3Rpb24gKGZpbGVuYW1lLCBleHQsIGlnbm9yZUV4dHMsIG1heFNpemUpIHtcbiAgICB2YXIgb2xkRXh0O1xuICAgIGlmIChtYXhTaXplID09IG51bGwpIHtcbiAgICAgIG1heFNpemUgPSA3O1xuICAgIH1cbiAgICBvbGRFeHQgPSB1cGF0aC5leHRuYW1lKGZpbGVuYW1lKTtcbiAgICBpZiAoaXNWYWxpZEV4dChvbGRFeHQsIGlnbm9yZUV4dHMsIG1heFNpemUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1cGF0aC5hZGRFeHQoZmlsZW5hbWUsIGV4dCk7XG4gICAgfVxuICB9XG59O1xuaXNWYWxpZEV4dCA9IGZ1bmN0aW9uIChleHQsIGlnbm9yZUV4dHMsIG1heFNpemUpIHtcbiAgaWYgKGlnbm9yZUV4dHMgPT0gbnVsbCkge1xuICAgIGlnbm9yZUV4dHMgPSBbXTtcbiAgfVxuICByZXR1cm4gZXh0ICYmIGV4dC5sZW5ndGggPD0gbWF4U2l6ZSAmJiBpbmRleE9mLmNhbGwoaWdub3JlRXh0cy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZVswXSAhPT0gXCIuXCIgPyBcIi5cIiA6IFwiXCIpICsgZTtcbiAgfSksIGV4dCkgPCAwO1xufTtcbmZvciAobmFtZSBpbiBleHRyYUZ1bmN0aW9ucykge1xuICBpZiAoIWhhc1Byb3AuY2FsbChleHRyYUZ1bmN0aW9ucywgbmFtZSkpXG4gICAgY29udGludWU7XG4gIGV4dHJhRm4gPSBleHRyYUZ1bmN0aW9uc1tuYW1lXTtcbiAgaWYgKHVwYXRoW25hbWVdICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoLlwiICsgbmFtZSArIFwiIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgfSBlbHNlIHtcbiAgICB1cGF0aFtuYW1lXSA9IGV4dHJhRm47XG4gIH1cbn1cblxuOyIsIi8qIVxuICogdXNlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC91c2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlKGFwcCwgb3B0aW9ucykge1xuICBpZiAoIWlzT2JqZWN0KGFwcCkgJiYgdHlwZW9mIGFwcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdCBvciBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIG9wdHMgPSBpc09iamVjdChvcHRpb25zKSA/IG9wdGlvbnMgOiB7fTtcbiAgdmFyIHByb3AgPSB0eXBlb2Ygb3B0cy5wcm9wID09PSAnc3RyaW5nJyA/IG9wdHMucHJvcCA6ICdmbnMnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXBwW3Byb3BdKSkge1xuICAgIGRlZmluZShhcHAsIHByb3AsIFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwbHVnaW4gZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHVzZS4gVGhlIG9ubHlcbiAgICogcGFyYW1ldGVyIGV4cG9zZWQgdG8gdGhlIHBsdWdpbiBpcyBgYXBwYCwgdGhlIG9iamVjdCBvciBmdW5jdGlvbi5cbiAgICogcGFzc2VkIHRvIGB1c2UoYXBwKWAuIGBhcHBgIGlzIGFsc28gZXhwb3NlZCBhcyBgdGhpc2AgaW4gcGx1Z2lucy5cbiAgICpcbiAgICogQWRkaXRpb25hbGx5LCAqKmlmIGEgcGx1Z2luIHJldHVybnMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIHdpbGxcbiAgICogYmUgcHVzaGVkIG9udG8gdGhlIGBmbnNgIGFycmF5KiosIGFsbG93aW5nIHRoZSBwbHVnaW4gdG8gYmVcbiAgICogY2FsbGVkIGF0IGEgbGF0ZXIgcG9pbnQgYnkgdGhlIGBydW5gIG1ldGhvZC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHVzZSA9IHJlcXVpcmUoJ3VzZScpO1xuICAgKlxuICAgKiAvLyBkZWZpbmUgYSBwbHVnaW5cbiAgICogZnVuY3Rpb24gZm9vKGFwcCkge1xuICAgKiAgIC8vIGRvIHN0dWZmXG4gICAqIH1cbiAgICpcbiAgICogdmFyIGFwcCA9IGZ1bmN0aW9uKCl7fTtcbiAgICogdXNlKGFwcCk7XG4gICAqXG4gICAqIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAgICogYXBwLnVzZShmb28pO1xuICAgKiBhcHAudXNlKGJhcik7XG4gICAqIGFwcC51c2UoYmF6KTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC51c2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYCBwbHVnaW4gZnVuY3Rpb24gdG8gY2FsbFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoYXBwLCAndXNlJywgdXNlKTtcblxuICAvKipcbiAgICogUnVuIGFsbCBwbHVnaW5zIG9uIGBmbnNgLiBBbnkgcGx1Z2luIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uXG4gICAqIHdoZW4gY2FsbGVkIGJ5IGB1c2VgIGlzIHB1c2hlZCBvbnRvIHRoZSBgZm5zYCBhcnJheS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNvbmZpZyA9IHt9O1xuICAgKiBhcHAucnVuKGNvbmZpZyk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAucnVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBgdmFsdWVgIE9iamVjdCB0byBiZSBtb2RpZmllZCBieSBwbHVnaW5zLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG9iamVjdCBwYXNzZWQgdG8gYHJ1bmBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKGFwcCwgJ3J1bicsIGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICghaXNPYmplY3QodmFsKSkgcmV0dXJuO1xuXG4gICAgaWYgKCF2YWwudXNlIHx8ICF2YWwucnVuKSB7XG4gICAgICBkZWZpbmUodmFsLCBwcm9wLCB2YWxbcHJvcF0gfHwgW10pO1xuICAgICAgZGVmaW5lKHZhbCwgJ3VzZScsIHVzZSk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxbcHJvcF0gfHwgdmFsW3Byb3BdLmluZGV4T2YoYmFzZSkgPT09IC0xKSB7XG4gICAgICB2YWwudXNlKGJhc2UpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCBhcHA7XG4gICAgdmFyIGZucyA9IHNlbGZbcHJvcF07XG4gICAgdmFyIGxlbiA9IGZucy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuXG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICB2YWwudXNlKGZuc1tpZHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGwgcGx1Z2luIGBmbmAuIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgcHVzaCBpdCBpbnRvIHRoZVxuICAgKiBgZm5zYCBhcnJheSB0byBiZSBjYWxsZWQgYnkgdGhlIGBydW5gIG1ldGhvZC5cbiAgICovXG5cbiAgZnVuY3Rpb24gdXNlKHR5cGUsIGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGZuID0gd3JhcCh0eXBlLCBmbik7XG4gICAgICBvZmZzZXQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZuO1xuICAgICAgZm4gPSB0eXBlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMgfHwgYXBwO1xuICAgIHZhciBmbnMgPSBzZWxmW3Byb3BdO1xuXG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgb2Zmc2V0KTtcbiAgICBhcmdzLnVuc2hpZnQoc2VsZik7XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuaG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0cy5ob29rLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciB2YWwgPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBmbnMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgZm5zLnB1c2godmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhIG5hbWVkIHBsdWdpbiBmdW5jdGlvbiBzbyB0aGF0IGl0J3Mgb25seSBjYWxsZWQgb24gb2JqZWN0cyBvZiB0aGVcbiAgICogZ2l2ZW4gYHR5cGVgXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYCBQbHVnaW4gZnVuY3Rpb25cbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdyYXAodHlwZSwgZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGx1Z2luKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZSA/IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwbHVnaW47XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBhcHA7XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbFxuICB9KTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsInZhciB0aHJvdWdoID0gcmVxdWlyZSgndGhyb3VnaDInKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNob2tpZGFyID0gcmVxdWlyZSgnY2hva2lkYXInKTtcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XG52YXIgYW55bWF0Y2ggPSByZXF1aXJlKCdhbnltYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdhdGNoaWZ5O1xubW9kdWxlLmV4cG9ydHMuYXJncyA9IHtcbiAgICBjYWNoZToge30sIHBhY2thZ2VDYWNoZToge31cbn07XG5cbmZ1bmN0aW9uIHdhdGNoaWZ5IChiLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgdmFyIGNhY2hlID0gYi5fb3B0aW9ucy5jYWNoZTtcbiAgICB2YXIgcGtnY2FjaGUgPSBiLl9vcHRpb25zLnBhY2thZ2VDYWNoZTtcbiAgICB2YXIgZGVsYXkgPSB0eXBlb2Ygb3B0cy5kZWxheSA9PT0gJ251bWJlcicgPyBvcHRzLmRlbGF5IDogMTAwO1xuICAgIHZhciBjaGFuZ2luZ0RlcHMgPSB7fTtcbiAgICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciB1cGRhdGluZyA9IGZhbHNlO1xuICAgIFxuICAgIHZhciB3b3B0cyA9IHtwZXJzaXN0ZW50OiB0cnVlfTtcbiAgICBpZiAob3B0cy5pZ25vcmVXYXRjaCkge1xuICAgICAgICB2YXIgaWdub3JlZCA9IG9wdHMuaWdub3JlV2F0Y2ggIT09IHRydWVcbiAgICAgICAgICAgID8gb3B0cy5pZ25vcmVXYXRjaFxuICAgICAgICAgICAgOiAnKiovbm9kZV9tb2R1bGVzLyoqJztcbiAgICB9XG4gICAgaWYgKG9wdHMucG9sbCB8fCB0eXBlb2Ygb3B0cy5wb2xsID09PSAnbnVtYmVyJykge1xuICAgICAgICB3b3B0cy51c2VQb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgd29wdHMuaW50ZXJ2YWwgPSBvcHRzLnBvbGwgIT09IHRydWVcbiAgICAgICAgICAgID8gb3B0cy5wb2xsXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgYi5vbigncmVzZXQnLCBjb2xsZWN0KTtcbiAgICAgICAgY29sbGVjdCgpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBjb2xsZWN0ICgpIHtcbiAgICAgICAgYi5waXBlbGluZS5nZXQoJ2RlcHMnKS5wdXNoKHRocm91Z2gub2JqKGZ1bmN0aW9uKHJvdywgZW5jLCBuZXh0KSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IHJvdy5leHBvc2UgPyBiLl9leHBvc2Vbcm93LmlkXSA6IHJvdy5maWxlO1xuICAgICAgICAgICAgY2FjaGVbZmlsZV0gPSB7XG4gICAgICAgICAgICAgICAgc291cmNlOiByb3cuc291cmNlLFxuICAgICAgICAgICAgICAgIGRlcHM6IHh0ZW5kKHJvdy5kZXBzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHVzaChyb3cpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIFxuICAgIGIub24oJ2ZpbGUnLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB3YXRjaEZpbGUoZmlsZSk7XG4gICAgfSk7XG4gICAgXG4gICAgYi5vbigncGFja2FnZScsIGZ1bmN0aW9uIChwa2cpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBwYXRoLmpvaW4ocGtnLl9fZGlybmFtZSwgJ3BhY2thZ2UuanNvbicpO1xuICAgICAgICB3YXRjaEZpbGUoZmlsZSk7XG4gICAgICAgIGlmIChwa2djYWNoZSkgcGtnY2FjaGVbZmlsZV0gPSBwa2c7XG4gICAgfSk7XG4gICAgXG4gICAgYi5vbigncmVzZXQnLCByZXNldCk7XG4gICAgcmVzZXQoKTtcbiAgICBcbiAgICBmdW5jdGlvbiByZXNldCAoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGJ5dGVzID0gMDtcbiAgICAgICAgYi5waXBlbGluZS5nZXQoJ3JlY29yZCcpLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBiLnBpcGVsaW5lLmdldCgnd3JhcCcpLnB1c2godGhyb3VnaCh3cml0ZSwgZW5kKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlIChidWYsIGVuYywgbmV4dCkge1xuICAgICAgICAgICAgYnl0ZXMgKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGltZTtcbiAgICAgICAgICAgIGIuZW1pdCgndGltZScsIGRlbHRhKTtcbiAgICAgICAgICAgIGIuZW1pdCgnYnl0ZXMnLCBieXRlcyk7XG4gICAgICAgICAgICBiLmVtaXQoJ2xvZycsIGJ5dGVzICsgJyBieXRlcyB3cml0dGVuICgnXG4gICAgICAgICAgICAgICAgKyAoZGVsdGEgLyAxMDAwKS50b0ZpeGVkKDIpICsgJyBzZWNvbmRzKSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIGZ3YXRjaGVycyA9IHt9O1xuICAgIHZhciBmd2F0Y2hlckZpbGVzID0ge307XG4gICAgdmFyIGlnbm9yZWRGaWxlcyA9IHt9O1xuICAgIFxuICAgIGIub24oJ3RyYW5zZm9ybScsIGZ1bmN0aW9uICh0ciwgbWZpbGUpIHtcbiAgICAgICAgdHIub24oJ2ZpbGUnLCBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICB3YXRjaEZpbGUobWZpbGUsIGRlcCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGIub24oJ2J1bmRsZScsIGZ1bmN0aW9uIChidW5kbGUpIHtcbiAgICAgICAgdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICBidW5kbGUub24oJ2Vycm9yJywgb25lbmQpO1xuICAgICAgICBidW5kbGUub24oJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgZnVuY3Rpb24gb25lbmQgKCkgeyB1cGRhdGluZyA9IGZhbHNlIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHdhdGNoRmlsZSAoZmlsZSwgZGVwKSB7XG4gICAgICAgIGRlcCA9IGRlcCB8fCBmaWxlO1xuICAgICAgICBpZiAoaWdub3JlZCkge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmVkRmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVkRmlsZXNbZmlsZV0gPSBhbnltYXRjaChpZ25vcmVkLCBmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZ25vcmVkRmlsZXNbZmlsZV0pIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ3YXRjaGVyc1tmaWxlXSkgZndhdGNoZXJzW2ZpbGVdID0gW107XG4gICAgICAgIGlmICghZndhdGNoZXJGaWxlc1tmaWxlXSkgZndhdGNoZXJGaWxlc1tmaWxlXSA9IFtdO1xuICAgICAgICBpZiAoZndhdGNoZXJGaWxlc1tmaWxlXS5pbmRleE9mKGRlcCkgPj0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB3ID0gYi5fd2F0Y2hlcihkZXAsIHdvcHRzKTtcbiAgICAgICAgdy5zZXRNYXhMaXN0ZW5lcnMoMCk7XG4gICAgICAgIHcub24oJ2Vycm9yJywgYi5lbWl0LmJpbmQoYiwgJ2Vycm9yJykpO1xuICAgICAgICB3Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnZhbGlkYXRlKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZndhdGNoZXJzW2ZpbGVdLnB1c2godyk7XG4gICAgICAgIGZ3YXRjaGVyRmlsZXNbZmlsZV0ucHVzaChkZXApO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlIChpZCkge1xuICAgICAgICBpZiAoY2FjaGUpIGRlbGV0ZSBjYWNoZVtpZF07XG4gICAgICAgIGlmIChwa2djYWNoZSkgZGVsZXRlIHBrZ2NhY2hlW2lkXTtcbiAgICAgICAgY2hhbmdpbmdEZXBzW2lkXSA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXVwZGF0aW5nICYmIGZ3YXRjaGVyc1tpZF0pIHtcbiAgICAgICAgICAgIGZ3YXRjaGVyc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgICAgIHcuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIGZ3YXRjaGVyc1tpZF07XG4gICAgICAgICAgICBkZWxldGUgZndhdGNoZXJGaWxlc1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBkaXNrL2VkaXRvciB0byBxdWlldCBkb3duIGZpcnN0OlxuICAgICAgICBpZiAocGVuZGluZykgY2xlYXJUaW1lb3V0KHBlbmRpbmcpO1xuICAgICAgICBwZW5kaW5nID0gc2V0VGltZW91dChub3RpZnksIGRlbGF5KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgICAgICAgaWYgKHVwZGF0aW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gc2V0VGltZW91dChub3RpZnksIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGIuZW1pdCgndXBkYXRlJywgT2JqZWN0LmtleXMoY2hhbmdpbmdEZXBzKSk7XG4gICAgICAgICAgICBjaGFuZ2luZ0RlcHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBiLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3Qua2V5cyhmd2F0Y2hlcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBmd2F0Y2hlcnNbaWRdLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgdy5jbG9zZSgpIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGIuX3dhdGNoZXIgPSBmdW5jdGlvbiAoZmlsZSwgb3B0cykge1xuICAgICAgICByZXR1cm4gY2hva2lkYXIud2F0Y2goZmlsZSwgb3B0cyk7XG4gICAgfTtcblxuICAgIHJldHVybiBiO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIlxubGV0IGRpc3BsYXllZEV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2V4ZXJjaXNlc1RvU2hvd09uSW5kZXguanNcIik7XG5sZXQgcXVpekV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvcXVpei5qc1wiKTtcblxubGV0IGV4ZXJjaXNlcyA9IFsuLi5kaXNwbGF5ZWRFeGVyY2lzZXMsIC4uLnF1aXpFeGVyY2lzZXNdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4ZXJjaXNlczsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICcyRCBBcnJheXMnLFxuICAgIC8vIFBzZXVkb2NvZGUgcHJvYmxlbXMgc2hvdWxkIHN0YXJ0IHdpdGggYSBjYXBpdGFsIGxldHRlclxuICAgIG5hbWU6ICcyZEFycmF5UHJpbnRBbGwnLFxuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMiwgM10sWzQsIDUsIDZdLFs3LCA4LCA5XV0pYCxcbiAgICAgICcoW1syLCAzXSwgWzYsIDRdXSknLFxuICAgICAgJyhbW1wiYVwiLCBcImJcIiwgXCJjXCJdLFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSwgW1wizrFcIixcIs6yXCIsIFwiw6dcIl1dKScsXG4gICAgICAnKFtbMTMsIDZdLCBbMSwgMl0sIFs0LCA2XV0pJyxcbiAgICAgICcoW1szLCAyLCAxLCA0XSxbMSwgMSwgMSwgMV0sIFszLCAxLCAtMywgMV0sIFs0LCA0LCAyLCA0XV0pJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSB0d28gLSBkaW1lbnNpb25hbCBhcnJheSBBUlIsIG91dHB1dCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG9uIGl0cyBvd24gbGluZS4gXG4gICAgQXQgdGhlIGVuZCBvZiBlYWNoIHJvdywgb3V0cHV0IHRoZSBwaHJhc2UgRU5EIFJPVy4gYCxcblxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFByaW50QWxsKEFSUilcbiAgbG9vcCBSIGZyb20gMCB0byBBUlIuTGVuZ3RoKCkgLSAxXG4gICAgbG9vcCBDIGZyb20gMCB0byBBUlJbUl0uTGVuZ3RoKCkgLSAxXG4gICAgICBvdXRwdXQgQVJSW1JdW0NdXG4gICAgZW5kIGxvb3BcbiAgICBvdXRwdXQgXCJFTkQgUk9XXCJcbiAgZW5kIGxvb3BcbmVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJzJEIEFycmF5cycsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ0RpYWdBcnJheScsXG4gICAgLy8gdGhlIGlucHV0cyB0aGF0IHdlIGFyZSBnb2luZyB0byB1c2UgdG8gdG8gdGVzdCB0aGUgY29kZS4gQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBFYWNoIHN0cmluZyBzaG91bGQgYmUgcGFyZW50aGVzZXMsIGFuZCBpbnNpZGUgeW91IGNhbiBoYXZlIG9uZSBvciBtb3JlIGFycmF5cyxcbiAgICAvLyBzdHJpbmdzLCBpbnRzLCBUUlVFL0ZBTFNFLCB3aGF0ZXZlci4gY2hlY2sgd2FybXVwLmpzIGZvciBtb3JlIGV4YW1wbGVzLlxuICAgIGlucHV0czogW1xuICAgICAgYChbWzEsIDIsIDNdLFs0LCA1LCA2XSxbNywgOCwgOV1dKWAsXG4gICAgICAnKFtbMiwgM10sIFs2LCA0XV0pJyxcbiAgICAgICcoW1tcImFcIiwgXCJiXCIsIFwiY1wiXSxbXCJBXCIsIFwiQlwiLCBcIkNcIl0sIFtcIs6xXCIsXCLOslwiLCBcIsOnXCJdXSknLFxuICAgICAgJyhbWzEzLCA2XSwgWzEsIDJdLCBbNCwgNl1dKScsXG4gICAgICAnKFtbMywgMiwgMSwgNF0sWzEsIDEsIDEsIDFdLCBbMywgMSwgLTMsIDFdLCBbNCwgNCwgMiwgNF1dKScsXG4gICAgXSxcbiAgICAvLyBUaGUgcXVlc3Rpb24gaXRzZWxmLiBUcnkgdG8gbWFrZSBpdCBQc2V1ZG9jb2RlLXlcbiAgICBxdWVzdGlvbjogYEdpdmUgYSB0d28gLSBkaW1lbnNpb25hbCBzcXVhcmUgYXJyYXkgQVJSLCBvdXRwdXQgYSBvbmUgLSBkaW1lbnNpb25hbCBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBcbiAgICBvZiBpdHMgPGk+cHJpbWFyeSBkaWFnb25hbDwvaSA+IC0gdGhhdCBpcywgdGhlIGVsZW1lbnRzIHdob3NlIHJvdyBpbmRleCBhbmQgXG4gICAgY29sdW1uIGluZGV4IGFyZSB0aGUgc2FtZS4gXG4gICAgWW91IGNhbiBhc3N1bWUgQVJSIGhhcyB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cbiAgICBZb3UgY2FuIG1ha2UgYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIEwgd2l0aCB0aGUgY29tbWFuZCA8Y29kZT5ORVcgPSBuZXcgQXJyYXkoTCk8L2NvZGU+IGAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRmluZERpYWdvbmFsKEFSUilcbiAgLy8gQVJSLkxlbmd0aCgpIHdpbGwgZ2l2ZSB0aGUgbnVtYmVyIG9mIHJvd3NcbiAgLy8gQVJSWzBdLkxlbmd0aCgpIHdvdWxkIGdpdmUgdGhlICMgb2YgY29sdW1uc1xuICBORVcgPSBuZXcgQXJyYXkoQVJSLkxlbmd0aCgpKVxuICBsb29wIEkgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKSAtIDFcbiAgICBORVdbSV0gPSBBUlJbSV1bSV1cbiAgZW5kIGxvb3BcbiAgb3V0cHV0IE5FV1xuZW5kIG1ldGhvZGAsXG4gIH0sIHtcbiAgICAvL3RpdGxlIGlzIHRoZSBjYXRlZ29yeSBpdCBhcHBlYXJzIGluIG9uIHRoZSBob21lcGFnZVxuICAgIHRpdGxlOiAnMkQgQXJyYXlzJyxcbiAgICAvLyBQc2V1ZG9jb2RlIHByb2JsZW1zIHNob3VsZCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXJcbiAgICBuYW1lOiAnRmluZFZhbHVlJyxcbiAgICAvLyB0aGUgaW5wdXRzIHRoYXQgd2UgYXJlIGdvaW5nIHRvIHVzZSB0byB0byB0ZXN0IHRoZSBjb2RlLiBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgIC8vIEVhY2ggc3RyaW5nIHNob3VsZCBiZSBwYXJlbnRoZXNlcywgYW5kIGluc2lkZSB5b3UgY2FuIGhhdmUgb25lIG9yIG1vcmUgYXJyYXlzLFxuICAgIC8vIHN0cmluZ3MsIGludHMsIFRSVUUvRkFMU0UsIHdoYXRldmVyLiBjaGVjayB3YXJtdXAuanMgZm9yIG1vcmUgZXhhbXBsZXMuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMiwgM10sWzQsIDUsIDZdXSwgMClgLFxuICAgICAgJyhbWzIsIDNdLCBbNiwgNF0sIFsyLCAzXV0sIDQpJyxcbiAgICAgICcoW1tcImFcIiwgXCJiXCIsIFwiY1wiXSxbXCJBXCIsIFwiQlwiLCBcIkNcIl0sIFtcIs6xXCIsXCLOslwiLCBcIsOnXCJdXSwgXCJBXCIpJyxcbiAgICAgICcoW1sxMywgNl0sIFsxLCAyXSwgWzQsIDZdXSwgNiknLFxuICAgICAgJyhbWzMsIDIsIDEsIDRdLFsxLCAxLCAxLCAxXSwgWzMsIDEsIC0zLCAxXSwgWzQsIDQsIDIsIDRdXSwgNCknLFxuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHR3by1kaW1lbnNpb25hbCBhcnJheSBBUlIgYW5kIGEgc2VhcmNoIHZhbHVlIFZBTCxcbiAgICBzZWFyY2ggdGhlIGFycmF5IGluIHJlYWRpbmcgb3JkZXIgLSByb3dzIHRoZW4gY29sdW1ucyAtIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgb2NjdXJlbmNlIG9mIFZBTC4gT25jZSB5b3UgZmluZCBpdCwgb3V0cHV0IFwiVkFMIGZvdW5kIGF0IGluZGV4IFtSXVtDXVwiXG4gICAgcmVwbGFjaW5nIFZBTCwgUiwgYW5kIEMgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzLiBJZiBpdCBpc24ndCBmb3VuZCwgb3V0cHV0XG4gICAgXCJWQUwgbm90IGZvdW5kXCIuIGAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRmluZFZhbHVlKEFSUiwgVkFMKVxuICAvLyBBUlIuTGVuZ3RoKCkgd2lsbCBnaXZlIHRoZSBudW1iZXIgb2Ygcm93c1xuICAvLyBBUlJbMF0uTGVuZ3RoKCkgd291bGQgZ2l2ZSB0aGUgIyBvZiBjb2x1bW5zXG4gIEZPVU5EID0gRkFMU0VcbiAgbG9vcCBST1cgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKSAtIDFcbiAgICBsb29wIENPTCBmcm9tIDAgdG8gQVJSW1JPV10uTGVuZ3RoKCkgLSAxXG4gICAgICBpZiBBUlJbUk9XXVtDT0xdID0gVkFMIHRoZW5cbiAgICAgICAgb3V0cHV0IFwiXCIgKyBWQUwgKyBcIiBmb3VuZCBhdCBpbmRleCBbXCIgKyBST1cgKyBcIl1bXCIgKyBDT0wgKyBcIl1cIlxuICAgICAgICByZXR1cm5cbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gIGVuZCBsb29wXG4gIG91dHB1dCBcIlwiICsgVkFMICsgXCIgbm90IGZvdW5kXCJcbmVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJzJEIEFycmF5cycsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ1N3YXBSb3dzJyxcbiAgICAvLyB0aGUgaW5wdXRzIHRoYXQgd2UgYXJlIGdvaW5nIHRvIHVzZSB0byB0byB0ZXN0IHRoZSBjb2RlLiBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgIC8vIEVhY2ggc3RyaW5nIHNob3VsZCBiZSBwYXJlbnRoZXNlcywgYW5kIGluc2lkZSB5b3UgY2FuIGhhdmUgb25lIG9yIG1vcmUgYXJyYXlzLFxuICAgIC8vIHN0cmluZ3MsIGludHMsIFRSVUUvRkFMU0UsIHdoYXRldmVyLiBjaGVjayB3YXJtdXAuanMgZm9yIG1vcmUgZXhhbXBsZXMuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMiwgM10sWzQsIDUsIDZdXSwgMCwgMSlgLFxuICAgICAgJyhbWzIsIDNdLCBbNiwgNF0sIFsyLCAzXV0sIDAsIDIpJyxcbiAgICAgICcoW1tcImFcIiwgXCJiXCIsIFwiY1wiXSxbXCJBXCIsIFwiQlwiLCBcIkNcIl0sIFtcIs6xXCIsXCLOslwiLCBcIsOnXCJdXSwgMSwgMiknLFxuICAgICAgJyhbWzEzLCA2XSwgWzEsIDJdLCBbNCwgNl1dLCAwLCAyKScsXG4gICAgICAnKFtbMywgMiwgMSwgNF0sWzEsIDEsIDEsIDFdLCBbMywgMSwgLTMsIDFdLCBbNCwgNCwgMiwgNF1dLCAyLCAzKScsXG4gICAgXSxcbiAgICAvLyBUaGUgcXVlc3Rpb24gaXRzZWxmLiBUcnkgdG8gbWFrZSBpdCBQc2V1ZG9jb2RlLXlcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgMmQgYXJyYXkgTUFUIGFuZCB0d28gaW5kaWNlcyBLIGFuZCBMLCBjb25zdHJ1Y3QgY29kZSB0byBzd2FwXG4gICAgdGhlIGVsZW1lbnRzIGluIHJvdyBLIHdpdGggdGhlIGVsZW1lbnRzIGluIHJvdyBMICh5b3UgY2FuIGFzc3VtZSBhbGwgcm93cyBhcmUgdGhlXG4gICAgICBzYW1lIGxlbmd0aCkuIE9VVFBVVCB0aGUgbmV3IE1BVCBvbiBjb21wbGV0aW9uLiAoSUIgTm92ZW1iZXIgMjAxOCwgMTJiKWAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3dhcFJvd3MoTUFULCBLLCBMKVxuICAgICAgbG9vcCBJIGZyb20gMCB0byBNQVRbS10uTGVuZ3RoKCktMVxuICAgICAgICBURU1QID0gTUFUW0tdW0ldXG4gICAgICAgIE1BVFtLXVtJXT1NQVRbTF1bSV1cbiAgICAgICAgTUFUW0xdW0ldPVRFTVBcbiAgICAgIGVuZCBsb29wXG4gICAgICBvdXRwdXQgTUFUXG4gICAgZW5kIG1ldGhvZGAsXG4gIH0sIHtcbiAgICAvL3RpdGxlIGlzIHRoZSBjYXRlZ29yeSBpdCBhcHBlYXJzIGluIG9uIHRoZSBob21lcGFnZVxuICAgIHRpdGxlOiAnMkQgQXJyYXlzJyxcbiAgICAvLyBQc2V1ZG9jb2RlIHByb2JsZW1zIHNob3VsZCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXJcbiAgICBuYW1lOiAnU29ydDJEJyxcbiAgICAvLyB0aGUgaW5wdXRzIHRoYXQgd2UgYXJlIGdvaW5nIHRvIHVzZSB0byB0byB0ZXN0IHRoZSBjb2RlLiBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgIC8vIEVhY2ggc3RyaW5nIHNob3VsZCBiZSBwYXJlbnRoZXNlcywgYW5kIGluc2lkZSB5b3UgY2FuIGhhdmUgb25lIG9yIG1vcmUgYXJyYXlzLFxuICAgIC8vIHN0cmluZ3MsIGludHMsIFRSVUUvRkFMU0UsIHdoYXRldmVyLiBjaGVjayB3YXJtdXAuanMgZm9yIG1vcmUgZXhhbXBsZXMuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMjEsIDVdLFs0LCAxNSwgNl1dKWAsXG4gICAgICAnKFtbMiwgM10sIFsxLCA2XSwgWzIsIDJdXSknLFxuICAgICAgJyhbWzEzLCA2LCAxMV0sIFsxLCAyLCAzXSwgWzQsIDYsIDVdLCBbNywgMCwgLTNdXSknLFxuICAgICAgJyhbWzMsIDIsIDEsIDRdLFsxLCAxLCAxLCAxXSwgWzMsIDEsIC0zLCAxXSwgWzQsIDQsIDIsIDRdXSknLFxuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIDJEIGFycmF5IE1BVCBvZiBudW1iZXJzLCBjb25zdHJ1Y3QgYSBtZXRob2QgdGhhdCB3aWxsIHNvcnQgdGhlIG1hdHJpeCBcbiAgICBzbyB0aGF0IHRoZSBzdW0gb2YgZWFjaCByb3cgaXMgaW4gYXNjZW5kaW5nIG9yZGVyLCBhbmQgcmV0dXJuIHRoZSBzb3J0ZWQgYXJyYXkuXG4gICAgXG4gICAgSGludDogSXQgbWF5IGJlIGhlbHBmdWwgdG8gbWFrZSBzdWJtZXRob2RzIHN1Y2ggYXMgU3VtUm93KE1BVCwgUk9XKSBhbmQgU3dhcFJvd3MoTUFULCBSMSwgUjIpLlxuICAgIElmIHlvdSBtYWtlIG1ldGhvZHMgaW5zaWRlIHRoZSBtYWluIG1ldGhvZCwgeW91IGNhbiB1c2UgdGhlbSBqdXN0IGZpbmUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTb3J0MkQoTUFUKVxuICAgIC8vIFVzaW5nIHNlbGVjdGlvbiBzb3J0XG4gICAgbG9vcCBGUk5UIGZyb20gMCB0byBNQVQuTGVuZ3RoKCkgLSAyXG4gICAgICBsb29wIENISyBmcm9tIChGUk5UICsgMSkgdG8gKE1BVC5MZW5ndGgoKSAtIDEpXG4gICAgICAgIE1JTiA9IEZSTlRcbiAgICAgICAgaWYgU3VtUm93KE1BVCwgQ0hLKSA8IFN1bVJvdyhNQVQsIE1JTikgdGhlblxuICAgICAgICAgIE1JTiA9IENIS1xuICAgICAgICBlbmQgaWZcbiAgICAgICAgaWYgTUlOICE9IEZSTlQgdGhlblxuICAgICAgICAgIFN3YXBSb3dzKE1BVCwgRlJOVCwgTUlOKVxuICAgICAgICBlbmQgaWZcbiAgICAgIGVuZCBsb29wXG4gICAgZW5kIGxvb3BcbiAgICBcbiAgICBvdXRwdXQgTUFUXG5cblxuICAgIG1ldGhvZCBTdW1Sb3coTUFULCBSKVxuICAgICAgUyA9IDBcbiAgICAgIGxvb3AgSSBmcm9tIDAgdG8gTUFUW1JdLkxlbmd0aCgpIC0gMVxuICAgICAgICBTID0gUyArIE1BVFtSXVtJXVxuICAgICAgZW5kIGxvb3BcbiAgICAgIHJldHVybiBTXG4gICAgZW5kIG1ldGhvZFxuXG4gICAgbWV0aG9kIFN3YXBSb3dzKE1BVCwgSywgTClcbiAgICAgIGxvb3AgSSBmcm9tIDAgdG8gTUFUW0tdLkxlbmd0aCgpIC0gMVxuICAgICAgICBURU1QID0gTUFUW0tdW0ldXG4gICAgICAgIE1BVFtLXVtJXT1NQVRbTF1bSV1cbiAgICAgICAgTUFUW0xdW0ldPVRFTVBcbiAgICAgIGVuZCBsb29wXG4gICAgICByZXR1cm4gTUFUXG4gICAgZW5kIG1ldGhvZFxuICAgIFxuICBlbmQgbWV0aG9kYCxcblxuICB9LCB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJzJEIEFycmF5cycsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ0RpYWdvbmFsQ29sbGVjdGlvbicsXG4gICAgLy8gdGhlIGlucHV0cyB0aGF0IHdlIGFyZSBnb2luZyB0byB1c2UgdG8gdG8gdGVzdCB0aGUgY29kZS4gQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBFYWNoIHN0cmluZyBzaG91bGQgYmUgcGFyZW50aGVzZXMsIGFuZCBpbnNpZGUgeW91IGNhbiBoYXZlIG9uZSBvciBtb3JlIGFycmF5cyxcbiAgICAvLyBzdHJpbmdzLCBpbnRzLCBUUlVFL0ZBTFNFLCB3aGF0ZXZlci4gY2hlY2sgd2FybXVwLmpzIGZvciBtb3JlIGV4YW1wbGVzLlxuICAgIGlucHV0czogW1xuICAgICAgYChbWzEsIDIsIDNdLFs0LCA1LCA2XSxbNywgOCwgOV1dKWAsXG4gICAgICAnKFtbMiwgM10sIFs2LCA0XV0pJyxcbiAgICAgICcoW1sxMywgNl0sIFsxLCAyXV0pJyxcbiAgICAgICcoW1szLCAyLCAxLCA0XSxbMSwgMSwgMSwgMV0sIFszLCAxLCAtMywgMV0sIFs0LCA0LCAyLCA0XV0pJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSAyZCBhcnJheSBzcXVhcmUgTUFULCBidWlsZCBhIGNvbGxlY3Rpb24gQ09MIHRoYXQgY29udGFpbnMgdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIE1BVC4gT3V0cHV0IHRoZSBuZXcgY29sbGVjdGlvbi4gWW91IGNhbiBtYWtlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCB0aGUgY29tbWFuZCBDT0wgPSBuZXcgQ29sbGVjdGlvbigpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBEaWFnb25hbChNQVQpXG4gICAgQ09MID0gbmV3IENvbGxlY3Rpb24oKSBcbiAgICBsb29wIEkgZnJvbSAwIHRvIE1BVC5MZW5ndGgoKSAtIDFcbiAgICAgIENPTC5hZGRJdGVtKE1BVFtJXVtJXSlcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBDT0xcbmVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJ1N0YWNrcyBhbmQgUXVldWVzJyxcbiAgICBuYW1lOiAnQ29sbGVjdGlvblRvU3RhY2snLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzfSknLFxuICAgICAgJyh7NywgLTMsIDE0fSknLFxuICAgICAgJyh7XCJmaXJzdFwiLCBcInNlY29uZFwiLCBcInRoaXJkXCJ9KScsXG4gICAgICAnKHtcIkJvYlwiLCBcIk1hcnlcIiwgXCJNYXJnYXJldFwiLCBcIkpvc2lhaFwiLCBcIkFsaXN0YWlyXCJ9KSdcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBjb2xsZWN0aW9uLCBDT0wsIGNyZWF0ZSBhIHN0YWNrIFNUSyB0aGF0IGNvbnRhaW5zIFxuICAgIHRoZSBlbGVtZW50cyBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIGlzIHRoZSBib3R0b20gXG4gICAgZWxlbWVudCBpbiB0aGUgc3RhY2suIE91dHB1dCB0aGUgc3RhY2suIFlvdSBjYW4gY3JlYXRlIGEgbmV3IHN0YWNrIHdpdGggdGhlIGNvbW1hbmRcbiAgICBTVEsgPSBuZXcgU3RhY2soKWAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQ29sbGVjdGlvblRvU3RhY2soQ09MKVxuICAgICAgICBTVEsgPSBuZXcgU3RhY2soKVxuICAgICAgICBsb29wIHdoaWxlIENPTC5oYXNOZXh0KCkgXG4gICAgICAgICAgU1RLLnB1c2goQ09MLmdldE5leHQoKSlcbiAgICAgICAgZW5kIGxvb3BcbiAgICAgICAgb3V0cHV0IFNUS1xuICAgIGVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJ1N0YWNrcyBhbmQgUXVldWVzJyxcbiAgICBuYW1lOiAnQ29sbGVjdGlvblRvUXVldWUnLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzfSknLFxuICAgICAgJyh7NywgLTMsIDE0fSknLFxuICAgICAgJyh7XCJmaXJzdFwiLCBcInNlY29uZFwiLCBcInRoaXJkXCJ9KScsXG4gICAgICAnKHtcIkJvYlwiLCBcIk1hcnlcIiwgXCJNYXJnYXJldFwiLCBcIkpvc2lhaFwiLCBcIkFsaXN0YWlyXCJ9KSdcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBjb2xsZWN0aW9uLCBDT0wsIGNyZWF0ZSBhIHF1ZXVlIHRoYXQgY29udGFpbnMgXG4gICAgdGhlIGVsZW1lbnRzIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gaXMgdGhlIGZyb250IG9mIHRoZSBxdWV1ZS4gXG4gICAgT3V0cHV0IHRoZSBxdWV1ZS4gWW91IGNhbiBjcmVhdGUgYSBuZXcgcXVldWUgd2l0aCB0aGUgY29tbWFuZFxuICAgIFFVRSA9IG5ldyBRdWV1ZSgpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBDb2xsZWN0aW5Ub1F1ZXVlKENPTClcbiAgICAgICAgUVVFID0gbmV3IFF1ZXVlKClcbiAgICAgICAgbG9vcCB3aGlsZSBDT0wuaGFzTmV4dCgpIFxuICAgICAgICAgIFFVRS5lbnF1ZXVlKENPTC5nZXROZXh0KCkpXG4gICAgICAgIGVuZCBsb29wXG4gICAgICAgIG91dHB1dCBRVUVcbiAgICBlbmQgbWV0aG9kYCxcbiAgfSwge1xuICAgIC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICdTdGFja3MgYW5kIFF1ZXVlcycsXG4gICAgbmFtZTogJ1JldmVyc2VDb2xsZWN0aW9uJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7MSwgMiwgM30pJyxcbiAgICAgICcoezcsIC0zLCAxNH0pJyxcbiAgICAgICcoe1wiZmlyc3RcIiwgXCJzZWNvbmRcIiwgXCJ0aGlyZFwifSknLFxuICAgICAgJyh7XCJCb2JcIiwgXCJNYXJ5XCIsIFwiTWFyZ2FyZXRcIiwgXCJKb3NpYWhcIiwgXCJBbGlzdGFpclwifSknXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgY29sbGVjdGlvbiwgQ09MLCBjcmVhdGUgYSBuZXcgY29sbGVjdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSByZXZlcnNlICBjcmVhdGUgYSBxdWV1ZVxuICAgICAgdGhhdCBjb250YWlucyB0aGUgc2FtZSBlbGVtZW50cyBpbiByZXZlcnNlIG9yZGVyLiAoSGludDogdXNlIGEgc3RhY2sgaW4gdGhlIG1pZGRsZSEpLlxuICAgICAgT3V0cHV0IHRoZSBuZXcgY29sbGVjdGlvbi5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFJldmVyc2VDb2xsZWN0aW9uKENPTClcbiAgICAgICAgU1RLID0gbmV3IFN0YWNrKClcbiAgICAgICAgQkNLID0gbmV3IENvbGxlY3Rpb24oKVxuICAgICAgICBDT0wucmVzZXROZXh0KClcblxuICAgICAgICBsb29wIHdoaWxlIENPTC5oYXNOZXh0KCkgXG4gICAgICAgICAgU1RLLnB1c2goQ09MLmdldE5leHQoKSlcbiAgICAgICAgZW5kIGxvb3BcblxuICAgICAgICBsb29wIHdoaWxlIE5PVCBTVEsuaXNFbXB0eSgpXG4gICAgICAgICAgQkNLLmFkZEl0ZW0oU1RLLnBvcCgpKVxuICAgICAgICBlbmQgbG9vcFxuICAgICAgICBcbiAgICAgICAgb3V0cHV0IEJDS1xuICAgIGVuZCBtZXRob2RgLFxuICB9LCB7IC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICdTdGFja3MgYW5kIFF1ZXVlcycsXG4gICAgbmFtZTogJ1NwbGl0U3RhY2snLFxuICAgIGlucHV0VHlwZTogXCJzdGFja1wiLFxuICAgIGlucHV0czogW1xuICAgICAgJyhCWzEsIDIsIDNdVCknLFxuICAgICAgJyhCWzcsIC0zLCAzLCAxNF1UKScsXG4gICAgICAnKEJbOSwgLTIsIDUsIDExLCAyXVQpJyxcbiAgICAgICcoQlsyLCAzLCA0LCA1LCA2XVQpJyxcbiAgICAgICcoQlszLCAtMywgMywgLTMsIDNdVCknXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RhY2sgaWYgaW50ZWdlcnMsIFNUSywgdGFrZSBpdGVtcyBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgYW5kIG1vdmUgdGhlbSBpbnRvIGEgc2Vjb25kIHN0YWNrLCB1bnRpbCB5b3UgZmluZCBhIDMuIFRoZSAzIHNob3VsZCBub3QgYmUgcHV0IGluXG4gICAgRUlUSEVSIHN0YWNrLiBcbiAgICBcbiAgICBPdXRwdXQgRklSU1QgdGhlIG5ldyBzdGFjayBUSEVOIHRoZSBvbGQgc3RhY2sgKG91dHB1dHRpbmcgZW1wdHkgc3RhY2tzIGlzIGZpbmUpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTcGxpdFN0YWNrKFNUSylcbiAgICBTVEsyID0gbmV3IFN0YWNrKClcbiAgICBGT1VORCA9IGZhbHNlXG4gICAgbG9vcCB3aGlsZSBOT1QgU1RLLmlzRW1wdHkoKSBBTkQgTk9UIEZPVU5EXG4gICAgICBFID0gU1RLLnBvcCgpXG4gICAgICBpZiBFID0gMyB0aGVuXG4gICAgICAgIEZPVU5EID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBTVEsyLnB1c2goRSlcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG5cbiAgICBvdXRwdXQgU1RLMlxuICAgIG91dHB1dCBTVEtcbmVuZCBtZXRob2RgLFxuICB9XG5dIiwibW9kdWxlLmV4cG9ydHMgPSBbe1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IFNDT1JFUywgb3V0cHV0IFwiVFJVRVwiIGlmIGVhY2ggc2NvcmUgaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgYmVmb3JlLiBUaGUgYXJyYXkgd2lsbCBiZSBsZW5ndGggMiBvciBtb3JlLiBZb3UgY2FuIHVzZSB0aGUgcHJvcGVydHkgQVJSLmxlbmd0aCB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdTY29yZXNJbmNyZWFzaW5nJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzEsIDMsIDRdKVwiLFxuICAgIFwiKFsxLCAzLCAyXSlcIixcbiAgICBcIihbMSwgMSwgNF0pXCIsXG4gICAgXCIoWzEsIDEsIDIsIDQsIDQsIDddKVwiLFxuICAgIFwiKFsxLCAxLCAyLCA0LCAzLCA3XSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHNjb3JlcywgcmV0dXJuIHRydWUgaWYgdGhlcmUgYXJlIHNjb3JlcyBvZiAxMDAgbmV4dCB0byBlYWNoIG90aGVyIGluIHRoZSBhcnJheS4gVGhlIGFycmF5IGxlbmd0aCB3aWxsIGJlIGF0IGxlYXN0IDIuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3JlczEwMCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsxLCAxMDAsIDEwMF0pXCIsXG4gICAgXCIoWzEsIDEwMCwgOTksIDEwMF0pXCIsXG4gICAgXCIoWzEwMCwgMSwgMTAwLCAxMDBdKVwiLFxuICAgIFwiKFsxMDAsIDEsIDEwMCwgMV0pXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDVdKVwiLFxuICAgIFwiKFsxLCAyLCAxMDAsIDQsIDVdKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc2NvcmVzIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgMyBhZGphY2VudCBzY29yZXMgdGhhdCBkaWZmZXIgZnJvbSBlYWNoIG90aGVyIGJ5IGF0IG1vc3QgMiwgc3VjaCBhcyB3aXRoIHszLCA0LCA1fSBvciB7MywgNSwgNX0uJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3Jlc0NsdW1wJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzMsIDQsIDVdKVwiLFxuICAgIFwiKFszLCA0LCA2XSlcIixcbiAgICBcIihbMSwgMywgNSwgNV0pXCIsXG4gICAgXCIoWzIsIDQsIDUsIDZdKVwiLFxuICAgIFwiKFsyLCA0LCA1LCA3XSlcIixcbiAgICBcIihbMiwgNCwgNCwgN10pXCIsXG4gICAgXCIoWzMsIDMsIDYsIDcsIDldKVwiLFxuICAgIFwiKFszLCAzLCA3LCA3LCA5XSlcIixcbiAgICBcIihbNCwgNSwgOF0pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzY29yZXMsIGNvbXB1dGUgdGhlIGludCBhdmVyYWdlIG9mIHRoZSBmaXJzdCBoYWxmIGFuZCB0aGUgc2Vjb25kIGhhbGYsIGFuZCByZXR1cm4gd2hpY2hldmVyIGlzIGxhcmdlci4gV2VcXCdsbCBzYXkgdGhhdCB0aGUgc2Vjb25kIGhhbGYgYmVnaW5zIGF0IGluZGV4IGxlbmd0aC8yLiBUaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMi4gVG8gcHJhY3RpY2UgZGVjb21wb3NpdGlvbiwgd3JpdGUgYSBzZXBhcmF0ZSBoZWxwZXIgbWV0aG9kIGludCBhdmVyYWdlKGludFtdIHNjb3JlcywgaW50IHN0YXJ0LCBpbnQgZW5kKSB7ICB3aGljaCBjb21wdXRlcyB0aGUgYXZlcmFnZSBvZiB0aGUgZWxlbWVudHMgYmV0d2VlbiBpbmRleGVzIHN0YXJ0Li5lbmQuIENhbGwgeW91ciBoZWxwZXIgbWV0aG9kIHR3aWNlIHRvIGltcGxlbWVudCBzY29yZXNBdmVyYWdlKCkuIFdyaXRlIHlvdXIgaGVscGVyIG1ldGhvZCBhZnRlciB5b3VyIHNjb3Jlc0F2ZXJhZ2UoKSBtZXRob2QgaW4gdGhlIEphdmFCYXQgdGV4dCBhcmVhLiBOb3JtYWxseSB5b3Ugd291bGQgY29tcHV0ZSBhdmVyYWdlcyB3aXRoIGRvdWJsZXMsIGJ1dCBoZXJlIHdlIHVzZSBpbnRzIHNvIHRoZSBleHBlY3RlZCByZXN1bHRzIGFyZSBleGFjdC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnc2NvcmVzQXZlcmFnZScsXG4gIGlucHV0czogW1xuICAgIFwiKFsyLCAyLCA0LCA0XSlcIixcbiAgICBcIihbNCwgNCwgNCwgMiwgMiwgMl0pXCIsXG4gICAgXCIoWzMsIDQsIDUsIDEsIDIsIDNdKVwiLFxuICAgIFwiKFs1LCA2XSlcIixcbiAgICBcIihbNSwgNF0pXCIsXG4gICAgXCIoWzUsIDQsIDUsIDYsIDIsIDEsIDIsIDNdKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJuIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIHN0cmluZ3Mgd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd3b3Jkc0NvdW50JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDEpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDQpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd6J10sIDEpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd6J10sIDIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLCByZXR1cm4gYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgZmlyc3QgTiBzdHJpbmdzLiBOIHdpbGwgYmUgaW4gdGhlIHJhbmdlIDEuLmxlbmd0aC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnd29yZHNGcm9udCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCAxKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCA0KVwiLFxuICAgIFwiKFsnSGknLCAnVGhlcmUnXSwgMSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybiBhIG5ldyBMaXN0IChlLmcuIGFuIEFycmF5TGlzdCkgd2hlcmUgYWxsIHRoZSBzdHJpbmdzIG9mIHRoZSBnaXZlbiBsZW5ndGggYXJlIG9taXR0ZWQuIFNlZSB3b3Jkc1dpdGhvdXQoKSBiZWxvdyB3aGljaCBpcyBtb3JlIGRpZmZpY3VsdCBiZWNhdXNlIGl0IHVzZXMgYXJyYXlzLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd3b3Jkc1dpdGhvdXRMaXN0JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDEpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDQpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd6J10sIDEpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhIHBvc2l0aXZlIGludCBuLCByZXR1cm4gdHJ1ZSBpZiBpdCBjb250YWlucyBhIDEgZGlnaXQuIE5vdGU6IHVzZSAlIHRvIGdldCB0aGUgcmlnaHRtb3N0IGRpZ2l0LCBhbmQgLyB0byBkaXNjYXJkIHRoZSByaWdodG1vc3QgZGlnaXQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2hhc09uZScsXG4gIGlucHV0czogW1xuICAgIFwiKDEwKVwiLFxuICAgIFwiKDIyKVwiLFxuICAgIFwiKDIyMClcIixcbiAgICBcIigyMTIpXCIsXG4gICAgXCIoMSlcIixcbiAgICBcIig5KVwiLFxuICAgIFwiKDIxMTExMilcIixcbiAgICBcIigxMjExMjEpXCIsXG4gICAgXCIoMjIyMjIyKVwiLFxuICAgIFwiKDU2MTU2KVwiLFxuICAgIFwiKDU2NTU2KVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnV2VcXCdsbCBzYXkgdGhhdCBhIHBvc2l0aXZlIGludCBkaXZpZGVzIGl0c2VsZiBpZiBldmVyeSBkaWdpdCBpbiB0aGUgbnVtYmVyIGRpdmlkZXMgaW50byB0aGUgbnVtYmVyIGV2ZW5seS4gU28gZm9yIGV4YW1wbGUgMTI4IGRpdmlkZXMgaXRzZWxmIHNpbmNlIDEsIDIsIGFuZCA4IGFsbCBkaXZpZGUgaW50byAxMjggZXZlbmx5LiBXZVxcJ2xsIHNheSB0aGF0IDAgZG9lcyBub3QgZGl2aWRlIGludG8gYW55dGhpbmcgZXZlbmx5LCBzbyBubyBudW1iZXIgd2l0aCBhIDAgZGlnaXQgZGl2aWRlcyBpdHNlbGYuIE5vdGU6IHVzZSAlIHRvIGdldCB0aGUgcmlnaHRtb3N0IGRpZ2l0LCBhbmQgLyB0byBkaXNjYXJkIHRoZSByaWdodG1vc3QgZGlnaXQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2RpdmlkZXNTZWxmJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoMTI4KVwiLFxuICAgIFwiKDEyKVwiLFxuICAgIFwiKDEyMClcIixcbiAgICBcIigxMjIpXCIsXG4gICAgXCIoMTMpXCIsXG4gICAgXCIoMzIpXCIsXG4gICAgXCIoMjIpXCIsXG4gICAgXCIoNDIpXCIsXG4gICAgXCIoMjEyKVwiLFxuICAgIFwiKDIxMylcIixcbiAgICBcIigxNjIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRzLCByZXR1cm4gYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIFwiY291bnRcIiBjb250YWluaW5nIHRoZSBmaXJzdCBldmVuIG51bWJlcnMgZnJvbSB0aGUgb3JpZ2luYWwgYXJyYXkuIFRoZSBvcmlnaW5hbCBhcnJheSB3aWxsIGNvbnRhaW4gYXQgbGVhc3QgXCJjb3VudFwiIGV2ZW4gbnVtYmVycy4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnY29weUV2ZW5zJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzMsIDIsIDQsIDUsIDhdLCAyKVwiLFxuICAgIFwiKFszLCAyLCA0LCA1LCA4XSwgMylcIixcbiAgICBcIihbNiwgMSwgMiwgNCwgNSwgOF0sIDMpXCIsXG4gICAgXCIoWzYsIDEsIDIsIDQsIDUsIDhdLCA0KVwiLFxuICAgIFwiKFszLCAxLCA0LCAxLCA1XSwgMSlcIixcbiAgICBcIihbMl0sIDEpXCIsXG4gICAgXCIoWzYsIDIsIDQsIDhdLCAyKVwiLFxuICAgIFwiKFs2LCAyLCA0LCA4XSwgMylcIixcbiAgICBcIihbNiwgMiwgNCwgOF0sIDQpXCIsXG4gICAgXCIoWzEsIDgsIDRdLCAxKVwiLFxuICAgIFwiKFsxLCA4LCA0XSwgMilcIixcbiAgICBcIihbMiwgOCwgNF0sIDIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdXZVxcJ2xsIHNheSB0aGF0IGEgcG9zaXRpdmUgaW50IG4gaXMgXCJlbmR5XCIgaWYgaXQgaXMgaW4gdGhlIHJhbmdlIDAuLjEwIG9yIDkwLi4xMDAgKGluY2x1c2l2ZSkuIEdpdmVuIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludHMsIHJldHVybiBhIG5ldyBhcnJheSBvZiBsZW5ndGggXCJjb3VudFwiIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGVuZHkgbnVtYmVycyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheS4gRGVjb21wb3NlIG91dCBhIHNlcGFyYXRlIGlzRW5keShpbnQgbikgbWV0aG9kIHRvIHRlc3QgaWYgYSBudW1iZXIgaXMgZW5keS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgY29udGFpbiBhdCBsZWFzdCBcImNvdW50XCIgZW5keSBudW1iZXJzLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdjb3B5RW5keScsXG4gIGlucHV0czogW1xuICAgIFwiKFs5LCAxMSwgOTAsIDIyLCA2XSwgMilcIixcbiAgICBcIihbOSwgMTEsIDkwLCAyMiwgNl0sIDMpXCIsXG4gICAgXCIoWzEyLCAxLCAxLCAxMywgMCwgMjBdLCAyKVwiLFxuICAgIFwiKFsxMiwgMSwgMSwgMTMsIDAsIDIwXSwgMylcIixcbiAgICBcIihbMF0sIDEpXCIsXG4gICAgXCIoWzEwLCAxMSwgOTBdLCAyKVwiLFxuICAgIFwiKFs5MCwgMjIsIDEwMF0sIDIpXCIsXG4gICAgXCIoWzEyLCAxMSwgMTAsIDg5LCAxMDEsIDRdLCAxKVwiLFxuICAgIFwiKFsxMywgMiwgMiwgMF0sIDIpXCIsXG4gICAgXCIoWzEzLCAyLCAyLCAwXSwgMylcIixcbiAgICBcIihbMTMsIDIsIDEzLCAyLCAwLCAzMF0sIDIpXCIsXG4gICAgXCIoWzEzLCAyLCAxMywgMiwgMCwgMzBdLCAzKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gMiBhcnJheXMgdGhhdCBhcmUgdGhlIHNhbWUgbGVuZ3RoIGNvbnRhaW5pbmcgc3RyaW5ncywgY29tcGFyZSB0aGUgMXN0IHN0cmluZyBpbiBvbmUgYXJyYXkgdG8gdGhlIDFzdCBzdHJpbmcgaW4gdGhlIG90aGVyIGFycmF5LCB0aGUgMm5kIHRvIHRoZSAybmQgYW5kIHNvIG9uLiBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIDIgc3RyaW5ncyBhcmUgbm9uLWVtcHR5IGFuZCBzdGFydCB3aXRoIHRoZSBzYW1lIGNoYXIuIFRoZSBzdHJpbmdzIG1heSBiZSBhbnkgbGVuZ3RoLCBpbmNsdWRpbmcgMC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnbWF0Y2hVcCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYWEnLCAnYmInLCAnY2MnXSwgWydhYWEnLCAneHgnLCAnYmInXSlcIixcbiAgICBcIihbJ2FhJywgJ2JiJywgJ2NjJ10sIFsnYWFhJywgJ2InLCAnYmInXSlcIixcbiAgICBcIihbJ2FhJywgJ2JiJywgJ2NjJ10sIFsnJywgJycsICdjY2MnXSlcIixcbiAgICBcIihbJycsICcnLCAnY2NjJ10sIFsnYWEnLCAnYmInLCAnY2MnXSlcIixcbiAgICBcIihbJycsICcnLCAnJ10sIFsnJywgJ2JiJywgJ2NjJ10pXCIsXG4gICAgXCIoWydhYScsICdiYicsICdjYyddLCBbJycsICcnLCAnJ10pXCIsXG4gICAgXCIoWydhYScsICcnLCAnY2NjJ10sIFsnJywgJ2JiJywgJ2NjJ10pXCIsXG4gICAgXCIoWyd4JywgJ3knLCAneiddLCBbJ3knLCAneicsICd4J10pXCIsXG4gICAgXCIoWycnLCAneScsICd6J10sIFsnJywgJ3knLCAneCddKVwiLFxuICAgIFwiKFsneCcsICd5JywgJ3onXSwgWyd4eCcsICd5eXknLCAnenp6J10pXCIsXG4gICAgXCIoWyd4JywgJ3knLCAneiddLCBbJ3h4JywgJ3l5eScsICcnXSlcIixcbiAgICBcIihbJ2InLCAneCcsICd5JywgJ3onXSwgWydhJywgJ3h4JywgJ3l5eScsICd6enonXSlcIixcbiAgICBcIihbJ2FhYScsICdiYicsICdjJ10sIFsnYWFhJywgJ3h4JywgJ2JiJ10pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdUaGUgXCJrZXlcIiBhcnJheSBpcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBjb3JyZWN0IGFuc3dlcnMgdG8gYW4gZXhhbSwgbGlrZSB7XCJhXCIsIFwiYVwiLCBcImJcIiwgXCJiXCJ9LiB0aGUgXCJhbnN3ZXJzXCIgYXJyYXkgY29udGFpbnMgYSBzdHVkZW50XFwncyBhbnN3ZXJzLCB3aXRoIFwiP1wiIHJlcHJlc2VudGluZyBhIHF1ZXN0aW9uIGxlZnQgYmxhbmsuIFRoZSB0d28gYXJyYXlzIGFyZSBub3QgZW1wdHkgYW5kIGFyZSB0aGUgc2FtZSBsZW5ndGguIFJldHVybiB0aGUgc2NvcmUgZm9yIHRoaXMgYXJyYXkgb2YgYW5zd2VycywgZ2l2aW5nICs0IGZvciBlYWNoIGNvcnJlY3QgYW5zd2VyLCAtMSBmb3IgZWFjaCBpbmNvcnJlY3QgYW5zd2VyLCBhbmQgKzAgZm9yIGVhY2ggYmxhbmsgYW5zd2VyLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdzY29yZVVwJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnYScsICdjJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYiddLCBbJ2EnLCAnYScsICdiJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWydhJywgJ2EnLCAnYicsICdiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnPycsICdjJywgJ2InLCAnPyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYiddLCBbJz8nLCAnYycsICc/JywgJz8nXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWydjJywgJz8nLCAnYicsICdiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnYycsICc/JywgJ2InLCAnPyddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnXSwgWydhJywgJ2MnLCAnYiddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJywgJ2MnXSwgWydhJywgJ2MnLCAnYScsICdjJywgJ2EnLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJywgJ2MnXSwgWydhJywgJ2MnLCAnPycsICc/JywgJ2EnLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJywgJ2MnXSwgWydhJywgJ2MnLCAnPycsICc/JywgJ2MnLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYyddKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGhvdXQgdGhlIHN0cmluZ3MgdGhhdCBhcmUgZXF1YWwgdG8gdGhlIHRhcmdldCBzdHJpbmcuIE9uZSBhcHByb2FjaCBpcyB0byBjb3VudCB0aGUgb2NjdXJyZW5jZXMgb2YgdGhlIHRhcmdldCBzdHJpbmcsIG1ha2UgYSBuZXcgYXJyYXkgb2YgdGhlIGNvcnJlY3QgbGVuZ3RoLCBhbmQgdGhlbiBjb3B5IG92ZXIgdGhlIGNvcnJlY3Qgc3RyaW5ncy4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnd29yZHNXaXRob3V0JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdhJ10sICdhJylcIixcbiAgICBcIihbJ2EnLCAnYicsICdjJywgJ2EnXSwgJ2InKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnYSddLCAnYycpXCIsXG4gICAgXCIoWydiJywgJ2MnLCAnYScsICdhJ10sICdiJylcIixcbiAgICBcIihbJ3h4JywgJ3l5eScsICd4JywgJ3l5JywgJ3gnXSwgJ3gnKVwiLFxuICAgIFwiKFsneHgnLCAneXl5JywgJ3gnLCAneXknLCAneCddLCAneXknKVwiLFxuICAgIFwiKFsnYWEnLCAnYWInLCAnYWMnLCAnYWEnXSwgJ2FhJylcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIHR3byBhcnJheXMsIEEgYW5kIEIsIG9mIG5vbi1uZWdhdGl2ZSBpbnQgc2NvcmVzLiBBIFwic3BlY2lhbFwiIHNjb3JlIGlzIG9uZSB3aGljaCBpcyBhIG11bHRpcGxlIG9mIDEwLCBzdWNoIGFzIDQwIG9yIDkwLiBSZXR1cm4gdGhlIHN1bSBvZiBsYXJnZXN0IHNwZWNpYWwgc2NvcmUgaW4gQSBhbmQgdGhlIGxhcmdlc3Qgc3BlY2lhbCBzY29yZSBpbiBCLiBUbyBwcmFjdGljZSBkZWNvbXBvc2l0aW9uLCB3cml0ZSBhIHNlcGFyYXRlIGhlbHBlciBtZXRob2Qgd2hpY2ggZmluZHMgdGhlIGxhcmdlc3Qgc3BlY2lhbCBzY29yZSBpbiBhbiBhcnJheS4gV3JpdGUgeW91ciBoZWxwZXIgbWV0aG9kIGFmdGVyIHlvdXIgc2NvcmVzU3BlY2lhbCgpIG1ldGhvZCBpbiB0aGUgSmF2YUJhdCB0ZXh0IGFyZWEuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3Jlc1NwZWNpYWwnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbMTIsIDEwLCA0XSwgWzIsIDIwLCAzMF0pXCIsXG4gICAgXCIoWzIwLCAxMCwgNF0sIFsyLCAyMCwgMTBdKVwiLFxuICAgIFwiKFsxMiwgMTEsIDRdLCBbMiwgMjAsIDMxXSlcIixcbiAgICBcIihbMSwgMjAsIDIsIDUwXSwgWzMsIDQsIDVdKVwiLFxuICAgIFwiKFszLCA0LCA1XSwgWzEsIDUwLCAyLCAyMF0pXCIsXG4gICAgXCIoWzEwLCA0LCAyMCwgMzBdLCBbMjBdKVwiLFxuICAgIFwiKFsxMCwgNCwgMjAsIDMwXSwgWzIwXSlcIixcbiAgICBcIihbMTAsIDQsIDIwLCAzMF0sIFszLCAyMCwgOTldKVwiLFxuICAgIFwiKFsxMCwgNCwgMjAsIDMwXSwgWzMwLCAyMCwgOTldKVwiLFxuICAgIFwiKFtdLCBbMl0pXCIsXG4gICAgXCIoW10sIFsyMF0pXCIsXG4gICAgXCIoWzE0LCAxMCwgNF0sIFs0LCAyMCwgMzBdKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnV2UgaGF2ZSBhbiBhcnJheSBvZiBoZWlnaHRzLCByZXByZXNlbnRpbmcgdGhlIGFsdGl0dWRlIGFsb25nIGEgd2Fsa2luZyB0cmFpbC4gR2l2ZW4gc3RhcnQvZW5kIGluZGV4ZXMgaW50byB0aGUgYXJyYXksIHJldHVybiB0aGUgc3VtIG9mIHRoZSBjaGFuZ2VzIGZvciBhIHdhbGsgYmVnaW5uaW5nIGF0IHRoZSBzdGFydCBpbmRleCBhbmQgZW5kaW5nIGF0IHRoZSBlbmQgaW5kZXguIEZvciBleGFtcGxlLCB3aXRoIHRoZSBoZWlnaHRzIHs1LCAzLCA2LCA3LCAyfSBhbmQgc3RhcnQ9MiwgZW5kPTQgeWllbGRzIGEgc3VtIG9mIDEgKyA1ID0gNi4gVGhlIHN0YXJ0IGVuZCBlbmQgaW5kZXggd2lsbCBib3RoIGJlIHZhbGlkIGluZGV4ZXMgaW50byB0aGUgYXJyYXkgd2l0aCBzdGFydCA8PSBlbmQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3N1bUhlaWdodHMnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDIsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAwLCAxKVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMCwgNClcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDEsIDEpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMCwgMylcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA0LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDcsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgOCwgOClcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAyLCAyKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDMsIDYpXCIsXG4gICAgXCIoWzEwLCA4LCA3LCA3LCA3LCA2LCA3XSwgMSwgNClcIixcbiAgICBcIihbMTAsIDgsIDcsIDcsIDcsIDYsIDddLCAxLCA1KVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnKEEgdmFyaWF0aW9uIG9uIHRoZSBzdW1IZWlnaHRzIHByb2JsZW0uKSBXZSBoYXZlIGFuIGFycmF5IG9mIGhlaWdodHMsIHJlcHJlc2VudGluZyB0aGUgYWx0aXR1ZGUgYWxvbmcgYSB3YWxraW5nIHRyYWlsLiBHaXZlbiBzdGFydC9lbmQgaW5kZXhlcyBpbnRvIHRoZSBhcnJheSwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlIGNoYW5nZXMgZm9yIGEgd2FsayBiZWdpbm5pbmcgYXQgdGhlIHN0YXJ0IGluZGV4IGFuZCBlbmRpbmcgYXQgdGhlIGVuZCBpbmRleCwgaG93ZXZlciBpbmNyZWFzZXMgaW4gaGVpZ2h0IGNvdW50IGRvdWJsZS4gRm9yIGV4YW1wbGUsIHdpdGggdGhlIGhlaWdodHMgezUsIDMsIDYsIDcsIDJ9IGFuZCBzdGFydD0yLCBlbmQ9NCB5aWVsZHMgYSBzdW0gb2YgMSoyICsgNSA9IDcuIFRoZSBzdGFydCBlbmQgZW5kIGluZGV4IHdpbGwgYm90aCBiZSB2YWxpZCBpbmRleGVzIGludG8gdGhlIGFycmF5IHdpdGggc3RhcnQgPD0gZW5kLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdzdW1IZWlnaHRzMicsXG4gIGlucHV0czogW1xuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMiwgNClcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDAsIDEpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMSwgMSlcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAwLCAzKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDQsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgNywgOClcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA4LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDIsIDIpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMywgNilcIixcbiAgICBcIihbMTAsIDgsIDcsIDcsIDcsIDYsIDddLCAxLCA0KVwiLFxuICAgIFwiKFsxMCwgOCwgNywgNywgNywgNiwgN10sIDEsIDUpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICcoQSB2YXJpYXRpb24gb24gdGhlIHN1bUhlaWdodHMgcHJvYmxlbS4pIFdlIGhhdmUgYW4gYXJyYXkgb2YgaGVpZ2h0cywgcmVwcmVzZW50aW5nIHRoZSBhbHRpdHVkZSBhbG9uZyBhIHdhbGtpbmcgdHJhaWwuIEdpdmVuIHN0YXJ0L2VuZCBpbmRleGVzIGludG8gdGhlIGFycmF5LCByZXR1cm4gdGhlIG51bWJlciBvZiBcImJpZ1wiIHN0ZXBzIGZvciBhIHdhbGsgc3RhcnRpbmcgYXQgdGhlIHN0YXJ0IGluZGV4IGFuZCBlbmRpbmcgYXQgdGhlIGVuZCBpbmRleC4gV2VcXCdsbCBzYXkgdGhhdCAgc3RlcCBpcyBiaWcgaWYgaXQgaXMgNSBvciBtb3JlIHVwIG9yIGRvd24uIFRoZSBzdGFydCBlbmQgZW5kIGluZGV4IHdpbGwgYm90aCBiZSB2YWxpZCBpbmRleGVzIGludG8gdGhlIGFycmF5IHdpdGggc3RhcnQgPD0gZW5kLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdiaWdIZWlnaHRzJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAyLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMCwgMSlcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDAsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDNdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMSwgMSlcIixcbiAgICBcIihbNSwgMTMsIDYsIDcsIDJdLCAxLCAyKVwiLFxuICAgIFwiKFs1LCAxMywgNiwgNywgMl0sIDAsIDIpXCIsXG4gICAgXCIoWzUsIDEzLCA2LCA3LCAyXSwgMSwgNClcIixcbiAgICBcIihbNSwgMTMsIDYsIDcsIDJdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAxMywgNiwgNywgMl0sIDAsIDMpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMCwgMylcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA0LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCAwLCAzKVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCA3LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCAzLCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCAyLCA4KVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnV2UgaGF2ZSBkYXRhIGZvciB0d28gdXNlcnMsIEEgYW5kIEIsIGVhY2ggd2l0aCBhIFN0cmluZyBuYW1lIGFuZCBhbiBpbnQgaWQuIFRoZSBnb2FsIGlzIHRvIG9yZGVyIHRoZSB1c2VycyBzdWNoIGFzIGZvciBzb3J0aW5nLiBSZXR1cm4gLTEgaWYgQSBjb21lcyBiZWZvcmUgQiwgMSBpZiBBIGNvbWVzIGFmdGVyIEIsIGFuZCAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLiBPcmRlciBmaXJzdCBieSB0aGUgc3RyaW5nIG5hbWVzLCBhbmQgdGhlbiBieSB0aGUgaWQgbnVtYmVycyBpZiB0aGUgbmFtZXMgYXJlIHRoZSBzYW1lLiBOb3RlOiB3aXRoIFN0cmluZ3Mgc3RyMS5jb21wYXJlVG8oc3RyMikgcmV0dXJucyBhbiBpbnQgdmFsdWUgd2hpY2ggaXMgbmVnYXRpdmUvMC9wb3NpdGl2ZSB0byBpbmRpY2F0ZSBob3cgc3RyMSBpcyBvcmRlcmVkIHRvIHN0cjIgKHRoZSB2YWx1ZSBpcyBub3QgbGltaXRlZCB0byAtMS8wLzEpLiAoT24gdGhlIEFQLCB0aGVyZSB3b3VsZCBiZSB0d28gVXNlciBvYmplY3RzLCBidXQgaGVyZSB0aGUgY29kZSBzaW1wbHkgdGFrZXMgdGhlIHR3byBzdHJpbmdzIGFuZCB0d28gaW50cyBkaXJlY3RseS4gVGhlIGNvZGUgbG9naWMgaXMgdGhlIHNhbWUuKScsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd1c2VyQ29tcGFyZScsXG4gIGlucHV0czogW1xuICAgIFwiKCdiYicsIDEsICd6eicsIDIpXCIsXG4gICAgXCIoJ2JiJywgMSwgJ2FhJywgMilcIixcbiAgICBcIignYmInLCAxLCAnYmInLCAxKVwiLFxuICAgIFwiKCdiYicsIDUsICdiYicsIDEpXCIsXG4gICAgXCIoJ2JiJywgNSwgJ2JiJywgMTApXCIsXG4gICAgXCIoJ2FkYW0nLCAxLCAnYm9iJywgMilcIixcbiAgICBcIignYm9iJywgMSwgJ2JvYicsIDIpXCIsXG4gICAgXCIoJ2J6YicsIDEsICdib2InLCAyKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnU3RhcnQgd2l0aCB0d28gYXJyYXlzIG9mIHN0cmluZ3MsIEEgYW5kIEIsIGVhY2ggd2l0aCBpdHMgZWxlbWVudHMgaW4gYWxwaGFiZXRpY2FsIG9yZGVyIGFuZCB3aXRob3V0IGR1cGxpY2F0ZXMuIFJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSBmaXJzdCBOIGVsZW1lbnRzIGZyb20gdGhlIHR3byBhcnJheXMuIFRoZSByZXN1bHQgYXJyYXkgc2hvdWxkIGJlIGluIGFscGhhYmV0aWNhbCBvcmRlciBhbmQgd2l0aG91dCBkdXBsaWNhdGVzLiBBIGFuZCBCIHdpbGwgYm90aCBoYXZlIGEgbGVuZ3RoIHdoaWNoIGlzIE4gb3IgbW9yZS4gVGhlIGJlc3QgXCJsaW5lYXJcIiBzb2x1dGlvbiBtYWtlcyBhIHNpbmdsZSBwYXNzIG92ZXIgQSBhbmQgQiwgdGFraW5nIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlciwgY29weWluZyBlbGVtZW50cyBkaXJlY3RseSB0byB0aGUgbmV3IGFycmF5LicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdtZXJnZVR3bycsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydiJywgJ2YnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydjJywgJ2YnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnZicsICdnJywgJ3onXSwgWydjJywgJ2YnLCAnZyddLCAzKVwiLFxuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydhJywgJ2MnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAneiddLCBbJ2EnLCAnYycsICd6J10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2MnLCAneiddLCBbJ2EnLCAnYicsICdjJywgJ3onXSwgMylcIixcbiAgICBcIihbJ2EnLCAnYycsICd6J10sIFsnYScsICdjJywgJ3onXSwgMilcIixcbiAgICBcIihbJ2EnLCAnYycsICd6J10sIFsnYScsICdjJywgJ3knLCAneiddLCAzKVwiLFxuICAgIFwiKFsneCcsICd5JywgJ3onXSwgWydhJywgJ2InLCAneiddLCAzKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnU3RhcnQgd2l0aCB0d28gYXJyYXlzIG9mIHN0cmluZ3MsIGEgYW5kIGIsIGVhY2ggaW4gYWxwaGFiZXRpY2FsIG9yZGVyLCBwb3NzaWJseSB3aXRoIGR1cGxpY2F0ZXMuIFJldHVybiB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiBzdHJpbmdzIHdoaWNoIGFwcGVhciBpbiBib3RoIGFycmF5cy4gVGhlIGJlc3QgXCJsaW5lYXJcIiBzb2x1dGlvbiBtYWtlcyBhIHNpbmdsZSBwYXNzIG92ZXIgYm90aCBhcnJheXMsIHRha2luZyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCB0aGV5IGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXIuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2NvbW1vblR3bycsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYScsICdjJywgJ3gnXSwgWydiJywgJ2MnLCAnZCcsICd4J10pXCIsXG4gICAgXCIoWydhJywgJ2MnLCAneCddLCBbJ2EnLCAnYicsICdjJywgJ3gnLCAneiddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYScsICdiJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InLCAnYyddLCBbJ2EnLCAnYicsICdiJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYScsICdiJywgJ2InLCAnYycsICdjJ10pXCIsXG4gICAgXCIoWydiJywgJ2InLCAnYicsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYicsICdiJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYicsICdjJywgJ2MnLCAnZCddLCBbJ2EnLCAnYicsICdiJywgJ2MnLCAnZCcsICdkJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydiJywgJ2InLCAnYiddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYycsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydiJywgJ2InLCAnYicsICd4J10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydiJywgJ2InXSlcIixcbiAgICBcIihbJ2EnXSwgWydhJywgJ2InXSlcIixcbiAgICBcIihbJ2EnXSwgWydiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnXSwgWydiJywgJ2InXSlcIixcbiAgICBcIihbJ2EnLCAnYiddLCBbJ2EnLCAnYiddKVwiXG4gIF1cbn1cbl07XG5cbiIsIi8qKi0tLSBTb2x1dGlvbnMgLS0tICoqL1xuXG5sZXQgc29sdXRpb25zID0ge307XG5cbnNvbHV0aW9ucy5TY29yZXNJbmNyZWFzaW5nID0gYG1ldGhvZCBTY29yZXNJbmNyZWFzaW5nKFNDT1JFUylcbiAgV09SS1MgPSBcIlRSVUVcIlxuICBsb29wIEkgZnJvbSAwIHRvIFNDT1JFUy5sZW5ndGggLSAxXG4gICAgaWYgU0NPUkVTW0ldICE9IFNDT1JFU1tJLTFdIEFORCBTQ09SRVNbSV0gPCBTQ09SRVNbSS0xXSB0aGVuXG4gICAgICBXT1JLUyA9IFwiRkFMU0VcIlxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgV09SS1NcbmVuZCBtZXRob2RgO1xuXG5zb2x1dGlvbnMuc2NvcmVzMTAwID0gZnVuY3Rpb24gc2NvcmVzMTAwKHNjb3Jlcykge1xuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNjb3Jlc1tpXSA9PSAxMDAgJiYgc2NvcmVzW2kgKyAxXSA9PSAxMDApIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudCA+IDA7XG59XG5cbnNvbHV0aW9ucy5zY29yZXNDbHVtcCA9IGZ1bmN0aW9uIHNjb3Jlc0NsdW1wKHNjb3Jlcykge1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChzY29yZXNbaSArIDJdIC0gc2NvcmVzW2ldIDw9IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5zY29yZXNBdmVyYWdlID0gZnVuY3Rpb24gc2NvcmVzQXZlcmFnZShzY29yZXMpIHtcblxuICBmdW5jdGlvbiBhdmVyYWdlKG51bXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bSArPSBudW1zW2ldXG4gICAgfVxuICAgIHJldHVybiBzdW0gLyBudW1zLmxlbmd0aDtcbiAgfVxuXG4gIGxldCBoYWxmID0gc2NvcmVzLmxlbmd0aCAvIDJcbiAgbGV0IGZpcnN0ID0gW107XG4gIGxldCBzZWNvbmQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbGY7IGkrKykge1xuICAgIGZpcnN0LnB1c2goc2NvcmVzW2ldKVxuICB9O1xuXG4gIGZvciAobGV0IGkgPSBoYWxmOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2Vjb25kLnB1c2goc2NvcmVzW2ldKVxuICB9O1xuXG4gIGxldCBhdjEgPSBhdmVyYWdlKGZpcnN0KTtcbiAgbGV0IGF2MiA9IGF2ZXJhZ2Uoc2Vjb25kKTtcblxuICBpZiAoYXYxID4gYXYyKSB7XG4gICAgcmV0dXJuIGF2MTtcbiAgfVxuICByZXR1cm4gYXYyXG59XG5cbnNvbHV0aW9ucy53b3Jkc0NvdW50ID0gZnVuY3Rpb24gd29yZHNDb3VudCh3b3JkcywgbGVuKSB7XG5cbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggPT0gbGVuKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy53b3Jkc0Zyb250ID0gZnVuY3Rpb24gd29yZHNGcm9udCh3b3Jkcywgbikge1xuXG4gIGxldCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBhcnIucHVzaCh3b3Jkc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuc29sdXRpb25zLndvcmRzV2l0aG91dExpc3QgPSBmdW5jdGlvbiB3b3Jkc1dpdGhvdXRMaXN0KHdvcmRzLCBsZW4pIHtcbiAgbGV0IGFyciA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAod29yZHNbaV0ubGVuZ3RoICE9IGxlbikge1xuICAgICAgYXJyLnB1c2god29yZHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5zb2x1dGlvbnMuaGFzT25lID0gZnVuY3Rpb24gaGFzT25lKG4pIHtcblxuICBsZXQgc3RyID0gbi50b1N0cmluZygpXG5cbiAgbGV0IGogPSBzdHIubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGogPj0gMCkge1xuICAgIGlmIChwYXJzZUludChzdHJbal0pICUgMTAgPT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGotLTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5kaXZpZGVzU2VsZiA9IGZ1bmN0aW9uIGRpdmlkZXNTZWxmKG4pIHtcbiAgbGV0IG51bSA9IG4udG9TdHJpbmcoKTtcblxuICBsZXQgaiA9IG51bS5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChqID49IDApIHtcbiAgICBpZiAobiAlIHBhcnNlSW50KG51bVtqXSkgIT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBqLS07XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5jb3B5RXZlbnMgPSBmdW5jdGlvbiBjb3B5RXZlbnMobnVtcywgY291bnQpIHtcblxuICBsZXQgZXJyYXkgPSBbXTtcbiAgbGV0IGogPSBjb3VudDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAlIDIgPT0gMCkge1xuICAgICAgZXJyYXkucHVzaChudW1zW2ldKTtcbiAgICAgIGotLTtcbiAgICAgIGlmIChqIDwgMSkgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycmF5O1xufVxuXG5zb2x1dGlvbnMuY29weUVuZHkgPSBmdW5jdGlvbiBjb3B5RW5keShudW1zLCBjb3VudCkge1xuICBsZXQgbmV3QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG4gPSBudW1zW2ldO1xuICAgIGlmIChuID49IDAgJiYgbiA8PSAxMCB8fCBuID49IDkwICYmIG4gPD0gMTAwKSB7XG4gICAgICBuZXdBcnJheS5wdXNoKG4pO1xuICAgIH1cbiAgICBpZiAobmV3QXJyYXkubGVuZ3RoID09PSBjb3VudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuc29sdXRpb25zLm1hdGNoVXAgPSBmdW5jdGlvbiBtYXRjaFVwKGEsIGIpIHtcbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXS5sZW5ndGggPiAwICYmIGJbaV0ubGVuZ3RoID4gMCAmJlxuICAgICAgYVtpXS5jaGFyQXQoMCkgPT0gYltpXS5jaGFyQXQoMCkpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuc2NvcmVVcCA9IGZ1bmN0aW9uIHNjb3JlVXAoa2V5LCBhbnN3ZXJzKSB7XG4gIGxldCBzY29yZSA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYW5zd2Vyc1tpXSA9PSBcIj9cIikge1xuICAgICAgc2NvcmUgKz0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5W2ldICE9IGFuc3dlcnNbaV0pIHtcbiAgICAgIHNjb3JlIC09IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjb3JlICs9IDQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY29yZTtcbn1cblxuc29sdXRpb25zLndvcmRzV2l0aG91dCA9IGZ1bmN0aW9uIHdvcmRzV2l0aG91dCh3b3JkcywgdGFyZ2V0KSB7XG4gIGxldCBudWFyciA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAod29yZHNbaV0gIT0gdGFyZ2V0KSB7XG4gICAgICBudWFyci5wdXNoKHdvcmRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51YXJyO1xufVxuXG5zb2x1dGlvbnMuc2NvcmVzU3BlY2lhbCA9IGZ1bmN0aW9uIHNjb3Jlc1NwZWNpYWwoYSwgYikge1xuICBmdW5jdGlvbiBsYXJnZXN0KHgpIHtcblxuICAgIGxldCBiaWcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhbaV0gPiBiaWcgJiYgeFtpXSAlIDEwID09IDApIHtcbiAgICAgICAgYmlnID0geFtpXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaWc7XG4gIH1cbiAgbGV0IGFyZXMgPSBsYXJnZXN0KGEpO1xuICBsZXQgYnJlcyA9IGxhcmdlc3QoYik7XG5cbiAgcmV0dXJuIGFyZXMgKyBicmVzO1xufVxuXG5zb2x1dGlvbnMuc3VtSGVpZ2h0cyA9IGZ1bmN0aW9uIHN1bUhlaWdodHMoaGVpZ2h0cywgc3RhcnQsIGVuZCkge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXMgKz0gTWF0aC5hYnMoaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSArIDFdKVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnNvbHV0aW9ucy5zdW1IZWlnaHRzMiA9IGZ1bmN0aW9uIHN1bUhlaWdodHMyKGhlaWdodHMsIHN0YXJ0LCBlbmQpIHtcblxuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaGVpZ2h0c1tpICsgMV0gPiBoZWlnaHRzW2ldKSB7XG4gICAgICBzdW0gKz0gTWF0aC5hYnMoaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSArIDFdKSAqIDJcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtICs9IE1hdGguYWJzKGhlaWdodHNbaV0gLSBoZWlnaHRzW2kgKyAxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbnNvbHV0aW9ucy5iaWdIZWlnaHRzID0gZnVuY3Rpb24gYmlnSGVpZ2h0cyhoZWlnaHRzLCBzdGFydCwgZW5kKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKE1hdGguYWJzKGhlaWdodHNbaV0gLSBoZWlnaHRzW2kgKyAxXSkgPj0gNSkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMudXNlckNvbXBhcmUgPSBmdW5jdGlvbiB1c2VyQ29tcGFyZShhTmFtZSwgYUlkLCBiTmFtZSwgYklkKSB7XG5cbiAgaWYgKGFOYW1lIDwgYk5hbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYU5hbWUgPiBiTmFtZSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGFJZCA8IGJJZCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhSWQgPiBiSWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuc29sdXRpb25zLm1lcmdlVHdvID0gZnVuY3Rpb24gbWVyZ2VUd28oYSwgYiwgbikge1xuICBsZXQgYWJpbml0ID0gYS5jb25jYXQoYik7XG4gIGxldCBhYiA9IGFiaW5pdC5zb3J0KCk7XG5cbiAgbGV0IGFyciA9IFwiXCJcblxuICBsZXQgY291bnQgPSBuO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKGNvdW50IDw9IDApIHsgYnJlYWs7IH1cblxuICAgIGlmIChhYltpXSA9PSBhYltpICsgMV0gJiYgYXJyLmNoYXJBdChhcnIubGVuZ3RoIC0gMSkgIT0gYWJbaV0pIHtcbiAgICAgIGFyciArPSBhYltpXTtcbiAgICAgIGNvdW50LS07XG4gICAgICBpKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyciArPSBhYltpXTtcbiAgICAgIGNvdW50LS07XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnIuc3BsaXQoXCJcIik7XG59XG5cbnNvbHV0aW9ucy5jb21tb25Ud28gPSBmdW5jdGlvbiBjb21tb25Ud28oYSwgYikge1xuICBsZXQgc3RyID0gXCJcIjtcbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChhW2pdID09IGJbaV0gJiYgIXN0ci5pbmNsdWRlcyhhW2pdKSkge1xuICAgICAgICBzdHIgKz0gYVtqXTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ0ZpcnN0TGFzdDYnLFxuICAgIC8vIHRoZSBpbnB1dHMgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRvIHRvIHRlc3QgdGhlIGNvZGUuIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgLy8gRWFjaCBzdHJpbmcgc2hvdWxkIGJlIHBhcmVudGhlc2VzLCBhbmQgaW5zaWRlIHlvdSBjYW4gaGF2ZSBvbmUgb3IgbW9yZSBhcnJheXMsXG4gICAgLy8gc3RyaW5ncywgaW50cywgVFJVRS9GQUxTRSwgd2hhdGV2ZXIuIGNoZWNrIHdhcm11cC5qcyBmb3IgbW9yZSBleGFtcGxlcy5cbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDZdKScsXG4gICAgICAnKFs2LCAxLCAyLCAzXSknLFxuICAgICAgJyhbMTMsIDYsIDEsIDIsIDNdKScsXG4gICAgICAnKFsxMywgNiwgMSwgMiwgNl0pJyxcbiAgICAgICcoWzMsIDIsIDFdKScsXG4gICAgICAnKFszLCA2LCAxXSknLFxuICAgICAgJyhbMywgNl0pJyxcbiAgICAgICcoWzZdKScsXG4gICAgICAnKFszXSknLFxuICAgICAgJyhbNSwgNl0pJyxcbiAgICAgICcoWzUsIDVdKScsXG4gICAgICAnKFsxLCAyLCAzLCA0LCA2XSknLFxuICAgICAgJyhbMSwgMiwgMywgNF0pJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgb3V0cHV0IFRSVUUgaWYgNiBhcHBlYXJzIGFzIGVpdGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IGluIHRoZSBhcnJheS4gVGhlIGFycmF5IHdpbGwgYmUgbGVuZ3RoIDEgb3IgbW9yZS4gVXNlIEFSUi5MZW5ndGgoKSB0byBhY2Nlc3MgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaXJzdExhc3Q2KE5VTVMpXG4gICAgRU5EID0gTlVNUy5MZW5ndGgoKSAtIDFcbiAgICBpZiBOVU1TWzBdID0gNiBPUiBOVU1TW0VORF0gPSA2IHRoZW5cbiAgICAgIG91dHB1dCBUUlVFXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IEZBTFNFXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ1NhbWVGaXJzdExhc3QnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzEsIDIsIDMsIDFdKScsXG4gICAgICAnKFsxLCAyLCAxXSknLFxuICAgICAgJyhbN10pJyxcbiAgICAgICcoW10pJyxcbiAgICAgICcoWzEsIDIsIDMsIDQsIDUsIDFdKScsXG4gICAgICAnKFsxLCAyLCAzLCA0LCA1LCAxM10pJyxcbiAgICAgICcoWzEzLCAyLCAzLCA0LCA1LCAxM10pJyxcbiAgICAgICcoWzcsIDddKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMsIG91dHB1dCBUUlVFIGlmIHRoZSBhcnJheSBpcyBsZW5ndGggMSBvciBtb3JlLCBhbmQgdGhlIGZpcnN0IGVsZW1lbnQgYW5kIHRoZSBsYXN0IGVsZW1lbnQgYXJlIGVxdWFsLiBPdGhlcndpc2Ugb3V0cHV0IEZBTFNFYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTYW1lRmlyc3RMYXN0KE5VTVMpXG4gICAgRU5EID0gTlVNUy5MZW5ndGgoKSAtIDFcbiAgICBpZiBFTkQgPj0gMCBBTkQgTlVNU1tFTkRdID0gTlVNU1swXSB0aGVuXG4gICAgICBvdXRwdXQgVFJVRVxuICAgIGVsc2VcbiAgICAgIG91dHB1dCBGQUxTRVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdDb21tb25FbmQnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10sIFs3LCAzXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFs3LCAzLCAyXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFsxLCAzXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFsxXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFsyXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGFycmF5cywgQVJSMSBhbmQgQVJSMiwgb3V0cHV0IFRSVUUgaWYgdGhleSBoYXZlIHRoZSBzYW1lIGZpcnN0IGVsZW1lbnQgb3IgdGhleSBoYXZlIHRoZSBzYW1lIGxhc3QgZWxlbWVudCwgYW5kIEZBTFNFIG90aGVyd2lzZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIENvbW1vbkVuZChBUlIxLCBBUlIyKVxuICAgIGlmIEFSUjFbMF0gPSBBUlIyWzBdIE9SIEFSUjFbQVJSMS5MZW5ndGgoKSAtIDFdID0gQVJSMltBUlIyLkxlbmd0aCgpIC0gMV0gdGhlblxuICAgICAgb3V0cHV0IFRSVUVcbiAgICBlbHNlXG4gICAgICBvdXRwdXQgRkFMU0VcbiAgICBlbmQgaWZcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdNYXhFbmQnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzExLCA1LCA5LCAyLCAxXSknLFxuICAgICAgJyhbMiwgMTEsIDMsIDcsIDFdKScsXG4gICAgICAnKFsxMSwgMywgM10pJyxcbiAgICAgICcoWzMsIDExXSknLFxuICAgICAgJyhbMiwgMiwgMiwgMl0pJyxcbiAgICAgICcoWzIsIDExLCAyXSknLFxuICAgICAgJyhbMCwgMCwgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgZmlndXJlIG91dCB3aGljaCBpcyBsYXJnZXIsIHRoZSBmaXJzdFxuICAgIG9yIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJyYXksIGFuZCBzZXQgYWxsIHRoZSBvdGhlciBlbGVtZW50cyB0byBiZSB0aGF0IHZhbHVlLiBUaGVuIG91dHB1dCB0aGUgbmV3IGFycmF5LlxuICAgIFlvdSBjYW4gdXNlIEFSUi5MZW5ndGgoKSB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWF4RW5kKE5VTVMpXG4gICAgaWYgTlVNU1swXSA+IE5VTVNbTlVNUy5MZW5ndGgoKS0xXSB0aGVuXG4gICAgICBNQVggPSBOVU1TWzBdXG4gICAgZWxzZVxuICAgICAgTUFYID0gTlVNU1tOVU1TLkxlbmd0aCgpLTFdXG4gICAgZW5kIGlmXG4gICAgbG9vcCBJIGZyb20gMCB0byBOVU1TLkxlbmd0aCgpLTFcbiAgICAgIE5VTVNbSV0gPSBNQVhcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBOVU1TXG4gIGVuZCBtZXRob2RgXG5cbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdTdW0yJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFsxLCAxXSknLFxuICAgICAgJyhbMSwgMSwgMSwgMV0pJyxcbiAgICAgICcoWzEsIDJdKScsXG4gICAgICAnKFsxXSknLFxuICAgICAgJyhbXSknLFxuICAgICAgJyhbNCwgNSwgNl0pJyxcbiAgICAgICcoWzRdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMsIG91dHB1dCB0aGUgc3VtIG9mIHRoZSBmaXJzdCAyIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cbiAgICBJZiB0aGUgYXJyYXkgbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLCBqdXN0IHN1bSB1cCB0aGUgZWxlbWVudHMgdGhhdCBleGlzdCwgcmV0dXJuaW5nIDAgaWZcbiAgICB0aGUgYXJyYXkgaXMgbGVuZ3RoIDAuIFlvdSBjYW4gdXNlIEFSUi5MZW5ndGgoKSB0byBhY2Nlc3MgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdW0yKE5VTVMpXG4gICAgaWYgTlVNUy5MZW5ndGgoKSA9IDAgdGhlblxuICAgICAgb3V0cHV0IDBcbiAgICBlbHNlIGlmIE5VTVMuTGVuZ3RoKCkgPSAxIHRoZW5cbiAgICAgIG91dHB1dCBOVU1TWzBdXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IE5VTVNbMF0rTlVNU1sxXVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ01pZGRsZVdheScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzQsIDUsIDZdKScsXG4gICAgICAnKFs3LCA3LCA3XSwgWzMsIDgsIDBdKScsXG4gICAgICAnKFs1LCAyLCA5XSwgWzEsIDQsIDVdKScsXG4gICAgICAnKFsxLCA5LCA3XSwgWzQsIDgsIDhdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzMsIDEsIDRdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzQsIDEsIDFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgYXJyYXlzIHRoYXQgYXJlIGJvdGgga25vd24gdG8gaGF2ZSBsZW5ndGggMywgb3V0cHV0IGEgbmV3IGFycmF5IG9mIGxlbmd0aCAyXG4gICAgY29udGFpbmluZyB0aGVpciBtaWRkbGUgZWxlbWVudHMuIFlvdSBjYW4gbWFrZSBhIG5ldyBhcnJheSB3aXRoIHRoZSBmb3JtYXQgPGNvZGU+TkVXID0gW2UxLCBlMiwgZTNdPC9jb2RlPmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWlkZGxlV2F5KEFSUjEsIEFSUjIpXG4gICAgTkVXID0gW0FSUjFbMV0sIEFSUjJbMV1dO1xuICAgIG91dHB1dCBORVdcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdNYWtlRW5kcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgICAgJyhbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCJdKScsXG4gICAgICAnKFtUUlVFLCBGQUxTRSwgRkFMU0UsIFRSVUVdKScsXG4gICAgICAnKFsxLjIsIDIuMCwgMmU4LCAyLjg5MiwgMiwgMiwgMiwgM10pJyxcbiAgICAgICcoWzcsIDRdKScsXG4gICAgICAnKFs3XSknLFxuICAgICAgJyhbNSwgMiwgOV0pJyxcbiAgICAgICcoWzIsIDMsIDQsIDFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5LCByZXR1cm4gYSBuZXcgYXJyYXkgbGVuZ3RoIDIgY29udGFpbmluZyB0aGVcbiAgICBmaXJzdCBhbmQgbGFzdCBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgYmVcbiAgICBsZW5ndGggMSBvciBtb3JlLiBZb3UgY2FuIG1ha2UgYSBuZXcgYXJyYXkgd2l0aCB0aGUgZm9ybWF0IDxjb2RlPk5FVyA9IFtlMSwgZTIsIGUzXTwvY29kZT5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1ha2VFbmRzKEFSUilcbiAgICBORVcgPSBbQVJSWzBdLCBBUlJbQVJSLkxlbmd0aCgpIC0gMV1dXG4gICAgb3V0cHV0IE5FV1xuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0hhczIzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzIsIDVdKScsXG4gICAgICAnKFs0LCAzXSknLFxuICAgICAgJyhbNCwgNV0pJyxcbiAgICAgICcoWzIsIDJdKScsXG4gICAgICAnKFszLCAyXSknLFxuICAgICAgJyhbMywgM10pJyxcbiAgICAgICcoWzcsIDddKScsXG4gICAgICAnKFszLCA5XSknLFxuICAgICAgJyhbOSwgNV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgdGhhdCBjb250YWlucyBleGFjdGx5IHR3byBudW1iZXJzLCBvdXRwdXQgVFJVRSBpZiBpdCBjb250YWlucyBhIDIgb3IgYSAzLC4gRkFMU0Ugb3RoZXJ3aXNlJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBIYXMyMyhOVU1TKVxuICAgIGlmIE5VTVNbMF0gPSAyIE9SIE5VTVNbMF0gPSAzIE9SIE5VTVNbMV0gPSAyIE9SIE5VTVNbMV0gPSAzIHRoZW5cbiAgICAgIG91dHB1dCBUUlVFXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IEZBTFNFXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnTm8yMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFs0LCA1XSknLFxuICAgICAgJyhbNCwgMl0pJyxcbiAgICAgICcoWzMsIDVdKScsXG4gICAgICAnKFsxLCA5XSknLFxuICAgICAgJyhbMiwgOV0pJyxcbiAgICAgICcoWzEsIDNdKScsXG4gICAgICAnKFsxLCAxXSknLFxuICAgICAgJyhbMiwgMl0pJyxcbiAgICAgICcoWzMsIDNdKScsXG4gICAgICAnKFs3LCA4XSknLFxuICAgICAgJyhbOCwgN10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBsZW5ndGggMiwgb3V0cHV0IFRSVUUgaWYgaXQgZG9lcyBub3QgY29udGFpbiBhIDIgb3IgMywgRkFMU0Ugb3RoZXJ3aXNlJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBObzIzKE5VTVMpXG4gIGlmIE5VTVNbMF0gPSAyIE9SIE5VTVNbMV0gPSAyIE9SIE5VTVNbMF0gPSAzIE9SIE5VTVNbMV0gPSAzIHRoZW5cbiAgICBvdXRwdXQgRkFMU0VcbiAgZWxzZVxuICAgIG91dHB1dCBUUlVFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdEb3VibGUyMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsyLCAyXSknLFxuICAgICAgJyhbMywgM10pJyxcbiAgICAgICcoWzIsIDNdKScsXG4gICAgICAnKFszLCAyLCAzXSknLFxuICAgICAgJyhbNCwgNSwgMiwgM10pJyxcbiAgICAgICcoWzJdKScsXG4gICAgICAnKFszXSknLFxuICAgICAgJyhbXSknLFxuICAgICAgJyhbMywgNF0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgb3V0cHV0IFRSVUUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IHR3byAycyBvciBhdCBsZWFzdCB0d28gM3MuIFVzZSBBUlIuTGVuZ3RoKCkgdG8gZ2V0IGl0cyBsZW5ndGguYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBEb3VibGUyMyhBUlIpXG4gIE5VTTIgPSAwXG4gIE5VTTMgPSAwXG5cbiAgbG9vcCBJIGZyb20gMCB0byBBUlIuTGVuZ3RoKCktMVxuICAgIGlmIEFSUltJXSA9IDIgdGhlblxuICAgICAgTlVNMiA9IE5VTTIgKyAxXG4gICAgZWxzZSBpZiBBUlJbSV0gPSAzIHRoZW5cbiAgICAgIE5VTTMgPSBOVU0zICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuXG4gIGlmIE5VTTMgPj0gMiBPUiBOVU0yID49IDIgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5cbmVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ1N1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzLCA0XSknLFxuICAgICAgJyhbMiwgMywgNSwgNywgMiwgM10pJyxcbiAgICAgICcoWzEsIDIsIDFdKScsXG4gICAgICAnKFszLCAyLCAxXSknLFxuICAgICAgJyhbMiwgMiwgM10pJyxcbiAgICAgICcoWzIsIDMsIDNdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludGVnZXJzLCBvdXRwdXQgdGhlIHN1bSBvZiBhbGwgbnVtYmVycyBpbiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdW0oQVJSKVxuICAgIFNVTSA9IDBcbiAgICBsb29wIEkgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKS0xXG4gICAgICBTVU0gPSBTVU0gKyBBUlJbSV1cbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBTVU1cbmVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnQXZlcmFnZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzLCA0XSknLFxuICAgICAgJyhbMiwgMywgNSwgNywgMiwgM10pJyxcbiAgICAgICcoWzEsIDIsIDFdKScsXG4gICAgICAnKFszLCAyLCAxXSknLFxuICAgICAgJyhbMiwgMiwgM10pJyxcbiAgICAgICcoWzIsIDMsIDNdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludGVnZXJzLCBvdXRwdXQgdGhlIGF2ZXJhZ2UgKG1lYW4pIG9mIGFsbCBudW1iZXJzIGluIHRoZSBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEF2ZXJhZ2UoQVJSKVxuICAgIFNVTSA9IDBcbiAgICBsb29wIEkgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKS0xXG4gICAgICBTVU0gPSBTVU0gKyBBUlJbSV1cbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBTVU0gLyBBUlIuTGVuZ3RoKClcbmVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnUG9zaXRpdmVBdmVyYWdlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDMsIDRdKScsXG4gICAgICAnKFsyLCAzLCA1LCA3LCAyLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMV0pJyxcbiAgICAgICcoWzMsIDIsIDFdKScsXG4gICAgICAnKFsyLCAyLCAzXSknLFxuICAgICAgJyhbMiwgMywgM10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50ZWdlcnMsIG91dHB1dCB0aGUgYXZlcmFnZSBvZiBhbGwgcG9zdGl2ZSBudW1iZXJzIGluIHRoZSBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFBvc2l0aXZlQXZlcmFnZShBUlIpXG4gICAgU1VNID0gMFxuICAgIENPVU5UID0gMFxuICAgIGxvb3AgSSBmcm9tIDAgdG8gQVJSLkxlbmd0aCgpLTFcbiAgICAgIGlmIEFSUltJXSA+IDBcbiAgICAgICAgU1VNID0gU1VNICsgQVJSW0ldXG4gICAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBTVU0gLyBDT1VOVFxuZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdGaXgyMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzLCA0XSknLFxuICAgICAgJyhbMiwgMywgNSwgNywgMiwgM10pJyxcbiAgICAgICcoWzEsIDIsIDFdKScsXG4gICAgICAnKFszLCAyLCAxXSknLFxuICAgICAgJyhbMiwgMiwgM10pJyxcbiAgICAgICcoWzIsIDMsIDNdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbnkgdGltZSB0aGVyZSBpcyBhIDIgZm9sbG93ZWQgYnkgYSAzLCBjaGFuZ2UgdGhlIDMgdG8gYSAwLiBcbiAgICBPdXRwdXQgdGhlIGNoYW5nZWQgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaXgyMyhBUlIpIFxuICAgIGxvb3AgSSBmcm9tIDAgdG8gQVJSLkxlbmd0aCgpLTJcbiAgICAgIGlmIEFSUltJXSA9IDIgQU5EIEFSUltJKzFdID0gMyB0aGVuXG4gICAgICAgIEFSUltJKzFdID0gMFxuICAgICAgZW5kIGlmXG4gICAgZW5kIGxvb3BcbiAgICBvdXRwdXQgQVJSXG5lbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ1N0YXJ0MScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzEsIDNdKScsXG4gICAgICAnKFs3LCAyLCAzXSwgWzFdKScsXG4gICAgICAnKFsxLCAyXSwgW10pJyxcbiAgICAgICcoW10sIFsxLCAyXSknLFxuICAgICAgJyhbN10sIFtdKScsXG4gICAgICAnKFs3XSwgWzFdKScsXG4gICAgICAnKFsxXSwgWzFdKScsXG4gICAgICAnKFs3XSwgWzhdKScsXG4gICAgICAnKFtdLCBbXSknLFxuICAgICAgJyhbMSwgM10sIFsxXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBTdGFydCB3aXRoIDIgaW50IGFycmF5cywgQSBhbmQgQiwgb2YgYW55IGxlbmd0aC4gT3V0cHV0IGhvdyBtYW55IG9mIHRoZSBhcnJheXNcbiAgICBoYXZlIDEgYXMgdGhlaXIgZmlyc3QgZWxlbWVudC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN0YXJ0MShBLEIpXG4gICAgQ09VTlQgPSAwXG4gICAgaWYgQS5MZW5ndGgoKSA+IDAgQU5EIEFbMF0gPSAxIHRoZW5cbiAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgZW5kIGlmXG4gICAgaWYgQi5MZW5ndGgoKSA+IDAgQU5EIEJbMF0gPSAxIHRoZW5cbiAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgZW5kIGlmXG4gICAgb3V0cHV0IENPVU5UXG4gIGVuZCBtZXRob2RgXG5cbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdCaWdnZXJTdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10sIFszLCA0LCA0XSknLFxuICAgICAgJyhbMywgNCwgMTFdLCBbMSwgMiwgOF0pJyxcbiAgICAgICcoWzEsIDEsIC0xXSwgWzEsIDAsIDBdKScsXG4gICAgICAnKFsyLCAxLCAxXSwgWzEsIDEsIDIsIDNdKScsXG4gICAgICAnKFsyLCAyLCAxLCAxXSwgWzEsIDMsIDMsIC0xXSknLFxuICAgICAgJyhbMSwgM10sIFsyLCAyXSknLFxuICAgICAgJyhbNiwgN10sIFszLCAxXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBTdGFydCB3aXRoIGludGVnZXIgYXJyYXlzLCBBIGFuZCBCLiBcbiAgICAgIEZpbmQgdGhlIHN1bSBvZiBlYWNoIGFycmF5IGFuZCBvdXRwdXQgdGhlIHdpbm5lciBcbiAgICAgIGluIHRoZSBmb3JtIFwiPGNvZGU+QTogMjM8L2NvZGU+XCIgKHdoZXJlIDIzIGlzIHRoZSBzdW0pLiBcbiAgICAgIElmIHRoZXJlIGlzIGEgdGllLCBvdXRwdXQgaW4gdGhlIGZvcm0gXCI8Y29kZT5USUU6IDIzPC9jb2RlPlwiYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBCaWdnZXJTdW0oQSxCKVxuICAgIFNVTUEgPSAwXG4gICAgU1VNQiA9IDBcbiAgICBsb29wIEkgZnJvbSAwIHRvIEEuTGVuZ3RoKCktMVxuICAgICAgU1VNQSA9IFNVTUEgKyBBW0ldXG4gICAgZW5kIGxvb3BcbiAgICBsb29wIEkgZnJvbSAwIHRvIEIuTGVuZ3RoKCkgLSAxXG4gICAgICBTVU1CID0gU1VNQiArIEJbSV1cbiAgICBlbmQgbG9vcFxuICAgIGlmIFNVTUEgPiBTVU1CIHRoZW5cbiAgICAgIG91dHB1dCBcIkE6IFwiICsgU1VNQVxuICAgIGVsc2UgaWYgU1VNQiA+IFNVTUEgdGhlblxuICAgICAgb3V0cHV0IFwiQjogXCIgKyBTVU1CXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IFwiVElFOiBcIiArIFNVTUFcbiAgICBlbmQgaWZcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdNYWtlTWlkZGxlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDMsIDQsIDVdKScsXG4gICAgICAnKFs3LCAxLCAyLCAzLCA0LCA5XSknLFxuICAgICAgJyhbMSwgMiwgN10pJyxcbiAgICAgICcoWzUsIDIsIDQsIDddKScsXG4gICAgICAnKFs5LCAwLCA0LCAzLCA5LCAxLCAyXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRlZ2Vycywgb3V0cHV0IGEgbmV3IGFycmF5IG9mIGxlbmd0aCAyLiBcbiAgICBUaGUgbmV3IGFycmF5IHNob3VsZCBjb250YWluIHRoZSB0d28gbWlkZGxlIGVsZW1lbnRzIGlmIHRoZSBvcmlnaW5hbCBhcnJheSBoYWRcbiAgICBhbiBldmVuIG51bWJlciBvZiBlbGVtZW50cywgb3IgaXQgc2hvdWxkIGNvbnRhaW4gdGhlIGV4YWN0IG1pZGRsZSBlbGVtZW50IHR3aWNlXG4gICAgaWYgdGhlIG9yaWdpbmFsIGFycmF5IGhhZCBhbiBvZGQgbnVtYmVyIG9mIGVsZW1lbnRzLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWFrZU1pZGRsZShBUlIpXG4gICAgaWYgQVJSLkxlbmd0aCgpIG1vZCAyID0gMCB0aGVuXG4gICAgICBNSUQgPSBBUlIuTGVuZ3RoKCkgLyAyIFxuICAgICAgLy9pZiBsZW5ndGggPSA0LCB0aGlzIHdpbGwgYmUgMiwgYW5kIHdlIHdhbnQgMSBhbmQgMlxuICAgICAgb3V0cHV0IFsgQVJSW01JRC0xXSwgQVJSW01JRF0gXVxuICAgIGVsc2VcbiAgICAgIE1JRCA9IEFSUi5MZW5ndGgoKSBkaXYgMlxuICAgICAgLy8gaWYgbGVuZ3RoID0gNSwgdGhpcyB3aWxsIGJlIDIsIGp1c3Qgd2hhdCB3ZSB3YW50IVxuICAgICAgb3V0cHV0IFsgQVJSW01JRF0sIEFSUltNSURdIF1cbiAgICBlbmQgaWZcbiAgZW5kIG1ldGhvZGAsXG5cbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdTZWxlY3Rpb25Tb3J0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDMsIDYsIDIsIDVdKScsXG4gICAgICAnKFs3LCAxLCAyLCAzLCA0LCA5XSknLFxuICAgICAgJyhbMSwgMywgMl0pJyxcbiAgICAgICcoWzUsIDIsIDQsIDddKScsXG4gICAgICAnKFs5LCAwLCA0LCAzLCA5LCAxLCAyXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBTb3J0IHRoZSBnaXZlbiBhcnJheSB1c2luZyBzZWxlY3Rpb24gc29ydCwgdGhlbiBvdXRwdXQgdGhlIHNvcnRlZCBhcnJheS5cbiAgICAodGhlIHRvb2wgd29uJ3Qga25vdyB3aGF0IHNvcnQgeW91IHVzZSwgc28gY2hlY2sgdGhlIHNvbHV0aW9uIHRvIG1ha2Ugc3VyZSBpdCBpcyByaWdodCEpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTZWxlY3Rpb25Tb3J0KEFSUilcbiAgICBsb29wIEZSTlQgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKSAtIDJcbiAgICAgIG1pbiA9IEFSUltGUk5UXVxuICAgICAgbG9vcCBDSEsgZnJvbSBGUk5UICsgMSB0byBBUlIuTGVuZ3RoKCkgLSAxXG4gICAgICAgIGlmIEFSUltDSEtdIDwgQVJSW0ZSTlRdIHRoZW5cbiAgICAgICAgICBURU1QID0gQVJSW0NIS11cbiAgICAgICAgICBBUlJbQ0hLXSA9IEFSUltGUk5UXVxuICAgICAgICAgIEFSUltGUk5UXSA9IFRFTVBcbiAgICAgICAgZW5kIGlmXG4gICAgICBlbmQgbG9vcFxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IEFSUlxuICBlbmQgbWV0aG9kYCxcblxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0J1YmJsZVNvcnQnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMywgNiwgMiwgNV0pJyxcbiAgICAgICcoWzcsIDEsIDIsIDMsIDQsIDldKScsXG4gICAgICAnKFsxLCAzLCAyXSknLFxuICAgICAgJyhbNSwgMiwgNCwgN10pJyxcbiAgICAgICcoWzksIDAsIDQsIDMsIDksIDEsIDJdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFNvcnQgdGhlIGdpdmVuIGFycmF5IHVzaW5nIGJ1YmJsZSBzb3J0LCB0aGVuIG91dHB1dCB0aGUgc29ydGVkIGFycmF5LlxuICAgICh0aGUgdG9vbCB3b24ndCBrbm93IHdoYXQgc29ydCB5b3UgdXNlLCBzbyBjaGVjayB0aGUgc29sdXRpb24gdG8gbWFrZSBzdXJlIGl0IGlzIHJpZ2h0ISlgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEJ1YmJsZVNvcnQoQVJSKVxuICAgIGxvb3AgTlVNQlVCQkxFRCBmcm9tIDAgdG8gQVJSLkxlbmd0aCgpIC0gMlxuICAgICAgRU5EID0gQVJSLkxlbmd0aCgpIC0gTlVNQlVCQkxFRCAtIDFcbiAgICAgIGxvb3AgQlVCIGZyb20gMCB0byBFTkRcbiAgICAgICAgaWYgQVJSW0JVQl0gPiBBUlJbQlVCICsgMV0gdGhlblxuICAgICAgICAgIFRFTVAgPSBBUlJbQlVCXVxuICAgICAgICAgIEFSUltCVUJdID0gQVJSW0JVQiArIDFdXG4gICAgICAgICAgQVJSW0JVQiArIDFdID0gVEVNUFxuICAgICAgICBlbmQgaWZcbiAgICAgIGVuZCBsb29wXG4gICAgZW5kIGxvb3BcbiAgICBvdXRwdXQgQVJSXG4gIGVuZCBtZXRob2RgLFxuXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnQmluYXJ5U2VhcmNoJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDMsIDUsIDcsIDExXSwgNyknLFxuICAgICAgJyhbMSwgMiwgMiwgMiwgMiwgMywgNCwgOV0sIDUpJyxcbiAgICAgICcoWzEsIDcsIDEyLCAxNywgMjAsIDIzLCAyM10sIDIwKScsXG4gICAgICAnKFsyLCA0LCA1LCA3LCA3LCAxMSwgMTEsIDE3XSwgMTcpJyxcbiAgICAgICcoWzAsIDEsIDIsIDgsIDksIDldLCAwKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFNlYXJjaCB0aGUgc29ydGVkIGFycmF5IEFSUiBmb3IgdGhlIHZhbHVlIFZBTCwgb3V0cHV0dGluZyB0aGUgSU5ERVggb2YgaXRzIGxvY2F0aW9uLiBJZiBWQUwgaXMgbm90IGluIHRoZSBhcnJheSwgb3V0cHV0IFwiTk9UIEZPVU5EXCIuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBCaW5hcnlTZWFyY2goQVJSLCBWQUwpXG4gICAgQkVHSU4gPSAwXG4gICAgRk9VTkQgPSBGQUxTRVxuICAgIEVORCA9IEFSUi5MZW5ndGgoKSAtIDFcblxuICAgIGxvb3Agd2hpbGUgQkVHSU4gPD0gRU5EIEFORCBOT1QgRk9VTkQgXG4gICAgICBNSUQgPSAoQkVHSU4gKyBFTkQpIGRpdiAyXG4gICAgICBpZiBBUlJbTUlEXSA9IFZBTCB0aGVuXG4gICAgICAgIG91dHB1dCBNSURcbiAgICAgICAgRk9VTkQgPSBUUlVFXG4gICAgICBlbHNlIGlmIEFSUltNSURdIDwgVkFMIHRoZW5cbiAgICAgICAgQkVHSU4gPSBNSUQgKyAxXG4gICAgICBlbHNlXG4gICAgICAgIEVORCA9IE1JRCAtIDFcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG5cbiAgICBpZiBOT1QgRk9VTkQgdGhlblxuICAgICAgb3V0cHV0IFwiTk9UIEZPVU5EXCJcbiAgICBlbmQgaWZcbiAgICBcbiAgZW5kIG1ldGhvZGAsXG5cbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdGaW5kVGFsbGVzdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFtcIkxlQnJvblwiLCBcIk1pY2hhZWxcIiwgXCJNYWdpY1wiLCBcIlNoYXF1aWxsZVwiXSwgWzIwNiwgMTk2LCAyMDIsIDIxNl0pJyxcbiAgICAgICcoW1wiUGVsw6lcIiwgXCJNYXJhZG9uYVwiLCBcIk1lc3NpXCIsIFwiUm9uYWxkb1wiXSwgWzE3MywgMTY1LCAxNzAsIDE4NV0pJyxcbiAgICAgICcoW1wiRGF2ZVwiLFwiTWFyeVwiLFwiQm9iXCJdLCBbMTgwLCAxNzIsIDE5MV0pJyxcblxuICAgIF0sXG4gICAgcHJlYW1ibGU6IGBmdW5jdGlvbiBDb21wYXJlKHN0cjEsIHN0cjIpIHsgcmV0dXJuIHN0cjEubG9jYWxlQ29tcGFyZShzdHIyKSB9YCxcbiAgICBxdWVzdGlvbjogYEluIHRoaXMgcHJvYmxlbSwgeW91IGFyZSBnaXZlbiB0d28gYXJyYXlzIGNhbGxlZCBOQU1FUyBhbmQgSEVJR0hUUy4gTkFNRVMgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmVwcmVzZW50aW5nIG5hbWVzLiBIRUlHSFRTIGlzIGFuIGFycmF5IG9mIGhlaWdodHMsIGluIGNtLiBUaGUgbmFtZSBpbiBhIGNlcnRhaW4gcG9zaXRpb24gY29ycmVzcG9uZHMgdG8gdGhlIGhlaWdodCBpbiB0aGUgc2FtZSBwb3NpdGlvbi4gWW91ciBtZXRob2Qgc2hvdWxkIGZpbmQsIGFuZCBvdXRwdXQsIHRoZSB0YWxsZXN0IHBlcnNvbiBpbiB0aGUgbGlzdC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEZpbmRUYWxsZXN0KE5BTUVTLCBIRUlHSFRTKVxuICAgIFRhbGxlc3RJbmRleCA9IDBcbiAgICBcbiAgICBsb29wIEkgZnJvbSAxIHRvIEhFSUdIVFMuTGVuZ3RoKCkgLSAxIFxuICAgICAgaWYgSEVJR0hUU1tJXSA+IEhFSUdIVFNbVGFsbGVzdEluZGV4XSB0aGVuXG4gICAgICAgICBUYWxsZXN0SW5kZXggPSBJXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBOQU1FU1tUYWxsZXN0SW5kZXhdXG4gICAgXG4gIGVuZCBtZXRob2RgLFxuXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnRmluZEJpZ2dlc3RCTUknLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbXCJMZUJyb25cIiwgXCJNaWNoYWVsXCIsIFwiTWFnaWNcIiwgXCJTaGFxdWlsbGVcIl0sIFsyMDYsIDE5NiwgMjAyLCAyMTZdLCBbMTEzLCA5OCwgMTAwLCAxNDddKScsXG4gICAgICAnKFtcIlBlbMOpXCIsIFwiTWFyYWRvbmFcIiwgXCJNZXNzaVwiLCBcIlJvbmFsZG9cIl0sIFsxNzMsIDE2NSwgMTcwLCAxODVdLCBbNjUsIDczLCA2OCwgODBdKScsXG4gICAgICAnKFtcIkRhdmVcIixcIk1hcnlcIixcIkJvYlwiXSwgWzE4MCwgMTcyLCAxOTFdLCBbODEsIDc0LCA4M10pJyxcblxuICAgIF0sXG4gICAgcHJlYW1ibGU6IGBmdW5jdGlvbiBDYWxjQk1JKGgsIHcpIHsgcmV0dXJuIHcgLyAoKGgvMTAwKSAqIChoLzEwMCkpIH1gLFxuICAgIHF1ZXN0aW9uOiBgSW4gdGhpcyBwcm9ibGVtLCB5b3UgYXJlIGdpdmVuIHRocmVlIGFycmF5cyBjYWxsZWQgTkFNRVMgKHN0cmluZ3MpLCBIRUlHSFRTIChudW1iZXJzLCBjbSksIGFuZCBXRUlHSFRTIChudW1iZXJzLCBrZykuIFlvdSBhbHNvIGhhdmUgYWNjZXNzIHRvIGEgbWV0aG9kIGNhbGxlZCBDYWxjQk1JKEgsIFcpIHRoYXQgYWNjZXB0cyB0aGUgaGVpZ2h0IChjbSkgYW5kIHdlaWdodCAoa2cpIGFuZCByZXR1cm5zIHRoZSBCb2R5IE1hc3MgSW5kZXggb2YgdGhlIHBlcnNvbi4gWW91ciBqb2IgaXMgdG8gaWRlbnRpZnkgdGhlIHBlcnNvbiB3aXRoIHRoZSBoaWdoZXN0IEJNSSBpbiBlYWNoIGdyb3VwIGFuZCBvdXRwdXQgc29tZXRoaW5nIGxpa2UgXCJCaWdnZXN0IEJNSSBvZiBfX19fIGZyb20gX19fX1wiYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaW5kQmlnZ2VzdEJNSShOQU1FUywgSEVJR0hUUywgV0VJR0hUUylcbiAgICBCaWdnZXN0Qk1JSW5kZXggPSAwXG4gICAgQmlnZ2VzdEJNSSA9IENhbGNCTUkoSEVJR0hUU1swXSwgV0VJR0hUU1swXSlcbiAgICBcbiAgICBsb29wIEkgZnJvbSAxIHRvIEhFSUdIVFMuTGVuZ3RoKCkgLSAxIFxuICAgICAgQk1JID0gQ2FsY0JNSShIRUlHSFRTW0ldLCBXRUlHSFRTW0ldKVxuICAgICAgaWYgQk1JID4gQmlnZ2VzdEJNSSB0aGVuXG4gICAgICAgICBCaWdnZXN0Qk1JSW5kZXggPSBJXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBcIkJpZ2dlc3QgQk1JIG9mIFwiICsgQmlnZ2VzdEJNSSArIFwiIGZyb20gXCIgKyBOQU1FU1tCaWdnZXN0Qk1JSW5kZXhdXG4gICAgXG4gIGVuZCBtZXRob2RgLFxuXG4gIH0sXG5cbl07XG5cbnZhciBub3RVc2VkID0gW1xuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3BsdXNUd28nLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMl0sIFszLCA0XSknLFxuICAgICAgJyhbNCwgNF0sIFsyLCAyXSknLFxuICAgICAgJyhbOSwgMl0sIFszLCA0XSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludCBhcnJheXMsIGVhY2ggbGVuZ3RoIDIsIHJldHVybiBhIG5ldyBhcnJheSBsZW5ndGggNFxuICAgIGNvbnRhaW5pbmcgYWxsIHRoZWlyIGVsZW1lbnRzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc3dhcEVuZHMnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgMywgNF0pJyxcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFs4LCA2LCA3LCA5LCA1XSknLFxuICAgICAgJyhbMywgMSwgNCwgMSwgNSwgOV0pJyxcbiAgICAgICcoWzEsIDJdKScsXG4gICAgICAnKFsxXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCBzd2FwIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXG4gICAgUmV0dXJuIHRoZSBtb2RpZmllZCBhcnJheS5UaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21pZFRocmVlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDMsIDQsIDVdKScsXG4gICAgICAnKFs4LCA2LCA3LCA1LCAzLCAwLCA5XSknLFxuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cyBvZiBvZGQgbGVuZ3RoLCByZXR1cm4gYSBuZXcgYXJyYXkgbGVuZ3RoIDNcbiAgICBjb250YWluaW5nIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBtaWRkbGUgb2YgdGhlIGFycmF5LlRoZSBhcnJheSBsZW5ndGggd2lsbCBiZVxuICAgIGF0IGxlYXN0IDMuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXhUcmlwbGUnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzEsIDUsIDNdKScsXG4gICAgICAnKFs1LCAyLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMywgMSwgMV0pJyxcbiAgICAgICcoWzEsIDcsIDMsIDEsIDVdKScsXG4gICAgICAnKFs1LCAxLCAzLCA3LCAxXSknLFxuICAgICAgJyhbNSwgMSwgNywgMywgNywgOCwgMV0pJyxcbiAgICAgICcoWzUsIDEsIDcsIDksIDcsIDgsIDFdKScsXG4gICAgICAnKFs1LCAxLCA3LCAzLCA3LCA4LCA5XSknLFxuICAgICAgJyhbMiwgMiwgNSwgMSwgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cyBvZiBvZGQgbGVuZ3RoLCBsb29rIGF0IHRoZSBmaXJzdCwgbGFzdCxcbiAgICBhbmQgbWlkZGxlIHZhbHVlcyBpbiB0aGUgYXJyYXkgYW5kIHJldHVybiB0aGUgbGFyZ2VzdC5UaGUgYXJyYXkgbGVuZ3RoIHdpbGxcbiAgICBiZSBhIGxlYXN0IDEuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmcm9udFBpZWNlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFsxLCAyXSknLFxuICAgICAgJyhbMV0pJyxcbiAgICAgICcoW10pJyxcbiAgICAgICcoWzYsIDUsIDBdKScsXG4gICAgICAnKFs2LCA1XSknLFxuICAgICAgJyhbMywgMSwgNCwgMSwgNV0pJyxcbiAgICAgICcoWzZdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGludCBhcnJheSBvZiBhbnkgbGVuZ3RoLCByZXR1cm4gYSBuZXcgYXJyYXkgb2YgaXRzIGZpcnN0XG4gICAgMiBlbGVtZW50cy5JZiB0aGUgYXJyYXkgaXMgc21hbGxlciB0aGFuIGxlbmd0aCAyLCB1c2Ugd2hhdGV2ZXJcbiAgICBlbGVtZW50cyBhcmUgcHJlc2VudC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3VubHVja3kxJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDMsIDQsIDVdKScsXG4gICAgICAnKFsyLCAxLCAzLCA0LCA1XSknLFxuICAgICAgJyhbMSwgMSwgMV0pJyxcbiAgICAgICcoWzEsIDMsIDFdKScsXG4gICAgICAnKFsxLCAxLCAzXSknLFxuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzMsIDMsIDNdKScsXG4gICAgICAnKFsxLCAzXSknLFxuICAgICAgJyhbMSwgNF0pJyxcbiAgICAgICcoWzFdKScsXG4gICAgICAnKFtdKScsXG4gICAgICAnKFsxLCAxLCAxLCAzLCAxXSknLFxuICAgICAgJyhbMSwgMSwgMywgMSwgMV0pJyxcbiAgICAgICcoWzEsIDEsIDEsIDEsIDNdKScsXG4gICAgICAnKFsxLCA0LCAxLCA1XSknLFxuICAgICAgJyhbMSwgMSwgMiwgM10pJyxcbiAgICAgICcoWzIsIDMsIDIsIDFdKScsXG4gICAgICAnKFsyLCAzLCAxLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMywgNCwgMSwgM10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYSAxIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgMyBpbiBhbiBhcnJheSBpc1xuICAgIGFuIFwidW5sdWNreVwiIDEuIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBhcnJheSBjb250YWlucyBhbiB1bmx1Y2t5IDEgaW4gdGhlXG4gICAgZmlyc3QgMiBvciBsYXN0IDIgcG9zaXRpb25zIGluIHRoZSBhcnJheS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21ha2UyJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzQsIDVdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzRdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoW10sIFsxLCAyXSknLFxuICAgICAgJyhbMSwgMl0sIFtdKScsXG4gICAgICAnKFszXSwgWzEsIDIsIDNdKScsXG4gICAgICAnKFszXSwgWzFdKScsXG4gICAgICAnKFszLCAxLCA0XSwgW10pJyxcbiAgICAgICcoWzFdLCBbMV0pJyxcbiAgICAgICcoWzEsIDIsIDNdLCBbNywgOF0pJyxcbiAgICAgICcoWzcsIDhdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzddLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzUsIDRdLCBbMiwgMywgN10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBpbnQgYXJyYXlzLCBhIGFuZCBiLCByZXR1cm4gYSBuZXcgYXJyYXkgbGVuZ3RoIDIgY29udGFpbmluZyxcbiAgICBhcyBtdWNoIGFzIHdpbGwgZml0LCB0aGUgZWxlbWVudHMgZnJvbSBhIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50cyBmcm9tIGIuVGhlXG4gICAgYXJyYXlzIG1heSBiZSBhbnkgbGVuZ3RoLCBpbmNsdWRpbmcgMCwgYnV0IHRoZXJlIHdpbGwgYmUgMiBvciBtb3JlIGVsZW1lbnRzXG4gICAgYXZhaWxhYmxlIGJldHdlZW4gdGhlIDIgYXJyYXlzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnZnJvbnQxMScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzcsIDksIDhdKScsXG4gICAgICAnKFsxXSwgWzJdKScsXG4gICAgICAnKFsxLCA3XSwgW10pJyxcbiAgICAgICcoW10sIFsyLCA4XSknLFxuICAgICAgJyhbXSwgW10pJyxcbiAgICAgICcoWzNdLCBbMSwgNCwgMSwgOV0pJyxcbiAgICAgICcoWzEsIDQsIDEsIDldLCBbXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludCBhcnJheXMsIGEgYW5kIGIsIG9mIGFueSBsZW5ndGgsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZVxuICAgIGZpcnN0IGVsZW1lbnQgb2YgZWFjaCBhcnJheS5JZiBlaXRoZXIgYXJyYXkgaXMgbGVuZ3RoIDAsIGlnbm9yZSB0aGF0IGFycmF5LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnZmluZExvd2VzdEluZGV4JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs5OSwgOTgsIDk3LCA5NiwgOTVdKVwiLFxuICAgICAgXCIoWzIsIDIsIDBdKVwiLFxuICAgICAgXCIoWzEsIDMsIDVdKVwiLFxuICAgICAgXCIoWzVdKVwiLFxuICAgICAgXCIoWzExLCA5LCAwLCAxXSlcIixcbiAgICAgIFwiKFsyLCAxMSwgOSwgMF0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbMiwgNSwgLTEyXSlcIixcbiAgICBdLFxuXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5LlRoZSBpbnB1dCBhcnJheSB3aWxsIGhhdmUgYXRcbiAgICAgbGVhc3Qgb25lIGVsZW1lbnQgaW4gaXQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2NvdW50RXZlbnMnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzIsIDEsIDIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzIsIDIsIDBdKVwiLFxuICAgICAgXCIoWzEsIDMsIDVdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMTEsIDksIDAsIDFdKVwiLFxuICAgICAgXCIoWzIsIDExLCA5LCAwXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFsyLCA1LCAxMl0pXCIsXG4gICAgXSxcblxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIHRoZSBudW1iZXIgb2YgZXZlbiBpbnRzIGluIHRoZSBnaXZlbiBhcnJheS5Ob3RlOiB0aGUgJSBcIm1vZFwiXG4gICAgb3BlcmF0b3IgY29tcHV0ZXMgdGhlIHJlbWFpbmRlciwgZS5nLiA1ICUgMiBpcyAxLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdiaWdEaWZmJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxMCwgMywgNSwgNl0pXCIsXG4gICAgICBcIihbNywgMiwgMTAsIDldKVwiLFxuICAgICAgXCIoWzIsIDEwLCA3LCAyXSlcIixcbiAgICAgIFwiKFsyLCAxMF0pXCIsXG4gICAgICBcIihbMTAsIDJdKVwiLFxuICAgICAgXCIoWzEwLCAwXSlcIixcbiAgICAgIFwiKFsyLCAzXSlcIixcbiAgICAgIFwiKFsyLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFs1LCAxLCA2LCAxLCA5LCA5XSlcIixcbiAgICAgIFwiKFs3LCA2LCA4LCA1XSlcIixcbiAgICAgIFwiKFs3LCA3LCA2LCA4LCA1LCA1LCA2XSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgbGVuZ3RoIDEgb3IgbW9yZSBvZiBpbnRzLCByZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxudGhlIGxhcmdlc3QgYW5kIHNtYWxsZXN0IHZhbHVlcyBpbiB0aGUgYXJyYXkuTm90ZTogdGhlIGJ1aWx0IC1pbiBNYXRoLm1pbih2MSwgdjIpXG5hbmQgTWF0aC5tYXgodjEsIHYyKSBtZXRob2RzIHJldHVybiB0aGUgc21hbGxlciBvciBsYXJnZXIgb2YgdHdvIHZhbHVlcy5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnY2VudGVyZWRBdmVyYWdlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAzLCA0LCAxMDBdKVwiLFxuICAgICAgXCIoWzEsIDEsIDUsIDUsIDEwLCA4LCA3XSlcIixcbiAgICAgIFwiKFstMTAsIC00LCAtMiwgLTQsIC0yLCAwXSlcIixcbiAgICAgIFwiKFs1LCAzLCA0LCA2LCAyXSlcIixcbiAgICAgIFwiKFs1LCAzLCA0LCAwLCAxMDBdKVwiLFxuICAgICAgXCIoWzEwMCwgMCwgNSwgMywgNF0pXCIsXG4gICAgICBcIihbNCwgMCwgMTAwXSlcIixcbiAgICAgIFwiKFswLCAyLCAzLCA0LCAxMDBdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEwMF0pXCIsXG4gICAgICBcIihbNywgNywgN10pXCIsXG4gICAgICBcIihbMSwgNywgOF0pXCIsXG4gICAgICBcIihbMSwgMSwgOTksIDk5XSlcIixcbiAgICAgIFwiKFsxMDAwLCAwLCAxLCA5OV0pXCIsXG4gICAgICBcIihbNCwgNCwgNCwgNCwgNV0pXCIsXG4gICAgICBcIihbNCwgNCwgNCwgMSwgNV0pXCIsXG4gICAgICBcIihbNiwgNCwgOCwgMTIsIDNdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIFwiY2VudGVyZWRcIiBhdmVyYWdlIG9mIGFuIGFycmF5IG9mIGludHMsIHdoaWNoIHdlJ2xsIHNheVxuaXMgdGhlIG1lYW4gYXZlcmFnZSBvZiB0aGUgdmFsdWVzLCBleGNlcHQgaWdub3JpbmcgdGhlIGxhcmdlc3QgYW5kIHNtYWxsZXN0XG52YWx1ZXMgaW4gdGhlIGFycmF5LklmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb3BpZXMgb2YgdGhlIHNtYWxsZXN0IHZhbHVlLCBpZ25vcmVcbmp1c3Qgb25lIGNvcHksIGFuZCBsaWtld2lzZSBmb3IgdGhlIGxhcmdlc3QgdmFsdWUuVXNlIGludCBkaXZpc2lvbiB0byBwcm9kdWNlXG50aGUgZmluYWwgYXZlcmFnZS5Zb3UgbWF5IGFzc3VtZSB0aGF0IHRoZSBhcnJheSBpcyBsZW5ndGggMyBvciBtb3JlLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzdW0xMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMiwgMV0pXCIsXG4gICAgICBcIihbMSwgMV0pXCIsXG4gICAgICBcIihbMSwgMiwgMiwgMSwgMTNdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEzLCAyLCAxLCAxM10pXCIsXG4gICAgICBcIihbMTMsIDEsIDIsIDEzLCAyLCAxLCAxM10pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxM10pXCIsXG4gICAgICBcIihbMTMsIDEzXSlcIixcbiAgICAgIFwiKFsxMywgMCwgMTNdKVwiLFxuICAgICAgXCIoWzEzLCAxLCAxM10pXCIsXG4gICAgICBcIihbNSwgNywgMl0pXCIsXG4gICAgICBcIihbNSwgMTMsIDJdKVwiLFxuICAgICAgXCIoWzBdKVwiLFxuICAgICAgXCIoWzEzLCAwXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIHRoZSBzdW0gb2YgdGhlIG51bWJlcnMgaW4gdGhlIGFycmF5LCByZXR1cm5pbmcgMCBmb3IgYW4gZW1wdHkgYXJyYXkuXG4gICAgRXhjZXB0IHRoZSBudW1iZXIgMTMgaXMgdmVyeSB1bmx1Y2t5LCBzbyBpdCBkb2VzIG5vdCBjb3VudCBhbmQgbnVtYmVycyB0aGF0IGNvbWVcbmltbWVkaWF0ZWx5IGFmdGVyIGEgMTMgYWxzbyBkbyBub3QgY291bnQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3N1bTY3JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCA2LCA5OSwgOTksIDddKVwiLFxuICAgICAgXCIoWzEsIDEsIDYsIDcsIDJdKVwiLFxuICAgICAgXCIoWzEsIDYsIDIsIDIsIDcsIDEsIDYsIDk5LCA5OSwgN10pXCIsXG4gICAgICBcIihbMSwgNiwgMiwgNiwgMiwgNywgMSwgNiwgOTksIDk5LCA3XSlcIixcbiAgICAgIFwiKFsyLCA3LCA2LCAyLCA2LCA3LCAyLCA3XSlcIixcbiAgICAgIFwiKFsyLCA3LCA2LCAyLCA2LCAyLCA3XSlcIixcbiAgICAgIFwiKFsxLCA2LCA3LCA3XSlcIixcbiAgICAgIFwiKFs2LCA3LCAxLCA2LCA3LCA3XSlcIixcbiAgICAgIFwiKFs2LCA4LCAxLCA2LCA3XSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzYsIDcsIDExXSlcIixcbiAgICAgIFwiKFsxMSwgNiwgNywgMTFdKVwiLFxuICAgICAgXCIoWzIsIDIsIDYsIDcsIDddKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBpbiB0aGUgYXJyYXksIGV4Y2VwdCBpZ25vcmUgc2VjdGlvbnMgb2Zcbm51bWJlcnMgc3RhcnRpbmcgd2l0aCBhIDYgYW5kIGV4dGVuZGluZyB0byB0aGUgbmV4dCA3KGV2ZXJ5IDYgd2lsbCBiZSBmb2xsb3dlZFxuICAgICAgIGJ5IGF0IGxlYXN0IG9uZSA3KS5SZXR1cm4gMCBmb3Igbm8gbnVtYmVycy5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnaGFzMjInLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDEsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDMsIDIsIDJdKVwiLFxuICAgICAgXCIoWzQsIDIsIDQsIDIsIDIsIDVdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDJdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMywgMywgMiwgMl0pXCIsXG4gICAgICBcIihbNSwgMiwgNSwgMl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIHRoZSBhcnJheSBjb250YWluc1xuYSAyIG5leHQgdG8gYSAyIHNvbWV3aGVyZS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbHVja3kxMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMCwgMiwgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgNF0pXCIsXG4gICAgICBcIihbMiwgNywgMiwgOF0pXCIsXG4gICAgICBcIihbMiwgNywgMSwgOF0pXCIsXG4gICAgICBcIihbMywgNywgMiwgOF0pXCIsXG4gICAgICBcIihbMiwgNywgMiwgMV0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMl0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbM10pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIG5vIDEncyBhbmQgbm8gMydzLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzdW0yOCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMiwgMywgMiwgMiwgNCwgMl0pXCIsXG4gICAgICBcIihbMiwgMywgMiwgMiwgNCwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMiwgMiwgMiwgNF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFs4XSlcIixcbiAgICAgIFwiKFsyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCAyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFs1LCAyLCAyLCAyLCA0LCAyXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIHN1bSBvZiBhbGwgdGhlIDIncyBpblxudGhlIGFycmF5IGlzIGV4YWN0bHkgOC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbW9yZTE0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCA0LCAxXSlcIixcbiAgICAgIFwiKFsxLCA0LCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCAxXSlcIixcbiAgICAgIFwiKFsxLCA2LCA2XSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsxLCA0XSlcIixcbiAgICAgIFwiKFs2LCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCA2LCA0XSlcIixcbiAgICAgIFwiKFsxLCAxLCA0LCA0LCAxXSlcIixcbiAgICAgIFwiKFsxLCAxLCA2LCA0LCA0LCAxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzQsIDEsIDQsIDZdKVwiLFxuICAgICAgXCIoWzQsIDEsIDQsIDYsIDFdKVwiLFxuICAgICAgXCIoWzEsIDQsIDEsIDQsIDEsIDZdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgbnVtYmVyIG9mIDEncyBpcyBncmVhdGVyXG50aGFuIHRoZSBudW1iZXIgb2YgNCdzYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3ByZXBlbmRTdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDBdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzUsIDddKVwiLFxuICAgICAgXCIoWzAsIDAsIDAsIDBdKVwiLFxuICAgICAgXCIoWzEyLCAxMywgMTksIDIwXSlcIixcbiAgICAgIFwiKFstMiwgMiwgLTIsIDJdKVwiLFxuICAgICAgXCIoWzUsIDQsIDMsIDIsIDEsIDBdKVwiLFxuICAgIF0sXG5cbiAgICBxdWVzdGlvbjogYFJldHVybiBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGlucHV0IGFycmF5IChudW1zKSwgd2hlcmUgdGhlIGZpcnN0IHR3byBpdGVtcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgIGFuZCBvbmUgaXRlbSDigJMgdGhlIHN1bSBvZiB0aG9zZSB0d28gaXRlbXMgLSBpcyBhZGRlZCB0byB0aGUgc3RhcnQgb2YgdGhlIGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXp6QXJyYXknLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDEpXCIsXG4gICAgICBcIigxMClcIixcbiAgICAgIFwiKDApXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoNylcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgbiwgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIG4sXG4gICAgY29udGFpbmluZyB0aGUgbnVtYmVycyAwLCAxLCAyLCAuLi4gbi0xLiBUaGUgZ2l2ZW4gbiBtYXkgYmUgMCwgaW4gd2hpY2ggY2FzZVxuICAgIGp1c3QgcmV0dXJuIGEgbGVuZ3RoIDAgYXJyYXkuIFlvdSBkbyBub3QgbmVlZCBhIHNlcGFyYXRlIGlmLXN0YXRlbWVudCBmb3IgdGhlXG4gICAgbGVuZ3RoLTAgY2FzZTsgdGhlIGZvci1sb29wIHNob3VsZCBuYXR1cmFsbHkgZXhlY3V0ZSAwIHRpbWVzIGluIHRoYXQgY2FzZSxcbiAgICBzbyBpdCBqdXN0IHdvcmtzLiBUaGUgc3ludGF4IHRvIG1ha2UgYSBuZXcgYXJyYXkgaXMgbGV0IG15QXJyYXkgPSBbXTtgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnb25seTE0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCA0LCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCA0LCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAxXSlcIixcbiAgICAgIFwiKFs0LCAxXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzEsIDQsIDEsIDNdKVwiLFxuICAgICAgXCIoWzMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzRdKVwiLFxuICAgICAgXCIoWzMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDVdKVwiLFxuICAgICAgXCIoWzQsIDEsIDQsIDFdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGlzIGEgMSBvciBhIDQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpenpBcnJheTInLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDEwKVwiLFxuICAgICAgXCIoMilcIixcbiAgICAgIFwiKDEpXCIsXG4gICAgICBcIigwKVwiLFxuICAgICAgXCIoNylcIixcbiAgICAgIFwiKDkpXCIsXG4gICAgICBcIigxMSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgbiwgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgc3RyaW5nIGFycmF5IG9mIGxlbmd0aCBuLFxuICAgIGNvbnRhaW5pbmcgdGhlIHN0cmluZ3MgXCIwXCIsIFwiMVwiIFwiMlwiIC4uIHRocm91Z2ggbi0xLiBOIG1heSBiZSAwLCBpbiB3aGljaCBjYXNlXG4gICAganVzdCByZXR1cm4gYSBsZW5ndGggMCBhcnJheS4gTm90ZTogU3RyaW5nKHh4eCkgd2lsbCBtYWtlIHRoZSBTdHJpbmdcbiAgICBmb3JtIG9mIG1vc3QgdHlwZXMuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ25vMTQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDNdKVwiLFxuICAgICAgXCIoWzEsIDIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDQsIDRdKVwiLFxuICAgICAgXCIoWzIsIDIsIDQsIDRdKVwiLFxuICAgICAgXCIoWzIsIDMsIDQsIDFdKVwiLFxuICAgICAgXCIoWzIsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDRdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzIsIDFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzRdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMV0pXCIsXG4gICAgICBcIihbOSwgNCwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgMiwgMywgMV0pXCIsXG4gICAgICBcIihbNCwgMiwgMywgNV0pXCIsXG4gICAgICBcIihbNCwgNCwgMl0pXCIsXG4gICAgICBcIihbMSwgNCwgNF0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIGl0IGNvbnRhaW5zIG5vIDEncyBvciBpdCBjb250YWlucyBubyA0J3MuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2lzRXZlcnl3aGVyZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMSwgM10sIDEpXCIsXG4gICAgICBcIihbMSwgMiwgMSwgM10sIDIpXCIsXG4gICAgICBcIihbMSwgMiwgMSwgMywgNF0sIDEpXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMV0sIDEpXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMV0sIDIpXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMywgMV0sIDIpXCIsXG4gICAgICBcIihbMywgMV0sIDMpXCIsXG4gICAgICBcIihbMywgMV0sIDIpXCIsXG4gICAgICBcIihbM10sIDEpXCIsXG4gICAgICBcIihbXSwgMSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAyLCAzLCAyLCA1XSwgMilcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAxLCAxLCAyXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAxLCAxLCAyXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAyLCAyLCAxLCAxLCAyXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAyLCAyLCAxLCAyLCAxXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAxLCAyXSwgMilcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYSB2YWx1ZSBpcyBcImV2ZXJ5d2hlcmVcIiBpbiBhbiBhcnJheSBpZiBmb3IgZXZlcnlcbiAgICBwYWlyIG9mIGFkamFjZW50IGVsZW1lbnRzIGluIHRoZSBhcnJheSwgYXQgbGVhc3Qgb25lIG9mIHRoZSBwYWlyIGlzIHRoYXQgdmFsdWUuXG4gICAgUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGV2ZXJ5d2hlcmUgaW4gdGhlIGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdlaXRoZXIyNCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMl0pXCIsXG4gICAgICBcIihbNCwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgNCwgMSwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMywgNSwgOV0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNCwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgMiwgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgMiwgNCwgNF0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMl0pXCIsXG4gICAgICBcIihbNCwgNF0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGEgMlxuICAgIG5leHQgdG8gYSAyIG9yIGEgNCBuZXh0IHRvIGEgNCwgYnV0IG5vdCBib3RoLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXRjaFVwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAzXSwgWzIsIDMsIDEwXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSwgWzIsIDMsIDVdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbMiwgMywgM10pXCIsXG4gICAgICBcIihbNSwgM10sIFs1LCA1XSlcIixcbiAgICAgIFwiKFs1LCAzXSwgWzQsIDRdKVwiLFxuICAgICAgXCIoWzUsIDNdLCBbMywgM10pXCIsXG4gICAgICBcIihbNSwgM10sIFsyLCAyXSlcIixcbiAgICAgIFwiKFs1LCAzXSwgWzEsIDFdKVwiLFxuICAgICAgXCIoWzUsIDNdLCBbMCwgMF0pXCIsXG4gICAgICBcIihbNF0sIFs0XSlcIixcbiAgICAgIFwiKFs0XSwgWzVdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhcnJheXMgbnVtczEgYW5kIG51bXMyIG9mIHRoZSBzYW1lIGxlbmd0aCwgZm9yIGV2ZXJ5IGVsZW1lbnRcbiAgICBpbiBudW1zMSwgY29uc2lkZXIgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBudW1zMiAoYXQgdGhlIHNhbWUgaW5kZXgpLlxuICAgIFJldHVybiB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSB0d28gZWxlbWVudHMgZGlmZmVyIGJ5IDIgb3JcbiAgICBsZXNzLCBidXQgYXJlIG5vdCBlcXVhbC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnaGFzNzcnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDcsIDddKVwiLFxuICAgICAgXCIoWzEsIDcsIDEsIDddKVwiLFxuICAgICAgXCIoWzEsIDcsIDEsIDEsIDddKVwiLFxuICAgICAgXCIoWzcsIDcsIDEsIDEsIDddKVwiLFxuICAgICAgXCIoWzIsIDcsIDIsIDIsIDcsIDJdKVwiLFxuICAgICAgXCIoWzIsIDcsIDIsIDIsIDcsIDddKVwiLFxuICAgICAgXCIoWzcsIDIsIDcsIDIsIDIsIDddKVwiLFxuICAgICAgXCIoWzcsIDIsIDYsIDIsIDIsIDddKVwiLFxuICAgICAgXCIoWzcsIDcsIDddKVwiLFxuICAgICAgXCIoWzcsIDEsIDddKVwiLFxuICAgICAgXCIoWzcsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzEsIDddKVwiLFxuICAgICAgXCIoWzddKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgdHdvIDcnc1xuICAgIG5leHQgdG8gZWFjaCBvdGhlciwgb3IgdGhlcmUgYXJlIHR3byA3J3Mgc2VwYXJhdGVkIGJ5IG9uZSBlbGVtZW50LFxuICAgIHN1Y2ggYXMgd2l0aCB7NywgMSwgN30uYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2hhczEyJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAzLCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCA0LCA1LCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCA0LCA1LCA2XSlcIixcbiAgICAgIFwiKFszLCAxLCA0LCAxLCA2LCAyXSlcIixcbiAgICAgIFwiKFsyLCAxLCA0LCAxLCA2LCAyXSlcIixcbiAgICAgIFwiKFsyLCAxLCA0LCAxLCA2XSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsyLCAxLCAzXSlcIixcbiAgICAgIFwiKFsyLCAxLCAzLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFszLCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCAzLCAyXSlcIixcbiAgICAgIFwiKFszLCA1LCA5XSlcIixcbiAgICAgIFwiKFszLCA1LCAxXSlcIixcbiAgICAgIFwiKFszLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSAxIGluIHRoZSBhcnJheVxuICAgIHdpdGggYSAyIHNvbWV3aGVyZSBsYXRlciBpbiB0aGUgYXJyYXkuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21vZFRocmVlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsyLCAxLCAzLCA1XSlcIixcbiAgICAgIFwiKFsyLCAxLCAyLCA1XSlcIixcbiAgICAgIFwiKFsyLCA0LCAyLCA1XSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAyLCAxXSlcIixcbiAgICAgIFwiKFs5LCA5LCA5XSlcIixcbiAgICAgIFwiKFsxLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzksIDcsIDIsIDldKVwiLFxuICAgICAgXCIoWzksIDcsIDIsIDksIDIsIDJdKVwiLFxuICAgICAgXCIoWzksIDcsIDIsIDksIDIsIDIsIDZdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgZWl0aGVyXG4gICAgMyBldmVuIG9yIDMgb2RkIHZhbHVlcyBhbGwgbmV4dCB0byBlYWNoIG90aGVyLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaW5kVGhlTWVkaWFuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs0LDksOSwyLDEsNV0pXCIsXG4gICAgICBcIihbMSwgNSwgMywgMSAsIDVdKVwiLFxuICAgICAgXCIoWzEwLCAxMiwgMTVdKVwiLFxuICAgICAgXCIoWzVdKVwiLFxuICAgICAgXCIoWzExLCA5LCAwLCAxXSlcIixcbiAgICAgIFwiKFstMSwgMTEsIC0yLCAxMCwgLTMsIDE1XSlcIixcbiAgICAgIFwiKFsyLCAxMCwgMTUsIDEzXSlcIixcbiAgICAgIFwiKFsyLCA1LCAtMTJdKVwiLFxuICAgIF0sXG5cbiAgICBxdWVzdGlvbjogYFdyaXRlIGEgbWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgbWVkaWFuIHZhbHVlIG9mIGFuIGFycmF5LiBUaGUgaW5wdXQgYXJyYXkgd2lsbCBuZXZlciBiZSBlbXB0eS5cbiAgICBcXG5JZiB0aGUgYXJyYXkgaXMgb2RkIGluIGxlbmd0aCwgdGhlIG1lZGlhbiBpcyB0aGUgdmFsdWUgaW4gdGhlIGNlbnRyZSBvZiB0aGUgYXJyYXkuXFxcbiAgICBcXG5JZiB0aGUgYXJyYXkgaXMgZXZlbiwgdGhlIG1lZGlhbiBzaG91bGQgYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGUgdmFsdWVzLiBcXG4gXG4gICAgSGludDogWW91IHdpbGwgbmVlZCB0byBlbnN1cmUgdGhlIGlucHV0IGFycmF5IGlzIHNvcnRlZCAtIHRoZXJlIGlzIGEgc29ydCgpIGFycmF5IG1ldGhvZCB5b3UgY2FuIHVzZSBmb3IgdGhpcyBzdGVwLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdoYXZlVGhyZWUnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzMsIDEsIDMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzMsIDEsIDMsIDNdKVwiLFxuICAgICAgXCIoWzMsIDQsIDMsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDMsIDEsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzEsIDMsIDMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDMsIDEsIDMsIDQsIDNdKVwiLFxuICAgICAgXCIoWzMsIDQsIDMsIDQsIDMsIDQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDNdKVwiLFxuICAgICAgXCIoWzEsIDNdKVwiLFxuICAgICAgXCIoWzNdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgMyBhcHBlYXJzIGluIHRoZSBhcnJheSBleGFjdGx5XG4gICAgIDMgdGltZXMsIGFuZCBubyAzJ3MgYXJlIG5leHQgdG8gZWFjaCBvdGhlci5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAndHdvVHdvJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs0LCAyLCAyLCAzXSlcIixcbiAgICAgIFwiKFsyLCAyLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCA0LCAyXSlcIixcbiAgICAgIFwiKFsxLCAzLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCA3XSlcIixcbiAgICAgIFwiKFsyLCAyLCA3LCAyLCAxXSlcIixcbiAgICAgIFwiKFs0LCAyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzUsIDIsIDIsIDNdKVwiLFxuICAgICAgXCIoWzIsIDIsIDUsIDJdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiBldmVyeSAyIHRoYXQgYXBwZWFycyBpblxuICAgIHRoZSBhcnJheSBpcyBuZXh0IHRvIGFub3RoZXIgMi5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc2FtZUVuZHMnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzUsIDYsIDQ1LCA5OSwgMTMsIDUsIDZdLCAxKVwiLFxuICAgICAgXCIoWzUsIDYsIDQ1LCA5OSwgMTMsIDUsIDZdLCAyKVwiLFxuICAgICAgXCIoWzUsIDYsIDQ1LCA5OSwgMTMsIDUsIDZdLCAzKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCAxKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCAyKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCAwKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCA1KVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAwKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAxKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAyKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAzKVwiLFxuICAgICAgXCIoWzFdLCAxKVwiLFxuICAgICAgXCIoW10sIDApXCIsXG4gICAgICBcIihbNCwgMiwgNCwgNV0sIDEpXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBncm91cCBvZiBOIG51bWJlcnMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlXG4gICAgYXJyYXkgYXJlIHRoZSBzYW1lLiBGb3IgZXhhbXBsZSwgd2l0aCB7NSwgNiwgNDUsIDk5LCAxMywgNSwgNn0sIHRoZSBlbmRzIGFyZVxuICAgIHRoZSBzYW1lIGZvciBuPTAgYW5kIG49MiwgYW5kIGZhbHNlIGZvciBuPTEgYW5kIG49My4gWW91IG1heSBhc3N1bWUgdGhhdCBuXG4gICAgaXMgaW4gdGhlIHJhbmdlIDAuLm51bXMuTGVuZ3RoKCkgaW5jbHVzaXZlLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd0cmlwbGVVcCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgNCwgNSwgNiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgNCwgNSwgNywgNiwgNSwgNiwgNywgNl0pXCIsXG4gICAgICBcIihbMSwgMiwgNCwgNSwgNywgNiwgNSwgNywgNywgNl0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxMCwgOSwgOCwgLTEwMCwgLTk5LCAtOTgsIDEwMF0pXCIsXG4gICAgICBcIihbMTAsIDksIDgsIC0xMDAsIC05OSwgOTksIDEwMF0pXCIsXG4gICAgICBcIihbLTEwMCwgLTk5LCAtOTksIDEwMCwgMTAxLCAxMDJdKVwiLFxuICAgICAgXCIoWzIsIDMsIDUsIDYsIDgsIDksIDIsIDNdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMsIHNvbWV3aGVyZSwgdGhyZWUgaW5jcmVhc2luZ1xuICAgIGFkamFjZW50IG51bWJlcnMgbGlrZSAuLi4uIDQsIDUsIDYsIC4uLiBvciAyMywgMjQsIDI1LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXp6QXJyYXkzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDUsIDEwKVwiLFxuICAgICAgXCIoMTEsIDE4KVwiLFxuICAgICAgXCIoMSwgMylcIixcbiAgICAgIFwiKDEsIDIpXCIsXG4gICAgICBcIigxLCAxKVwiLFxuICAgICAgXCIoMTAwMCwgMTAwNSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gc3RhcnQgYW5kIGVuZCBudW1iZXJzLCByZXR1cm4gYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGVcbiAgICBzZXF1ZW5jZSBvZiBpbnRlZ2VycyBmcm9tIHN0YXJ0IHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGVuZCwgc28gc3RhcnQ9NSBhbmRcbiAgICBlbmQ9MTAgeWllbGRzIHs1LCA2LCA3LCA4LCA5fS4gVGhlIGVuZCBudW1iZXIgd2lsbCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZVxuICAgIHN0YXJ0IG51bWJlci4gTm90ZSB0aGF0IGEgbGVuZ3RoLTAgYXJyYXkgaXMgdmFsaWQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3NoaWZ0TGVmdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbNiwgMiwgNSwgM10pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxLCAxLCAyLCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGFuIGFycmF5IHRoYXQgaXMgXCJsZWZ0IHNoaWZ0ZWRcIiBieSBvbmUgLS0gc28gezYsIDIsIDUsIDN9XG4gICAgcmV0dXJucyB7MiwgNSwgMywgNn0uIFlvdSBtYXkgbW9kaWZ5IGFuZCByZXR1cm4gdGhlIGdpdmVuIGFycmF5LCBvciByZXR1cm5cbiAgICBhIG5ldyBhcnJheS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAndGVuUnVuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsyLCAxMCwgMywgNCwgMjAsIDVdKVwiLFxuICAgICAgXCIoWzEwLCAxLCAyMCwgMl0pXCIsXG4gICAgICBcIihbMTAsIDEsIDksIDIwXSlcIixcbiAgICAgIFwiKFsxLCAyLCA1MCwgMV0pXCIsXG4gICAgICBcIihbMSwgMjAsIDUwLCAxXSlcIixcbiAgICAgIFwiKFsxMCwgMTBdKVwiLFxuICAgICAgXCIoWzEwLCAyXSlcIixcbiAgICAgIFwiKFswLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBGb3IgZWFjaCBtdWx0aXBsZSBvZiAxMCBpbiB0aGUgZ2l2ZW4gYXJyYXksIGNoYW5nZSBhbGwgdGhlIHZhbHVlc1xuICAgIGZvbGxvd2luZyBpdCB0byBiZSB0aGF0IG11bHRpcGxlIG9mIDEwLCB1bnRpbCBlbmNvdW50ZXJpbmcgYW5vdGhlciBtdWx0aXBsZVxuICAgIG9mIDEwLiBTbyB7MiwgMTAsIDMsIDQsIDIwLCA1fSB5aWVsZHMgezIsIDEwLCAxMCwgMTAsIDIwLCAyMH0uYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3ByZTQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDQsIDFdKVwiLFxuICAgICAgXCIoWzMsIDEsIDRdKVwiLFxuICAgICAgXCIoWzEsIDQsIDRdKVwiLFxuICAgICAgXCIoWzEsIDQsIDQsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDQsIDIsIDRdKVwiLFxuICAgICAgXCIoWzQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDRdKVwiLFxuICAgICAgXCIoWzIsIDEsIDQsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDEsIDQsIDJdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIG5vbi1lbXB0eSBhcnJheSBvZiBpbnRzLCByZXR1cm4gYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGVcbiAgICBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheSB0aGF0IGNvbWUgYmVmb3JlIHRoZSBmaXJzdCA0IGluIHRoZSBvcmlnaW5hbFxuICAgICBhcnJheS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgY29udGFpbiBhdCBsZWFzdCBvbmUgNC4gTm90ZSB0aGF0IGl0IGlzIHZhbGlkXG4gICAgIGluIGphdmEgdG8gY3JlYXRlIGFuIGFycmF5IG9mIGxlbmd0aCAwLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdwb3N0NCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMiwgNCwgMSwgMl0pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgMl0pXCIsXG4gICAgICBcIihbNCwgNCwgMSwgMiwgM10pXCIsXG4gICAgICBcIihbNCwgMl0pXCIsXG4gICAgICBcIihbNCwgNCwgM10pXCIsXG4gICAgICBcIihbNCwgNF0pXCIsXG4gICAgICBcIihbNF0pXCIsXG4gICAgICBcIihbMiwgNCwgMSwgNCwgMywgMl0pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgMiwgMiwgMl0pXCIsXG4gICAgICBcIihbMywgNCwgMywgMl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbm9uLWVtcHR5IGFycmF5IG9mIGludHMsIHJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZVxuICAgIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIGFycmF5IHRoYXQgY29tZSBhZnRlciB0aGUgbGFzdCA0IGluIHRoZSBvcmlnaW5hbFxuICAgIGFycmF5LiBUaGUgb3JpZ2luYWwgYXJyYXkgd2lsbCBjb250YWluIGF0IGxlYXN0IG9uZSA0LiBOb3RlIHRoYXQgaXQgaXMgdmFsaWRcbiAgICBpbiBqYXZhIHRvIGNyZWF0ZSBhbiBhcnJheSBvZiBsZW5ndGggMC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbm90QWxvbmUnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDNdLCAyKVwiLFxuICAgICAgXCIoWzEsIDIsIDMsIDIsIDUsIDJdLCAyKVwiLFxuICAgICAgXCIoWzMsIDRdLCAzKVwiLFxuICAgICAgXCIoWzMsIDNdLCAzKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDJdLCAxKVwiLFxuICAgICAgXCIoWzNdLCAzKVwiLFxuICAgICAgXCIoW10sIDMpXCIsXG4gICAgICBcIihbNywgMSwgNl0sIDEpXCIsXG4gICAgICBcIihbMSwgMSwgMV0sIDEpXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMl0sIDEpXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFdlJ2xsIHNheSB0aGF0IGFuIGVsZW1lbnQgaW4gYW4gYXJyYXkgaXMgXCJhbG9uZVwiIGlmIHRoZXJlIGFyZSB2YWx1ZXNcbiAgICBiZWZvcmUgYW5kIGFmdGVyIGl0LCBhbmQgdGhvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgZnJvbSBpdC4gUmV0dXJuIGEgdmVyc2lvblxuICAgIG9mIHRoZSBnaXZlbiBhcnJheSB3aGVyZSBldmVyeSBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gdmFsdWUgd2hpY2ggaXMgYWxvbmUgaXNcbiAgICByZXBsYWNlZCBieSB3aGljaGV2ZXIgdmFsdWUgdG8gaXRzIGxlZnQgb3IgcmlnaHQgaXMgbGFyZ2VyLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd6ZXJvRnJvbnQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDAsIDAsIDFdKVwiLFxuICAgICAgXCIoWzAsIDEsIDEsIDAsIDFdKVwiLFxuICAgICAgXCIoWzEsIDBdKVwiLFxuICAgICAgXCIoWzAsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDBdKVwiLFxuICAgICAgXCIoWzIsIDIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzAsIDAsIDEsIDBdKVwiLFxuICAgICAgXCIoWy0xLCAwLCAwLCAtMSwgMF0pXCIsXG4gICAgICBcIihbMCwgLTMsIDAsIC0zXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzksIDksIDAsIDksIDAsIDldKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgZXhhY3Qgc2FtZSBudW1iZXJzIGFzIHRoZSBnaXZlblxuICAgIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGFsbCB0aGUgemVyb3MgYXJlIGdyb3VwZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgIGFycmF5LiBUaGUgb3JkZXIgb2YgdGhlIG5vbi16ZXJvIG51bWJlcnMgZG9lcyBub3QgbWF0dGVyLiBTbyB7MSwgMCwgMCwgMX1cbiAgICBiZWNvbWVzIHswICwwLCAxLCAxfS4gWW91IG1heSBtb2RpZnkgYW5kIHJldHVybiB0aGUgZ2l2ZW4gYXJyYXkgb3IgbWFrZSBhXG4gICAgbmV3IGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd3aXRob3V0VGVuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAxMCwgMTAsIDJdKVwiLFxuICAgICAgXCIoWzEwLCAyLCAxMF0pXCIsXG4gICAgICBcIihbMSwgOTksIDEwXSlcIixcbiAgICAgIFwiKFsxMCwgMTMsIDEwLCAxNF0pXCIsXG4gICAgICBcIihbMTAsIDEzLCAxMCwgMTQsIDEwXSlcIixcbiAgICAgIFwiKFsxMCwgMTAsIDNdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzEzLCAxXSlcIixcbiAgICAgIFwiKFsxMF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gYXJyYXkgd2hlcmUgYWxsIHRoZSAxMCdzIGhhdmUgYmVlblxuICAgIHJlbW92ZWQuIFRoZSByZW1haW5pbmcgZWxlbWVudHMgc2hvdWxkIHNoaWZ0IGxlZnQgdG93YXJkcyB0aGUgc3RhcnQgb2YgdGhlXG4gICAgYXJyYXkgYXMgbmVlZGVkLCBhbmQgdGhlIGVtcHR5IHNwYWNlcyBhIHRoZSBlbmQgb2YgdGhlIGFycmF5IHNob3VsZCBiZSAwLlxuICAgIFNvIHsxLCAxMCwgMTAsIDJ9IHlpZWxkcyB7MSwgMiwgMCwgMH0uIFlvdSBtYXkgbW9kaWZ5IGFuZCByZXR1cm4gdGhlIGdpdmVuXG4gICAgYXJyYXkgb3IgbWFrZSBhIG5ldyBhcnJheS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnemVyb01heCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMCwgNSwgMCwgM10pXCIsXG4gICAgICBcIihbMCwgNCwgMCwgM10pXCIsXG4gICAgICBcIihbMCwgMSwgMF0pXCIsXG4gICAgICBcIihbMCwgMSwgNV0pXCIsXG4gICAgICBcIihbMCwgMiwgMF0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbMF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs3LCAwLCA0LCAzLCAwLCAyXSlcIixcbiAgICAgIFwiKFs3LCAwLCA0LCAzLCAwLCAxXSlcIixcbiAgICAgIFwiKFs3LCAwLCA0LCAzLCAwLCAwXSlcIixcbiAgICAgIFwiKFs3LCAwLCAxLCAwLCAwLCA3XSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gYXJyYXkgd2hlcmUgZWFjaCB6ZXJvIHZhbHVlIGluIHRoZVxuICAgIGFycmF5IGlzIHJlcGxhY2VkIGJ5IHRoZSBsYXJnZXN0IG9kZCB2YWx1ZSB0byB0aGUgcmlnaHQgb2YgdGhlIHplcm8gaW4gdGhlXG4gICAgYXJyYXkuIElmIHRoZXJlIGlzIG5vIG9kZCB2YWx1ZSB0byB0aGUgcmlnaHQgb2YgdGhlIHplcm8sIGxlYXZlIHRoZSB6ZXJvXG4gICAgYXMgYSB6ZXJvLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdldmVuT2RkJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAwLCAxLCAwLCAwLCAxLCAxXSlcIixcbiAgICAgIFwiKFszLCAzLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCAyXSlcIixcbiAgICAgIFwiKFszLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAxLCAwLCAxLCAwXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsyLCAxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgZXhhY3Qgc2FtZSBudW1iZXJzIGFzIHRoZSBnaXZlblxuICAgIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGFsbCB0aGUgZXZlbiBudW1iZXJzIGNvbWUgYmVmb3JlIGFsbCB0aGUgb2RkXG4gICAgbnVtYmVycy4gT3RoZXIgdGhhbiB0aGF0LCB0aGUgbnVtYmVycyBjYW4gYmUgaW4gYW55IG9yZGVyLiBZb3UgbWF5IG1vZGlmeVxuICAgIGFuZCByZXR1cm4gdGhlIGdpdmVuIGFycmF5LCBvciBtYWtlIGEgbmV3IGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXp6QnV6eicsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxLCA2KVwiLFxuICAgICAgXCIoMSwgOClcIixcbiAgICAgIFwiKDEsIDExKVwiLFxuICAgICAgXCIoMSwgMTYpXCIsXG4gICAgICBcIigxLCA0KVwiLFxuICAgICAgXCIoMSwgMilcIixcbiAgICAgIFwiKDUwLCA1NilcIixcbiAgICAgIFwiKDE1LCAxNylcIixcbiAgICAgIFwiKDMwLCAzNilcIixcbiAgICAgIFwiKDEwMDAsIDEwMDYpXCIsXG4gICAgICBcIig5OSwgMTAyKVwiLFxuICAgICAgXCIoMTQsIDIwKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBUaGlzIGlzIHNsaWdodGx5IG1vcmUgZGlmZmljdWx0IHZlcnNpb24gb2YgdGhlIGZhbW91cyBGaXp6QnV6eiBwcm9ibGVtXG4gICAgd2hpY2ggaXMgc29tZXRpbWVzIGdpdmVuIGFzIGEgZmlyc3QgcHJvYmxlbSBmb3Igam9iIGludGVydmlld3MuXG4gICAgIENvbnNpZGVyIHRoZSBzZXJpZXMgb2YgbnVtYmVycyBiZWdpbm5pbmcgYXQgc3RhcnQgYW5kIHJ1bm5pbmcgdXAgdG8gYnV0IG5vdFxuICAgICBpbmNsdWRpbmcgZW5kLCBzbyBmb3IgZXhhbXBsZSBzdGFydD0xIGFuZCBlbmQ9NSBnaXZlcyB0aGUgc2VyaWVzIDEsIDIsIDMsIDQuXG4gICAgIFJldHVybiBhIG5ldyBTdHJpbmdbXSBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGVzZSBudW1iZXJzLCBleGNlcHRcbiAgICAgZm9yIG11bHRpcGxlcyBvZiAzLCB1c2UgXCJGaXp6XCIgaW5zdGVhZCBvZiB0aGUgbnVtYmVyLCBmb3IgbXVsdGlwbGVzIG9mIDUgdXNlIFwiQnV6elwiLFxuICAgICBhbmQgZm9yIG11bHRpcGxlcyBvZiBib3RoIDMgYW5kIDUgdXNlIFwiRml6ekJ1enpcIi4gSW4gSmF2YSwgU3RyaW5nLnZhbHVlT2YoeHh4KSB3aWxsXG4gICAgIG1ha2UgdGhlIFN0cmluZyBmb3JtIG9mIGFuIGludCBvciBvdGhlciB0eXBlLiBUaGlzIHZlcnNpb24gaXMgYSBsaXR0bGUgbW9yZVxuICAgICBjb21wbGljYXRlZCB0aGFuIHRoZSB1c3VhbCB2ZXJzaW9uIHNpbmNlIHlvdSBoYXZlIHRvIGFsbG9jYXRlIGFuZCBpbmRleCBpbnRvIGFuXG4gICAgIGFycmF5IGluc3RlYWQgb2YganVzdCBwcmludGluZywgYW5kIHdlIHZhcnkgdGhlIHN0YXJ0L2VuZCBpbnN0ZWFkIG9mIGp1c3QgYWx3YXlzXG4gICAgIGRvaW5nIDEuLjEwMC5gXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0NvbnNpZGVyIHRoZSBsZWZ0bW9zdCBhbmQgcmlnaG1vc3QgYXBwZWFyYW5jZXMgb2Ygc29tZSB2YWx1ZSBpbiBhbiBhcnJheS4gV2VcXCdsbCBzYXkgdGhhdCB0aGUgXCJzcGFuXCIgaXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSB0d28gaW5jbHVzaXZlLiBBIHNpbmdsZSB2YWx1ZSBoYXMgYSBzcGFuIG9mIDEuIFJldHVybnMgdGhlIGxhcmdlc3Qgc3BhbiBmb3VuZCBpbiB0aGUgZ2l2ZW4gYXJyYXkuIChFZmZpY2llbmN5IGlzIG5vdCBhIHByaW9yaXR5LiknLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXhTcGFuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAxLCAxLCAzXSlcIixcbiAgICAgIFwiKFsxLCA0LCAyLCAxLCA0LCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCA0LCAyLCAxLCA0LCA0LCA0XSlcIixcbiAgICAgIFwiKFszLCAzLCAzXSlcIixcbiAgICAgIFwiKFszLCA5LCAzXSlcIixcbiAgICAgIFwiKFszLCA5LCA5XSlcIixcbiAgICAgIFwiKFszLCA5XSlcIixcbiAgICAgIFwiKFszLCAzXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzFdKVwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgcXVlc3Rpb246ICdSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyBleGFjdGx5IHRoZSBzYW1lIG51bWJlcnMgYXMgdGhlIGdpdmVuIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGV2ZXJ5IDMgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSA0LiBEbyBub3QgbW92ZSB0aGUgM1xcJ3MsIGJ1dCBldmVyeSBvdGhlciBudW1iZXIgbWF5IG1vdmUuIFRoZSBhcnJheSBjb250YWlucyB0aGUgc2FtZSBudW1iZXIgb2YgM1xcJ3MgYW5kIDRcXCdzLCBldmVyeSAzIGhhcyBhIG51bWJlciBhZnRlciBpdCB0aGF0IGlzIG5vdCBhIDMsIGFuZCBhIDMgYXBwZWFycyBpbiB0aGUgYXJyYXkgYmVmb3JlIGFueSA0LicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpeDM0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAzLCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCAzLCAxLCA0LCA0LCAzLCAxXSlcIixcbiAgICAgIFwiKFszLCAyLCAyLCA0XSlcIixcbiAgICAgIFwiKFszLCAyLCAzLCAyLCA0LCA0XSlcIixcbiAgICAgIFwiKFsyLCAzLCAyLCAzLCAyLCA0LCA0XSlcIixcbiAgICAgIFwiKFs1LCAzLCA1LCA0LCA1LCA0LCA1LCA0LCAzLCA1LCAzLCA1XSlcIixcbiAgICAgIFwiKFszLCAxLCA0XSlcIixcbiAgICAgIFwiKFszLCA0LCAxXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzcsIDMsIDcsIDcsIDRdKVwiLFxuICAgICAgXCIoWzMsIDEsIDQsIDMsIDEsIDRdKVwiLFxuICAgICAgXCIoWzMsIDEsIDEsIDMsIDQsIDRdKVwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgcXVlc3Rpb246ICcoVGhpcyBpcyBhIHNsaWdodGx5IGhhcmRlciB2ZXJzaW9uIG9mIHRoZSBmaXgzNCBwcm9ibGVtLikgUmV0dXJuIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXhhY3RseSB0aGUgc2FtZSBudW1iZXJzIGFzIHRoZSBnaXZlbiBhcnJheSwgYnV0IHJlYXJyYW5nZWQgc28gdGhhdCBldmVyeSA0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgNS4gRG8gbm90IG1vdmUgdGhlIDRcXCdzLCBidXQgZXZlcnkgb3RoZXIgbnVtYmVyIG1heSBtb3ZlLiBUaGUgYXJyYXkgY29udGFpbnMgdGhlIHNhbWUgbnVtYmVyIG9mIDRcXCdzIGFuZCA1XFwncywgYW5kIGV2ZXJ5IDQgaGFzIGEgbnVtYmVyIGFmdGVyIGl0IHRoYXQgaXMgbm90IGEgNC4gSW4gdGhpcyB2ZXJzaW9uLCA1XFwncyBtYXkgYXBwZWFyIGFueXdoZXJlIGluIHRoZSBvcmlnaW5hbCBhcnJheS4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXg0NScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbNSwgNCwgOSwgNCwgOSwgNV0pXCIsXG4gICAgICBcIihbMSwgNCwgMSwgNV0pXCIsXG4gICAgICBcIihbMSwgNCwgMSwgNSwgNSwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgOSwgNCwgOSwgNSwgNSwgNCwgOSwgNV0pXCIsXG4gICAgICBcIihbNSwgNSwgNCwgMSwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgMiwgMiwgNV0pXCIsXG4gICAgICBcIihbNCwgMiwgNCwgMiwgNSwgNV0pXCIsXG4gICAgICBcIihbNCwgMiwgNCwgNSwgNV0pXCIsXG4gICAgICBcIihbMSwgMSwgMV0pXCIsXG4gICAgICBcIihbNCwgNV0pXCIsXG4gICAgICBcIihbNSwgNCwgMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs1LCA0LCA1LCA0LCAxXSlcIixcbiAgICAgIFwiKFs0LCA1LCA0LCAxLCA1XSlcIixcbiAgICAgIFwiKFszLCA0LCA1XSlcIixcbiAgICAgIFwiKFs0LCAxLCA1XSlcIixcbiAgICAgIFwiKFs1LCA0LCAxXSlcIixcbiAgICAgIFwiKFsyLCA0LCAyLCA1XSlcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYSBub24tZW1wdHkgYXJyYXksIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgcGxhY2UgdG8gc3BsaXQgdGhlIGFycmF5IHNvIHRoYXQgdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBvbiBvbmUgc2lkZSBpcyBlcXVhbCB0byB0aGUgc3VtIG9mIHRoZSBudW1iZXJzIG9uIHRoZSBvdGhlciBzaWRlLicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2NhbkJhbGFuY2UnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDEsIDEsIDIsIDFdKVwiLFxuICAgICAgXCIoWzIsIDEsIDEsIDIsIDFdKVwiLFxuICAgICAgXCIoWzEwLCAxMF0pXCIsXG4gICAgICBcIihbMTAsIDAsIDEsIC0xLCAxMF0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMSwgNF0pXCIsXG4gICAgICBcIihbMiwgMSwgMSwgMSwgNF0pXCIsXG4gICAgICBcIihbMiwgMywgNCwgMSwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMSwgMCwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMSwgMCwgMSwgM10pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMiwgMV0pXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0dpdmVuIHR3byBhcnJheXMgb2YgaW50cyBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciwgb3V0ZXIgYW5kIGlubmVyLCByZXR1cm4gdHJ1ZSBpZiBhbGwgb2YgdGhlIG51bWJlcnMgaW4gaW5uZXIgYXBwZWFyIGluIG91dGVyLiBUaGUgYmVzdCBzb2x1dGlvbiBtYWtlcyBvbmx5IGEgc2luZ2xlIFwibGluZWFyXCIgcGFzcyBvZiBib3RoIGFycmF5cywgdGFraW5nIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGJvdGggYXJyYXlzIGFyZSBhbHJlYWR5IGluIHNvcnRlZCBvcmRlci4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdsaW5lYXJJbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgNCwgNl0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCA0LCA2XSwgWzIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDQsIDQsIDZdLCBbMiwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgNCwgNCwgNiwgNl0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCAyLCAyLCAyXSwgWzIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDIsIDIsIDJdLCBbMiwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMiwgMiwgNF0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSwgWzJdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbLTFdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbXSlcIixcbiAgICAgIFwiKFstMSwgMCwgMywgMywgMywgMTAsIDEyXSwgWy0xLCAwLCAzLCAxMl0pXCIsXG4gICAgICBcIihbLTEsIDAsIDMsIDMsIDMsIDEwLCAxMl0sIFswLCAzLCAxMiwgMTRdKVwiLFxuICAgICAgXCIoWy0xLCAwLCAzLCAzLCAzLCAxMCwgMTJdLCBbLTEsIDEwLCAxMV0pXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0dpdmVuIG4+PTAsIGNyZWF0ZSBhbiBhcnJheSBsZW5ndGggbipuIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuLCBzaG93biBoZXJlIGZvciBuPTMgOiB7MCwgMCwgMSwgICAgMCwgMiwgMSwgICAgMywgMiwgMX0gKHNwYWNlcyBhZGRlZCB0byBzaG93IHRoZSAzIGdyb3VwcykuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc3F1YXJlVXAnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMylcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIig0KVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDApXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0dpdmVuIG4+PTAsIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBwYXR0ZXJuIHsxLCAgICAxLCAyLCAgICAxLCAyLCAzLCAgIC4uLiAxLCAyLCAzIC4uIG59IChzcGFjZXMgYWRkZWQgdG8gc2hvdyB0aGUgZ3JvdXBpbmcpLiBOb3RlIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgd2lsbCBiZSAxICsgMiArIDMgLi4uICsgbiwgd2hpY2ggaXMga25vd24gdG8gc3VtIHRvIGV4YWN0bHkgbioobiArIDEpLzIuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc2VyaWVzVXAnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMylcIixcbiAgICAgIFwiKDQpXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDApXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ1dlXFwnbGwgc2F5IHRoYXQgYSBcIm1pcnJvclwiIHNlY3Rpb24gaW4gYW4gYXJyYXkgaXMgYSBncm91cCBvZiBjb250aWd1b3VzIGVsZW1lbnRzIHN1Y2ggdGhhdCBzb21ld2hlcmUgaW4gdGhlIGFycmF5LCB0aGUgc2FtZSBncm91cCBhcHBlYXJzIGluIHJldmVyc2Ugb3JkZXIuIEZvciBleGFtcGxlLCB0aGUgbGFyZ2VzdCBtaXJyb3Igc2VjdGlvbiBpbiB7MSwgMiwgMywgOCwgOSwgMywgMiwgMX0gaXMgbGVuZ3RoIDMgKHRoZSB7MSwgMiwgM30gcGFydCkuIFJldHVybiB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBtaXJyb3Igc2VjdGlvbiBmb3VuZCBpbiB0aGUgZ2l2ZW4gYXJyYXkuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbWF4TWlycm9yJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAzLCA4LCA5LCAzLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCA0XSlcIixcbiAgICAgIFwiKFs3LCAxLCAyLCA5LCA3LCAyLCAxXSlcIixcbiAgICAgIFwiKFsyMSwgMjIsIDksIDgsIDcsIDYsIDIzLCAyNCwgNiwgNywgOCwgOSwgMjUsIDcsIDgsIDldKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDIwLCAyMSwgMSwgMiwgMSwgMiwgMjMsIDI0LCAyLCAxLCAyLCAxLCAyNV0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgMV0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMywgOF0pXCIsXG4gICAgICBcIihbMSwgMiwgNywgOCwgMSwgNywgMl0pXCIsXG4gICAgICBcIihbMSwgMSwgMV0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs5LCAxLCAxLCA0LCAyLCAxLCAxLCAxXSlcIixcbiAgICAgIFwiKFs1LCA5LCA5LCA0LCA1LCA0LCA5LCA5LCAyXSlcIixcbiAgICAgIFwiKFs1LCA5LCA5LCA2LCA1LCA0LCA5LCA5LCAyXSlcIixcbiAgICAgIFwiKFs1LCA5LCAxLCA2LCA1LCA0LCAxLCA5LCA1XSlcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnU2F5IHRoYXQgYSBcImNsdW1wXCIgaW4gYW4gYXJyYXkgaXMgYSBzZXJpZXMgb2YgMiBvciBtb3JlIGFkamFjZW50IGVsZW1lbnRzIG9mIHRoZSBzYW1lIHZhbHVlLiBSZXR1cm4gdGhlIG51bWJlciBvZiBjbHVtcHMgaW4gdGhlIGdpdmVuIGFycmF5LicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2NvdW50Q2x1bXBzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAyLCAzLCA0LCA0XSlcIixcbiAgICAgIFwiKFsxLCAxLCAyLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSlcIixcbiAgICAgIFwiKFsyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFswLCAyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFswLCAwLCAyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFswLCAwLCAwLCAyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFtdKVwiXG4gICAgXVxuICB9LFxuXSIsImxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLm1ha2VMYXN0ID0gZnVuY3Rpb24gbWFrZUxhc3QobnVtcykge1xuICBsZXQgbmV3TGVuZ3RoID0gbnVtcy5sZW5ndGggKiAyO1xuICBsZXQgbmV3QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdMZW5ndGg7IGkrKykge1xuICAgIG5ld0FycmF5W2ldID0gMDtcbiAgfVxuICBuZXdBcnJheVtuZXdMZW5ndGggLSAxXSA9IG51bXNbbnVtcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5zb2x1dGlvbnMuZG91YmxlMjMgPSBmdW5jdGlvbiBkb3VibGUyMyhudW1zKSB7XG4gIGlmIChudW1zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAoKG51bXNbMF0gPT0gMiAmJiBudW1zWzFdID09IDIpIHx8IChudW1zWzBdID09IDMgJiYgbnVtc1sxXSA9PSAzKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnNvbHV0aW9ucy5maXgyMyA9IGZ1bmN0aW9uIGZpeDIzKG51bXMpIHtcbiAgLy9zaW5jZSB0aGUgbGVuZ3RoIGlzIHRocmVlLCB0aGUgb25seSBvcHRpb25zIGFyZSB0aGUgZmlyc3QgdHdvIG9yIGxhc3QgdHdvIGVsZW1lbnRzXG4gIGlmIChudW1zWzBdID09IDIgJiYgbnVtc1sxXSA9PSAzKSB7XG4gICAgbnVtc1sxXSA9IDA7XG4gIH0gZWxzZSBpZiAobnVtc1sxXSA9PSAyICYmIG51bXNbMl0gPT0gMykge1xuICAgIG51bXNbMl0gPSAwO1xuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuZmluZFRoZU1lZGlhbiA9IGZ1bmN0aW9uIGZpbmRUaGVNZWRpYW4obnVtcykge1xuICAvL3doZXJlIGlzIHRoZSBzb3J0IG1ldGhvZD8gXG4gIGxldCBlbmQgPSBudW1zLmxlbmd0aCAtIDE7XG4gIGxldCBtaWQgPSBudW1zLmxlbmd0aCAvIDJcbiAgaWYgKG51bXMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgIHJldHVybiBudW1zW2VuZCAvIDJdO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xuICB9XG59XG5cbnNvbHV0aW9ucy5zdGFydDEgPSBmdW5jdGlvbiBzdGFydDEoYSwgYikge1xuICBsZXQgY291bnQgPSAwO1xuICBpZiAoYVswXSA9PSAxKSB7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuXG4gIGlmIChiWzBdID09IDEpIHtcbiAgICBjb3VudCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuYmlnZ2VyVHdvID0gZnVuY3Rpb24gYmlnZ2VyVHdvKGEsIGIpIHtcbiAgaWYgKGJbMF0gKyBiWzFdID4gYVswXSArIGFbMV0pIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBlbHNlIGlmIChhWzBdICsgYVsxXSA+IGJbMF0gKyBiWzFdKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZWxzZSByZXR1cm4gYTtcbn1cblxuc29sdXRpb25zLm1ha2VNaWRkbGUgPSBmdW5jdGlvbiBtYWtlTWlkZGxlKG51bXMpIHtcbiAgLy8gY29uc2lkZXIgYW4gZXhhbXBsZS4gSWYgdGhlIGFycmF5IGhhcyBsZW5ndGggNFxuICAvLyB0aGVuIGhhbGYgd2lsbCBiZSAyLCBhbmQgd2Ugd2FudCB0aGUgMm5kIGFuZCB0aGlyZCBlbGVtZW50c1xuICAvLyB3aGljaCB3aWxsIGhhdmUgaW5kZXggMSAoaGFsZiAtIDEpIGFuZCAyIChoYWxmKVxuICBsZXQgaGFsZiA9IG51bXMubGVuZ3RoIC8gMjtcbiAgcmV0dXJuIFtudW1zW2hhbGYgLSAxXSwgbnVtc1toYWxmXV07XG59XG5cbnNvbHV0aW9ucy5wbHVzVHdvID0gZnVuY3Rpb24gcGx1c1R3byhhLCBiKSB7XG4gIGxldCBkdW9BcnIgPSBbXTtcbiAgZHVvQXJyWzBdID0gYVswXTtcbiAgZHVvQXJyWzFdID0gYVsxXTtcbiAgZHVvQXJyWzJdID0gYlswXTtcbiAgZHVvQXJyWzNdID0gYlsxXTtcblxuICByZXR1cm4gZHVvQXJyO1xufVxuXG5zb2x1dGlvbnMuc3dhcEVuZHMgPSBmdW5jdGlvbiBzd2FwRW5kcyhudW1zKSB7XG4gIC8vIHNhdmUgdGhlIGZpcnN0IHZhbHVlIHRlbXBvcmFyaWx5XG4gIGxldCBmaXJzdCA9IG51bXNbMF1cbiAgLy8gbW92ZSB0aGUgbGFzdCB2YWx1ZSBpbnRvIHRoZSBmaXJzdCB2YWx1ZVxuICBudW1zWzBdID0gbnVtc1tudW1zLmxlbmd0aCAtIDFdO1xuICAvLyBtb3ZlIHRoZSBmaXJzdCB2YWx1ZSBpbnRvIHRoZSBsYXN0IHBsYWNlXG4gIG51bXNbbnVtcy5sZW5ndGggLSAxXSA9IGZpcnN0O1xuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLmZpbmRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uIGZpbmRMb3dlc3RJbmRleChudW1zKSB7XG4gIGxldCBtaW5WYWwgPSBudW1zWzBdO1xuICBsZXQgbWluVmFsSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA8IG1pblZhbCkge1xuICAgICAgbWluVmFsID0gbnVtc1tpXVxuICAgICAgbWluVmFsSW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluVmFsSW5kZXg7XG59XG5cblxuXG5cbnNvbHV0aW9ucy5taWRUaHJlZSA9IGZ1bmN0aW9uIG1pZFRocmVlKG51bXMpIHtcbiAgLy9pZiBvdXIgYXJyYXkgaXMgb2Ygc2l6ZSAzLCB3ZSB3YW50IG91ciBcInBpdm90XCIgKG1pZGRsZSkgaW5kZXggdG8gYmUgMVxuICAvLyB3ZSBjYW4gZG8gdGhpcyB3aXRoIChzaXplIC0gMSkvMlxuICBsZXQgaGFsZiA9IChudW1zLmxlbmd0aCAtIDEpIC8gMjtcbiAgcmV0dXJuIFtudW1zW2hhbGYgLSAxXSwgbnVtc1toYWxmXSwgbnVtc1toYWxmICsgMV1dO1xufVxuXG5zb2x1dGlvbnMubWF4VHJpcGxlID0gZnVuY3Rpb24gbWF4VHJpcGxlKG51bXMpIHtcbiAgbGV0IG1pZCA9IG51bXNbKG51bXMubGVuZ3RoIC0gMSkgLyAyXTtcbiAgbGV0IHN0YXJ0ID0gbnVtc1swXVxuICBsZXQgZW5kID0gbnVtc1tudW1zLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChtaWQgPiBzdGFydCAmJiBtaWQgPiBlbmQpIHtcbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKHN0YXJ0ID4gbWlkICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmQ7XG4gIH1cbn1cblxuc29sdXRpb25zLmZyb250UGllY2UgPSBmdW5jdGlvbiBmcm9udFBpZWNlKG51bXMpIHtcbiAgaWYgKG51bXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBudW1zO1xuICB9XG4gIHJldHVybiBbbnVtc1swXSwgbnVtc1sxXV07XG59XG5cbnNvbHV0aW9ucy51bmx1Y2t5MSA9IGZ1bmN0aW9uIHVubHVja3kxKG51bXMpIHtcbiAgaWYgKChudW1zWzBdID09IDEgJiYgbnVtc1sxXSA9PSAzKSB8fCAobnVtc1tudW1zLmxlbmd0aCAtIDJdID09IDEgJiYgbnVtc1tudW1zLmxlbmd0aCAtIDFdID09IDMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5tYWtlMiA9IGZ1bmN0aW9uIG1ha2UyKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoID49IDIpIHtcbiAgICByZXR1cm4gW2FbMF0sIGFbMV1dXG4gIH1cbiAgZWxzZSBpZiAoYS5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBbYVswXSwgYlswXV1cbiAgfVxuICBlbHNlIHJldHVybiBbYlswXSwgYlsxXV1cbn1cblxuc29sdXRpb25zLmZyb250MTEgPSBmdW5jdGlvbiBmcm9udDExKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW2JbMF1dXG4gIH1cbiAgZWxzZSBpZiAoYi5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBbYVswXV1cbiAgfVxuICBlbHNlIGlmIChhLmxlbmd0aCA9PSAwICYmIGIubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBlbHNlIHJldHVybiBbYVswXSwgYlswXV1cbn1cblxuXG5cbi8vIEFycmF5LTJcblxuc29sdXRpb25zLmNvdW50RXZlbnMgPSBmdW5jdGlvbiBjb3VudEV2ZW5zKG51bXMpIHtcbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAlIDIgPT0gMCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuYmlnRGlmZiA9IGZ1bmN0aW9uIGJpZ0RpZmYobnVtcykge1xuICAvL2NoYW5nZWQgaXQgdG8gYSBsb29wIHByb2JsZW0gXG4gIC8vTWF0aC5hYnMgcmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIgXG4gIGxldCBtYXggPSBudW1zWzBdXG4gIGxldCBtaW4gPSBudW1zWzBdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID4gbWF4KSB7XG4gICAgICBtYXggPSBudW1zW2ldXG4gICAgfVxuICAgIGVsc2UgaWYgKG51bXNbaV0gPCBtaW4pIHtcbiAgICAgIG1pbiA9IG51bXNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKG1heCAtIG1pbik7XG59XG5cbnNvbHV0aW9ucy5jZW50ZXJlZEF2ZXJhZ2UgPSBmdW5jdGlvbiBjZW50ZXJlZEF2ZXJhZ2UobnVtcykge1xuICBsZXQgbWF4ID0gbnVtc1swXVxuICBsZXQgbWluID0gbnVtc1swXVxuICBsZXQgbWF4SW5kZXggPSAwO1xuICBsZXQgbWluSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHsvL2ZpbmQgbWF4IGFuZCBtaW4gXG4gICAgaWYgKG51bXNbaV0gPj0gbWF4KSB7XG4gICAgICBtYXggPSBudW1zW2ldXG4gICAgICBtYXhJbmRleCA9IGk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG51bXNbaV0gPCBtaW4pIHtcbiAgICAgIG1pbiA9IG51bXNbaV1cbiAgICAgIG1pbkluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7Ly9pZiB0aGUgaW5kZXggb2YgZWxlbWVudCBpcyBuZWl0aGVyIGEgbWF4SW5kZXggb3IgbWluSW5kZXgsIGFkZCB0byB0b3RhbFxuICAgIGlmICghKGkgPT0gbWF4SW5kZXggfHwgaSA9PSBtaW5JbmRleCkpIHtcbiAgICAgIHRvdGFsID0gdG90YWwgKyBudW1zW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiB0b3RhbCAvIChudW1zLmxlbmd0aCAtIDIpXG5cbn1cblxuc29sdXRpb25zLnN1bTEzID0gZnVuY3Rpb24gc3VtMTMobnVtcykge1xuICBsZXQgcHJlMTMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMTMgfHwgbnVtc1tpIC0gMV0gPT0gMTMpIHtcblxuICAgIH0gZWxzZSB7XG4gICAgICBwcmUxMy5wdXNoKG51bXNbaV0pO1xuICAgIH1cbiAgfVxuICBsZXQgc3VtID0gcHJlMTMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgcmV0dXJuIHN1bTtcbn1cblxuc29sdXRpb25zLnN1bTY3ID0gZnVuY3Rpb24gc3VtNjcobnVtcykge1xuICBsZXQgc3VtbSA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gIT0gNikge1xuICAgICAgc3VtbSArPSBudW1zW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobnVtc1tpXSAhPSA3KSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bW07XG59XG5cbnNvbHV0aW9ucy5oYXMyMiA9IGZ1bmN0aW9uIGhhczIyKG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMiAmJiBudW1zW2kgKyAxXSA9PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMubHVja3kxMyA9IGZ1bmN0aW9uIGx1Y2t5MTMobnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAxIHx8IG51bXNbaV0gPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcblxufVxuXG5zb2x1dGlvbnMuc3VtMjggPSBmdW5jdGlvbiBzdW0yOChudW1zKSB7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMikge1xuICAgICAgY291bnQgKz0gbnVtc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50ID09IDg7XG59XG5cbnNvbHV0aW9ucy5tb3JlMTQgPSBmdW5jdGlvbiBtb3JlMTQobnVtcykge1xuXG4gIGxldCBvbmUgPSAwO1xuICBsZXQgZm91ciA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMSkge1xuICAgICAgb25lICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgZm91ciArPSAxO1xuICAgIH1cbiAgfVxuICBpZiAob25lID4gZm91cikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5zb2x1dGlvbnMuQXJyYXkgPSBmdW5jdGlvbiBmaXp6QXJyYXkobikge1xuICBsZXQgbmV3QSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIG5ld0FbaV0gPSBpO1xuICB9XG4gIHJldHVybiBuZXdBO1xufVxuXG5zb2x1dGlvbnMucHJlcGVuZFN1bSA9IGZ1bmN0aW9uIHByZXBlbmRTdW0obnVtcykge1xuICBsZXQgYXJyID0gW107XG4gIGFyclswXSA9IG51bXNbMF0gKyBudW1zWzFdXG4gIGZvciAobGV0IGkgPSAyOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGFycltpIC0gMV0gPSBudW1zW2ldOyAvL251bXMgc3RhcnQgYXQgaT0yIGJlY2F1c2UgdGhlIGZpcnN0IHR3byBlbGVtZW50cyB3ZXJlIHJlbW92ZWRcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5cblxuc29sdXRpb25zLm9ubHkxNCA9IGZ1bmN0aW9uIG9ubHkxNChudW1zKSB7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gIT0gNCAmJiBudW1zW2ldICE9IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5maXp6QXJyYXkyID0gZnVuY3Rpb24gZml6ekFycmF5MihuKSB7XG4gIGxldCBudSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIG51W2ldID0gaS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBudTtcbn1cblxuc29sdXRpb25zLm5vMTQgPSBmdW5jdGlvbiBubzE0KG51bXMpIHtcbiAgbGV0IGhhczEgPSBmYWxzZTtcbiAgbGV0IGhhczQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMSkge1xuICAgICAgaGFzMSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgaGFzNCA9IHRydWU7XG4gICAgfVxuXG4gIH1cbiAgaWYgKGhhczEgPT0gdHJ1ZSAmJiBoYXM0ID09IHRydWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZWxzZSByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLmlzRXZlcnl3aGVyZSA9IGZ1bmN0aW9uIGlzRXZlcnl3aGVyZShudW1zLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChudW1zW2ldICE9IHZhbCAmJiBudW1zW2kgKyAxXSAhPSB2YWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5laXRoZXIyNCA9IGZ1bmN0aW9uIGVpdGhlcjI0KG51bXMpIHtcbiAgbGV0IGhhczIyID0gZmFsc2U7XG4gIGxldCBoYXM0NCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAyICYmIG51bXNbaSArIDFdID09IDIpXG4gICAgICBoYXMyMiA9IHRydWU7XG5cbiAgICBpZiAobnVtc1tpXSA9PSA0ICYmIG51bXNbaSArIDFdID09IDQpXG4gICAgICBoYXM0NCA9IHRydWU7XG4gIH1cblxuICBpZiAoaGFzMjIgIT0gaGFzNDQpIHsvL2JvdGggYm9vbGVhbiB2YWx1ZXMgbXVzdCBiZSBkaWZmZXJlbnQgKGJvdGggdHJ1ZSAtPiBmYWxzZSwgYm90aCBmYWxzZS0+IGZhbHNlKVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMubWF0Y2hVcCA9IGZ1bmN0aW9uIG1hdGNoVXAobnVtczEsIG51bXMyKSB7XG4gIC8vTWF0aC5hYnMoYS1iKSBjYWxjdWxhdGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zMS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBkaWZmID0gTWF0aC5hYnMobnVtczFbaV0gLSBudW1zMltpXSk7XG4gICAgaWYgKGRpZmYgPiAwICYmIGRpZmYgPCAzKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy5oYXM3NyA9IGZ1bmN0aW9uIGhhczc3KG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICgobnVtc1tpXSA9PSA3ICYmIG51bXNbaSArIDFdID09IDcpIHx8IChudW1zW2ldID09IDcgJiYgbnVtc1tpICsgMl0gPT0gNykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5oYXMxMiA9IGZ1bmN0aW9uIGhhczEyKG51bXMpIHtcbiAgbGV0IGhhczEgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAxKSB7XG4gICAgICBoYXMxID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzMSA9PSB0cnVlICYmIG51bXNbaV0gPT0gMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLm1vZFRocmVlID0gZnVuY3Rpb24gbW9kVGhyZWUobnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gJSAyID09IG51bXNbaSArIDFdICUgMiAmJiBudW1zW2kgKyAxXSAlIDIgPT0gbnVtc1tpICsgMl0gJSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuaGF2ZVRocmVlID0gZnVuY3Rpb24gaGF2ZVRocmVlKG51bXMpIHtcbiAgbGV0IHRocmVlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMykge1xuICAgICAgdGhyZWUrKztcbiAgICB9XG4gICAgaWYgKG51bXNbaSArIDFdID09IDMgJiYgbnVtc1tpXSA9PSAzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH1cbiAgaWYgKHRocmVlID09IDMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLnR3b1R3byA9IGZ1bmN0aW9uIHR3b1R3byhudW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICgobnVtc1tpXSA9PSAyKSAmJiAobnVtc1tpICsgMV0gPT0gMikpIHtcbiAgICAgIGkgPSBpICsgMi8vaWYgMiBpcyBhbHJlYWR5IGZvdW5kLCBza2lwIHR3byBpbmRleGVzIGJlY2F1c2UgdGhlIGxhc3QgMiBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgXG4gICAgfVxuICAgIGVsc2UgaWYgKChudW1zW2ldID09IDIpICYmIChudW1zW2kgKyAxXSAhPSAyKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLnNhbWVFbmRzID0gZnVuY3Rpb24gc2FtZUVuZHMobnVtcywgbGVuKSB7XG4gIGxldCBmcm9udCA9IG51bXMuc2xpY2UoMCwgbGVuKTtcbiAgbGV0IGVuZCA9IG51bXMuc2xpY2UobnVtcy5sZW5ndGggLSBsZW4pO1xuXG4gIHJldHVybiBmcm9udC50b1N0cmluZygpID09IGVuZC50b1N0cmluZygpO1xufVxuXG5zb2x1dGlvbnMudHJpcGxlVXAgPSBmdW5jdGlvbiB0cmlwbGVVcChudW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSArIDEgPT0gbnVtc1tpICsgMV0gJiYgbnVtc1tpICsgMV0gKyAxID09IG51bXNbaSArIDJdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuZml6ekFycmF5MyA9IGZ1bmN0aW9uIGZpenpBcnJheTMoc3RhcnQsIGVuZCkge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGFycltjb3VudF0gPSBpO1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5zb2x1dGlvbnMuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bXMpIHtcbiAgbGV0IGZpcnN0VmFsID0gbnVtc1swXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgbGV0IHRlbXAgPSBudW1zW2ldO1xuICAgIG51bXNbaV0gPSBudW1zW2kgKyAxXVxuICAgIG51bXNbaSArIDFdID0gbnVtc1tpXVxuICB9XG4gIG51bXNbbnVtcy5sZW5ndGggLSAxXSA9IGZpcnN0VmFsXG4gIHJldHVybiBudW1zXG59XG5cbnNvbHV0aW9ucy50ZW5SdW4gPSBmdW5jdGlvbiB0ZW5SdW4obnVtcykge1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbnVtcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKG51bXNbaV0gJSAxMCA9PSAwICYmICEobnVtc1tpICsgMV0gJSAxMCA9PSAwKSkgey8vaWYgdGhlIGN1cnJlbnQgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgMTAgQU5EIHRoZSBuZXh0IG51bWJlciBpcyBOT1QgYSBtdWx0aXBsZSBvZiAxMCBcbiAgICAgIG51bXNbaSArIDFdID0gbnVtc1tpXTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgZWxzZSBpKys7XG4gIH1cbiAgcmV0dXJuIG51bXM7XG59XG5cbnNvbHV0aW9ucy5wcmU0ID0gZnVuY3Rpb24gcHJlNChudW1zKSB7XG4gIC8vYXJyYXkucHVzaChudW0pIGFkZHMgbnVtIHRvIGFycmF5IFxuXG4gIGxldCBiNDQgPSBbXTtcblxuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBudW1zLmxlbmd0aCAmJiBudW1zW2ldICE9IDQpIHtcbiAgICBiNDQucHVzaChudW1zW2ldKTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGI0NDtcbn1cblxuc29sdXRpb25zLnBvc3Q0ID0gZnVuY3Rpb24gcG9zdDQobnVtcykge1xuICBsZXQgYXJyID0gW107XG4gIGxldCBpbmRleDQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykgey8vZ2V0IHRoZSBsYXJnZXN0IGluZGV4IG9mIDRcbiAgICBpZiAobnVtc1tpXSA9PSA0KSB7XG4gICAgICBpbmRleDQgPSBpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBjID0gMDsgYyA8IG51bXMubGVuZ3RoIC0gMSAtIGluZGV4NDsgYysrKSB7XG4gICAgYXJyW2NdID0gbnVtc1tjICsgMSArIGluZGV4NF0vL3B1dCB0aGUgdmFsdWVzIGFmdGVyIDQgaW50byBhbiBhcnJheVxuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbnNvbHV0aW9ucy5ub3RBbG9uZSA9IGZ1bmN0aW9uIG5vdEFsb25lKG51bXMsIHZhbCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gdmFsKSB7XG4gICAgICBpZiAobnVtc1tpICsgMV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudW1zO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtc1tpIC0gMV0gPT0gdmFsIHx8IG51bXNbaSArIDFdID09IHZhbCkge1xuXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW1zW2kgLSAxXSA9PSB1bmRlZmluZWQpIHtcblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtc1tpIC0gMV0gPiBudW1zW2kgKyAxXSkge1xuICAgICAgICBudW1zW2ldID0gbnVtc1tpIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1zW2ldID0gbnVtc1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuemVyb0Zyb250ID0gZnVuY3Rpb24gemVyb0Zyb250KG51bXMpIHtcbiAgaWYgKG51bXMubGVuZ3RoID09IDApXG4gICAgcmV0dXJuIG51bXM7XG5cbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChudW1zW2ldID09IDApXG4gICAgaSsrO1xuXG4gIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG51bXMubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAobnVtc1tqXSA9PSAwKSB7XG4gICAgICBsZXQgdGVtcCA9IG51bXNbaV07XG4gICAgICBudW1zW2ldID0gbnVtc1tqXTtcbiAgICAgIG51bXNbal0gPSB0ZW1wO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMud2l0aG91dFRlbiA9IGZ1bmN0aW9uIHdpdGhvdXRUZW4obnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAxMCkge1xuICAgICAgbnVtc1tpXSA9IDA7XG4gICAgICBmb3IgKGxldCBjID0gaTsgYyA8IG51bXMubGVuZ3RoIC0gMTsgYysrKSB7XG4gICAgICAgIGxldCB0ZW1wID0gbnVtc1tjXS8vYmFzaWMgc3dhcCBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IFxuICAgICAgICBudW1zW2NdID0gbnVtc1tjICsgMV07XG4gICAgICAgIG51bXNbYyArIDFdID0gdGVtcDtcbiAgICAgICAgaWYgKG51bXNbY10gPT0gMTApIHsvL2lmIHRlbiByZXBsYWNlcyBhbm90aGVyIHRlbiwgZG8gdGhlIHN0ZXAgb25lIG1vcmUgdGltZSBcbiAgICAgICAgICBpID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bXM7XG59XG5cbnNvbHV0aW9ucy56ZXJvTWF4ID0gZnVuY3Rpb24gemVyb01heChudW1zKSB7XG4gIGxldCBvZGQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAwKSB7XG4gICAgICBmb3IgKGxldCBjID0gaSArIDE7IGMgPCBudW1zLmxlbmd0aDsgYysrKSB7Ly9maW5kIGxhcmdlc3Qgb2RkIHZhbHVlIFJJR0hUIG9mIHRoZSAwIFxuICAgICAgICBpZiAobnVtc1tjXSA+IG9kZCAmJiBudW1zW2NdICUgMiA9PSAxKSB7XG4gICAgICAgICAgb2RkID0gbnVtc1tjXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbnVtc1tpXSA9IG9kZDtcbiAgICAgIG9kZCA9IDA7Ly9yZXNldCBvZGQganVzdCBpbiBjYXNlIHRoZXJlIGlzIGEgbGFyZ2VyIG51bWJlciBiZWZvcmUgdGhlIGN1cnJlbnQgMC4gXG4gICAgfVxuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuZXZlbk9kZCA9IGZ1bmN0aW9uIGV2ZW5PZGQobnVtcykge1xuICAvL2FycmF5LmNvbmNhdChhcnJheTEpIGNvbWJpbmVzIHRoZSB0d28gYXJyYXlzLiBVc2UgaXQgd2lzZWx5IFxuICAvL2FycmF5LnB1c2gobnVtKSBhZGRzIGEgdmFyaWFibGUgbnVtIHRvIHRoZSBhcnJheSBcbiAgbGV0IGV2ZW4gPSBbXTtcbiAgbGV0IG9kZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAlIDIgPT0gMCkge1xuICAgICAgZXZlbi5wdXNoKG51bXNbaV0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2RkLnB1c2gobnVtc1tpXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW4uY29uY2F0KG9kZClcbn1cblxuZnVuY3Rpb24gaXNFdmVuKG51bSkge1xuICByZXR1cm4gbnVtICUgMiA9PSAwO1xufVxuXG5mdW5jdGlvbiBpc09kZChudW0pIHtcbiAgcmV0dXJuIG51bSAlIDIgIT0gMDtcbn1cblxuc29sdXRpb25zLmZpenpCdXp6ID0gZnVuY3Rpb24gZml6ekJ1enooc3RhcnQsIGVuZCkge1xuICBsZXQgc3RyQXJyYXkgPSBbXTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSAlIDMgPT0gMCAmJiAhKGkgJSA1ID09IDApKSB7XG4gICAgICBzdHJBcnJheVtjb3VudF0gPSBcIkZpenpcIlxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSAlIDUgPT0gMCAmJiAhKGkgJSAzID09IDApKSB7XG4gICAgICBzdHJBcnJheVtjb3VudF0gPSBcIkJ1enpcIlxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSAlIDMgPT0gMCAmJiBpICUgNSA9PSAwKSB7XG4gICAgICBzdHJBcnJheVtjb3VudF0gPSBcIkZpenpCdXp6XCJcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RyQXJyYXlbY291bnRdID0gaS50b1N0cmluZygpO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ckFycmF5O1xufVxuXG4vLyBBcnJheS0zXG5cbnNvbHV0aW9ucy5tYXhTcGFuID0gZnVuY3Rpb24gbWF4U3BhbihudW1zKSB7XG4gIGxldCBtYXggPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBqID0gbnVtcy5sZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKG51bXNbaV0gIT0gbnVtc1tqXSkge1xuICAgICAgai0tO1xuICAgIH1cblxuICAgIGxldCBzcGFuID0gaiAtIGkgKyAxO1xuXG4gICAgaWYgKHNwYW4gPiBtYXgpXG4gICAgICBtYXggPSBzcGFuO1xuICB9XG5cbiAgcmV0dXJuIG1heDtcbn1cblxuc29sdXRpb25zLmZpeDM0ID0gZnVuY3Rpb24gZml4MzQobnVtcykge1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBudW1zLmxlbmd0aCAmJiBudW1zW2ldICE9IDMpXG4gICAgaSsrO1xuXG4gIGxldCBqID0gaSArIDE7XG5cbiAgd2hpbGUgKGogPCBudW1zLmxlbmd0aCAmJiBudW1zW2pdICE9IDQpXG4gICAgaisrO1xuXG4gIHdoaWxlIChpIDwgbnVtcy5sZW5ndGgpIHtcbiAgICBpZiAobnVtc1tpXSA9PSAzKSB7XG4gICAgICBsZXQgdGVtcCA9IG51bXNbaSArIDFdO1xuICAgICAgbnVtc1tpICsgMV0gPSBudW1zW2pdO1xuICAgICAgbnVtc1tqXSA9IHRlbXA7XG5cbiAgICAgIHdoaWxlIChqIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tqXSAhPSA0KVxuICAgICAgICBqKys7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuZml4NDUgPSBmdW5jdGlvbiBmaXg0NShudW1zKSB7XG5cbiAgbGV0IGkgPSAwO1xuICBsZXQgaiA9IDA7XG5cbiAgd2hpbGUgKGogPCBudW1zLmxlbmd0aCAmJiBudW1zW2pdICE9IDUpIHtcbiAgICBqKys7XG4gIH1cblxuICB3aGlsZSAoaSA8IG51bXMubGVuZ3RoKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgbGV0IHRlbXAgPSBudW1zW2kgKyAxXTtcbiAgICAgIG51bXNbaSArIDFdID0gbnVtc1tqXTtcbiAgICAgIG51bXNbal0gPSB0ZW1wO1xuXG4gICAgICB3aGlsZSAoKGogPCBudW1zLmxlbmd0aCAmJiBudW1zW2pdICE9IDUpIHx8IGogPT0gaSArIDEpXG4gICAgICAgIGorKztcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuY2FuQmFsYW5jZSA9IGZ1bmN0aW9uIGNhbkJhbGFuY2UobnVtcykge1xuICBsZXQgZmlyc3QgPSAwO1xuICBsZXQgc2Vjb25kID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBzZWNvbmQgKz0gbnVtc1tpXTsgLy9hZGRpbmcgYWxsIG51bXMgdG9nZXRoZXJcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bXMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgZmlyc3QgKz0gbnVtc1tpXTtcbiAgICBzZWNvbmQgLT0gbnVtc1tpXTtcblxuICAgIGlmIChmaXJzdCA9PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmxpbmVhckluID0gZnVuY3Rpb24gbGluZWFySW4ob3V0ZXIsIGlubmVyKSB7XG4gIC8vaW5kZXggZm9yIGlubmVyIGFycmF5LCBhbHNvIGFjdHMgYXMgYSAnY291bnQnIHZhcmlhYmxlXG4gIGxldCBqID0gMDtcblxuICAvL2xvb3BpbmcgdGhyb3VnaCB0aGUgb3V0ZXIgYXJyYXkgb25jZS4gbG9va2luZyBmb3IgbWF0Y2hlcy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbm5lcltqXSA9PSBvdXRlcltpXSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqID09IGlubmVyLmxlbmd0aDtcblxufVxuXG5zb2x1dGlvbnMuc3F1YXJlVXAgPSBmdW5jdGlvbiBzcXVhcmVVcChuKSB7XG5cbiAgbGV0IHN1YkFycmF5ID0gW107XG4gIGxldCBqID0gbjtcbiAgd2hpbGUgKGogPiAwKSB7XG4gICAgc3ViQXJyYXkucHVzaCgwKTtcbiAgICBqLS07XG4gIH1cblxuICBsZXQgb3V0cHV0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN1YkFycmF5LnNwbGljZShpLCAxLCBuIC0gaSk7XG4gICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChzdWJBcnJheSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuc29sdXRpb25zLnNlcmllc1VwID0gZnVuY3Rpb24gc2VyaWVzVXAobikge1xuICBsZXQgbW9kQXJyID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBsZXQgaiA9IGk7XG4gICAgbGV0IHggPSAxO1xuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIG1vZEFyci5wdXNoKHgpO1xuICAgICAgeCArPSAxO1xuICAgICAgai0tO1xuICAgIH1cbiAgICB4ID0gMTtcbiAgfVxuICByZXR1cm4gbW9kQXJyO1xufVxuXG5zb2x1dGlvbnMubWF4TWlycm9yID0gZnVuY3Rpb24gbWF4TWlycm9yKG51bXMpIHtcbiAgLy9UaGlzIHNvbHV0aW9uIHdhcyBtYWRlIGJ5IFN1bmcgSG8gUGFyay4gSGUgdG9vayA1IGhvdXJzIHRvIHNpbXBsaWZ5IHRoZSBzb2x1dGlvbi4gWW91J3JlIHdlbGNvbWUuIFxuICAvLy5pbmNsdWRlcygpIG1ldGhvZCBjaGVja3Mgd2hldGhlciBhIHNwZWNpZmljIHN0cmluZyBleGlzdHMgd2l0aGluIGFuIHN0cmluZyBvciBub3QudG9TdHJpbmcoKSBjb252ZXJ0cyBhIG51bWJlciB0byBhIHN0cmluZyBcbiAgaWYgKG51bXMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvL3JldmVyc2VzIG51bXMgYW5kIG1ha2VzIGl0IGludG8gYSBzdHJpbmcgXG4gIGxldCByZXZlcnNlID0gXCJcIjtcbiAgcmV2ZXJzZSA9IHJldmVyc2UgKyBudW1zW251bXMubGVuZ3RoIC0gMV07XG4gIGZvciAobGV0IGkgPSBudW1zLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgcmV2ZXJzZSA9IHJldmVyc2UgKyBcIixcIiArIG51bXNbaV0udG9TdHJpbmcoKTtcbiAgfVxuICBsZXQgbWF4TnVtID0gbnVtcy5sZW5ndGggLSAxO1xuICB3aGlsZSAobWF4TnVtID49IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gbWF4TnVtOyBpKyspIHtcbiAgICAgIGlmIChyZXZlcnNlLmluY2x1ZGVzKGNyZWF0ZUNhbmRpZGF0ZShudW1zLCBpLCBtYXhOdW0gKyBpKSkpIHtcbiAgICAgICAgcmV0dXJuIG1heE51bSArIGkgKyAxIC0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWF4TnVtID0gbWF4TnVtIC0gMTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDYW5kaWRhdGUobnVtLCBtaW4sIG1heCkgey8vY3JlYXRlcyBjYW5kaWRhdGVzIGJldHdlZW4gcmFuZ2VzIG9mIG1pbiBhbmQgbWF4XG4gICAgbGV0IGFuc3dlciA9IFwiXCI7XG4gICAgYW5zd2VyID0gYW5zd2VyICsgbnVtW21pbl0udG9TdHJpbmcoKTtcbiAgICBmb3IgKGxldCBjID0gbWluICsgMTsgYyA8IG1heCArIDE7IGMrKykge1xuICAgICAgYW5zd2VyID0gYW5zd2VyICsgXCIsXCIgKyBudW1bY10udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuc3dlcjtcbiAgfVxufVxuXG5zb2x1dGlvbnMuY291bnRDbHVtcHMgPSBmdW5jdGlvbiBjb3VudENsdW1wcyhudW1zKSB7XG4gIGxldCB5YXJkU3RpY2sgPSAtMTtcbiAgbGV0IGNsdW1wcyA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gbnVtc1tpICsgMV0gJiYgbnVtc1tpXSAhPSB5YXJkU3RpY2spIHtcbiAgICAgIGNsdW1wcyArPSAxO1xuICAgICAgeWFyZFN0aWNrID0gbnVtc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG51bXNbaV0gIT0geWFyZFN0aWNrKSB7XG4gICAgICAgIHlhcmRTdGljayA9IC0xXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2x1bXBzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdDb3VudDdzJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7MSwgMiwgNn0pJyxcbiAgICAgICcoezMsIDcsIDd9KScsXG4gICAgICBgKHs4LCAxMSwgNywgMywgN30pYCxcbiAgICAgIGAoezcsIDcsIDcsIDd9KWAsXG4gICAgICBgKHs3LjIsIDExLCAzfSlgLFxuICAgICAgJyh7MiwgNywgMiwgMTEsIDcsIDI0LCA3fSknXG4gICAgXSxcbiAgICAvLyBUaGUgcXVlc3Rpb24gaXRzZWxmLiBUcnkgdG8gbWFrZSBpdCBQc2V1ZG9jb2RlLXlcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgY29sbGVjdGlvbiBvZiBudW1iZXJzLCBjb3VudCBhbmQgdGhlbiBvdXRwdXQgaG93IG1hbnkgN3MgYXBwZWFyIGluIHRoZSBjb2xsZWN0aW9uLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQ291bnQ3cyhOVU1TKVxuICAgIENPVU5UID0gMFxuICAgIE5VTVMucmVzZXROZXh0KClcbiAgICBsb29wIHdoaWxlIE5VTVMuaGFzTmV4dCgpXG4gICAgICBOID0gTlVNUy5nZXROZXh0KClcbiAgICAgIGlmIE4gPSA3IHRoZW5cbiAgICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgXG4gICAgb3V0cHV0IENPVU5UXG4gIGVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ05lZ2F0aXZlT25ldG9PbmUnLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHswLjMsIDEsIC0wLjcsIDIuMywgMC4yLCA1LjN9KScsXG4gICAgICAnKHsxLjEsIDAuOTksIDEuMH0pJyxcbiAgICAgIGAoezAuMiwgMC4zLCAwLjQsIC0wLjIsIC0wLjMsIC0wLjR9KWAsXG4gICAgICBgKHsyLCAtMiwgMywgLTMsIDQsIC00fSlgLFxuICAgICAgYCh7LjIsIC0wLjIsIDAuMywgLTAuMywgMC40LCAtMC40fSlgLFxuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGNvbGxlY3Rpb24gb2YgcmVhbCBudW1iZXJzLCBjb3VudCBob3cgbWFueSBlbGVtZW50cyBhcmUgaW4gdGhlIGludGVydmFsIFstMSwgMV0gaW5jbHVzaXZlLiBPdXRwdXQgdGhlIGNvdW50LiAoSUIgTm92ZW1iZXIgMjAxOCwgcXVlc3Rpb24gOGQpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBOZWdhdGl2ZU9uZXRvT25lKE5VTVMpXG4gICAgQ09VTlQgPSAwXG4gICAgTlVNUy5yZXNldE5leHQoKVxuICAgIGxvb3Agd2hpbGUgTlVNUy5oYXNOZXh0KClcbiAgICAgIE4gPSBOVU1TLmdldE5leHQoKVxuICAgICAgaWYgTiA+PSAtMSBBTkQgTiA8PSAxIHRoZW5cbiAgICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IENPVU5UXG4gIGVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ0NvdW50QXMnLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHtcImFiY1wiLCBcIkFCQ1wiLCBcIkNCQVwiLCBcImNiYVwiLCBcImJjYmNiY1wifSknLFxuICAgICAgJyh7XCJiYlwiLFwiYWFcIixcIkFCXCIsXCJCQVwifSknLFxuICAgICAgJyh7XCJiYXRcIiwgXCJhYmFjdXNcIn0pJ1xuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGNvbGxlY3Rpb24gb2Ygc3RyaW5ncywgY291bnQgYWxsIHRoZSBzdHJpbmdzIHdob3NlIGZpcnN0IGxldHRlciBpcyBcImFcIiBvZiBcIkFcIiBhbmQgb3V0cHV0IHRoZSBjb3VudC4gWW91IGNhbiB1c2UgdGhlIFNUUi5TdWJTdHIoaSwgYykgbWV0aG9kIChsb29rIGF0IHRoZSByZWZlcmVuY2UgbGlua2VkIGFib3ZlKS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIENvdW50QXMoV09SRFMpXG4gIENPVU5UID0gMFxuICBXT1JEUy5yZXNldE5leHQoKVxuICBsb29wIHdoaWxlIFdPUkRTLmhhc05leHQoKVxuICAgIFcgPSBXT1JEUy5nZXROZXh0KClcbiAgICBpZiBXLlN1YlN0cigwLDEpID0gXCJhXCIgT1IgVy5TdWJTdHIoMCwxKSA9IFwiQVwiIHRoZW5cbiAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIFxuICBvdXRwdXQgQ09VTlRcbmVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ1N1bUNvbGxlY3Rpb24nLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzfSknLFxuICAgICAgJyh7NSwgMTEsIDIsIC0zfSknLFxuICAgICAgJyh7NywgMCwgMCwgLTd9KScsXG4gICAgICAnKHsxLCAyLCAxLCAxLCAyfSknLFxuICAgICAgJyh7MSwgMSwgMSwgMX0pJyxcbiAgICAgICcoezIsIDcsIDIsIDEwM30pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYSBDb2xsZWN0aW9uIG9mIG51bWJlcnMsIHJldHVybiB0aGUgc3VtIG9mIGFsbCB0aGUgZWxlbWVudHMuJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdW1Db2xsZWN0aW9uKE5VTVMpXG4gICAgU1VNID0gMFxuICAgIE5VTVMucmVzZXROZXh0KClcbiAgICBsb29wIHdoaWxlIE5VTVMuaGFzTmV4dCgpXG4gICAgICBOID0gTlVNUy5nZXROZXh0KClcbiAgICAgIFNVTSA9IFNVTSArIE5cbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBTVU1cbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdBdmVyYWdlQ29sbGVjdGlvbicsXG4gICAgaW5wdXRUeXBlOiBcImNvbGxlY3Rpb25cIixcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoezEsIDIsIDMsIDQsIDV9KScsXG4gICAgICAnKHs1LCAxMSwgMiwgLTgsIDB9KScsXG4gICAgICAnKHs3LCAwLCAwLCAtMSwgLTF9KScsXG4gICAgICAnKHsxLCAyLCAxLCAyLCAxfSknLFxuICAgICAgJyh7MSwgMSwgMSwgMSwgMX0pJyxcbiAgICAgICcoezIsIDcsIDJ9KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogJ0dpdmVuIGEgQ29sbGVjdGlvbiBvZiBudW1iZXJzLCByZXR1cm4gdGhlIG1lYW4gKGF2ZXJhZ2UpIG9mIGFsbCB0aGUgZWxlbWVudHMuJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBBdmVyYWdlQ29sbGVjdGlvbihOVU1TKVxuICAgIFNVTSA9IDBcbiAgICBDT1VOVCA9IDBcbiAgICBOVU1TLnJlc2V0TmV4dCgpXG4gICAgbG9vcCB3aGlsZSBOVU1TLmhhc05leHQoKVxuICAgICAgTiA9IE5VTVMuZ2V0TmV4dCgpXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgICAgU1VNID0gU1VNICsgTlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IChTVU0gLyBDT1VOVClcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdDb3VudEFNJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7XCJTbWl0aCwgSmFuZVwiLFwiQnJvd24sIEphbWVzXCJ9KScsXG4gICAgICAnKHtcIkR1Y2t3b3J0aCwgRWxpemFcIiwgXCJBbHRtYW4sIFBoaWxcIn0pJyxcbiAgICAgICcoe1wiTWl6cmFoaSwgTWFyaW5hXCIsIFwiTmVsc29uLCBKdWRkXCJ9KScsXG4gICAgICAnKHtcIkEsIEJcIiwgXCJDLCBEXCIsIFwiTSwgTlwiLCBcIlAsIEpcIiwgXCJRLCBaXCJ9KSdcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgPHA+R2l2ZW4gYSBjb2xsZWN0aW9uIG9mIG5hbWVzIGluIHRoZSBmb3JtIFwiTGFzdCwgRmlyc3RcIiwgb3V0cHV0IHRoZSBudW1iZXIgb2YgbmFtZXMgd2hvc2UgbGFzdCBuYW1lIHN0YXJ0cyB3aXRoIGEgbGV0dGVyIGJldHdlZW4gQSBhbmQgTSBpbiB0aGUgRW5nbGlzaCBhbHBoYWJldC48L3A+XG5cbiAgICA8cD5Zb3UgY2FuIGFzc3VtZSB5b3UgaGF2ZSBhY2Nlc3MgdG8gYSBtZXRob2QgY2FsbGVkIDxjb2RlPkNvbXBhcmUoU1RSMSwgU1RSMik8L2NvZGU+IHRoYXQgcmV0dXJucyA8Y29kZT4wPC9jb2RlPiBpZiB0aGUgdHdvIHN0cmluZ3MgYXJlIGlkZW50aWNhbCwgPGNvZGU+LTE8L2NvZGU+IGlmIDxjb2RlPlNUUjE8L2NvZGU+IGlzIGVhcmxpZXIgdGhhbiA8Y29kZT5TVFIyPC9jb2RlPiBpbiB0aGUgYWxwaGFiZXQsIGFuZCA8Y29kZT4xPC9jb2RlPiBpZiA8Y29kZT5TVFIxPC9jb2RlPiBpcyBsYXRlciB0aGFuIDxjb2RlPlNUUjI8L2NvZGU+IGluIHRoZSBhbHBoYWJldC48L3A+YCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBDb3VudEFNKE5BTUVTKVxuICBBTSA9IDBcbiAgTkFNRVMucmVzZXROZXh0KClcbiAgbG9vcCB3aGlsZSBOQU1FUy5oYXNOZXh0KClcbiAgICBOID0gTkFNRVMuZ2V0TmV4dCgpXG4gICAgaWYgQ29tcGFyZShOLCBcIk5cIikgPSAtMSB0aGVuXG4gICAgICBBTSA9IEFNICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgQU1cbmVuZCBtZXRob2RgLFxuICAgIHByZWFtYmxlOiBgZnVuY3Rpb24gQ29tcGFyZShzdHIxLCBzdHIyKSB7IHJldHVybiBzdHIxLmxvY2FsZUNvbXBhcmUoc3RyMikgfWAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0NvbGxlY3Rpb25zJyxcbiAgICBuYW1lOiAnUm90YXRlTGVmdENvbGxlY3Rpb24nLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzLCA0LCA1fSknLFxuICAgICAgJyh7NSwgMTEsIDIsIC04LCAwfSknLFxuICAgICAgJyh7NywgMCwgMCwgLTEsIC0xfSknLFxuICAgICAgJyh7MSwgMiwgMSwgMiwgMX0pJyxcbiAgICAgICcoezEsIDEsIDEsIDEsIDF9KScsXG4gICAgICAnKHsyLCA3LCAyfSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBjb2xsZWN0aW9uIG9mIG51bWJlcnMsIGNyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHRoYXQgaXMgdGhlIHNhbWUgdGhpbmcsIGJ1dCB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IG1vdmVkIHRvIHRoZSBiYWNrLiBJZiB0aGUgb3JpZ2luYWwgY29sbGVjdGlvbiBpcyBlbXB0eSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb24uIFlvdSBjYW4gbWFrZSBhbiBlbXB0eSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBjb21tYW5kIFwiQyA9IG5ldyBDb2xsZWN0aW9uKClcImAsXG4gICAgc29sdXRpb246IGBtZXRob2QgUm90YXRlTGVmdENvbGxlY3Rpb24oTlVNUylcbiAgICBDID0gbmV3IENvbGxlY3Rpb24oKVxuICAgIGlmIE5PVCBOVU1TLmlzRW1wdHkoKSB0aGVuXG4gICAgICBGSVJTVCA9IE5VTVMuZ2V0TmV4dCgpXG4gICAgICBsb29wIHdoaWxlIE5VTVMuaGFzTmV4dCgpXG4gICAgICAgIEMuYWRkSXRlbShOVU1TLmdldE5leHQoKSlcbiAgICAgIGVuZCBsb29wXG4gICAgICBDLmFkZEl0ZW0oRklSU1QpXG4gICAgZW5kIGlmXG4gICAgb3V0cHV0IEMgIFxuICBlbmQgbWV0aG9kYFxuICB9XG5dXG5cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnY2lnYXJQYXJ0eScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMwLCBmYWxzZSknLFxuICAgICAgJyg1MCwgZmFsc2UpJyxcbiAgICAgICcoNzAsIHRydWUpJyxcbiAgICAgICcoMzAsIHRydWUpJyxcbiAgICAgICcoNTAsIHRydWUpJyxcbiAgICAgICcoNjAsIGZhbHNlKScsXG4gICAgICAnKDYxLCBmYWxzZSknLFxuICAgICAgJyg0MCwgZmFsc2UpJyxcbiAgICAgICcoMzksIGZhbHNlKScsXG4gICAgICAnKDQwLCB0cnVlKScsXG4gICAgICAnKDM5LCB0cnVlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFdoZW4gc3F1aXJyZWxzIGdldCB0b2dldGhlciBmb3IgYSBwYXJ0eSwgdGhleSBsaWtlIHRvIGhhdmUgY2lnYXJzLiBBIHNxdWlycmVsXG4gICAgcGFydHkgaXMgc3VjY2Vzc2Z1bCB3aGVuIHRoZSBudW1iZXIgb2YgY2lnYXJzIGlzIGJldHdlZW4gNDAgYW5kIDYwLCBpbmNsdXNpdmUuIFVubGVzcyBpdFxuICAgIGlzIHRoZSB3ZWVrZW5kLCBpbiB3aGljaCBjYXNlIHRoZXJlIGlzIG5vIHVwcGVyIGJvdW5kIG9uIHRoZSBudW1iZXIgb2YgY2lnYXJzLiBSZXR1cm5cbiAgICB0cnVlIGlmIHRoZSBwYXJ0eSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMgaXMgc3VjY2Vzc2Z1bCwgb3IgZmFsc2Ugb3RoZXJ3aXNlLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdkYXRlRmFzaGlvbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDUsIDEwKScsXG4gICAgICAnKDUsIDIpJyxcbiAgICAgICcoNSwgNSknLFxuICAgICAgJygzLCAzKScsXG4gICAgICAnKDEwLCAyKScsXG4gICAgICAnKDIsIDkpJyxcbiAgICAgICcoOSwgOSknLFxuICAgICAgJygxMCwgNSknLFxuICAgICAgJygyLCAyKScsXG4gICAgICAnKDMsIDcpJyxcbiAgICAgICcoMiwgNyknLFxuICAgICAgJyg2LCAyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdSBhbmQgeW91ciBkYXRlIGFyZSB0cnlpbmcgdG8gZ2V0IGEgdGFibGUgYXQgYSByZXN0YXVyYW50LiBUaGUgcGFyYW1ldGVyXG4gICAgXCJ5b3VcIiBpcyB0aGUgc3R5bGlzaG5lc3Mgb2YgeW91ciBjbG90aGVzLCBpbiB0aGUgcmFuZ2UgMC4uMTAsIGFuZCBcImRhdGVcIiBpcyB0aGUgc3R5bGlzaG5lc3NcbiAgICBvZiB5b3VyIGRhdGUncyBjbG90aGVzLiBUaGUgcmVzdWx0IGdldHRpbmcgdGhlIHRhYmxlIGlzIGVuY29kZWQgYXMgYW4gaW50IHZhbHVlIHdpdGggMD1ubyxcbiAgICAxPW1heWJlLCAyPXllcy4gSWYgZWl0aGVyIG9mIHlvdSBpcyB2ZXJ5IHN0eWxpc2gsIDggb3IgbW9yZSwgdGhlbiB0aGUgcmVzdWx0IGlzIDIgKHllcykuXG4gICAgV2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaWYgZWl0aGVyIG9mIHlvdSBoYXMgc3R5bGUgb2YgMiBvciBsZXNzLCB0aGVuIHRoZSByZXN1bHQgaXMgMCAobm8pLlxuICAgIE90aGVyd2lzZSB0aGUgcmVzdWx0IGlzIDEgKG1heWJlKS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc3F1aXJyZWxQbGF5JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNzAsIGZhbHNlKScsXG4gICAgICAnKDk1LCBmYWxzZSknLFxuICAgICAgJyg5NSwgdHJ1ZSknLFxuICAgICAgJyg5MCwgZmFsc2UpJyxcbiAgICAgICcoOTAsIHRydWUpJyxcbiAgICAgICcoNTAsIGZhbHNlKScsXG4gICAgICAnKDUwLCB0cnVlKScsXG4gICAgICAnKDEwMCwgZmFsc2UpJyxcbiAgICAgICcoMTAwLCB0cnVlKScsXG4gICAgICAnKDEwNSwgdHJ1ZSknLFxuICAgICAgJyg1OSwgZmFsc2UpJyxcbiAgICAgICcoNTksIHRydWUpJyxcbiAgICAgICcoNjAsIGZhbHNlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFRoZSBzcXVpcnJlbHMgaW4gUGFsbyBBbHRvIHNwZW5kIG1vc3Qgb2YgdGhlIGRheSBwbGF5aW5nLiBJbiBwYXJ0aWN1bGFyLFxuICAgIHRoZXkgcGxheSBpZiB0aGUgdGVtcGVyYXR1cmUgaXMgYmV0d2VlbiA2MCBhbmQgOTAgKGluY2x1c2l2ZSkuIFVubGVzcyBpdCBpcyBzdW1tZXIsXG4gICAgdGhlbiB0aGUgdXBwZXIgbGltaXQgaXMgMTAwIGluc3RlYWQgb2YgOTAuIEdpdmVuIGFuIGludCB0ZW1wZXJhdHVyZSBhbmQgYSBib29sZWFuIGlzU3VtbWVyLFxuICAgIHJldHVybiB0cnVlIGlmIHRoZSBzcXVpcnJlbHMgcGxheSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdjYXVnaHRTcGVlZGluZycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDYwLCBmYWxzZSknLFxuICAgICAgJyg2NSwgZmFsc2UpJyxcbiAgICAgICcoNjUsIHRydWUpJyxcbiAgICAgICcoODAsIGZhbHNlKScsXG4gICAgICAnKDg1LCBmYWxzZSknLFxuICAgICAgJyg4NSwgdHJ1ZSknLFxuICAgICAgJyg3MCwgZmFsc2UpJyxcbiAgICAgICcoNzUsIGZhbHNlKScsXG4gICAgICAnKDc1LCB0cnVlKScsXG4gICAgICAnKDQwLCBmYWxzZSknLFxuICAgICAgJyg0MCwgdHJ1ZSknLFxuICAgICAgJyg5MCwgZmFsc2UpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91IGFyZSBkcml2aW5nIGEgbGl0dGxlIHRvbyBmYXN0LCBhbmQgYSBwb2xpY2Ugb2ZmaWNlciBzdG9wcyB5b3UuIFdyaXRlIGNvZGVcbiAgICB0byBjb21wdXRlIHRoZSByZXN1bHQsIGVuY29kZWQgYXMgYW4gaW50IHZhbHVlOiAwPW5vIHRpY2tldCwgMT1zbWFsbCB0aWNrZXQsIDI9YmlnIHRpY2tldC5cbiAgICBJZiBzcGVlZCBpcyA2MCBvciBsZXNzLCB0aGUgcmVzdWx0IGlzIDAuIElmIHNwZWVkIGlzIGJldHdlZW4gNjEgYW5kIDgwIGluY2x1c2l2ZSwgdGhlIHJlc3VsdFxuICAgIGlzIDEuIElmIHNwZWVkIGlzIDgxIG9yIG1vcmUsIHRoZSByZXN1bHQgaXMgMi4gVW5sZXNzIGl0IGlzIHlvdXIgYmlydGhkYXkgLS0gb24gdGhhdCBkYXksXG4gICAgeW91ciBzcGVlZCBjYW4gYmUgNSBoaWdoZXIgaW4gYWxsIGNhc2VzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdzb3J0YVN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMsIDQpJyxcbiAgICAgICcoOSwgNCknLFxuICAgICAgJygxMCwgMTEpJyxcbiAgICAgICcoMTIsIC0zKScsXG4gICAgICAnKC0zLCAxMiknLFxuICAgICAgJyg0LCA1KScsXG4gICAgICAnKDQsIDYpJyxcbiAgICAgICcoMTQsIDcpJyxcbiAgICAgICcoMTQsIDYpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBpbnRzLCBhIGFuZCBiLCByZXR1cm4gdGhlaXIgc3VtLiBIb3dldmVyLCBzdW1zIGluIHRoZSByYW5nZSAxMC4uMTlcbiAgICBpbmNsdXNpdmUsIGFyZSBmb3JiaWRkZW4sIHNvIGluIHRoYXQgY2FzZSBqdXN0IHJldHVybiAyMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnYWxhcm1DbG9jaycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIGZhbHNlKScsXG4gICAgICAnKDUsIGZhbHNlKScsXG4gICAgICAnKDAsIGZhbHNlKScsXG4gICAgICAnKDYsIGZhbHNlKScsXG4gICAgICAnKDAsIHRydWUpJyxcbiAgICAgICcoNiwgdHJ1ZSknLFxuICAgICAgJygxLCB0cnVlKScsXG4gICAgICAnKDMsIHRydWUpJyxcbiAgICAgICcoNSwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGRheSBvZiB0aGUgd2VlayBlbmNvZGVkIGFzIDA9U3VuLCAxPU1vbiwgMj1UdWUsIC4uLjY9U2F0LCBhbmQgYVxuICAgIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB3ZSBhcmUgb24gdmFjYXRpb24sIHJldHVybiBhIHN0cmluZyBvZiB0aGUgZm9ybSBcIjc6MDBcIiBpbmRpY2F0aW5nXG4gICAgd2hlbiB0aGUgYWxhcm0gY2xvY2sgc2hvdWxkIHJpbmcuIFdlZWtkYXlzLCB0aGUgYWxhcm0gc2hvdWxkIGJlIFwiNzowMFwiIGFuZCBvbiB0aGUgd2Vla2VuZFxuICAgIGl0IHNob3VsZCBiZSBcIjEwOjAwXCIuIFVubGVzcyB3ZSBhcmUgb24gdmFjYXRpb24gLS0gdGhlbiBvbiB3ZWVrZGF5cyBpdCBzaG91bGQgYmUgXCIxMDowMFwiXG4gICAgYW5kIHdlZWtlbmRzIGl0IHNob3VsZCBiZSBcIm9mZlwiLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdsb3ZlNicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDYsIDQpJyxcbiAgICAgICcoNCwgNSknLFxuICAgICAgJygxLCA1KScsXG4gICAgICAnKDEsIDYpJyxcbiAgICAgICcoMSwgOCknLFxuICAgICAgJygxLCA3KScsXG4gICAgICAnKDcsIDUpJyxcbiAgICAgICcoOCwgMiknLFxuICAgICAgJyg2LCA2KScsXG4gICAgICAnKC02LCAyKScsXG4gICAgICAnKC00LCAtMTApJyxcbiAgICAgICcoLTcsIDEpJyxcbiAgICAgICcoNywgLTEpJyxcbiAgICAgICcoLTYsIDEyKScsXG4gICAgICAnKC0yLCAtNCknLFxuICAgICAgJyg3LCAxKScsXG4gICAgICAnKDAsIDkpJyxcbiAgICAgICcoOCwgMyknLFxuICAgICAgJygzLCAzKScsXG4gICAgICAnKDMsIDQpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgVGhlIG51bWJlciA2IGlzIGEgdHJ1bHkgZ3JlYXQgbnVtYmVyLiBHaXZlbiB0d28gaW50IHZhbHVlcywgYSBhbmQgYiwgcmV0dXJuXG4gICAgdHJ1ZSBpZiBlaXRoZXIgb25lIGlzIDYuIE9yIGlmIHRoZWlyIHN1bSBvciBkaWZmZXJlbmNlIGlzIDYuIE5vdGU6IHRoZSBmdW5jdGlvblxuICAgIE1hdGguYWJzKG51bSkgY29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdpbjFUbzEwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNSwgZmFsc2UpJyxcbiAgICAgICcoMTEsIGZhbHNlKScsXG4gICAgICAnKDExLCB0cnVlKScsXG4gICAgICAnKDEwLCBmYWxzZSknLFxuICAgICAgJygxMCwgdHJ1ZSknLFxuICAgICAgJyg5LCBmYWxzZSknLFxuICAgICAgJyg5LCB0cnVlKScsXG4gICAgICAnKDEsIGZhbHNlKScsXG4gICAgICAnKDEsIHRydWUpJyxcbiAgICAgICcoMCwgZmFsc2UpJyxcbiAgICAgICcoMCwgdHJ1ZSknLFxuICAgICAgJygtMSwgZmFsc2UpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgbiwgcmV0dXJuIHRydWUgaWYgbiBpcyBpbiB0aGUgcmFuZ2UgMS4uMTAsIGluY2x1c2l2ZS5cbiAgICBVbmxlc3MgXCJvdXRzaWRlTW9kZVwiIGlzIHRydWUsIGluIHdoaWNoIGNhc2UgcmV0dXJuIHRydWUgaWYgdGhlIG51bWJlciBpcyBsZXNzIG9yXG4gICAgZXF1YWwgdG8gMSwgb3IgZ3JlYXRlciBvciBlcXVhbCB0byAxMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc3BlY2lhbEVsZXZlbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIyKScsXG4gICAgICAnKDIzKScsXG4gICAgICAnKDI0KScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDExKScsXG4gICAgICAnKDEyKScsXG4gICAgICAnKDEwKScsXG4gICAgICAnKDkpJyxcbiAgICAgICcoOCknLFxuICAgICAgJygwKScsXG4gICAgICAnKDEpJyxcbiAgICAgICcoMiknLFxuICAgICAgJygxMjEpJyxcbiAgICAgICcoMTIyKScsXG4gICAgICAnKDEyMyknLFxuICAgICAgJyg0NiknLFxuICAgICAgJyg0OSknLFxuICAgICAgJyg1MiknLFxuICAgICAgJyg1NCknLFxuICAgICAgJyg1NSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBXZSdsbCBzYXkgYSBudW1iZXIgaXMgc3BlY2lhbCBpZiBpdCBpcyBhIG11bHRpcGxlIG9mIDExIG9yIGlmIGl0IGlzIG9uZSBtb3JlXG4gICAgdGhhbiBhIG11bHRpcGxlIG9mIDExLiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9uLW5lZ2F0aXZlIG51bWJlciBpcyBzcGVjaWFsLiBVc2UgdGhlICVcbiAgICBcIm1vZFwiIG9wZXJhdG9yLmAsIC8vIFRPRE8gYWRkIGluZm8gb24gbW9kLCB1cCB0byBhbmQgaW5jbCBleGVyY2lzZSBuZWFyVGVuXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdtb3JlMjAnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyMCknLFxuICAgICAgJygyMSknLFxuICAgICAgJygyMiknLFxuICAgICAgJygyMyknLFxuICAgICAgJygyNSknLFxuICAgICAgJygzMCknLFxuICAgICAgJygzMSknLFxuICAgICAgJyg1OSknLFxuICAgICAgJyg2MCknLFxuICAgICAgJyg2MSknLFxuICAgICAgJyg2MiknLFxuICAgICAgJygxMDIwKScsXG4gICAgICAnKDEwMjEpJyxcbiAgICAgICcoMTAwMCknLFxuICAgICAgJygxMDAxKScsXG4gICAgICAnKDUwKScsXG4gICAgICAnKDU1KScsXG4gICAgICAnKDQwKScsXG4gICAgICAnKDQxKScsXG4gICAgICAnKDM5KScsXG4gICAgICAnKDQyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBub24tbmVnYXRpdmUgbnVtYmVyIGlzIDEgb3IgMiBtb3JlIHRoYW4gYVxuICAgIG11bHRpcGxlIG9mIDIwLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdvbGQzNScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMpJyxcbiAgICAgICcoMTApJyxcbiAgICAgICcoMTUpJyxcbiAgICAgICcoNSknLFxuICAgICAgJyg5KScsXG4gICAgICAnKDgpJyxcbiAgICAgICcoNyknLFxuICAgICAgJyg2KScsXG4gICAgICAnKDE3KScsXG4gICAgICAnKDE4KScsXG4gICAgICAnKDI5KScsXG4gICAgICAnKDIwKScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDIyKScsXG4gICAgICAnKDQ1KScsXG4gICAgICAnKDk5KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBub24tbmVnYXRpdmUgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgMyBvciA1LFxuICAgIGJ1dCBub3QgYm90aC4gVXNlIHRoZSAlIFwibW9kXCIgb3BlcmF0b3IuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2xlc3MyMCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDE4KScsXG4gICAgICAnKDE5KScsXG4gICAgICAnKDIwKScsXG4gICAgICAnKDgpJyxcbiAgICAgICcoMTcpJyxcbiAgICAgICcoMjMpJyxcbiAgICAgICcoMjUpJyxcbiAgICAgICcoMzApJyxcbiAgICAgICcoMzEpJyxcbiAgICAgICcoNTgpJyxcbiAgICAgICcoNTkpJyxcbiAgICAgICcoNjApJyxcbiAgICAgICcoNjEpJyxcbiAgICAgICcoNjIpJyxcbiAgICAgICcoMTAxNyknLFxuICAgICAgJygxMDE4KScsXG4gICAgICAnKDEwMTkpJyxcbiAgICAgICcoMTAyMCknLFxuICAgICAgJygxMDIxKScsXG4gICAgICAnKDEwMjIpJyxcbiAgICAgICcoMTAyMyknLFxuICAgICAgJygzNyknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9uLW5lZ2F0aXZlIG51bWJlciBpcyAxIG9yIDIgbGVzcyB0aGFuIGFcbiAgICBtdWx0aXBsZSBvZiAyMC4gU28gZm9yIGV4YW1wbGUgMzggYW5kIDM5IHJldHVybiB0cnVlLCBidXQgNDAgcmV0dXJucyBmYWxzZS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnbmVhclRlbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEyKScsXG4gICAgICAnKDE3KScsXG4gICAgICAnKDE5KScsXG4gICAgICAnKDMxKScsXG4gICAgICAnKDYpJyxcbiAgICAgICcoMTApJyxcbiAgICAgICcoMTEpJyxcbiAgICAgICcoMjEpJyxcbiAgICAgICcoMjIpJyxcbiAgICAgICcoMjMpJyxcbiAgICAgICcoNTQpJyxcbiAgICAgICcoMTU1KScsXG4gICAgICAnKDE1OCknLFxuICAgICAgJygzKScsXG4gICAgICAnKDEpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24tbmVnYXRpdmUgbnVtYmVyIFwibnVtXCIsIHJldHVybiB0cnVlIGlmIG51bSBpcyB3aXRoaW4gMiBvZiBhXG4gICAgbXVsdGlwbGUgb2YgMTAuIE5vdGU6IChhICUgYikgaXMgdGhlIHJlbWFpbmRlciBvZiBkaXZpZGluZyBhIGJ5IGIsIHNvICg3ICUgNSkgaXMgMi5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAndGVlblN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMsIDQpJyxcbiAgICAgICcoMTAsIDEzKScsXG4gICAgICAnKDEzLCAyKScsXG4gICAgICAnKDMsIDE5KScsXG4gICAgICAnKDEzLCAxMyknLFxuICAgICAgJygxMCwgMTApJyxcbiAgICAgICcoNiwgMTQpJyxcbiAgICAgICcoMTUsIDIpJyxcbiAgICAgICcoMTksIDE5KScsXG4gICAgICAnKDE5LCAyMCknLFxuICAgICAgJygyLCAxOCknLFxuICAgICAgJygxMiwgNCknLFxuICAgICAgJygyLCAyMCknLFxuICAgICAgJygyLCAxNyknLFxuICAgICAgJygyLCAxNiknLFxuICAgICAgJyg2LCA3KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50cywgYSBhbmQgYiwgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgXCJ0ZWVuXCIgdmFsdWVzIGluIHRoZSByYW5nZVxuICAgIDEzLi4xOSBpbmNsdXNpdmUsIGFyZSBleHRyYSBsdWNreS4gU28gaWYgZWl0aGVyIHZhbHVlIGlzIGEgdGVlbiwganVzdCByZXR1cm4gMTkuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2Fuc3dlckNlbGwnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhmYWxzZSwgZmFsc2UsIGZhbHNlKScsXG4gICAgICAnKGZhbHNlLCBmYWxzZSwgdHJ1ZSknLFxuICAgICAgJyh0cnVlLCBmYWxzZSwgZmFsc2UpJyxcbiAgICAgICcodHJ1ZSwgdHJ1ZSwgZmFsc2UpJyxcbiAgICAgICcoZmFsc2UsIHRydWUsIGZhbHNlKScsXG4gICAgICAnKHRydWUsIHRydWUsIHRydWUpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91ciBjZWxsIHBob25lIHJpbmdzLiBSZXR1cm4gdHJ1ZSBpZiB5b3Ugc2hvdWxkIGFuc3dlciBpdC4gTm9ybWFsbHkgeW91XG4gICAgYW5zd2VyLCBleGNlcHQgaW4gdGhlIG1vcm5pbmcgeW91IG9ubHkgYW5zd2VyIGlmIGl0IGlzIHlvdXIgbW9tIGNhbGxpbmcuIEluIGFsbCBjYXNlcyxcbiAgICBpZiB5b3UgYXJlIGFzbGVlcCwgeW91IGRvIG5vdCBhbnN3ZXIuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3RlYVBhcnR5JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNiwgOCknLFxuICAgICAgJygzLCA4KScsXG4gICAgICAnKDIwLCA2KScsXG4gICAgICAnKDEyLCA2KScsXG4gICAgICAnKDExLCA2KScsXG4gICAgICAnKDExLCA0KScsXG4gICAgICAnKDQsIDUpJyxcbiAgICAgICcoNSwgNSknLFxuICAgICAgJyg2LCA2KScsXG4gICAgICAnKDUsIDEwKScsXG4gICAgICAnKDUsIDkpJyxcbiAgICAgICcoMTAsIDQpJyxcbiAgICAgICcoMTAsIDIwKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFdlIGFyZSBoYXZpbmcgYSBwYXJ0eSB3aXRoIGFtb3VudHMgb2YgdGVhIGFuZCBjYW5keS4gUmV0dXJuIHRoZSBpbnQgb3V0Y29tZVxuICAgIG9mIHRoZSBwYXJ0eSBlbmNvZGVkIGFzIDA9YmFkLCAxPWdvb2QsIG9yIDI9Z3JlYXQuIEEgcGFydHkgaXMgZ29vZCAoMSkgaWYgYm90aCB0ZWEgYW5kXG4gICAgY2FuZHkgYXJlIGF0IGxlYXN0IDUuIEhvd2V2ZXIsIGlmIGVpdGhlciB0ZWEgb3IgY2FuZHkgaXMgYXQgbGVhc3QgZG91YmxlIHRoZSBhbW91bnQgb2ZcbiAgICB0aGUgb3RoZXIgb25lLCB0aGUgcGFydHkgaXMgZ3JlYXQgKDIpLiBIb3dldmVyLCBpbiBhbGwgY2FzZXMsIGlmIGVpdGhlciB0ZWEgb3IgY2FuZHkgaXNcbiAgICBsZXNzIHRoYW4gNSwgdGhlIHBhcnR5IGlzIGFsd2F5cyBiYWQgKDApLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdmaXp6U3RyaW5nJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdmaWcnKVwiLFxuICAgICAgXCIoJ2RpYicpXCIsXG4gICAgICBcIignZmliJylcIixcbiAgICAgIFwiKCdhYmMnKVwiLFxuICAgICAgXCIoJ2Zvb28nKVwiLFxuICAgICAgXCIoJ2Jvb28nKVwiLFxuICAgICAgXCIoJ29vb2InKVwiLFxuICAgICAgXCIoJ2Zvb29iJylcIixcbiAgICAgIFwiKCdmJylcIixcbiAgICAgIFwiKCdiJylcIixcbiAgICAgIFwiKCdhYmNiJylcIixcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIignSGVsbG9iJylcIixcbiAgICAgIFwiKCdhZicpXCIsXG4gICAgICBcIignYmYnKVwiLFxuICAgICAgXCIoJ2ZiJylcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcgc3RyLCBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIFwiZlwiIHJldHVybiBcIkZpenpcIi4gSWZcbiAgICB0aGUgc3RyaW5nIGVuZHMgd2l0aCBcImJcIiByZXR1cm4gXCJCdXp6XCIuIElmIGJvdGggdGhlIFwiZlwiIGFuZCBcImJcIiBjb25kaXRpb25zIGFyZSB0cnVlLFxuICAgIHJldHVybiBcIkZpenpCdXp6XCIuIEluIGFsbCBvdGhlciBjYXNlcywgcmV0dXJuIHRoZSBzdHJpbmcgdW5jaGFuZ2VkLiBgLCAvLyBUT0RPIGFkZCBmaXp6YnV6eiBsaW5rXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdmaXp6U3RyaW5nMicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEpJyxcbiAgICAgICcoMiknLFxuICAgICAgJygzKScsXG4gICAgICAnKDQpJyxcbiAgICAgICcoNSknLFxuICAgICAgJyg2KScsXG4gICAgICAnKDcpJyxcbiAgICAgICcoOCknLFxuICAgICAgJyg5KScsXG4gICAgICAnKDE1KScsXG4gICAgICAnKDE2KScsXG4gICAgICAnKDE4KScsXG4gICAgICAnKDE5KScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDQ0KScsXG4gICAgICAnKDQ1KScsXG4gICAgICAnKDEwMCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBpbnQgbiwgcmV0dXJuIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgbnVtYmVyIGZvbGxvd2VkIGJ5IFwiIVwiLiBTbyB0aGVcbiAgICBpbnQgNiB5aWVsZHMgXCI2IVwiLiBFeGNlcHQgaWYgdGhlIG51bWJlciBpcyBkaXZpc2libGUgYnkgMyB1c2UgXCJGaXp6XCIgaW5zdGVhZCBvZiB0aGUgbnVtYmVyLFxuICAgIGFuZCBpZiB0aGUgbnVtYmVyIGlzIGRpdmlzaWJsZSBieSA1IHVzZSBcIkJ1enpcIiwgYW5kIGlmIGRpdmlzaWJsZSBieSBib3RoIDMgYW5kIDUsIHVzZVxuICAgIFwiRml6ekJ1enpcIi4gTm90ZTogdGhlICUgXCJtb2RcIiBvcGVyYXRvciBjb21wdXRlcyB0aGUgcmVtYWluZGVyIGFmdGVyIGRpdmlzaW9uLCBzbyAyMyAlIDEwXG4gICAgeWllbGRzIDMuIFdoYXQgd2lsbCB0aGUgcmVtYWluZGVyIGJlIHdoZW4gb25lIG51bWJlciBkaXZpZGVzIGV2ZW5seSBpbnRvIGFub3RoZXI/YCwgLy8gVE9ETyBmaXp6YnV6eiBjb2RlIGFuZCBpbnRybyB0byBtb2RcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3R3b0FzT25lJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygzLCAxLCAyKScsXG4gICAgICAnKDMsIDIsIDIpJyxcbiAgICAgICcoMiwgMywgMSknLFxuICAgICAgJyg1LCAzLCAtMiknLFxuICAgICAgJyg1LCAzLCAtMyknLFxuICAgICAgJygyLCA1LCAzKScsXG4gICAgICAnKDksIDUsIDUpJyxcbiAgICAgICcoOSwgNCwgNSknLFxuICAgICAgJyg1LCA0LCA5KScsXG4gICAgICAnKDMsIDMsIDApJyxcbiAgICAgICcoMywgMywgMiknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgaXQgaXMgcG9zc2libGUgdG8gYWRkIHR3byBvZiB0aGUgaW50c1xuICAgIHRvIGdldCB0aGUgdGhpcmQuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2luT3JkZXInLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCA0LCBmYWxzZSknLFxuICAgICAgJygxLCAyLCAxLCBmYWxzZSknLFxuICAgICAgJygxLCAxLCAyLCB0cnVlKScsXG4gICAgICAnKDMsIDIsIDQsIGZhbHNlKScsXG4gICAgICAnKDIsIDMsIDQsIGZhbHNlKScsXG4gICAgICAnKDMsIDIsIDQsIHRydWUpJyxcbiAgICAgICcoNCwgMiwgMiwgdHJ1ZSknLFxuICAgICAgJyg0LCA1LCAyLCB0cnVlKScsXG4gICAgICAnKDIsIDQsIDYsIHRydWUpJyxcbiAgICAgICcoNywgOSwgMTAsIGZhbHNlKScsXG4gICAgICAnKDcsIDUsIDYsIHRydWUpJyxcbiAgICAgICcoNywgNSwgNCwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgYiBpcyBncmVhdGVyIHRoYW4gYSwgYW5kIGMgaXMgZ3JlYXRlclxuICAgIHRoYW4gYi4gSG93ZXZlciwgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaWYgXCJiT2tcIiBpcyB0cnVlLCBiIGRvZXMgbm90IG5lZWQgdG8gYmUgZ3JlYXRlclxuICAgIHRoYW4gYS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnaW5PcmRlckVxdWFsJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgNSwgMTEsIGZhbHNlKScsXG4gICAgICAnKDUsIDcsIDYsIGZhbHNlKScsXG4gICAgICAnKDUsIDUsIDcsIHRydWUpJyxcbiAgICAgICcoNSwgNSwgNywgZmFsc2UpJyxcbiAgICAgICcoMiwgNSwgNCwgZmFsc2UpJyxcbiAgICAgICcoMywgNCwgMywgZmFsc2UpJyxcbiAgICAgICcoMywgNCwgNCwgZmFsc2UpJyxcbiAgICAgICcoMywgNCwgMywgdHJ1ZSknLFxuICAgICAgJygzLCA0LCA0LCB0cnVlKScsXG4gICAgICAnKDEsIDUsIDUsIHRydWUpJyxcbiAgICAgICcoNSwgNSwgNSwgdHJ1ZSknLFxuICAgICAgJygyLCAyLCAxLCB0cnVlKScsXG4gICAgICAnKDksIDIsIDIsIHRydWUpJyxcbiAgICAgICcoMCwgMSwgMCwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgaW4gc3RyaWN0IGluY3JlYXNpbmcgb3JkZXIsXG4gICAgc3VjaCBhcyAyIDUgMTEsIG9yIDUgNiA3LCBidXQgbm90IDYgNSA3IG9yIDUgNSA3LiBIb3dldmVyLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpZlxuICAgIFwiZXF1YWxPa1wiIGlzIHRydWUsIGVxdWFsaXR5IGlzIGFsbG93ZWQsIHN1Y2ggYXMgNSA1IDcgb3IgNSA1IDUuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2xhc3REaWdpdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIzLCAxOSwgMTMpJyxcbiAgICAgICcoMjMsIDE5LCAxMiknLFxuICAgICAgJygyMywgMTksIDMpJyxcbiAgICAgICcoMjMsIDE5LCAzOSknLFxuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDEsIDEsIDIpJyxcbiAgICAgICcoMSwgMiwgMiknLFxuICAgICAgJygxNCwgMjUsIDQzKScsXG4gICAgICAnKDE0LCAyNSwgNDUpJyxcbiAgICAgICcoMjQ4LCAxMDYsIDEwMDIpJyxcbiAgICAgICcoMjQ4LCAxMDYsIDEwMDgpJyxcbiAgICAgICcoMTAsIDExLCAyMCknLFxuICAgICAgJygwLCAxMSwgMCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgdHdvIG9yIG1vcmUgb2YgdGhlbSBoYXZlIHRoZSBzYW1lXG4gICAgcmlnaHRtb3N0IGRpZ2l0LiBUaGUgaW50cyBhcmUgbm9uLW5lZ2F0aXZlLiBOb3RlOiB0aGUgJSBcIm1vZFwiIG9wZXJhdG9yIGNvbXB1dGVzIHRoZVxuICAgIHJlbWFpbmRlciwgZS5nLiAxNyAlIDEwIGlzIDcuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2xlc3NCeTEwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgNywgMTEpJyxcbiAgICAgICcoMSwgNywgMTApJyxcbiAgICAgICcoMTEsIDEsIDcpJyxcbiAgICAgICcoMTAsIDcsIDEpJyxcbiAgICAgICcoLTEwLCAyLCAyKScsXG4gICAgICAnKDIsIDExLCAxMSknLFxuICAgICAgJygzLCAzLCAzMCknLFxuICAgICAgJygzLCAzLCAzKScsXG4gICAgICAnKDEwLCAxLCAxMSknLFxuICAgICAgJygxMCwgMTEsIDEpJyxcbiAgICAgICcoMTAsIDExLCAyKScsXG4gICAgICAnKDMsIDMwLCAzKScsXG4gICAgICAnKDIsIDIsIC04KScsXG4gICAgICAnKDIsIDgsIDEyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIHRocmVlIGludHMsIGEgYiBjLCByZXR1cm4gdHJ1ZSBpZiBvbmUgb2YgdGhlbSBpcyAxMCBvciBtb3JlIGxlc3NcbiAgICB0aGFuIG9uZSBvZiB0aGUgb3RoZXJzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICd3aXRob3V0RG91YmxlcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIsIDMsIHRydWUpJyxcbiAgICAgICcoMywgMywgdHJ1ZSknLFxuICAgICAgJygzLCAzLCBmYWxzZSknLFxuICAgICAgJygyLCAzLCBmYWxzZSknLFxuICAgICAgJyg1LCA0LCB0cnVlKScsXG4gICAgICAnKDUsIDQsIGZhbHNlKScsXG4gICAgICAnKDUsIDUsIHRydWUpJyxcbiAgICAgICcoNSwgNSwgZmFsc2UpJyxcbiAgICAgICcoNiwgNiwgdHJ1ZSknLFxuICAgICAgJyg2LCA2LCBmYWxzZSknLFxuICAgICAgJygxLCA2LCB0cnVlKScsXG4gICAgICAnKDYsIDEsIGZhbHNlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgc3VtIG9mIHR3byA2LXNpZGVkIGRpY2Ugcm9sbHMsIGVhY2ggaW4gdGhlIHJhbmdlIDEuLjYuIEhvd2V2ZXIsXG4gICAgaWYgbm9Eb3VibGVzIGlzIHRydWUsIGlmIHRoZSB0d28gZGljZSBzaG93IHRoZSBzYW1lIHZhbHVlLCBpbmNyZW1lbnQgb25lIGRpZSB0byB0aGUgbmV4dFxuICAgIHZhbHVlLCB3cmFwcGluZyBhcm91bmQgdG8gMSBpZiBpdHMgdmFsdWUgd2FzIDYuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ21heE1vZDUnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyLCAzKScsXG4gICAgICAnKDYsIDIpJyxcbiAgICAgICcoMywgMiknLFxuICAgICAgJyg4LCAxMiknLFxuICAgICAgJyg3LCAxMiknLFxuICAgICAgJygxMSwgNiknLFxuICAgICAgJygyLCA3KScsXG4gICAgICAnKDcsIDcpJyxcbiAgICAgICcoOSwgMSknLFxuICAgICAgJyg5LCAxNCknLFxuICAgICAgJygxLCAyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIHR3byBpbnQgdmFsdWVzLCByZXR1cm4gd2hpY2hldmVyIHZhbHVlIGlzIGxhcmdlci4gSG93ZXZlciBpZiB0aGUgdHdvXG4gICAgdmFsdWVzIGhhdmUgdGhlIHNhbWUgcmVtYWluZGVyIHdoZW4gZGl2aWRlZCBieSA1LCB0aGVuIHRoZSByZXR1cm4gdGhlIHNtYWxsZXIgdmFsdWUuXG4gICAgSG93ZXZlciwgaW4gYWxsIGNhc2VzLCBpZiB0aGUgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUsIHJldHVybiAwLiBOb3RlOiB0aGUgJSBcIm1vZFwiXG4gICAgb3BlcmF0b3IgY29tcHV0ZXMgdGhlIHJlbWFpbmRlciwgZS5nLiA3ICUgNSBpcyAyLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdyZWRUaWNrZXQnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyLCAyLCAyKScsXG4gICAgICAnKDIsIDIsIDEpJyxcbiAgICAgICcoMCwgMCwgMCknLFxuICAgICAgJygyLCAwLCAwKScsXG4gICAgICAnKDEsIDEsIDEpJyxcbiAgICAgICcoMSwgMiwgMSknLFxuICAgICAgJygxLCAyLCAwKScsXG4gICAgICAnKDAsIDIsIDIpJyxcbiAgICAgICcoMSwgMiwgMiknLFxuICAgICAgJygwLCAyLCAwKScsXG4gICAgICAnKDEsIDEsIDIpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91IGhhdmUgYSByZWQgbG90dGVyeSB0aWNrZXQgc2hvd2luZyBpbnRzIGEsIGIsIGFuZCBjLCBlYWNoIG9mIHdoaWNoIGlzIDAsIDEsXG4gICAgb3IgMi4gSWYgdGhleSBhcmUgYWxsIHRoZSB2YWx1ZSAyLCB0aGUgcmVzdWx0IGlzIDEwLiBPdGhlcndpc2UgaWYgdGhleSBhcmUgYWxsIHRoZSBzYW1lLFxuICAgIHRoZSByZXN1bHQgaXMgNS4gT3RoZXJ3aXNlIHNvIGxvbmcgYXMgYm90aCBiIGFuZCBjIGFyZSBkaWZmZXJlbnQgZnJvbSBhLCB0aGUgcmVzdWx0IGlzIDEuXG4gICAgT3RoZXJ3aXNlIHRoZSByZXN1bHQgaXMgMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnZ3JlZW5UaWNrZXQnLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDIsIDIsIDIpJyxcbiAgICAgICcoMSwgMSwgMiknLFxuICAgICAgJygyLCAxLCAxKScsXG4gICAgICAnKDEsIDIsIDEpJyxcbiAgICAgICcoMywgMiwgMSknLFxuICAgICAgJygwLCAwLCAwKScsXG4gICAgICAnKDIsIDAsIDApJyxcbiAgICAgICcoMCwgOSwgMTApJyxcbiAgICAgICcoMCwgMTAsIDApJyxcbiAgICAgICcoOSwgOSwgOSknLFxuICAgICAgJyg5LCAwLCA5KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdSBoYXZlIGEgZ3JlZW4gbG90dGVyeSB0aWNrZXQsIHdpdGggaW50cyBhLCBiLCBhbmQgYyBvbiBpdC4gSWYgdGhlIG51bWJlcnNcbiAgICBhcmUgYWxsIGRpZmZlcmVudCBmcm9tIGVhY2ggb3RoZXIsIHRoZSByZXN1bHQgaXMgMC4gSWYgYWxsIG9mIHRoZSBudW1iZXJzIGFyZSB0aGUgc2FtZSxcbiAgICB0aGUgcmVzdWx0IGlzIDIwLiBJZiB0d28gb2YgdGhlIG51bWJlcnMgYXJlIHRoZSBzYW1lLCB0aGUgcmVzdWx0IGlzIDEwLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdibHVlVGlja2V0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoOSwgMSwgMCknLFxuICAgICAgJyg5LCAyLCAwKScsXG4gICAgICAnKDYsIDEsIDQpJyxcbiAgICAgICcoNiwgMSwgNSknLFxuICAgICAgJygxMCwgMCwgMCknLFxuICAgICAgJygxNSwgMCwgNSknLFxuICAgICAgJyg1LCAxNSwgNSknLFxuICAgICAgJyg0LCAxMSwgMSknLFxuICAgICAgJygxMywgMiwgMyknLFxuICAgICAgJyg4LCA0LCAzKScsXG4gICAgICAnKDgsIDQsIDIpJyxcbiAgICAgICcoOCwgNCwgMSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBZb3UgaGF2ZSBhIGJsdWUgbG90dGVyeSB0aWNrZXQsIHdpdGggaW50cyBhLCBiLCBhbmQgYyBvbiBpdC4gVGhpcyBtYWtlc1xuICAgIHRocmVlIHBhaXJzLCB3aGljaCB3ZSdsbCBjYWxsIGFiLCBiYywgYW5kIGFjLiBDb25zaWRlciB0aGUgc3VtIG9mIHRoZSBudW1iZXJzIGluIGVhY2ggcGFpci5cbiAgICBJZiBhbnkgcGFpciBzdW1zIHRvIGV4YWN0bHkgMTAsIHRoZSByZXN1bHQgaXMgMTAuIE90aGVyd2lzZSBpZiB0aGUgYWIgc3VtIGlzIGV4YWN0bHkgMTBcbiAgICBtb3JlIHRoYW4gZWl0aGVyIGJjIG9yIGFjIHN1bXMsIHRoZSByZXN1bHQgaXMgNS4gT3RoZXJ3aXNlIHRoZSByZXN1bHQgaXMgMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc2hhcmVEaWdpdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEyLCAyMyknLFxuICAgICAgJygxMiwgNDMpJyxcbiAgICAgICcoMTIsIDQ0KScsXG4gICAgICAnKDIzLCAxMiknLFxuICAgICAgJygyMywgMzkpJyxcbiAgICAgICcoMjMsIDE5KScsXG4gICAgICAnKDMwLCA5MCknLFxuICAgICAgJygzMCwgOTEpJyxcbiAgICAgICcoNTUsIDU1KScsXG4gICAgICAnKDU1LCA0NCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0d28gaW50cywgZWFjaCBpbiB0aGUgcmFuZ2UgMTAuLjk5LCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIGRpZ2l0XG4gICAgdGhhdCBhcHBlYXJzIGluIGJvdGggbnVtYmVycywgc3VjaCBhcyB0aGUgMiBpbiAxMiBhbmQgMjMuIChOb3RlOiBkaXZpc2lvbiwgZS5nLiBuLzEwLCBnaXZlc1xuICAgICAgdGhlIGxlZnQgZGlnaXQgd2hpbGUgdGhlICUgXCJtb2RcIiBuJTEwIGdpdmVzIHRoZSByaWdodCBkaWdpdC4pYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3N1bUxpbWl0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgMyknLFxuICAgICAgJyg4LCAzKScsXG4gICAgICAnKDgsIDEpJyxcbiAgICAgICcoMTEsIDM5KScsXG4gICAgICAnKDExLCA5OSknLFxuICAgICAgJygwLCAwKScsXG4gICAgICAnKDk5LCAwKScsXG4gICAgICAnKDk5LCAxKScsXG4gICAgICAnKDEyMywgMSknLFxuICAgICAgJygxLCAxMjMpJyxcbiAgICAgICcoMjMsIDYwKScsXG4gICAgICAnKDIzLCA4MCknLFxuICAgICAgJyg5MDAwLCAxKScsXG4gICAgICAnKDkwMDAwMDAwLCAxKScsXG4gICAgICAnKDkwMDAsIDEwMDApJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBub24tbmVnYXRpdmUgaW50cywgYSBhbmQgYiwgcmV0dXJuIHRoZWlyIHN1bSwgc28gbG9uZyBhcyB0aGUgc3VtIGhhc1xuICAgIHRoZSBzYW1lIG51bWJlciBvZiBkaWdpdHMgYXMgYS4gSWYgdGhlIHN1bSBoYXMgbW9yZSBkaWdpdHMgdGhhbiBhLCBqdXN0IHJldHVybiBhIHdpdGhvdXRcbiAgICBiLiAoTm90ZTogb25lIHdheSB0byBjb21wdXRlIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGEgbm9uLW5lZ2F0aXZlIGludCBuIGlzIHRvIGNvbnZlcnQgaXRcbiAgICAgIHRvIGEgc3RyaW5nIHdpdGggU3RyaW5nLnZhbHVlT2YobikgYW5kIHRoZW4gY2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLilgLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnV2Ugd2FudCB0byBtYWtlIGEgcm93IG9mIGJyaWNrcyB0aGF0IGlzIGdvYWwgaW5jaGVzIGxvbmcuIFdlIGhhdmUgYSBudW1iZXIgb2Ygc21hbGwgYnJpY2tzICgxIGluY2ggZWFjaCkgYW5kIGJpZyBicmlja3MgKDUgaW5jaGVzIGVhY2gpLiBSZXR1cm4gdHJ1ZSBpZiBpdCBpcyBwb3NzaWJsZSB0byBtYWtlIHRoZSBnb2FsIGJ5IGNob29zaW5nIGZyb20gdGhlIGdpdmVuIGJyaWNrcy4gVGhpcyBpcyBhIGxpdHRsZSBoYXJkZXIgdGhhbiBpdCBsb29rcyBhbmQgY2FuIGJlIGRvbmUgd2l0aG91dCBhbnkgbG9vcHMuIFNlZSBhbHNvOiBJbnRyb2R1Y3Rpb24gdG8gTWFrZUJyaWNrcycsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnbWFrZUJyaWNrcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMsIDEsIDgpJyxcbiAgICAgICcoMywgMSwgOSknLFxuICAgICAgJygzLCAyLCAxMCknLFxuICAgICAgJygzLCAyLCA4KScsXG4gICAgICAnKDMsIDIsIDkpJyxcbiAgICAgICcoNiwgMSwgMTEpJyxcbiAgICAgICcoNiwgMCwgMTEpJyxcbiAgICAgICcoMSwgNCwgMTEpJyxcbiAgICAgICcoMCwgMywgMTApJyxcbiAgICAgICcoMSwgNCwgMTIpJyxcbiAgICAgICcoMywgMSwgNyknLFxuICAgICAgJygxLCAxLCA3KScsXG4gICAgICAnKDIsIDEsIDcpJyxcbiAgICAgICcoNywgMSwgMTEpJyxcbiAgICAgICcoNywgMSwgOCknLFxuICAgICAgJyg3LCAxLCAxMyknLFxuICAgICAgJyg0MywgMSwgNDYpJyxcbiAgICAgICcoNDAsIDEsIDQ2KScsXG4gICAgICAnKDQwLCAyLCA0NyknLFxuICAgICAgJyg0MCwgMiwgNTApJyxcbiAgICAgICcoNDAsIDIsIDUyKScsXG4gICAgICAnKDIyLCAyLCAzMyknLFxuICAgICAgJygwLCAyLCAxMCknLFxuICAgICAgJygxMDAwMDAwLCAxMDAwLCAxMDAwMTAwKScsXG4gICAgICAnKDIsIDEwMDAwMDAsIDEwMDAwMyknLFxuICAgICAgJygyMCwgMCwgMTkpJyxcbiAgICAgICcoMjAsIDAsIDIxKScsXG4gICAgICAnKDIwLCA0LCA1MSknLFxuICAgICAgJygyMCwgNCwgMzkpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gMyBpbnQgdmFsdWVzLCBhIGIgYywgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgaWYgb25lIG9mIHRoZSB2YWx1ZXMgaXMgdGhlIHNhbWUgYXMgYW5vdGhlciBvZiB0aGUgdmFsdWVzLCBpdCBkb2VzIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzdW0uJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdsb25lU3VtJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygzLCAyLCAzKScsXG4gICAgICAnKDMsIDMsIDMpJyxcbiAgICAgICcoOSwgMiwgMiknLFxuICAgICAgJygyLCAyLCA5KScsXG4gICAgICAnKDIsIDksIDIpJyxcbiAgICAgICcoMiwgOSwgMyknLFxuICAgICAgJyg0LCAyLCAzKScsXG4gICAgICAnKDEsIDMsIDEpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gMyBpbnQgdmFsdWVzLCBhIGIgYywgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgaWYgb25lIG9mIHRoZSB2YWx1ZXMgaXMgMTMgdGhlbiBpdCBkb2VzIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzdW0gYW5kIHZhbHVlcyB0byBpdHMgcmlnaHQgZG8gbm90IGNvdW50LiBTbyBmb3IgZXhhbXBsZSwgaWYgYiBpcyAxMywgdGhlbiBib3RoIGIgYW5kIGMgZG8gbm90IGNvdW50LicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnbHVja3lTdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDEsIDIsIDEzKScsXG4gICAgICAnKDEsIDEzLCAzKScsXG4gICAgICAnKDEsIDEzLCAxMyknLFxuICAgICAgJyg2LCA1LCAyKScsXG4gICAgICAnKDEzLCAyLCAzKScsXG4gICAgICAnKDEzLCAyLCAxMyknLFxuICAgICAgJygxMywgMTMsIDIpJyxcbiAgICAgICcoOSwgNCwgMTMpJyxcbiAgICAgICcoOCwgMTMsIDIpJyxcbiAgICAgICcoNywgMiwgMSknLFxuICAgICAgJygzLCAzLCAxMyknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiAzIGludCB2YWx1ZXMsIGEgYiBjLCByZXR1cm4gdGhlaXIgc3VtLiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpcyBhIHRlZW4gLS0gaW4gdGhlIHJhbmdlIDEzLi4xOSBpbmNsdXNpdmUgLS0gdGhlbiB0aGF0IHZhbHVlIGNvdW50cyBhcyAwLCBleGNlcHQgMTUgYW5kIDE2IGRvIG5vdCBjb3VudCBhcyBhIHRlZW5zLiBXcml0ZSBhIHNlcGFyYXRlIGhlbHBlciBcInB1YmxpYyBpbnQgZml4VGVlbihpbnQgbikge1widGhhdCB0YWtlcyBpbiBhbiBpbnQgdmFsdWUgYW5kIHJldHVybnMgdGhhdCB2YWx1ZSBmaXhlZCBmb3IgdGhlIHRlZW4gcnVsZS4gSW4gdGhpcyB3YXksIHlvdSBhdm9pZCByZXBlYXRpbmcgdGhlIHRlZW4gY29kZSAzIHRpbWVzIChpLmUuIFwiZGVjb21wb3NpdGlvblwiKS4gRGVmaW5lIHRoZSBoZWxwZXIgYmVsb3cgYW5kIGF0IHRoZSBzYW1lIGluZGVudCBsZXZlbCBhcyB0aGUgbWFpbiBub1RlZW5TdW0oKS4nLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ25vVGVlblN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDIsIDMpJyxcbiAgICAgICcoMiwgMTMsIDEpJyxcbiAgICAgICcoMiwgMSwgMTQpJyxcbiAgICAgICcoMiwgMSwgMTUpJyxcbiAgICAgICcoMiwgMSwgMTYpJyxcbiAgICAgICcoMiwgMSwgMTcpJyxcbiAgICAgICcoMTcsIDEsIDIpJyxcbiAgICAgICcoMiwgMTUsIDIpJyxcbiAgICAgICcoMTYsIDE3LCAxOCknLFxuICAgICAgJygxNywgMTgsIDE5KScsXG4gICAgICAnKDE1LCAxNiwgMSknLFxuICAgICAgJygxNSwgMTUsIDE5KScsXG4gICAgICAnKDE1LCAxOSwgMTYpJyxcbiAgICAgICcoNSwgMTcsIDE4KScsXG4gICAgICAnKDE3LCAxOCwgMTYpJyxcbiAgICAgICcoMTcsIDE5LCAxOCknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdGb3IgdGhpcyBwcm9ibGVtLCB3ZVxcJ2xsIHJvdW5kIGFuIGludCB2YWx1ZSB1cCB0byB0aGUgbmV4dCBtdWx0aXBsZSBvZiAxMCBpZiBpdHMgcmlnaHRtb3N0IGRpZ2l0IGlzIDUgb3IgbW9yZSwgc28gMTUgcm91bmRzIHVwIHRvIDIwLiBBbHRlcm5hdGVseSwgcm91bmQgZG93biB0byB0aGUgcHJldmlvdXMgbXVsdGlwbGUgb2YgMTAgaWYgaXRzIHJpZ2h0bW9zdCBkaWdpdCBpcyBsZXNzIHRoYW4gNSwgc28gMTIgcm91bmRzIGRvd24gdG8gMTAuIEdpdmVuIDMgaW50cywgYSBiIGMsIHJldHVybiB0aGUgc3VtIG9mIHRoZWlyIHJvdW5kZWQgdmFsdWVzLiBUbyBhdm9pZCBjb2RlIHJlcGV0aXRpb24sIHdyaXRlIGEgc2VwYXJhdGUgaGVscGVyIFwicHVibGljIGludCByb3VuZDEwKGludCBudW0pIHtcIiBhbmQgY2FsbCBpdCAzIHRpbWVzLiBXcml0ZSB0aGUgaGVscGVyIGVudGlyZWx5IGJlbG93IGFuZCBhdCB0aGUgc2FtZSBpbmRlbnQgbGV2ZWwgYXMgcm91bmRTdW0oKS4nLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ3JvdW5kU3VtJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMTYsIDE3LCAxOCknLFxuICAgICAgJygxMiwgMTMsIDE0KScsXG4gICAgICAnKDYsIDQsIDQpJyxcbiAgICAgICcoNCwgNiwgNSknLFxuICAgICAgJyg0LCA0LCA2KScsXG4gICAgICAnKDksIDQsIDQpJyxcbiAgICAgICcoMCwgMCwgMSknLFxuICAgICAgJygwLCA5LCAwKScsXG4gICAgICAnKDEwLCAxMCwgMTkpJyxcbiAgICAgICcoMjAsIDMwLCA0MCknLFxuICAgICAgJyg0NSwgMjEsIDMwKScsXG4gICAgICAnKDIzLCAxMSwgMjYpJyxcbiAgICAgICcoMjMsIDI0LCAyNSknLFxuICAgICAgJygyNSwgMjQsIDI1KScsXG4gICAgICAnKDIzLCAyNCwgMjkpJyxcbiAgICAgICcoMTEsIDI0LCAzNiknLFxuICAgICAgJygyNCwgMzYsIDMyKScsXG4gICAgICAnKDE0LCAxMiwgMjYpJyxcbiAgICAgICcoMTIsIDEwLCAyNCknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgb25lIG9mIGIgb3IgYyBpcyBcImNsb3NlXCIgKGRpZmZlcmluZyBmcm9tIGEgYnkgYXQgbW9zdCAxKSwgd2hpbGUgdGhlIG90aGVyIGlzIFwiZmFyXCIsIGRpZmZlcmluZyBmcm9tIGJvdGggb3RoZXIgdmFsdWVzIGJ5IDIgb3IgbW9yZS4gTm90ZTogTWF0aC5hYnMobnVtKSBjb21wdXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdjbG9zZUZhcicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDIsIDEwKScsXG4gICAgICAnKDEsIDIsIDMpJyxcbiAgICAgICcoNCwgMSwgMyknLFxuICAgICAgJyg0LCA1LCAzKScsXG4gICAgICAnKDQsIDMsIDUpJyxcbiAgICAgICcoLTEsIDEwLCAwKScsXG4gICAgICAnKDAsIC0xLCAxMCknLFxuICAgICAgJygxMCwgMTAsIDgpJyxcbiAgICAgICcoMTAsIDgsIDkpJyxcbiAgICAgICcoOCwgOSwgMTApJyxcbiAgICAgICcoOCwgOSwgNyknLFxuICAgICAgJyg4LCA2LCA5KScsXG4gICAgXSxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIDIgaW50IHZhbHVlcyBncmVhdGVyIHRoYW4gMCwgcmV0dXJuIHdoaWNoZXZlciB2YWx1ZSBpcyBuZWFyZXN0IHRvIDIxIHdpdGhvdXQgZ29pbmcgb3Zlci4gUmV0dXJuIDAgaWYgdGhleSBib3RoIGdvIG92ZXIuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdibGFja2phY2snLFxuICAgIGlucHV0czogW1xuICAgICAgJygxOSwgMjEpJyxcbiAgICAgICcoMjEsIDE5KScsXG4gICAgICAnKDE5LCAyMiknLFxuICAgICAgJygyMiwgMTkpJyxcbiAgICAgICcoMjIsIDUwKScsXG4gICAgICAnKDIyLCAyMiknLFxuICAgICAgJygzMywgMSknLFxuICAgICAgJygxLCAyKScsXG4gICAgICAnKDM0LCAzMyknLFxuICAgICAgJygxNywgMTkpJyxcbiAgICAgICcoMTgsIDE3KScsXG4gICAgICAnKDE2LCAyMyknLFxuICAgICAgJygzLCA0KScsXG4gICAgICAnKDMsIDIpJyxcbiAgICAgICcoMjEsIDIwKScsXG4gICAgXSxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIHRocmVlIGludHMsIGEgYiBjLCBvbmUgb2YgdGhlbSBpcyBzbWFsbCwgb25lIGlzIG1lZGl1bSBhbmQgb25lIGlzIGxhcmdlLiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdGhyZWUgdmFsdWVzIGFyZSBldmVubHkgc3BhY2VkLCBzbyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNtYWxsIGFuZCBtZWRpdW0gaXMgdGhlIHNhbWUgYXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBtZWRpdW0gYW5kIGxhcmdlLicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnZXZlbmx5U3BhY2VkJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgNCwgNiknLFxuICAgICAgJyg0LCA2LCAyKScsXG4gICAgICAnKDQsIDYsIDMpJyxcbiAgICAgICcoNiwgMiwgNCknLFxuICAgICAgJyg2LCAyLCA4KScsXG4gICAgICAnKDIsIDIsIDIpJyxcbiAgICAgICcoMiwgMiwgMyknLFxuICAgICAgJyg5LCAxMCwgMTEpJyxcbiAgICAgICcoMTAsIDksIDExKScsXG4gICAgICAnKDEwLCA5LCA5KScsXG4gICAgICAnKDIsIDQsIDQpJyxcbiAgICAgICcoMiwgMiwgNCknLFxuICAgICAgJygzLCA2LCAxMiknLFxuICAgICAgJygxMiwgMywgNiknLFxuICAgIF0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlIHdhbnQgbWFrZSBhIHBhY2thZ2Ugb2YgZ29hbCBraWxvcyBvZiBjaG9jb2xhdGUuIFdlIGhhdmUgc21hbGwgYmFycyAoMSBraWxvIGVhY2gpIGFuZCBiaWcgYmFycyAoNSBraWxvcyBlYWNoKS4gUmV0dXJuIHRoZSBudW1iZXIgb2Ygc21hbGwgYmFycyB0byB1c2UsIGFzc3VtaW5nIHdlIGFsd2F5cyB1c2UgYmlnIGJhcnMgYmVmb3JlIHNtYWxsIGJhcnMuIFJldHVybiAtMSBpZiBpdCBjYW5cXCd0IGJlIGRvbmUuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdtYWtlQ2hvY29sYXRlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNCwgMSwgOSknLFxuICAgICAgJyg0LCAxLCAxMCknLFxuICAgICAgJyg0LCAxLCA3KScsXG4gICAgICAnKDYsIDIsIDcpJyxcbiAgICAgICcoNCwgMSwgNSknLFxuICAgICAgJyg0LCAxLCA0KScsXG4gICAgICAnKDUsIDQsIDkpJyxcbiAgICAgICcoOSwgMywgMTgpJyxcbiAgICAgICcoMywgMSwgOSknLFxuICAgICAgJygxLCAyLCA3KScsXG4gICAgICAnKDEsIDIsIDYpJyxcbiAgICAgICcoMSwgMiwgNSknLFxuICAgICAgJyg2LCAxLCAxMCknLFxuICAgICAgJyg2LCAxLCAxMSknLFxuICAgICAgJyg2LCAxLCAxMiknLFxuICAgICAgJyg2LCAxLCAxMyknLFxuICAgICAgJyg2LCAyLCAxMCknLFxuICAgICAgJyg2LCAyLCAxMSknLFxuICAgICAgJyg2LCAyLCAxMiknLFxuICAgICAgJyg2MCwgMTAwLCA1NTApJyxcbiAgICAgICcoMTAwMCwgMTAwMDAwMCwgNTAwMDAwNiknLFxuICAgICAgJyg3LCAxLCAxMiknLFxuICAgICAgJyg3LCAxLCAxMyknLFxuICAgICAgJyg3LCAyLCAxMyknLFxuICAgIF0gfVxuICBdO1xuIiwiLyoqIC0tLSBTb2x1dGlvbnMgLS0tICoqL1xuXG5sZXQgc29sdXRpb25zID0ge307XG5zb2x1dGlvbnMuY2lnYXJQYXJ0eSA9IGZ1bmN0aW9uIGNpZ2FyUGFydHkoY2lnYXJzLCBpc1dlZWtlbmQpIHtcbiAgICBpZiAoaXNXZWVrZW5kKSB7XG4gICAgICByZXR1cm4gY2lnYXJzID49IDQwO1xuICAgIH1cbiAgICByZXR1cm4gY2lnYXJzID49IDQwICYmIGNpZ2FycyA8PSA2MDtcbiAgfTtcblxuICBcbiAgc29sdXRpb25zLmRhdGVGYXNoaW9uID0gZnVuY3Rpb24gZGF0ZUZhc2hpb24oeW91LCBkYXRlKSB7XG4gICAgaWYgKHlvdSA8PSAyIHx8IGRhdGUgPD0gMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBcbiAgICBpZiAoeW91ID49IDggfHwgZGF0ZSA+PSA4KSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gIFxuICAgIHJldHVybiAxO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnNxdWlycmVsUGxheSA9IGZ1bmN0aW9uIHNxdWlycmVsUGxheSh0ZW1wLCBpc1N1bW1lcikge1xuICAgIGlmIChpc1N1bW1lciAmJiB0ZW1wID49IDYwICYmIHRlbXAgPD0gMTAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIGlmICghaXNTdW1tZXIgJiYgdGVtcCA+PSA2MCAmJiB0ZW1wIDw9IDkwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5jYXVnaHRTcGVlZGluZyA9IGZ1bmN0aW9uIGNhdWdodFNwZWVkaW5nKHNwZWVkLCBpc0JpcnRoZGF5KSB7XG4gICAgaWYgKGlzQmlydGhkYXkpIHtcbiAgICAgIGlmIChzcGVlZCA8PSA2NSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPj0gNjYgJiYgc3BlZWQgPD0gODUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID49IDg2KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgaWYgKHNwZWVkIDw9IDYwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHNwZWVkID49IDYxICYmIHNwZWVkIDw9IDgwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICB9O1xuICBcbiAgc29sdXRpb25zLnNvcnRhU3VtID0gZnVuY3Rpb24gc29ydGFTdW0oYSwgYikge1xuICAgIGNvbnN0IHJlcyA9IGEgKyBiO1xuICAgIGlmIChyZXMgPj0gMTAgJiYgcmVzIDw9IDE5KSB7XG4gICAgICByZXR1cm4gMjA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuYWxhcm1DbG9jayA9IGZ1bmN0aW9uIGFsYXJtQ2xvY2soZGF5LCB2YWNhdGlvbikge1xuICAgIGlmICh2YWNhdGlvbikge1xuICAgICAgaWYgKGRheSA+PSAxICYmIGRheSA8PSA1KSB7XG4gICAgICAgIHJldHVybiAnMTA6MDAnO1xuICAgICAgfSBlbHNlIHJldHVybiAnb2ZmJztcbiAgICB9XG4gIFxuICAgIGlmIChkYXkgPj0gMSAmJiBkYXkgPD0gNSkge1xuICAgICAgcmV0dXJuICc3OjAwJztcbiAgICB9IGVsc2UgcmV0dXJuICcxMDowMCc7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubG92ZTYgPSBmdW5jdGlvbiBsb3ZlNihhLCBiKSB7XG4gICAgaWYgKGEgPT0gNiB8fCBiID09IDYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgaWYgKGEgKyBiID09IDYgfHwgTWF0aC5hYnMoYSAtIGIpID09IDYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmluMVRvMTAgPSBmdW5jdGlvbiBpbjFUbzEwKG4sIG91dHNpZGVNb2RlKSB7XG4gICAgaWYgKG91dHNpZGVNb2RlKSB7XG4gICAgICByZXR1cm4gKG4gPD0gMSB8fCBuID49IDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIChuID49IDEgJiYgbiA8PSAxMCk7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuc3BlY2lhbEVsZXZlbiA9IGZ1bmN0aW9uIHNwZWNpYWxFbGV2ZW4obikge1xuICAgIGlmIChuICUgMTEgPT0gMCB8fCBuICUgMTEgPT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5tb3JlMjAgPSBmdW5jdGlvbiBtb3JlMjAobikge1xuICAgIHJldHVybiAobiAlIDIwID09IDEgfHwgbiAlIDIwID09IDIpO1xuICB9O1xuICBcbiAgc29sdXRpb25zLm9sZDM1ID0gZnVuY3Rpb24gb2xkMzUobikge1xuICAgIHJldHVybiAobiAlIDMgPT0gMCkgIT0gKG4gJSA1ID09IDApO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxlc3MyMCA9IGZ1bmN0aW9uIGxlc3MyMChuKSB7XG4gICAgcmV0dXJuIChuICUgMjAgPT0gMTggfHwgbiAlIDIwID09IDE5KTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5uZWFyVGVuID0gZnVuY3Rpb24gbmVhclRlbihudW0pIHtcbiAgICByZXR1cm4gKG51bSAlIDEwIDw9IDIgfHwgbnVtICUgMTAgPj0gOCk7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMudGVlblN1bSA9IGZ1bmN0aW9uIHRlZW5TdW0oYSwgYikge1xuICAgIGlmICgoYSA+PSAxMyAmJiBhIDw9IDE5KSB8fCAoYiA+PSAxMyAmJiBiIDw9IDE5KSkge1xuICAgICAgcmV0dXJuIDE5O1xuICAgIH1cbiAgICByZXR1cm4gYSArIGI7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuYW5zd2VyQ2VsbCA9IGZ1bmN0aW9uIGFuc3dlckNlbGwoaXNNb3JuaW5nLCBpc01vbSwgaXNBc2xlZXApIHtcbiAgICBpZiAoaXNBc2xlZXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIGlmIChpc01vcm5pbmcgJiYgIWlzTW9tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy50ZWFQYXJ0eSA9IGZ1bmN0aW9uIHRlYVBhcnR5KHRlYSwgY2FuZHkpIHtcbiAgICBpZiAodGVhID49IDUgJiYgY2FuZHkgPj0gNSkge1xuICAgICAgaWYgKHRlYSA+PSBjYW5keSAqIDIgfHwgY2FuZHkgPj0gdGVhICogMikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5maXp6U3RyaW5nID0gZnVuY3Rpb24gZml6elN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyWzBdID09ICdmJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09ICdiJykge1xuICAgICAgcmV0dXJuICdGaXp6QnV6eic7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT0gJ2YnKSB7XG4gICAgICByZXR1cm4gJ0ZpenonO1xuICAgIH0gZWxzZSBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PSAnYicpIHtcbiAgICAgIHJldHVybiAnQnV6eic7XG4gICAgfSBlbHNlIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICBcbiAgc29sdXRpb25zLmZpenpTdHJpbmcyID0gZnVuY3Rpb24gZml6elN0cmluZzIobikge1xuICAgIGlmIChuICUgMyA9PSAwICYmIG4gJSA1ID09IDApIHtcbiAgICAgIHJldHVybiAnRml6ekJ1enohJztcbiAgICB9IGVsc2UgaWYgKG4gJSAzID09IDApIHtcbiAgICAgIHJldHVybiAnRml6eiEnO1xuICAgIH0gZWxzZSBpZiAobiAlIDUgPT0gMCkge1xuICAgICAgcmV0dXJuICdCdXp6ISc7XG4gICAgfVxuICAgIHJldHVybiBgJHtuLnRvU3RyaW5nKCl9IWA7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMudHdvQXNPbmUgPSBmdW5jdGlvbiB0d29Bc09uZShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGEgKyBiID09IGMgfHwgYSArIGMgPT0gYiB8fCBiICsgYyA9PSBhO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmluT3JkZXIgPSBmdW5jdGlvbiBpbk9yZGVyKGEsIGIsIGMsIGJPaykge1xuICAgIGlmIChiT2spIHtcbiAgICAgIHJldHVybiBjID4gYjtcbiAgICB9XG4gICAgcmV0dXJuIGIgPiBhICYmIGMgPiBiO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmluT3JkZXJFcXVhbCA9IGZ1bmN0aW9uIGluT3JkZXJFcXVhbChhLCBiLCBjLCBlcXVhbE9rKSB7XG4gICAgaWYgKGVxdWFsT2spIHtcbiAgICAgIHJldHVybiBhIDw9IGIgJiYgYiA8PSBjO1xuICAgIH1cbiAgICByZXR1cm4gYSA8IGIgJiYgYiA8IGM7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubGFzdERpZ2l0ID0gZnVuY3Rpb24gbGFzdERpZ2l0KGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYSAlIDEwID09IGIgJSAxMCB8fCBiICUgMTAgPT0gYyAlIDEwIHx8IGEgJSAxMCA9PSBjO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxlc3NCeTEwID0gZnVuY3Rpb24gbGVzc0J5MTAoYSwgYiwgYykge1xuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPj0gMTAgfHwgTWF0aC5hYnMoYiAtIGMpID49IDEwIHx8IE1hdGguYWJzKGMgLSBhKSA+PSAxMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy53aXRob3V0RG91YmxlcyA9IGZ1bmN0aW9uIHdpdGhvdXREb3VibGVzKGRpZTEsIGRpZTIsIG5vRG91Ymxlcykge1xuICAgIGlmIChub0RvdWJsZXMpIHtcbiAgICAgIGlmIChkaWUxID09IGRpZTIpIHtcbiAgICAgICAgaWYgKGRpZTEgPT0gNiB8fCBkaWUyID09IDYpIHtcbiAgICAgICAgICBkaWUxID0gMTtcbiAgICAgICAgICByZXR1cm4gZGllMSArIGRpZTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZTEgKyBkaWUyICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZTEgKyBkaWUyO1xuICB9O1xuICBcbiAgc29sdXRpb25zLm1heE1vZDUgPSBmdW5jdGlvbiBtYXhNb2Q1KGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIFxuICAgIGlmIChhICUgNSA9PSBiICUgNSkge1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMucmVkVGlja2V0ID0gZnVuY3Rpb24gcmVkVGlja2V0KGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PSAyICYmIGIgPT0gMiAmJiBjID09IDIpIHtcbiAgICAgIHJldHVybiAxMDtcbiAgICB9XG4gIFxuICAgIGlmIChhID09IGIgJiYgYiA9PSBjICYmIGEgPT0gYykge1xuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICBcbiAgICBpZiAoYiAhPSBhICYmIGMgIT0gYSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICBcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5ncmVlblRpY2tldCA9IGZ1bmN0aW9uIGdyZWVuVGlja2V0KGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PSBiICYmIGIgPT0gYykge1xuICAgICAgcmV0dXJuIDIwO1xuICAgIH1cbiAgXG4gICAgaWYgKGEgPT0gYiB8fCBiID09IGMgfHwgYyA9PSBhKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfVxuICBcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5ibHVlVGlja2V0ID0gZnVuY3Rpb24gYmx1ZVRpY2tldChhLCBiLCBjKSB7XG4gICAgaWYgKGEgKyBiID09IDEwIHx8IGIgKyBjID09IDEwIHx8IGEgKyBjID09IDEwKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfVxuICBcbiAgICBpZiAoYSArIGIgPT0gYiArIGMgKyAxMCB8fCBhICsgYiA9PSBjICsgYSArIDEwKSB7XG4gICAgICByZXR1cm4gNTtcbiAgICB9XG4gIFxuICAgIHJldHVybiAwO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnNoYXJlRGlnaXQgPSBmdW5jdGlvbiBzaGFyZURpZ2l0KGEsIGIpIHtcbiAgICBjb25zdCBhRmlyc3QgPSBNYXRoLmZsb29yKGEgLyAxMCk7XG4gICAgY29uc3QgYUxhc3QgPSBhICUgMTA7XG4gIFxuICAgIGlmIChhRmlyc3QgPT0gTWF0aC5mbG9vcihiIC8gMTApIHx8IGFGaXJzdCA9PSBiICUgMTApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgaWYgKGFMYXN0ID09IE1hdGguZmxvb3IoYiAvIDEwKSB8fCBhTGFzdCA9PSBiICUgMTApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnN1bUxpbWl0ID0gZnVuY3Rpb24gc3VtTGltaXQoYSwgYikge1xuICAgIGNvbnN0IGFMZW4gPSBNYXRoLmFicyhhKS50b1N0cmluZygpLmxlbmd0aDtcbiAgICBjb25zdCBiTGVuID0gTWF0aC5hYnMoYikudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgY29uc3QgcmVzTGVuID0gTWF0aC5hYnMocmVzKS50b1N0cmluZygpLmxlbmd0aDtcbiAgXG4gICAgaWYgKHJlc0xlbiA9PSBhTGVuKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAocmVzTGVuID49IGFMZW4pIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIExvZ2ljLTJcbiAgXG4gIHNvbHV0aW9ucy5tYWtlQnJpY2tzID0gZnVuY3Rpb24gbWFrZUJyaWNrcyhzbWFsbCwgYmlnLCBnb2FsKSB7XG4gICAgICAvLyBub3QgZW5vdWdoIGJyaWNrc1xuICAgIGlmIChnb2FsID4gYmlnICogNSArIHNtYWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBcbiAgICAgIC8vIG5vdCBlbm91Z2ggc21hbGwgYnJpY2tzXG4gICAgaWYgKGdvYWwgJSA1ID4gc21hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxvbmVTdW0gPSBmdW5jdGlvbiBsb25lU3VtKGEsIGIsIGMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBpZiAoYSAhPSBiICYmIGEgIT0gYykge1xuICAgICAgc3VtICs9IGE7XG4gICAgfVxuICBcbiAgICBpZiAoYiAhPSBjICYmIGIgIT0gYSkge1xuICAgICAgc3VtICs9IGI7XG4gICAgfVxuICBcbiAgICBpZiAoYyAhPSBhICYmIGMgIT0gYikge1xuICAgICAgc3VtICs9IGM7XG4gICAgfVxuICBcbiAgICByZXR1cm4gc3VtO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmx1Y2t5U3VtID0gZnVuY3Rpb24gbHVja3lTdW0oYSwgYiwgYykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGNvbnN0IGFyciA9IFthLCBiLCBjXTtcbiAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldICE9IDEzKSB7XG4gICAgICAgIHN1bSArPSBhcnJbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9O1xuICBcbiAgXG4gIC8vIFRPRE86IG1ha2UgaXQgd29yayBmb3IgdHdvIGZ1bmNzXG4gIHNvbHV0aW9ucy5ub1RlZW5TdW0gPSBmdW5jdGlvbiBub1RlZW5TdW0oYSwgYiwgYykge1xuICAgIGNvbnN0IGZpeFRlZW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgaWYgKG4gPj0gMTMgJiYgbiA8PSAxOSAmJiBuICE9IDE1ICYmIG4gIT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICByZXR1cm4gZml4VGVlbihhKSArIGZpeFRlZW4oYikgKyBmaXhUZWVuKGMpO1xuICB9O1xuICBcbiAgXG4gIHNvbHV0aW9ucy5yb3VuZFN1bSA9IGZ1bmN0aW9uIHJvdW5kU3VtKGEsIGIsIGMpIHtcbiAgICBjb25zdCByb3VuZDEwID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtIC8gMTApICogMTA7XG4gICAgfTtcbiAgICByZXR1cm4gcm91bmQxMChhKSArIHJvdW5kMTAoYikgKyByb3VuZDEwKGMpO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmNsb3NlRmFyID0gZnVuY3Rpb24gY2xvc2VGYXIoYSwgYiwgYykge1xuICAgIGNvbnN0IGZhciA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gKE1hdGguYWJzKHggLSB5KSA+PSAyKTtcbiAgICB9O1xuICBcbiAgICBjb25zdCBjbG9zZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDw9IDE7XG4gICAgfTtcbiAgXG4gICAgaWYgKGNsb3NlKGEsIGIpICYmIGZhcihiLCBjKSAmJiBmYXIoYSwgYykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2xvc2UoYSwgYykgJiYgZmFyKGIsIGMpICYmIGZhcihhLCBiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICBcbiAgc29sdXRpb25zLmJsYWNramFjayA9IGZ1bmN0aW9uIGJsYWNramFjayhhLCBiKSB7XG4gICAgaWYgKGEgPiAyMSAmJiBiID4gMjEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgXG4gICAgY29uc3QgYmlnID0gTWF0aC5tYXgoYSwgYik7XG4gICAgY29uc3Qgc21hbGwgPSBNYXRoLm1pbihhLCBiKTtcbiAgXG4gICAgaWYgKGJpZyA8PSAyMSkge1xuICAgICAgcmV0dXJuIGJpZztcbiAgICB9IGVsc2UgaWYgKHNtYWxsIDw9IDIxKSB7XG4gICAgICByZXR1cm4gc21hbGw7XG4gICAgfVxuICB9O1xuICBcbiAgc29sdXRpb25zLmV2ZW5seVNwYWNlZCA9IGZ1bmN0aW9uIGV2ZW5seVNwYWNlZChhLCBiLCBjKSB7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoYSwgYiwgYyk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oYSwgYiwgYyk7XG4gICAgY29uc3QgbWlkID0gYSArIGIgKyBjIC0gbWF4IC0gbWluO1xuICBcbiAgICByZXR1cm4gbWF4IC0gbWlkID09IG1pZCAtIG1pbjtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5tYWtlQ2hvY29sYXRlID0gZnVuY3Rpb24gbWFrZUNob2NvbGF0ZShzbWFsbCwgYmlnLCBnb2FsKSB7XG4gICAgICAvLyBub3QgZW5vdWdoXG4gICAgaWYgKHNtYWxsICsgYmlnICogNSA8IGdvYWwpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGJpZ3NOZWVkZWQgPSBNYXRoLmZsb29yKGdvYWwgLyA1KTtcbiAgXG4gICAgY29uc3QgYmlnc1VzZWQgPSBNYXRoLm1pbihiaWcsIGJpZ3NOZWVkZWQpO1xuICAgICAvLyBob3cgbWFueSBsZWZ0b3ZlclxuICAgIGNvbnN0IHNtYWxsc05lZWRlZCA9IGdvYWwgLSBiaWdzVXNlZCAqIDU7XG4gIFxuICAgIHJldHVybiBzbWFsbHNOZWVkZWQ7XG4gIH07XG4gIFxuICBcbiAgICAvLyB7XG4gICAgLy8gICB0aXRsZTogJ0FQLTEnLFxuICAgIC8vICAgbmFtZTogJ3Njb3Jlc0luY3JlYXNpbmcnLFxuICAgIC8vICAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzY29yZXMsIHJldHVybiB0cnVlIGlmIGVhY2ggc2NvcmUgaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgYmVmb3JlLiBUaGUgYXJyYXkgd2lsbCBiZSBsZW5ndGggMiBvciBtb3JlLicsXG4gICAgLy8gICBpbnB1dHM6IFtcbiAgICAvLyAgICAgJyhbMSwgMywgNF0pJyxcbiAgICAvLyAgICAgJyhbMSwgMywgMl0pJyxcbiAgICAvLyAgICAgJyhbMSwgMSwgNF0pJyxcbiAgICAvLyAgICAgJyhbMSwgMSwgMiwgNCwgNCwgN10pJyxcbiAgICAvLyAgICAgJyhbMSwgMSwgMiwgNCwgMywgN10pJyxcbiAgICAvLyAgICAgJyhbLTUsIDQsIDExXSknLFxuICAgIC8vICAgXSxcbiAgICAvLyB9LFxuICAgIC8vIHtcbiAgICAvLyAgIHRpdGxlOiAnQVAtMScsXG4gICAgLy8gICBuYW1lOiAnc2NvcmVzMTAwJyxcbiAgICAvLyAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc2NvcmVzLCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgc2NvcmVzIG9mIDEwMCBuZXh0IHRvIGVhY2ggb3RoZXIgaW4gdGhlIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMi4nLFxuICAgIC8vICAgaW5wdXRzOiBbXG4gICAgLy8gICAgICcoWzEsIDEwMCwgMTAwXSknLFxuICAgIC8vICAgICAnKFsxLCAxMDAsIDk5LCAxMDBdKScsXG4gICAgLy8gICAgICcoWzEwMCwgMSwgMTAwLCAxMDBdKScsXG4gICAgLy8gICAgICcoWzEwMCwgMSwgMTAwLCAxXSknLFxuICAgIC8vICAgICAnKFsxLCAyLCAzLCA0LCA1XSknLFxuICAgIC8vICAgICAnKFsxLCAyLCAxMDAsIDQsIDVdKScsXG4gICAgLy8gICBdLFxuICAgIC8vIH0sXG5cbm1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIi8qKiAtLS0gc29sdXRpb25zIC0tLSAqKi9cblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuXG5zb2x1dGlvbnMubWFwQnVsbHkgPSBmdW5jdGlvbiBtYXBCdWxseShzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImFcIikpIHtcbiAgICBzb21lTWFwLnNldChcImJcIiwgc29tZU1hcC5nZXQoXCJhXCIpKTtcbiAgICBzb21lTWFwLnNldChcImFcIiwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy5tYXBTaGFyZSA9IGZ1bmN0aW9uIG1hcFNoYXJlKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiYlwiLCBzb21lTWFwLmdldChcImFcIikpO1xuICB9XG4gIHNvbWVNYXAuZGVsZXRlKFwiY1wiKTtcbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy5tYXBBQiA9IGZ1bmN0aW9uIG1hcEFCKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBsZXQgY29tYmluZWRTdHJpbmcgPSBzb21lTWFwLmdldChcImFcIikgKyBzb21lTWFwLmdldChcImJcIik7XG4gICAgc29tZU1hcC5zZXQoXCJhYlwiLCBjb21iaW5lZFN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy50b3BwaW5nMSA9IGZ1bmN0aW9uIHRvcHBpbmcxKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiaWNlIGNyZWFtXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJpY2UgY3JlYW1cIiwgXCJjaGVycnlcIik7XG4gIH1cbiAgc29tZU1hcC5zZXQoXCJicmVhZFwiLCBcImJ1dHRlclwiKTtcbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy50b3BwaW5nMiA9IGZ1bmN0aW9uIHRvcHBpbmcyKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiaWNlIGNyZWFtXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJ5b2d1cnRcIiwgc29tZU1hcC5nZXQoXCJpY2UgY3JlYW1cIikpO1xuICB9XG4gIGlmIChzb21lTWFwLmhhcyhcInNwaW5hY2hcIikpIHtcbiAgICBzb21lTWFwLnNldChcInNwaW5hY2hcIiwgXCJudXRzXCIpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMudG9wcGluZzMgPSBmdW5jdGlvbiB0b3BwaW5nMyhzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcInBvdGF0b1wiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiZnJpZXNcIiwgc29tZU1hcC5nZXQoXCJwb3RhdG9cIikpO1xuICB9XG4gIGlmIChzb21lTWFwLmhhcyhcInNhbGFkXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJzcGluYWNoXCIsIHNvbWVNYXAuZ2V0KFwic2FsYWRcIikpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwQUIyID0gZnVuY3Rpb24gbWFwQUIyKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBpZiAoc29tZU1hcC5nZXQoXCJhXCIpID09PSBzb21lTWFwLmdldChcImJcIikpIHtcbiAgICAgIHNvbWVNYXAuZGVsZXRlKFwiYVwiKTtcbiAgICAgIHNvbWVNYXAuZGVsZXRlKFwiYlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy5tYXBBQjMgPSBmdW5jdGlvbiBtYXBBQjMoc29tZU1hcCkge1xuICBpZiAoc29tZU1hcC5oYXMoXCJhXCIpICYmICFzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBzb21lTWFwLnNldChcImJcIiwgc29tZU1hcC5nZXQoXCJhXCIpKTtcbiAgfVxuICBlbHNlIGlmICghc29tZU1hcC5oYXMoXCJhXCIpICYmIHNvbWVNYXAuaGFzKFwiYlwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiYVwiLCBzb21lTWFwLmdldChcImJcIikpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwQUI0ID0gZnVuY3Rpb24gbWFwQUI0KHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBhTGVuZ3RoID0gc29tZU1hcC5nZXQoXCJhXCIpLmxlbmd0aDtcbiAgICBiTGVuZ3RoID0gc29tZU1hcC5nZXQoXCJiXCIpLmxlbmd0aDtcblxuICAgIGlmIChhTGVuZ3RoID4gYkxlbmd0aCkge1xuICAgICAgc29tZU1hcC5zZXQoXCJjXCIsIHNvbWVNYXAuZ2V0KFwiYVwiKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJMZW5ndGggPiBhTGVuZ3RoKSB7XG4gICAgICBzb21lTWFwLnNldChcImNcIiwgc29tZU1hcC5nZXQoXCJiXCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzb21lTWFwLnNldChcImFcIiwgXCJcIik7XG4gICAgICBzb21lTWFwLnNldChcImJcIiwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG4gbW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7IiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhbiBpbnRlZ2VyLCBuLCByZXR1cm4gdGhlIHN1bSBvZiB0aGUgcG9zaXRpdmUgaW50ZWdlcnMgbiArIChuLTIpICsgKG4tNCkgKyAuLi4gICAgTm90ZTogWW91ciBzb2x1dGlvbiBtdXN0IGJlIHJlY3Vyc2l2ZS4gSW4gb3RoZXIgd29yZHMsIHRoZXJlIGNhbiBiZSBubyBmb3Igb3Igd2hpbGUgbG9vcHMgaW4geW91ciBzb2x1dGlvbi4nLFxuICAgIHRpdGxlOiAnUXVpelF1ZXN0aW9ucycsXG4gICAgbmFtZTogJ3N1bURvd25CeTInLFxuICBpbnB1dHM6IFtcbiAgXCIoNylcIixcbiAgXCIoOClcIixcbiAgXCIoMClcIixcbiAgXCIoMSlcIixcbiAgXCIoLTEpXCIsXG4gIFwiKDEwKVwiLFxuICBcIig1KVwiLFxuICBcIigtNSlcIixcbiAgXCIoNTApXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCJcbl0gfSxcbiAgeyBcbiAgICB0aXRsZTogJ1F1aXpRdWVzdGlvbnMnLFxuICAgIG5hbWU6ICdtYWtlczgnLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gMiBpbnRzLCBhIGFuZCBiLCByZXR1cm4gdHJ1ZSBpZiBvbmUgaWYgdGhlbSBpcyA4IG9yIGlmIHRoZWlyIHN1bSBpcyA4LicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDUsIDgpJyxcbiAgICAgICcoMywgOCknLFxuICAgICAgJygzLCA0KScsXG4gICAgICAnKDQsIDQpJyxcbiAgICAgICcoNSwgMiknLFxuICAgICAgJyg1LCAzKScsXG4gICAgICAnKDgsIDcpJyxcbiAgICAgICcoOCwgOCknLFxuICAgICAgJygtMTYsIDI0KScsXG4gICAgICAnKDksIDEpJyxcbiAgICBdLCBcbiAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJ1F1aXpRdWVzdGlvbnMnLFxuICAgICAgbmFtZTogJ2NvdW50T2RkcycsXG4gICAgICBpbnB1dHM6IFtcbiAgICAgICAgXCIoWzIsIDEsIDIsIDMsIDRdKVwiLFxuICAgICAgICBcIihbMiwgMiwgMF0pXCIsXG4gICAgICAgIFwiKFsxLCAzLCA1XSlcIixcbiAgICAgICAgXCIoW10pXCIsXG4gICAgICAgIFwiKFsxMSwgOSwgMCwgMV0pXCIsXG4gICAgICAgIFwiKFsyLCAxMSwgOSwgMF0pXCIsXG4gICAgICAgIFwiKFsyXSlcIixcbiAgICAgICAgXCIoWzIsIDUsIDEyXSlcIixcbiAgICAgIF0sXG4gICAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgbnVtYmVyIG9mIG9kZCBpbnRlZ2VycyBpbiB0aGUgZ2l2ZW4gYXJyYXkuIE5vdGU6IHRoZSAlIFwibW9kXCJcbiAgICAgIG9wZXJhdG9yIGNvbXB1dGVzIHRoZSByZW1haW5kZXIsIGUuZy4gNSAlIDIgaXMgMS5gXG4gICAgfSxcbiAgICB7IHF1ZXN0aW9uOiAnVGhlIGZpYm9uYWNjaSBzZXF1ZW5jZSBpcyBhIGZhbW91cyBiaXQgb2YgbWF0aGVtYXRpY3MsIGFuZCBpdCBoYXBwZW5zIHRvIGhhdmUgYSByZWN1cnNpdmUgZGVmaW5pdGlvbi4gVGhlIGZpcnN0IHR3byB2YWx1ZXMgaW4gdGhlIHNlcXVlbmNlIGFyZSAwIGFuZCAxIChlc3NlbnRpYWxseSAyIGJhc2UgY2FzZXMpLiBFYWNoIHN1YnNlcXVlbnQgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgcHJldmlvdXMgdHdvIHZhbHVlcywgc28gdGhlIHdob2xlIHNlcXVlbmNlIGlzOiAwLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjEgYW5kIHNvIG9uLiBEZWZpbmUgYSByZWN1cnNpdmUgZmlib25hY2NpKG4pIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIG50aCBmaWJvbmFjY2kgbnVtYmVyLCB3aXRoIG49MCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS4nLFxuICAgICAgdGl0bGU6ICdRdWl6UXVlc3Rpb25zJyxcbiAgICAgIG5hbWU6ICdmaWInLFxuICAgICAgaW5wdXRzOiBbXG4gICAgICBcIigwKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIigzKVwiLFxuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDUpXCIsXG4gICAgICBcIig2KVwiLFxuICAgICAgXCIoNylcIlxuICAgXSB9LFxuXTtcbiIsIi8qKiAtLS0gc29sdXRpb25zIC0tLSAqKi9cblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuXG5zb2x1dGlvbnMuc3VtRG93bkJ5MiA9IGZ1bmN0aW9uIHN1bURvd25CeTIobikge1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG4gPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuICsgdGhpcy5zdW1Eb3duQnkyKG4tMik7XG4gICAgfVxuIH1cbiBcbiBcbnNvbHV0aW9ucy5tYWtlczggPSBmdW5jdGlvbiBtYWtlczgoYSwgYikge1xuICByZXR1cm4gKChhID09IDggfHwgYiA9PSA4KSB8fCAoYSArIGIgPT0gOCkpO1xufTtcbiBcbnNvbHV0aW9ucy5jb3VudE9kZHMgPSBmdW5jdGlvbiBjb3VudE9kZHMobnVtcykge1xuICAgbGV0IGNvdW50ID0gMDtcbiBcbiAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgIGlmIChudW1zW2ldJTIgPT09IDEpe1xuICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICB9XG4gICAgIH1cbiAgICAgcmV0dXJuIGNvdW50O1xuIH1cbiBcbiBzb2x1dGlvbnMuZmliID0gZnVuY3Rpb24gZmliKG4pIHtcbiAgIGlmIChuIDwgMikge1xuICAgICAgIHJldHVybiBuO1xuICAgfTtcbiAgICAgcmV0dXJuIHRoaXMuZmliKG4tMSkgKyB0aGlzLmZpYihuLTIpO1xuIH1cblxuIG1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gbiBvZiAxIG9yIG1vcmUsIHJldHVybiB0aGUgZmFjdG9yaWFsIG9mIG4sIHdoaWNoIGlzIG4gKiAobi0xKSAqIChuLTIpIC4uLiAxLiBDb21wdXRlIHRoZSByZXN1bHQgcmVjdXJzaXZlbHkgKHdpdGhvdXQgbG9vcHMpLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2ZhY3RvcmlhbCcsXG4gIGlucHV0czogW1xuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIig2KVwiLFxuICBcIig3KVwiLFxuICBcIig4KVwiLFxuICBcIigxMilcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnV2UgaGF2ZSBhIG51bWJlciBvZiBidW5uaWVzIGFuZCBlYWNoIGJ1bm55IGhhcyB0d28gYmlnIGZsb3BweSBlYXJzLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIHRvdGFsIG51bWJlciBvZiBlYXJzIGFjcm9zcyBhbGwgdGhlIGJ1bm5pZXMgcmVjdXJzaXZlbHkgKHdpdGhvdXQgbG9vcHMgb3IgbXVsdGlwbGljYXRpb24pLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2J1bm55RWFycycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCIsXG4gIFwiKDQpXCIsXG4gIFwiKDUpXCIsXG4gIFwiKDEyKVwiLFxuICBcIig1MClcIixcbiAgXCIoMjM0KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdUaGUgZmlib25hY2NpIHNlcXVlbmNlIGlzIGEgZmFtb3VzIGJpdCBvZiBtYXRoZW1hdGljcywgYW5kIGl0IGhhcHBlbnMgdG8gaGF2ZSBhIHJlY3Vyc2l2ZSBkZWZpbml0aW9uLiBUaGUgZmlyc3QgdHdvIHZhbHVlcyBpbiB0aGUgc2VxdWVuY2UgYXJlIDAgYW5kIDEgKGVzc2VudGlhbGx5IDIgYmFzZSBjYXNlcykuIEVhY2ggc3Vic2VxdWVudCB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBwcmV2aW91cyB0d28gdmFsdWVzLCBzbyB0aGUgd2hvbGUgc2VxdWVuY2UgaXM6IDAsIDEsIDEsIDIsIDMsIDUsIDgsIDEzLCAyMSBhbmQgc28gb24uIERlZmluZSBhIHJlY3Vyc2l2ZSBmaWJvbmFjY2kobikgbWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgbnRoIGZpYm9uYWNjaSBudW1iZXIsIHdpdGggbj0wIHJlcHJlc2VudGluZyB0aGUgc3RhcnQgb2YgdGhlIHNlcXVlbmNlLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2ZpYm9uYWNjaScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCIsXG4gIFwiKDQpXCIsXG4gIFwiKDUpXCIsXG4gIFwiKDYpXCIsXG4gIFwiKDcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlIGhhdmUgYnVubmllcyBzdGFuZGluZyBpbiBhIGxpbmUsIG51bWJlcmVkIDEsIDIsIC4uLiBUaGUgb2RkIGJ1bm5pZXMgKDEsIDMsIC4uKSBoYXZlIHRoZSBub3JtYWwgMiBlYXJzLiBUaGUgZXZlbiBidW5uaWVzICgyLCA0LCAuLikgd2VcXCdsbCBzYXkgaGF2ZSAzIGVhcnMsIGJlY2F1c2UgdGhleSBlYWNoIGhhdmUgYSByYWlzZWQgZm9vdC4gUmVjdXJzaXZlbHkgcmV0dXJuIHRoZSBudW1iZXIgb2YgXCJlYXJzXCIgaW4gdGhlIGJ1bm55IGxpbmUgMSwgMiwgLi4uIG4gKHdpdGhvdXQgbG9vcHMgb3IgbXVsdGlwbGljYXRpb24pLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2J1bm55RWFyczInLFxuICAgIGlucHV0czogW1xuICBcIigwKVwiLFxuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIig2KVwiLFxuICBcIigxMClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnV2UgaGF2ZSB0cmlhbmdsZSBtYWRlIG9mIGJsb2Nrcy4gVGhlIHRvcG1vc3Qgcm93IGhhcyAxIGJsb2NrLCB0aGUgbmV4dCByb3cgZG93biBoYXMgMiBibG9ja3MsIHRoZSBuZXh0IHJvdyBoYXMgMyBibG9ja3MsIGFuZCBzbyBvbi4gQ29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMgb3IgbXVsdGlwbGljYXRpb24pIHRoZSB0b3RhbCBudW1iZXIgb2YgYmxvY2tzIGluIHN1Y2ggYSB0cmlhbmdsZSB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICd0cmlhbmdsZScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCIsXG4gIFwiKDQpXCIsXG4gIFwiKDUpXCIsXG4gIFwiKDYpXCIsXG4gIFwiKDcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgbm9uLW5lZ2F0aXZlIGludCBuLCByZXR1cm4gdGhlIHN1bSBvZiBpdHMgZGlnaXRzIHJlY3Vyc2l2ZWx5IChubyBsb29wcykuIE5vdGUgdGhhdCBtb2QgKCUpIGJ5IDEwIHlpZWxkcyB0aGUgcmlnaHRtb3N0IGRpZ2l0ICgxMjYgJSAxMCBpcyA2KSwgd2hpbGUgZmxvb3JpbmcgZGl2aXNpb24gKE1hdGguZmxvb3Iobi8xMCkpIGJ5IDEwIHJlbW92ZXMgdGhlIHJpZ2h0bW9zdCBkaWdpdCBbTWF0aC5mbG9vcigxMjYgLyAxMCkgaXMgMTJdLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3N1bURpZ2l0czEnLFxuICAgIGlucHV0czogW1xuICBcIigxMjYpXCIsXG4gIFwiKDQ5KVwiLFxuICBcIigxMilcIixcbiAgXCIoMTApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDApXCIsXG4gIFwiKDczMClcIixcbiAgXCIoMTExMSlcIixcbiAgXCIoMTExMTEpXCIsXG4gIFwiKDEwMTEwKVwiLFxuICBcIigyMzUpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgbm9uLW5lZ2F0aXZlIGludCBuLCByZXR1cm4gdGhlIGNvdW50IG9mIHRoZSBvY2N1cnJlbmNlcyBvZiA3IGFzIGEgZGlnaXQsIHNvIGZvciBleGFtcGxlIDcxNyB5aWVsZHMgMi4gKG5vIGxvb3BzKS4gTm90ZSB0aGF0IG1vZCAoJSkgYnkgMTAgeWllbGRzIHRoZSByaWdodG1vc3QgZGlnaXQgKDEyNiAlIDEwIGlzIDYpLCB3aGlsZSBmbG9vcmluZyBkaXZpc2lvbiAoTWF0aC5mbG9vcihuLzEwKSkgYnkgMTAgcmVtb3ZlcyB0aGUgcmlnaHRtb3N0IGRpZ2l0IFtNYXRoLmZsb29yKDEyNiAvIDEwKSBpcyAxMl0uJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnQ3JyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoNzE3KVwiLFxuICBcIig3KVwiLFxuICBcIigxMjMpXCIsXG4gIFwiKDc3KVwiLFxuICBcIig3MTIzKVwiLFxuICBcIig3NzEyMzcpXCIsXG4gIFwiKDc3MTczNylcIixcbiAgXCIoNDc1NzEpXCIsXG4gIFwiKDc3Nzc3NylcIixcbiAgXCIoNzA3MDEyNzcpXCIsXG4gIFwiKDc3NzU3NjE5NylcIixcbiAgXCIoOTk5OTkpXCIsXG4gIFwiKDk5Nzk5KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIG5vbi1uZWdhdGl2ZSBpbnQgbiwgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSBjb3VudCBvZiB0aGUgb2NjdXJyZW5jZXMgb2YgOCBhcyBhIGRpZ2l0LCBleGNlcHQgdGhhdCBhbiA4IHdpdGggYW5vdGhlciA4IGltbWVkaWF0ZWx5IHRvIGl0cyBsZWZ0IGNvdW50cyBkb3VibGUsIHNvIDg4MTggeWllbGRzIDQuIE5vdGUgdGhhdCBtb2QgKCUpIGJ5IDEwIHlpZWxkcyB0aGUgcmlnaHRtb3N0IGRpZ2l0ICgxMjYgJSAxMCBpcyA2KSwgd2hpbGUgZmxvb3JpbmcgZGl2aXNpb24gKE1hdGguZmxvb3Iobi8xMCkpIGJ5IDEwIHJlbW92ZXMgdGhlIHJpZ2h0bW9zdCBkaWdpdCBbTWF0aC5mbG9vcigxMjYgLyAxMCkgaXMgMTJdLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50OCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDgpXCIsXG4gIFwiKDgxOClcIixcbiAgXCIoODgxOClcIixcbiAgXCIoODA4OClcIixcbiAgXCIoMTIzKVwiLFxuICBcIig4MTIzOClcIixcbiAgXCIoODg3ODgpXCIsXG4gIFwiKDgyMzQpXCIsXG4gIFwiKDIzNDgpXCIsXG4gIFwiKDIzODg0KVwiLFxuICBcIigwKVwiLFxuICBcIigxODE4MTg4KVwiLFxuICBcIig4ODE4MTgxKVwiLFxuICBcIigxMDgwKVwiLFxuICBcIigxODgpXCIsXG4gIFwiKDg4ODg4KVwiLFxuICBcIig5ODk4KVwiLFxuICBcIig3OClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYmFzZSBhbmQgbiB0aGF0IGFyZSBib3RoIDEgb3IgbW9yZSwgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSB2YWx1ZSBvZiBiYXNlIHRvIHRoZSBuIHBvd2VyLCBzbyBwb3dlck4oMywgMikgaXMgOSAoMyBzcXVhcmVkKS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdwb3dlck4nLFxuICAgIGlucHV0czogW1xuICBcIigzLCAxKVwiLFxuICBcIigzLCAyKVwiLFxuICBcIigzLCAzKVwiLFxuICBcIigyLCAxKVwiLFxuICBcIigyLCAyKVwiLFxuICBcIigyLCAzKVwiLFxuICBcIigyLCA0KVwiLFxuICBcIigyLCA1KVwiLFxuICBcIigxMCwgMSlcIixcbiAgXCIoMTAsIDIpXCIsXG4gIFwiKDEwLCAzKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSBudW1iZXIgb2YgbG93ZXJjYXNlIFxcJ3hcXCcgY2hhcnMgaW4gdGhlIHN0cmluZy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjb3VudFgnLFxuICAgIGlucHV0czogW1xuICBcIigneHhoaXh4JylcIixcbiAgXCIoJ3hoaXhoaXgnKVwiLFxuICBcIignaGknKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdoaWhpJylcIixcbiAgXCIoJ2hpQUFoaTEyaGknKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSBudW1iZXIgb2YgdGltZXMgbG93ZXJjYXNlIFwiaGlcIiBhcHBlYXJzIGluIHRoZSBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRIaScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4eGhpeHgnKVwiLFxuICBcIigneGhpeGhpeCcpXCIsXG4gIFwiKCdoaScpXCIsXG4gIFwiKCdoaWhpaCcpXCIsXG4gIFwiKCdoJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdpaGloaWhpaGloJylcIixcbiAgXCIoJ2loaWhpaGloaWhpJylcIixcbiAgXCIoJ2hpQUFoaTEyaGknKVwiLFxuICBcIigneGhpeGh4aWhpaGhoaWgnKVwiLFxuICBcIignc2hpcCcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IChubyBsb29wcykgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgbG93ZXJjYXNlIFxcJ3hcXCcgY2hhcnMgaGF2ZSBiZWVuIGNoYW5nZWQgdG8gXFwneVxcJyBjaGFycy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjaGFuZ2VYWScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdjb2RleCcpXCIsXG4gIFwiKCd4eGhpeHgnKVwiLFxuICBcIigneGhpeGhpeCcpXCIsXG4gIFwiKCdoaXknKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCd4eHgnKVwiLFxuICBcIigneXloeHlpJylcIixcbiAgXCIoJ2hpaGknKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIGEgbmV3IHN0cmluZyB3aGVyZSBhbGwgYXBwZWFyYW5jZXMgb2YgXCJwaVwiIGhhdmUgYmVlbiByZXBsYWNlZCBieSBcIjMuMTRcIi4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjaGFuZ2VQaScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4cGl4JylcIixcbiAgXCIoJ3BpcGknKVwiLFxuICBcIigncGlwJylcIixcbiAgXCIoJ3BpJylcIixcbiAgXCIoJ2hpcCcpXCIsXG4gIFwiKCdwJylcIixcbiAgXCIoJ3gnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ3BpeHgnKVwiLFxuICBcIigneHl6enknKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSBhIG5ldyBzdHJpbmcgd2hlcmUgYWxsIHRoZSBcXCd4XFwnIGNoYXJzIGhhdmUgYmVlbiByZW1vdmVkLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ25vWCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4YXhiJylcIixcbiAgXCIoJ2FiYycpXCIsXG4gIFwiKCd4eCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignYXh4Ynh4JylcIixcbiAgXCIoJ0hlbGxveCcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIGludHMsIGNvbXB1dGUgcmVjdXJzaXZlbHkgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGEgNi4gV2VcXCdsbCB1c2UgdGhlIGNvbnZlbnRpb24gb2YgY29uc2lkZXJpbmcgb25seSB0aGUgcGFydCBvZiB0aGUgYXJyYXkgdGhhdCBiZWdpbnMgYXQgdGhlIGdpdmVuIGluZGV4LiBJbiB0aGlzIHdheSwgYSByZWN1cnNpdmUgY2FsbCBjYW4gcGFzcyBpbmRleCsxIHRvIG1vdmUgZG93biB0aGUgYXJyYXkuIFRoZSBpbml0aWFsIGNhbGwgd2lsbCBwYXNzIGluIGluZGV4IGFzIDAuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnYXJyYXk2JyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoWzEsIDYsIDRdLCAwKVwiLFxuICBcIihbMSwgNF0sIDApXCIsXG4gIFwiKFs2XSwgMClcIixcbiAgXCIoW10sIDApXCIsXG4gIFwiKFs2LCAyLCAyXSwgMClcIixcbiAgXCIoWzIsIDVdLCAwKVwiLFxuICBcIihbMSwgOSwgNCwgNiwgNl0sIDApXCIsXG4gIFwiKFsyLCA1LCA2XSwgMClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgY29tcHV0ZSByZWN1cnNpdmVseSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIHZhbHVlIDExIGFwcGVhcnMgaW4gdGhlIGFycmF5LiBXZVxcJ2xsIHVzZSB0aGUgY29udmVudGlvbiBvZiBjb25zaWRlcmluZyBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBhcnJheSB0aGF0IGJlZ2lucyBhdCB0aGUgZ2l2ZW4gaW5kZXguIEluIHRoaXMgd2F5LCBhIHJlY3Vyc2l2ZSBjYWxsIGNhbiBwYXNzIGluZGV4KzEgdG8gbW92ZSBkb3duIHRoZSBhcnJheS4gVGhlIGluaXRpYWwgY2FsbCB3aWxsIHBhc3MgaW4gaW5kZXggYXMgMC4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdhcnJheTExJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoWzEsIDIsIDExXSwgMClcIixcbiAgXCIoWzExLCAxMV0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0XSwgMClcIixcbiAgXCIoWzEsIDExLCAzLCAxMSwgMTFdLCAwKVwiLFxuICBcIihbMTFdLCAwKVwiLFxuICBcIihbMV0sIDApXCIsXG4gIFwiKFtdLCAwKVwiLFxuICBcIihbMTEsIDIsIDMsIDQsIDExLCA1XSwgMClcIixcbiAgXCIoWzExLCA1LCAxMV0sIDApXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIGludHMsIGNvbXB1dGUgcmVjdXJzaXZlbHkgaWYgdGhlIGFycmF5IGNvbnRhaW5zIHNvbWV3aGVyZSBhIHZhbHVlIGZvbGxvd2VkIGluIHRoZSBhcnJheSBieSB0aGF0IHZhbHVlIHRpbWVzIDEwLiBXZVxcJ2xsIHVzZSB0aGUgY29udmVudGlvbiBvZiBjb25zaWRlcmluZyBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBhcnJheSB0aGF0IGJlZ2lucyBhdCB0aGUgZ2l2ZW4gaW5kZXguIEluIHRoaXMgd2F5LCBhIHJlY3Vyc2l2ZSBjYWxsIGNhbiBwYXNzIGluZGV4KzEgdG8gbW92ZSBkb3duIHRoZSBhcnJheS4gVGhlIGluaXRpYWwgY2FsbCB3aWxsIHBhc3MgaW4gaW5kZXggYXMgMC4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdhcnJheTIyMCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKFsxLCAyLCAyMF0sIDApXCIsXG4gIFwiKFszLCAzMF0sIDApXCIsXG4gIFwiKFszXSwgMClcIixcbiAgXCIoW10sIDApXCIsXG4gIFwiKFszLCAzLCAzMCwgNF0sIDApXCIsXG4gIFwiKFsyLCAxOSwgNF0sIDApXCIsXG4gIFwiKFsyMCwgMiwgMjFdLCAwKVwiLFxuICBcIihbMjAsIDIsIDIxLCAyMTBdLCAwKVwiLFxuICBcIihbMiwgMjAwLCAyMDAwXSwgMClcIixcbiAgXCIoWzAsIDBdLCAwKVwiLFxuICBcIihbMSwgMiwgMywgNCwgNSwgNl0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0LCA1LCA1MCwgNl0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0LCA1LCA1MSwgNl0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0LCA0LCA1MCwgNTAwLCA2XSwgMClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgYWRqYWNlbnQgY2hhcnMgYXJlIG5vdyBzZXBhcmF0ZWQgYnkgYSBcIipcIi4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdhbGxTdGFyJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2hlbGxvJylcIixcbiAgXCIoJ2FiYycpXCIsXG4gIFwiKCdhYicpXCIsXG4gIFwiKCdhJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCczLjE0JylcIixcbiAgXCIoJ0Nob2NvbGF0ZScpXCIsXG4gIFwiKCcxMjM0JylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGlkZW50aWNhbCBjaGFycyB0aGF0IGFyZSBhZGphY2VudCBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nIGFyZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IGEgXCIqXCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAncGFpclN0YXInLFxuICAgIGlucHV0czogW1xuICBcIignaGVsbG8nKVwiLFxuICBcIigneHh5eScpXCIsXG4gIFwiKCdhYWFhJylcIixcbiAgXCIoJ2FhYWInKVwiLFxuICBcIignYWEnKVwiLFxuICBcIignYScpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignbm9hZGphY2VudCcpXCIsXG4gIFwiKCdhYmJhJylcIixcbiAgXCIoJ2FiYmJhJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgbG93ZXJjYXNlIFxcJ3hcXCcgY2hhcnMgaGF2ZSBiZWVuIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmluZy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdlbmRYJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ3h4cmUnKVwiLFxuICBcIigneHhoaXh4JylcIixcbiAgXCIoJ3hoaXhoaXgnKVwiLFxuICBcIignaGl5JylcIixcbiAgXCIoJ2gnKVwiLFxuICBcIigneCcpXCIsXG4gIFwiKCd4eCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignYnh4JylcIixcbiAgXCIoJ2J4YXgnKVwiLFxuICBcIignYXhheGF4JylcIixcbiAgXCIoJ3h4aHhpJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnV2VcXCdsbCBzYXkgdGhhdCBhIFwicGFpclwiIGluIGEgc3RyaW5nIGlzIHR3byBpbnN0YW5jZXMgb2YgYSBjaGFyIHNlcGFyYXRlZCBieSBhIGNoYXIuIFNvIFwiQXhBXCIgdGhlIEFcXCdzIG1ha2UgYSBwYWlyLiBQYWlyXFwncyBjYW4gb3ZlcmxhcCwgc28gXCJBeEF4QVwiIGNvbnRhaW5zIDMgcGFpcnMgLS0gMiBmb3IgQSBhbmQgMSBmb3IgeC4gUmVjdXJzaXZlbHkgY29tcHV0ZSB0aGUgbnVtYmVyIG9mIHBhaXJzIGluIHRoZSBnaXZlbiBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRQYWlycycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdheGEnKVwiLFxuICBcIignYXhheCcpXCIsXG4gIFwiKCdheGJ4JylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJ2hpaGloJylcIixcbiAgXCIoJ2loaWhoaCcpXCIsXG4gIFwiKCdpaGp4aGgnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2EnKVwiLFxuICBcIignYWEnKVwiLFxuICBcIignYWFhJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnQ291bnQgcmVjdXJzaXZlbHkgdGhlIHRvdGFsIG51bWJlciBvZiBcImFiY1wiIGFuZCBcImFiYVwiIHN1YnN0cmluZ3MgdGhhdCBhcHBlYXIgaW4gdGhlIGdpdmVuIHN0cmluZy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjb3VudEFiYycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdhYmMnKVwiLFxuICBcIignYWJjeHhhYmMnKVwiLFxuICBcIignYWJheHhhYmEnKVwiLFxuICBcIignYWJhYmMnKVwiLFxuICBcIignYWJ4YmMnKVwiLFxuICBcIignYWFhYmMnKVwiLFxuICBcIignaGVsbG8nKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2FiJylcIixcbiAgXCIoJ2FiYScpXCIsXG4gIFwiKCdhY2EnKVwiLFxuICBcIignYWFhJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSB0aGUgbnVtYmVyIG9mIFwiMTFcIiBzdWJzdHJpbmdzIGluIHRoZSBzdHJpbmcuIFRoZSBcIjExXCIgc3Vic3RyaW5ncyBzaG91bGQgbm90IG92ZXJsYXAuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnQxMScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCcxMWFiYzExJylcIixcbiAgXCIoJ2FiYzExeDExeDExJylcIixcbiAgXCIoJzExMScpXCIsXG4gIFwiKCcxMTExJylcIixcbiAgXCIoJzEnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJzExeDExMXgxMTExJylcIixcbiAgXCIoJzF4MTExJylcIixcbiAgXCIoJzFIZWxsbzEnKVwiLFxuICBcIignSGVsbG8nKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgcmV0dXJuIHJlY3Vyc2l2ZWx5IGEgXCJjbGVhbmVkXCIgc3RyaW5nIHdoZXJlIGFkamFjZW50IGNoYXJzIHRoYXQgYXJlIHRoZSBzYW1lIGhhdmUgYmVlbiByZWR1Y2VkIHRvIGEgc2luZ2xlIGNoYXIuIFNvIFwieXl6enphXCIgeWllbGRzIFwieXphXCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyaW5nQ2xlYW4nLFxuICAgIGlucHV0czogW1xuICBcIigneXl6enphJylcIixcbiAgXCIoJ2FiYmJjZGQnKVwiLFxuICBcIignSGVsbG8nKVwiLFxuICBcIignWFhhYmNZWScpXCIsXG4gIFwiKCcxMTJhYjQ0NScpXCIsXG4gIFwiKCdIZWxsbyBCb29ra2VlcGVyJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgdGhlIG51bWJlciBvZiB0aW1lcyBsb3dlcmNhc2UgXCJoaVwiIGFwcGVhcnMgaW4gdGhlIHN0cmluZywgaG93ZXZlciBkbyBub3QgY291bnQgXCJoaVwiIHRoYXQgaGF2ZSBhbiBcXCd4XFwnIGltbWVkYXRlbHkgYmVmb3JlIHRoZW0uJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRIaTInLFxuICAgIGlucHV0czogW1xuICBcIignYWhpeGhpJylcIixcbiAgXCIoJ2FoaWJoaScpXCIsXG4gIFwiKCd4aGl4aGknKVwiLFxuICBcIignaGl4aGknKVwiLFxuICBcIignaGl4aGhpJylcIixcbiAgXCIoJ2hpaGloaScpXCIsXG4gIFwiKCdoaWhpaGl4JylcIixcbiAgXCIoJ3hoaWhpaGl4JylcIixcbiAgXCIoJ3h4aGknKVwiLFxuICBcIignaGl4eGhpJylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJ3h4eHgnKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdIZWxsb2hpJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnVGhpcyBxdWVzdGlvbiBpcyBtb2RpZmllZCBmcm9tIHBhcmVuQml0IG9uIENvZGluZ0JhdCB0byBzdGFyQml0LiBHaXZlbiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIGEgZGFzaCBhbmQgYSBzdGFyLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGEgbmV3IHN0cmluZyBtYWRlIG9mIG9ubHkgb2YgdGhlIGRhc2ggYW5kIHN0YXIgYW5kIHRoZWlyIGNvbnRlbnRzLCBzbyBcInh5ei1hYmMqMTIzXCIgeWllbGRzIFwiLWFiYypcIi4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdzdGFyQml0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCd4eXosLWFiYyoxMjMnKVwiLFxuICAgICAgXCIoJ3gsLWhlbGxvKicpXCIsXG4gICAgICBcIignLC14eSoxJylcIixcbiAgICAgIFwiKCdub3QgcmVhbGx5ICwtcG9zc2libGUqJylcIixcbiAgICAgIFwiKCcsLWFiYyonKVwiLFxuICAgICAgXCIoJywtYWJjKnh5eicpXCIsXG4gICAgICBcIignLC1hYmMqeCcpXCIsXG4gICAgICBcIignLC14KicpXCIsXG4gICAgICBcIignLC0pKicpXCIsXG4gICAgICBcIigncmVzICwtaXBzYSogbG9xdWl0b3InKVwiLFxuICAgICAgXCIoJ2hlbGxvLC1ub3QgcmVhbGx5KnRoZXJlJylcIixcbiAgICAgIFwiKCdhYiwtYWIqYWInKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgcmV0dXJuIHRydWUgaWYgaXQgaXMgYSBuZXN0aW5nIG9mIHplcm8gb3IgbW9yZSBwYWlycyBvZiBwYXJlbnRoZXNpcywgbGlrZSBcIigoKSlcIiBvciBcIigoKCkpKVwiLiBTdWdnZXN0aW9uOiBjaGVjayB0aGUgZmlyc3QgYW5kIGxhc3QgY2hhcnMsIGFuZCB0aGVuIHJlY3VyIG9uIHdoYXRcXCdzIGluc2lkZSB0aGVtLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ25lc3RQYXJlbicsXG4gICAgaW5wdXRzOiBbXG4gICAgXCIoJygoKSknKVwiLFxuICAgIFwiKCcoKCgpKSknKVwiLFxuICAgIFwiKCcoKCh4KSknKVwiLFxuICAgIFwiKCcoKCgpKScpXCIsXG4gICAgXCIoJygoKCkoKScpXCIsXG4gICAgXCIoJygpJylcIixcbiAgICBcIignJylcIixcbiAgICBcIignKHl5KScpXCIsXG4gICAgXCIoJygoKSknKVwiLFxuICAgIFwiKCcoKCh5KSknKVwiLFxuICAgIFwiKCcoKHkpKSknKVwiLFxuICAgIFwiKCcoKCgpKSknKVwiLFxuICAgIFwiKCcoKCkpKSknKVwiLFxuICAgIFwiKCcoKHl5KCkpKSknKVwiLFxuICAgIFwiKCcoKCgoKSkpKScpXCJcbiAgICBdIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZyBhbmQgYSBub24tZW1wdHkgc3Vic3RyaW5nIHN1YiwgY29tcHV0ZSByZWN1cnNpdmVseSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgc3ViIGFwcGVhcnMgaW4gdGhlIHN0cmluZywgd2l0aG91dCB0aGUgc3ViIHN0cmluZ3Mgb3ZlcmxhcHBpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyQ291bnQnLFxuICAgIGlucHV0czogW1xuICBcIignY2F0Y293Y2F0JywgJ2NhdCcpXCIsXG4gIFwiKCdjYXRjb3djYXQnLCAnY293JylcIixcbiAgXCIoJ2NhdGNvd2NhdCcsICdkb2cnKVwiLFxuICBcIignY2FjYXRjb3djYXQnLCAnY2F0JylcIixcbiAgXCIoJ3h5eCcsICd4JylcIixcbiAgXCIoJ2lpaWlqaicsICdpJylcIixcbiAgXCIoJ2lpaWlqaicsICdpaScpXCIsXG4gIFwiKCdpaWlpamonLCAnaWlpJylcIixcbiAgXCIoJ2lpaWlqaicsICdqJylcIixcbiAgXCIoJ2lpaWlqaicsICdqaicpXCIsXG4gIFwiKCdhYWFiYWJhYmFiJywgJ2FiJylcIixcbiAgXCIoJ2FhYWJhYmFiYWInLCAnYWEnKVwiLFxuICBcIignYWFhYmFiYWJhYicsICdhJylcIixcbiAgXCIoJ2FhYWJhYmFiYWInLCAnYicpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nIGFuZCBhIG5vbi1lbXB0eSBzdWJzdHJpbmcgc3ViLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGlmIGF0IGxlYXN0IG4gY29waWVzIG9mIHN1YiBhcHBlYXIgaW4gdGhlIHN0cmluZyBzb21ld2hlcmUsIHBvc3NpYmx5IHdpdGggb3ZlcmxhcHBpbmcuIE4gd2lsbCBiZSBub24tbmVnYXRpdmUuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyQ29waWVzJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2NhdGNvd2NhdCcsICdjYXQnLCAyKVwiLFxuICBcIignY2F0Y293Y2F0JywgJ2NvdycsIDIpXCIsXG4gIFwiKCdjYXRjb3djYXQnLCAnY293JywgMSlcIixcbiAgXCIoJ2lpaWpqaicsICdpJywgMylcIixcbiAgXCIoJ2lpaWpqaicsICdpJywgNClcIixcbiAgXCIoJ2lpaWpqaicsICdpaScsIDIpXCIsXG4gIFwiKCdpaWlqamonLCAnaWknLCAzKVwiLFxuICBcIignaWlpampqJywgJ3gnLCAzKVwiLFxuICBcIignaWlpampqJywgJ3gnLCAwKVwiLFxuICBcIignaWlpaWlqJywgJ2lpaScsIDMpXCIsXG4gIFwiKCdpaWlpaWonLCAnaWlpJywgNClcIixcbiAgXCIoJ2lqaWlpaWlqJywgJ2lpaWknLCAyKVwiLFxuICBcIignaWppaWlpaWonLCAnaWlpaScsIDMpXCIsXG4gIFwiKCdkb2djYXRkb2djYXQnLCAnZG9nJywgMilcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcgYW5kIGEgbm9uLWVtcHR5IHN1YnN0cmluZyBzdWIsIGNvbXB1dGUgcmVjdXJzaXZlbHkgdGhlIGxhcmdlc3Qgc3Vic3RyaW5nIHdoaWNoIHN0YXJ0cyBhbmQgZW5kcyB3aXRoIHN1YiBhbmQgcmV0dXJuIGl0cyBsZW5ndGguJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyRGlzdCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdjYXRjb3djYXQnLCAnY2F0JylcIixcbiAgXCIoJ2NhdGNvd2NhdCcsICdjb3cnKVwiLFxuICBcIignY2NjYXRjb3djYXR4eCcsICdjYXQnKVwiLFxuICBcIignYWJjY2F0Y293Y2F0Y2F0eHl6JywgJ2NhdCcpXCIsXG4gIFwiKCd4eXgnLCAneCcpXCIsXG4gIFwiKCd4eXgnLCAneScpXCIsXG4gIFwiKCd4eXgnLCAneicpXCIsXG4gIFwiKCd6JywgJ3onKVwiLFxuICBcIigneCcsICd6JylcIixcbiAgXCIoJycsICd6JylcIixcbiAgXCIoJ2hpSGVsbG9oaWhpaGknLCAnaGknKVwiLFxuICBcIignaGlIZWxsb2hpaGloaScsICdoaWgnKVwiLFxuICBcIignaGlIZWxsb2hpaGloaScsICdvJylcIixcbiAgXCIoJ2hpSGVsbG9oaWhpaGknLCAnbGwnKVwiXG5dIH1cbl07XG4iLCIvKiogLS0tIHNvbHV0aW9ucyAtLS0gKiovXG5cbmxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgICByZXR1cm4gbiAqIHRoaXMuZmFjdG9yaWFsKG4tMSlcbiB9XG4gXG4gc29sdXRpb25zLmJ1bm55RWFycyA9IGZ1bmN0aW9uIGJ1bm55RWFycyhidW5uaWVzKSB7XG4gICAgIGlmIChidW5uaWVzIDw9IDApIHtcbiAgICAgICByZXR1cm4gMDtcbiAgICAgfVxuICAgICBlbHNlIHtcbiAgICAgICByZXR1cm4gMiArIHRoaXMuYnVubnlFYXJzKGJ1bm5pZXMtMSk7XG4gICAgIH1cbiB9XG4gXG4gc29sdXRpb25zLmZpYm9uYWNjaSA9IGZ1bmN0aW9uIGZpYm9uYWNjaShuKSB7XG4gICBpZiAobiA8IDIpIHtcbiAgICAgICByZXR1cm4gbjs7XG4gICB9O1xuICAgICByZXR1cm4gdGhpcy5maWJvbmFjY2kobi0xKSArIHRoaXMuZmlib25hY2NpKG4tMilcbiB9XG4gXG4gc29sdXRpb25zLmJ1bm55RWFyczIgPSBmdW5jdGlvbiBidW5ueUVhcnMyKGJ1bm5pZXMpIHtcbiBcbiAgaWYgKGJ1bm5pZXMgPD0gMCl7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiBcbiAgaWYgKGJ1bm5pZXMlMiA9PSAwKXtcbiAgICByZXR1cm4gMyArIHRoaXMuYnVubnlFYXJzMihidW5uaWVzIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDIgKyB0aGlzLmJ1bm55RWFyczIoYnVubmllcyAtIDEpO1xuICB9XG4gfVxuIFxuIHNvbHV0aW9ucy50cmlhbmdsZSA9IGZ1bmN0aW9uIHRyaWFuZ2xlKHJvd3MpIHtcbiBcbiAgIGlmIChyb3dzIDw9IDApe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiAgIHJldHVybiByb3dzICsgdGhpcy50cmlhbmdsZShyb3dzLTEpXG4gfVxuIFxuIHNvbHV0aW9ucy5zdW1EaWdpdHMxID0gZnVuY3Rpb24gc3VtRGlnaXRzMShuKSB7XG4gICAgIGlmKG4gPD0gMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgICB9XG4gICAgIHJldHVybiBuICUgMTAgKyB0aGlzLnN1bURpZ2l0czEoTWF0aC5mbG9vcihuLzEwKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudDcgPSBmdW5jdGlvbiBjb3VudDcobikge1xuICAgICBpZihuIDw9IDApXG4gICAgICAgICByZXR1cm4gMDtcbiBcbiAgICAgaWYobiAlIDEwID09IDcpXG4gICAgICAgICByZXR1cm4gMSArIHRoaXMuY291bnQ3KE1hdGguZmxvb3Iobi8xMCkpO1xuIFxuICAgICByZXR1cm4gdGhpcy5jb3VudDcoTWF0aC5mbG9vcihuLzEwKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudDggPSBmdW5jdGlvbiBjb3VudDgobikge1xuICAgICBpZihuID09IDApe1xuICAgICAgIHJldHVybiAwO1xuICAgICB9XG4gXG4gICAgIGlmKG4gJSAxMCA9PSA4KSB7XG4gICAgICAgICBpZihwYXJzZUludChuLzEwKSAlIDEwID09IDgpIHtcbiAgICAgICAgICAgIHJldHVybiAyICsgdGhpcy5jb3VudDgocGFyc2VJbnQobi8xMCkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50OChwYXJzZUludChuLzEwKSk7XG4gICAgICAgICB9XG4gICAgIH1cbiAgICAgcmV0dXJuIHRoaXMuY291bnQ4KHBhcnNlSW50KG4vMTApKTtcbiB9XG4gXG4gc29sdXRpb25zLnBvd2VyTiA9IGZ1bmN0aW9uIHBvd2VyTihiYXNlLCBuKSB7XG4gICBpZiAobiA9PSAxKXtcbiAgICAgcmV0dXJuIGJhc2U7XG4gICB9XG4gICByZXR1cm4gYmFzZSAqIHRoaXMucG93ZXJOKGJhc2UsIG4tMSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudFggPSBmdW5jdGlvbiBjb3VudFgoc3RyKSB7XG4gICAgIGlmKHN0ci5sZW5ndGggPT0gMClcbiAgICAgICAgIHJldHVybiAwO1xuIFxuICAgICBpZihzdHIuY2hhckF0KDApID09ICd4Jyl7XG4gICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50WChzdHIuc3Vic3RyaW5nKDEpKTtcbiAgICAgfSBlbHNlIHtcbiAgICAgICByZXR1cm4gdGhpcy5jb3VudFgoc3RyLnN1YnN0cmluZygxKSk7XG4gICAgIH1cbiB9XG4gXG4gc29sdXRpb25zLmNvdW50SGkgPSBmdW5jdGlvbiBjb3VudEhpKHN0cikge1xuICAgaWYgKHN0ci5sZW5ndGggPT0gMCl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMikgPT0gXCJoaVwiKXtcbiAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50SGkoc3RyLnN1YnN0cmluZygyKSlcbiAgIH1cbiAgIHJldHVybiB0aGlzLmNvdW50SGkoc3RyLnN1YnN0cmluZygxKSlcbiB9XG4gXG4gc29sdXRpb25zLmNoYW5nZVhZID0gZnVuY3Rpb24gY2hhbmdlWFkoc3RyKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA9PSAwKXtcbiAgICAgcmV0dXJuIFwiXCI7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcInhcIil7XG4gICAgIHJldHVybiBcInlcIiArIHRoaXMuY2hhbmdlWFkoc3RyLnN1YnN0cmluZygxKSlcbiAgIH1cbiAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5jaGFuZ2VYWShzdHIuc3Vic3RyaW5nKDEpKVxuIH1cbiBcbiBzb2x1dGlvbnMuY2hhbmdlUGkgPSBmdW5jdGlvbiBjaGFuZ2VQaShzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDApe1xuICAgICByZXR1cm4gXCJcIjtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDIpID09IFwicGlcIil7XG4gICAgIHJldHVybiAzLjE0ICsgdGhpcy5jaGFuZ2VQaShzdHIuc3Vic3RyaW5nKDIpKVxuICAgfSBlbHNlIHtcbiAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLmNoYW5nZVBpKHN0ci5zdWJzdHJpbmcoMSkpXG4gICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5ub1ggPSBmdW5jdGlvbiBub1goc3RyKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA9PSAwKXtcbiAgICAgcmV0dXJuIFwiXCI7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcInhcIil7XG4gICAgIHJldHVybiB0aGlzLm5vWChzdHIuc3Vic3RyaW5nKDEpKTtcbiAgIH0gZWxzZSB7XG4gICAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5ub1goc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5hcnJheTYgPSBmdW5jdGlvbiBhcnJheTYobnVtcywgaSkge1xuICAgaWYgKGkgPiBudW1zLmxlbmd0aCl7XG4gICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiBcbiAgIGlmIChudW1zW2ldID09IDYpe1xuICAgICByZXR1cm4gdHJ1ZTtcbiAgIH0gZWxzZSB7XG4gICAgIHJldHVybiB0aGlzLmFycmF5NihudW1zLCBpKzEpXG4gICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5hcnJheTExID0gZnVuY3Rpb24gYXJyYXkxMShudW1zLCBpKSB7XG4gICBpZiAoaSA+PSBudW1zLmxlbmd0aCl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKG51bXNbaV0gPT0gMTEpe1xuICAgICByZXR1cm4gMSArIHRoaXMuYXJyYXkxMShudW1zLCBpKzEpO1xuICAgfSBlbHNlIHtcbiAgICAgcmV0dXJuIHRoaXMuYXJyYXkxMShudW1zLCBpKzEpO1xuICAgfVxuIH1cbiBcbiBzb2x1dGlvbnMuYXJyYXkyMjAgPSBmdW5jdGlvbiBhcnJheTIyMChudW1zLCBpKSB7XG4gXG4gICBpZiAoaSA9PSBudW1zLmxlbmd0aC0xIHx8IG51bXMubGVuZ3RoID09IDApe1xuICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gXG4gICBpZiAobnVtc1tpXSAqIDEwID09IG51bXNbaSsxXSl7XG4gICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgcmV0dXJuIHRoaXMuYXJyYXkyMjAobnVtcywgaSsxKTtcbiB9XG4gXG4gc29sdXRpb25zLmFsbFN0YXIgPSBmdW5jdGlvbiBhbGxTdGFyKHN0cikge1xuIFxuICAgaWYgKHN0ci5sZW5ndGggPD0gMSl7XG4gICAgIHJldHVybiBzdHI7XG4gICB9XG4gXG4gICByZXR1cm4gIHN0ci5jaGFyQXQoMCkgKyBcIipcIiArIHRoaXMuYWxsU3RhcihzdHIuc3Vic3RyaW5nKDEpKTtcbiB9XG4gXG4gc29sdXRpb25zLnBhaXJTdGFyID0gZnVuY3Rpb24gcGFpclN0YXIoc3RyKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAxKXtcbiAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCk7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBzdHIuY2hhckF0KDEpKXtcbiAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyBcIipcIiArIHRoaXMucGFpclN0YXIoc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gICByZXR1cm4gc3RyLmNoYXJBdCgwKSArIHRoaXMucGFpclN0YXIoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5lbmRYID0gZnVuY3Rpb24gZW5kWChzdHIpIHtcbiAgICAgaWYoc3RyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgcmV0dXJuIHN0cjtcbiAgICAgfVxuIFxuICAgIGlmIChzdHIuY2hhckF0KDApID09IFwieFwiKXtcbiAgICAgIHJldHVybiB0aGlzLmVuZFgoc3RyLnN1YnN0cmluZygxKSkgKyBcInhcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLmVuZFgoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudFBhaXJzID0gZnVuY3Rpb24gY291bnRQYWlycyhzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDIpe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuY2hhckF0KDApID09IHN0ci5jaGFyQXQoMikpe1xuICAgICByZXR1cm4gMSArIHRoaXMuY291bnRQYWlycyhzdHIuc3Vic3RyaW5nKDEpKTtcbiAgIH1cbiAgIHJldHVybiB0aGlzLmNvdW50UGFpcnMoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudEFiYyA9IGZ1bmN0aW9uIGNvdW50QWJjKHN0cil7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAyKSB7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMykgPT09IFwiYWJjXCIgfHwgc3RyLnN1YnN0cmluZygwLCAzKSA9PT0gXCJhYmFcIil7XG4gICAgIHJldHVybiAxICsgdGhpcy5jb3VudEFiYyhzdHIuc3Vic3RyaW5nKDIpKTtcbiAgIH1cbiAgIHJldHVybiB0aGlzLmNvdW50QWJjKHN0ci5zdWJzdHJpbmcoMSkpXG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudDExID0gZnVuY3Rpb24gY291bnQxMShzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDEpe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDIpID09IFwiMTFcIil7XG4gICAgIHJldHVybiAxICsgdGhpcy5jb3VudDExKHN0ci5zdWJzdHJpbmcoMikpXG4gICB9XG4gICByZXR1cm4gdGhpcy5jb3VudDExKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuc3RyaW5nQ2xlYW4gPSBmdW5jdGlvbiBzdHJpbmdDbGVhbihzdHIpIHtcbiAgIGlmIChzdHIubGVuZ3RoID09IDEpe1xuICAgICByZXR1cm4gc3RyO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gc3RyLmNoYXJBdCgxKSl7XG4gICAgIHJldHVybiB0aGlzLnN0cmluZ0NsZWFuKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgfVxuICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLnN0cmluZ0NsZWFuKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnRIaTIgPSBmdW5jdGlvbiBjb3VudEhpMihzdHIpe1xuICAgaWYgKHN0ci5sZW5ndGggPD0gMSl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gXCJ4aGlcIil7XG4gICAgIHJldHVybiB0aGlzLmNvdW50SGkyKHN0ci5zdWJzdHJpbmcoMykpXG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCAyKSA9PSBcImhpXCIpe1xuICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50SGkyKHN0ci5zdWJzdHJpbmcoMikpXG4gICB9XG4gXG4gICAgcmV0dXJuIHRoaXMuY291bnRIaTIoc3RyLnN1YnN0cmluZygxKSlcbiB9XG4gXG4gc29sdXRpb25zLnN0YXJCaXQgPSBmdW5jdGlvbiBzdGFyQml0KHN0cikge1xuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gXCItXCIgJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT0gXCIqXCIpe1xuICAgICByZXR1cm4gc3RyO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aC0xKSA9PSBcIipcIil7XG4gICAgIHJldHVybiB0aGlzLnN0YXJCaXQoc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcIi1cIil7XG4gICAgIHJldHVybiB0aGlzLnN0YXJCaXQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoLTEpKTtcbiAgIH1cbiBcbiAgIHJldHVybiB0aGlzLnN0YXJCaXQoc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMubmVzdFBhcmVuID0gZnVuY3Rpb24gbmVzdFBhcmVuKHN0cikge1xuICAgICBpZihzdHIubGVuZ3RoID09IDApXG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiBcbiAgICAgaWYoc3RyLmNoYXJBdCgwKSA9PSAnKCcgJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoLTEpID09ICcpJyl7XG4gICAgICAgICByZXR1cm4gdGhpcy5uZXN0UGFyZW4oc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoLTEpKTtcbiAgICAgfVxuIFxuICAgICByZXR1cm4gZmFsc2U7XG4gfVxuIFxuIHNvbHV0aW9ucy5zdHJDb3VudCA9IGZ1bmN0aW9uIHN0ckNvdW50KHN0ciwgc3ViKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA8PSAwKXtcbiAgICAgcmV0dXJuIDA7XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCBzdWIubGVuZ3RoKSA9PSBzdWIpe1xuICAgICByZXR1cm4gMSArIHRoaXMuc3RyQ291bnQoc3RyLnN1YnN0cmluZyhzdWIubGVuZ3RoKSwgc3ViKVxuICAgfVxuICAgcmV0dXJuIHRoaXMuc3RyQ291bnQoc3RyLnN1YnN0cmluZygxKSwgc3ViKTtcbiB9XG4gXG4gc29sdXRpb25zLnN0ckNvcGllcyA9IGZ1bmN0aW9uIHN0ckNvcGllcyhzdHIsIHN1Yiwgbikge1xuICAgaWYgKG4gPT0gMCl7XG4gICAgIHJldHVybiB0cnVlO1xuICAgfVxuIFxuICAgaWYgKHN0ci5sZW5ndGggPCBzdWIubGVuZ3RoKXtcbiAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgc3ViLmxlbmd0aCkgPT0gc3ViKXtcbiAgICAgcmV0dXJuIHRoaXMuc3RyQ29waWVzKHN0ci5zdWJzdHJpbmcoMSksIHN1Yiwgbi0xKVxuICAgfVxuICAgcmV0dXJuIHRoaXMuc3RyQ29waWVzKHN0ci5zdWJzdHJpbmcoMSksIHN1YiwgbilcbiB9XG4gXG4gc29sdXRpb25zLnN0ckRpc3QgPSBmdW5jdGlvbiBzdHJEaXN0KHN0ciwgc3ViKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSBzdWIubGVuZ3RoKXtcbiAgICAgICAgIGlmIChzdHIgPT0gc3ViKXtcbiAgICAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiAwO1xuICAgICAgIH1cbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIHN1Yi5sZW5ndGgpID09IHN1YiAmJiBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGgtc3ViLmxlbmd0aCkgPT0gc3ViKXtcbiAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCBzdWIubGVuZ3RoKSA9PSBzdWIpe1xuICAgICByZXR1cm4gdGhpcy5zdHJEaXN0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aC0xKSwgc3ViKTtcbiAgIH1cbiBcbiAgICBpZiAoc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoLXN1Yi5sZW5ndGgpID09IHN1Yil7XG4gICAgIHJldHVybiB0aGlzLnN0ckRpc3Qoc3RyLnN1YnN0cmluZygxKSwgc3ViKTtcbiAgIH1cbiBcbiAgIHJldHVybiB0aGlzLnN0ckRpc3Qoc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoLTEpLCBzdWIpXG4gfVxuXG4gbW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7IiwiLyoqIC0tLSBTb2x1dGlvbnMgLS0tICoqL1xuLy8gU3RyaW5nLTFcblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuXG5zb2x1dGlvbnMuaGVsbG9OYW1lID0gZnVuY3Rpb24gaGVsbG9OYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gYEhlbGxvICR7bmFtZX0hYDtcbiAgfTtcbiAgXG5zb2x1dGlvbnMubWFrZUFiYmEgPSBmdW5jdGlvbiBtYWtlQWJiYShhLCBiKSB7XG4gIHJldHVybiBhICsgYiArIGIgKyBhO1xufTtcblxuc29sdXRpb25zLm1ha2VPdXRXb3JkID0gZnVuY3Rpb24gbWFrZU91dFdvcmQob3V0LCB3b3JkKSB7XG4gIGZyb250ID0gb3V0LnN1YnN0cmluZygwLCAyKTtcbiAgYmFjayA9IG91dC5zdWJzdHJpbmcoMiwgNCk7XG4gIHJldHVybiBmcm9udCArIHdvcmQgKyBiYWNrO1xufTtcblxuc29sdXRpb25zLmV4dHJhRW5kID0gZnVuY3Rpb24gZXh0cmFFbmQoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMSkge1xuICAgIGJhY2sgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyKTtcbiAgICByZXR1cm4gYmFjayArIGJhY2sgKyBiYWNrO1xuICB9XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dEVuZCA9IGZ1bmN0aW9uIHdpdGhvdXRFbmQoc3RyKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDEsIHN0ci5sZW5ndGggLSAxKTtcbn07XG5cbnNvbHV0aW9ucy5jb21ib1N0cmluZyA9IGZ1bmN0aW9uIGNvbWJvU3RyaW5nKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYSArIGIgKyBhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiICsgYSArIGI7XG4gIH1cbn07XG5cbnNvbHV0aW9ucy5ub25TdGFydCA9IGZ1bmN0aW9uIG5vblN0YXJ0KGEsIGIpIHtcbiAgYSA9IGEuc3Vic3RyaW5nKDEsIGEubGVuZ3RoKTtcbiAgYiA9IGIuc3Vic3RyaW5nKDEsIGIubGVuZ3RoKTtcbiAgcmV0dXJuIGEgKyBiO1xufTtcblxuc29sdXRpb25zLmZpcnN0SGFsZiA9IGZ1bmN0aW9uIGZpcnN0SGFsZihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggJSAyID09IDApIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuc29sdXRpb25zLmZpcnN0VHdvID0gZnVuY3Rpb24gZmlyc3RUd28oc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMubGVmdDIgPSBmdW5jdGlvbiBsZWZ0MihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPiAxKSB7XG4gICAgZnJvbnQgPSBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICAgIGJhY2sgPSBzdHIuc3Vic3RyaW5nKDIsIHN0ci5sZW5ndGgpO1xuICAgIHJldHVybiBiYWNrICsgZnJvbnQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy5yaWdodDIgPSBmdW5jdGlvbiByaWdodDIoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMSkge1xuICAgIGJhY2sgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyLCBzdHIubGVuZ3RoKTtcbiAgICBmcm9udCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpO1xuICAgIHJldHVybiBiYWNrICsgZnJvbnQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy50aGVFbmQgPSBmdW5jdGlvbiB0aGVFbmQoc3RyLCBmcm9udCkge1xuICBpZiAoZnJvbnQpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKTtcbiAgfVxuICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMSk7XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dEVuZDIgPSBmdW5jdGlvbiB3aXRob3V0RW5kMihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSk7XG59O1xuXG5zb2x1dGlvbnMubWlkZGxlVHdvID0gZnVuY3Rpb24gbWlkZGxlVHdvKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCAlIDIgPT0gMCkge1xuICAgIHRlbXAgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGgpO1xuICAgIG1pZCA9IHRlbXAuc3Vic3RyaW5nKDAsIDIpO1xuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy5lbmRzTHkgPSBmdW5jdGlvbiBlbmRzTHkoc3RyKSB7XG4gIGlmIChzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyLCBzdHIubGVuZ3RoKSA9PSAnbHknKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5zb2x1dGlvbnMublR3aWNlID0gZnVuY3Rpb24gblR3aWNlKHN0ciwgbikge1xuICBmaXJzdCA9IHN0ci5zdWJzdHJpbmcoMCwgbik7XG4gIGVuZCA9IHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIG4pO1xuICByZXR1cm4gZmlyc3QgKyBlbmQ7XG59O1xuXG5zb2x1dGlvbnMubWFrZVRhZ3MgPSBmdW5jdGlvbiBtYWtlVGFncyh0YWcsIHdvcmQpIHtcbiAgY29uc3Qgb3RhZyA9IGA8JHt0YWd9PmA7XG4gIGNvbnN0IGN0YWcgPSBgPC8ke3RhZ30+YDtcbiAgcmV0dXJuIG90YWcgKyB3b3JkICsgY3RhZztcbn07XG5cbnNvbHV0aW9ucy50d29DaGFyID0gZnVuY3Rpb24gdHdvQ2hhcihzdHIsIGluZGV4KSB7XG4gIGlmIChpbmRleCArIDIgPiBzdHIubGVuZ3RoIHx8IGluZGV4IDwgMCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgMik7XG59O1xuXG5zb2x1dGlvbnMubWlkZGxlVGhyZWUgPSBmdW5jdGlvbiBtaWRkbGVUaHJlZShzdHIpIHtcbiAgY29uc3QgaSA9IE1hdGguZmxvb3Ioc3RyLmxlbmd0aCAvIDIpO1xuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKGkgLSAxLCBpICsgMik7XG59O1xuXG5zb2x1dGlvbnMuaGFzQmFkID0gZnVuY3Rpb24gaGFzQmFkKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PSAzKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gJ2JhZCc7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+PSA0KSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gJ2JhZCcgfHxcbiAgICAgICAgICAgIHN0ci5zdWJzdHJpbmcoMSwgNCkgPT0gJ2JhZCc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5zb2x1dGlvbnMuYXRGaXJzdCA9IGZ1bmN0aW9uIGF0Rmlyc3Qoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gJ0BAJztcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gYCR7c3RyfUBgO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMik7XG59O1xuXG5zb2x1dGlvbnMubGFzdENoYXJzID0gZnVuY3Rpb24gbGFzdENoYXJzKGEsIGIpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBpZiAoYS5sZW5ndGggPT0gMCkge1xuICAgIHJlcyArPSAnQCc7XG4gIH0gZWxzZSB7XG4gICAgcmVzICs9IGEuY2hhckF0KDApO1xuICB9XG5cbiAgaWYgKGIubGVuZ3RoID09IDApIHtcbiAgICByZXMgKz0gJ0AnO1xuICB9IGVsc2Uge1xuICAgIHJlcyArPSBiLmNoYXJBdChiLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbnNvbHV0aW9ucy5jb25DYXQgPSBmdW5jdGlvbiBjb25DYXQoYSwgYikge1xuICBpZiAoYS5jaGFyQXQoYS5sZW5ndGggLSAxKSA9PSBiLmNoYXJBdCgwKSkge1xuICAgIHJldHVybiBhICsgYi5zdWJzdHJpbmcoMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9XG59O1xuXG5zb2x1dGlvbnMubGFzdFR3byA9IGZ1bmN0aW9uIGxhc3RUd28oc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMikgKyBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSArXG4gICAgICAgIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDIpO1xufTtcblxuc29sdXRpb25zLnNlZUNvbG9yID0gZnVuY3Rpb24gc2VlQ29sb3Ioc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID49IDMgJiYgc3RyLnN1YnN0cmluZygwLCAzKSA9PSAncmVkJykge1xuICAgIHJldHVybiAncmVkJztcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID49IDQgJiYgc3RyLnN1YnN0cmluZygwLCA0KSA9PSAnYmx1ZScpIHtcbiAgICByZXR1cm4gJ2JsdWUnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuc29sdXRpb25zLmZyb250QWdhaW4gPSBmdW5jdGlvbiBmcm9udEFnYWluKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAyKSA9PSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyKTtcbn07XG5cbnNvbHV0aW9ucy5taW5DYXQgPSBmdW5jdGlvbiBtaW5DYXQoYSwgYikge1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuXG4gIHJldHVybiBhLnN1YnN0cmluZyhhLmxlbmd0aCAtIG1pbikgKyBiLnN1YnN0cmluZyhiLmxlbmd0aCAtIG1pbik7XG59O1xuXG5zb2x1dGlvbnMuZXh0cmFGcm9udCA9IGZ1bmN0aW9uIGV4dHJhRnJvbnQoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID49IDIpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHN0ciArIHN0cjtcbn07XG5cbnNvbHV0aW9ucy53aXRob3V0MiA9IGZ1bmN0aW9uIHdpdGhvdXQyKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+PSAyICYmXG4gICAgICAgIHN0ci5zdWJzdHJpbmcoMCwgMikgPT0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMikpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygyKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMuZGVGcm9udCA9IGZ1bmN0aW9uIGRlRnJvbnQoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID09IDEgJiYgc3RyLmNoYXJBdCgwKSAhPSAnYScpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoMCkgIT0gJ2EnICYmIHN0ci5jaGFyQXQoMSkgIT0gJ2InKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygyKTtcbiAgICB9IGVsc2UgaWYgKHN0ci5jaGFyQXQoMCkgIT0gJ2EnKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2UgaWYgKHN0ci5jaGFyQXQoMSkgIT0gJ2InKSB7XG4gICAgICByZXR1cm4gYGEke3N0ci5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuc29sdXRpb25zLnN0YXJ0V29yZCA9IGZ1bmN0aW9uIHN0YXJ0V29yZChzdHIsIHdvcmQpIHtcbiAgaWYgKHN0ci5sZW5ndGggPj0gd29yZC5sZW5ndGggJiZcbiAgICAgICAgc3RyLnN1YnN0cmluZygxLCB3b3JkLmxlbmd0aCkgPT0gKHdvcmQuc3Vic3RyaW5nKDEpKSkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHdvcmQubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbnNvbHV0aW9ucy53aXRob3V0WCA9IGZ1bmN0aW9uIHdpdGhvdXRYKHN0cikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gc3RyLmxlbmd0aDtcblxuICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgc3RyLmNoYXJBdCgwKSA9PSAneCcpIHsgc3RhcnQgPSAxOyB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPiAxICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09ICd4Jykge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dFgyID0gZnVuY3Rpb24gd2l0aG91dFgyKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PSAxICYmIHN0ci5jaGFyQXQoMCkgPT0gJ3gnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPj0gMikge1xuICAgIGlmIChzdHIuY2hhckF0KDApID09ICd4JyAmJiBzdHIuY2hhckF0KDEpID09ICd4Jykge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMik7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KDApID09ICd4Jykge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KDEpID09ICd4Jykge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyBzdHIuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vLyBTdHJpbmctMlxuXG5zb2x1dGlvbnMuZG91YmxlQ2hhciA9IGZ1bmN0aW9uIGRvdWJsZUNoYXIoc3RyKSB7XG4gIGxldCBkU3RyID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICBkU3RyICs9IHN0cltpXStzdHJbaV07XG4gIH1cbiAgcmV0dXJuIGRTdHI7XG59XG5cbnNvbHV0aW9ucy5jb3VudEhpID0gZnVuY3Rpb24gY291bnRIaShzdHIpIHtcblxuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChzdHJbaV0gKyBzdHJbaSsxXSA9PSBcImhpXCIpe1xuICAgICAgICAgIGNvdW50ICs9MTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG5cbn1cblxuc29sdXRpb25zLmNhdERvZyA9IGZ1bmN0aW9uIGNhdERvZyhzdHIpIHtcbiAgbGV0IGNhdCA9IDA7XG4gIGxldCBkb2cgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihzdHIuc3Vic3RyaW5nKGksIGkrMykgPT0gXCJjYXRcIikge1xuICAgICAgICAgIGNhdCArPSAxO1xuICAgICAgfVxuICAgICAgICBpZihzdHIuc3Vic3RyaW5nKGksIGkrMykgPT0gXCJkb2dcIikge1xuICAgICAgICAgIGRvZyArPSAxO1xuICAgICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gY2F0ID09IGRvZztcbn1cblxuc29sdXRpb25zLmNvdW50Q29kZSA9IGZ1bmN0aW9uIGNvdW50Q29kZShzdHIpIHtcbiAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoc3RyLnN1YnN0cmluZyhpLCBpKzIpID09IFwiY29cIiAmJiBzdHIuc3Vic3RyaW5nKGkrMywgaSs0KSA9PSBcImVcIil7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuZW5kT3RoZXIgPSBmdW5jdGlvbiBlbmRPdGhlcihhLCBiKSB7XG4gIGxldCBzaG9ydCA9IFwiXCI7XG4gIGxldCBsb25nID0gXCJcIjtcblxuICAgIGlmIChhID09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpe1xuICAgICAgICBzaG9ydCArPSBhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvbmcgKz0gYi50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3J0ICs9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG9uZyArPSBhLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGV0IGxvbmdFbmQgPSBsb25nLnN1YnN0cmluZyhsb25nLmxlbmd0aCAtc2hvcnQubGVuZ3RoKTtcblxuICAgIHJldHVybiBsb25nRW5kID09IHNob3J0O1xufVxuXG5zb2x1dGlvbnMueHl6VGhlcmUgPSBmdW5jdGlvbiB4eXpUaGVyZShzdHIpIHtcbiAgbGV0IHggPSBcInh5elwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYoc3RyLnN1YnN0cmluZyhpLCBpKzMpID09IHggJiYgc3RyLmNoYXJBdChpLTEsIGkpICE9IFwiLlwiKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuYm9iVGhlcmUgPSBmdW5jdGlvbiBib2JUaGVyZShzdHIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspe1xuICAgICAgaWYgKHN0ci5jaGFyQXQoaSkgPT0gXCJiXCIgJiYgc3RyLmNoYXJBdChpKzIpID09IFwiYlwiKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLnh5QmFsYW5jZSA9IGZ1bmN0aW9uIHh5QmFsYW5jZShzdHIpIHtcbiAgICBsZXQgeSA9IGZhbHNlO1xuICAgIC8vYmFja3dhcmRzIGxvb3BcbiAgICBmb3IobGV0IGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYoc3RyLmNoYXJBdChpKSA9PSAneScpXG4gICAgICAgICAgICB5ID0gdHJ1ZTtcblxuICAgICAgICBpZihzdHIuY2hhckF0KGkpID09ICd4JyAmJiAheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLm1peFN0cmluZyA9IGZ1bmN0aW9uIG1peFN0cmluZyhhLCBiKSB7XG4gICAgbGV0IGxhcmdlID0gXCJcIjtcbiAgICBsZXQgbmV3U3RyID0gXCJcIjtcblxuICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgICAgIGxhcmdlICs9IGEubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhcmdlICs9IGIubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFyZ2U7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdTdHIgKz0gYVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYltpXSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgbmV3U3RyICs9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U3RyO1xufVxuXG5zb2x1dGlvbnMucmVwZWF0RW5kID0gZnVuY3Rpb24gcmVwZWF0RW5kKHN0ciwgbikge1xuICAgIGxldCByZXRTdHIgPSBcIlwiO1xuICBsZXQgc3ViID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gbik7XG5cbiAgICB3aGlsZSAobiAhPSAwKSB7XG4gICAgICAgIHJldFN0ciArPSBzdWI7XG4gICAgICAgIG4tLVxuICAgIH1cblxuICAgIHJldHVybiByZXRTdHI7XG59XG5cbnNvbHV0aW9ucy5yZXBlYXRGcm9udCA9IGZ1bmN0aW9uIHJlcGVhdEZyb250KHN0ciwgbikge1xuXG4gICAgbGV0IG51ID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSBuOyBpID4gMDsgaS0tKXtcbiAgICAgICAgbnUgKz0gc3RyLnN1YnN0cmluZygwLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnU7XG59XG5cbnNvbHV0aW9ucy5yZXBlYXRTZXBhcmF0b3IgPSBmdW5jdGlvbiByZXBlYXRTZXBhcmF0b3Iod29yZCwgc2VwLCBjb3VudCkge1xuICBsZXQgbnUgPSBcIlwiO1xuXG4gICAgICBpZiAoY291bnQgPT0gMCl7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50IC0gMTsgaSsrKXtcbiAgICAgICAgbnUgKz0gd29yZDtcbiAgICAgICAgbnUgKz0gc2VwO1xuICAgIH1cblxuICAgIG51ICs9IHdvcmQ7XG5cbiAgICByZXR1cm4gbnU7XG59XG5cbnNvbHV0aW9ucy5wcmVmaXhBZ2FpbiA9IGZ1bmN0aW9uIHByZWZpeEFnYWluKHN0ciwgbikge1xuICAgIGxldCBwcmVmaXggPSBzdHIuc3Vic3RyaW5nKDAsIG4pO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0ci5sZW5ndGg7IGkgPiBuOyBpLS0pe1xuICAgICAgICBpZihzdHIuc3Vic3RyaW5nKGktbiwgaSkgPT0gcHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy54eXpNaWRkbGUgPSBmdW5jdGlvbiB4eXpNaWRkbGUoc3RyKSB7XG4gICAgaWYoc3RyLmxlbmd0aCA8IDMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBzdGFydDEgPSBzdHIubGVuZ3RoIC8gMiAtIDI7XG4gICAgbGV0IHN0YXJ0MiA9IHN0ci5sZW5ndGggLyAyIC0gMTtcblxuICAgIGlmKHN0ci5sZW5ndGggJSAyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQxLCBzdGFydDEgKyAzKSA9PSBcInh5elwiIHx8XG4gICAgICAgICAgICBzdHIuc3Vic3RyaW5nKHN0YXJ0Miwgc3RhcnQyICsgMykgPT0gXCJ4eXpcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydDIsIHN0YXJ0MiArIDMpID09IFwieHl6XCI7XG59XG5cbnNvbHV0aW9ucy5nZXRTYW5kd2ljaCA9IGZ1bmN0aW9uIGdldFNhbmR3aWNoKHN0cikge1xuICBsZXQgdGVtcDEgPSBcIlwiO1xuICBsZXQgaTEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpLCBpKzUpID09IFwiYnJlYWRcIikge1xuICAgICAgICAgICAgdGVtcDEgPSBzdHIuc2xpY2UoaSwgaSs1KTtcbiAgICAgICAgICAgIGkxID0gaSs1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIGxldCB0ZW1wMiA9IFwiXCI7XG4gIGxldCBpMiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0ci5sZW5ndGg7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpLTUsIGkpID09IFwiYnJlYWRcIikge1xuICAgICAgICAgICAgdGVtcDIgPSBzdHIuc2xpY2UoaS01LCBpKTtcbiAgICAgICAgICAgIGkyID0gaS01O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzID0gXCJcIjtcblxuICAgIGZvciAobGV0IGogPSBpMTsgaiA8IGkyOyBqKyspe1xuICAgICAgICByZXMgKz0gc3RyW2pdO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbnNvbHV0aW9ucy5zYW1lU3RhckNoYXIgPSBmdW5jdGlvbiBzYW1lU3RhckNoYXIoc3RyKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0ci5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChpKSA9PSAnKicgJiYgc3RyLmNoYXJBdChpLTEpICE9IHN0ci5jaGFyQXQoaSsxKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5vbmVUd28gPSBmdW5jdGlvbiBvbmVUd28oc3RyKSB7XG4gICAgbGV0IG51c3QgPSBcIlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoLTE7IGkrPSAzKXtcbiAgICAgICAgaWYgKHN0cltpKzJdICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgbnVzdCArPSBzdHJbaSsxXTsgLy9jXG4gICAgICAgICAgbnVzdCArPSBzdHJbaSsyXTsgLy9iXG4gICAgICAgICAgbnVzdCArPSBzdHJbaV07IC8vYVxuICAgICAgICB9XG4gIH1cbiAgICByZXR1cm4gbnVzdDtcbn1cblxuc29sdXRpb25zLnppcFphcCA9IGZ1bmN0aW9uIHppcFphcChzdHIpIHtcbiAgbGV0IG51c3QgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYgKHN0cltpLTFdICE9IFwielwiIHx8IHN0cltpKzFdICE9IFwicFwiKXtcbiAgICAgIG51c3QgKz0gc3RyW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVzdDtcbn1cblxuc29sdXRpb25zLnN0YXJPdXQgPSBmdW5jdGlvbiBzdGFyT3V0KHN0cikge1xuICAgIGlmKHN0ci5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgIGlmKHN0ci5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZihzdHIuY2hhckF0KDApID09ICcqJylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBhcnIgPSBuZXcgQXJyYXkoKTtcblxuICAgIGxldCBjb3VudCA9IDA7XG5cblxuICAgIGlmKHN0ci5jaGFyQXQoMCkgIT0gJyonICYmIHN0ci5jaGFyQXQoMSkgIT0gJyonKSB7XG4gICAgICAgIGFycltjb3VudF0gPSBzdHIuY2hhckF0KDApO1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdHIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmKHN0ci5jaGFyQXQoaS0xKSE9JyonICYmIHN0ci5jaGFyQXQoaSkgIT0gJyonICYmXG4gICAgICAgICAgICBzdHIuY2hhckF0KGkrMSkgIT0gJyonKSB7XG4gICAgICAgICAgICBhcnJbY291bnRdID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihzdHIuY2hhckF0KHN0ci5sZW5ndGgtMSkgIT0gJyonICYmXG4gICAgICAgIHN0ci5jaGFyQXQoc3RyLmxlbmd0aC0yKSAhPSAnKicpIHtcbiAgICAgICAgYXJyW2NvdW50XSA9IHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGxldCB4ID0gYXJyLnRvU3RyaW5nKCk7XG5cbiAgICAgIHJldHVybiB4LnJlcGxhY2UoLywvZywgXCJcIik7XG59XG5cbnNvbHV0aW9ucy5wbHVzT3V0ID0gZnVuY3Rpb24gcGx1c091dChzdHIsIHdvcmQpIHtcbiAgbGV0IHNsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgd2xlbiA9IHdvcmQubGVuZ3RoO1xuICBsZXQgZmluID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsZW47IGkrKykge1xuICAgIGlmIChpIDw9IHNsZW4gLSB3bGVuKSB7XG4gICAgICBsZXQgdG1wID0gc3RyLnN1YnN0cmluZyhpLGkrd2xlbik7XG4gICAgICBpZiAodG1wID09IHdvcmQpIHtcbiAgICAgICAgZmluICs9IHdvcmQ7XG4gICAgICAgIGkgKz0gd2xlbi0xO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBmaW4gKz0gXCIrXCI7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIGZpbiArPSBcIitcIjtcbiAgfVxuICByZXR1cm4gZmluO1xufVxuXG5zb2x1dGlvbnMud29yZEVuZHMgPSBmdW5jdGlvbiB3b3JkRW5kcyhzdHIsIHdvcmQpe1xuICBsZXQgc2xlbiA9IHN0ci5sZW5ndGg7XG4gIGxldCB3bGVuID0gd29yZC5sZW5ndGg7XG4gIGxldCByZXMgPSBcIlwiO1xuXG4gIGlmIChzbGVuLmxlbmd0aCA8IDEpe1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsZW47IGkrKykge1xuICAgIGlmIChpIDw9IHNsZW4gLSB3bGVuKXtcbiAgICAgIGxldCB0ZW1wID0gc3RyLnN1YnN0cmluZyhpLCBpK3dsZW4pO1xuICAgICAgaWYgKHRlbXAgPT0gd29yZCl7XG4gICAgICAgIGlmIChzdHJbaS0xXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXMgKz0gc3RyW2ktMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltpK3dsZW5dKXtcbiAgICAgICAgICByZXMrPSBzdHJbaSt3bGVuXTtcbiAgICAgICAgfVxuICAgICAgICBpICs9IHdsZW4tMTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy0zXG5cbnNvbHV0aW9ucy5jb3VudFlaID0gZnVuY3Rpb24gY291bnRZWihzdHIpe1xuICBsZXQgY291bnQ9MDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXN0cltpXS5tYXRjaCgvW2Etel0vaSkgfHwgc3RyLmNoYXJBdChpKSA9PSBcIiBcIikge1xuXG4gICAgICAgIGlmIChzdHIuY2hhckF0KGktMSkudG9Mb3dlckNhc2UoKSA9PSBcInlcIiB8fCBzdHIuY2hhckF0KGktMSkudG9Mb3dlckNhc2UoKSA9PSBcInpcIil7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09IHN0ci5sZW5ndGgtMSkge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChpKS50b0xvd2VyQ2FzZSgpID09IFwieVwiIHx8IHN0ci5jaGFyQXQoaSkudG9Mb3dlckNhc2UoKSA9PSBcInpcIil7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuc29sdXRpb25zLndpdGhvdXRTdHJpbmcgPSBmdW5jdGlvbiB3aXRob3V0U3RyaW5nKGJhc2UsIHJlbW92ZSl7XG5cbiAgbGV0IHJsZW4gPSByZW1vdmUubGVuZ3RoO1xuXG4gIGxldCByZXMgPSBcIlwiO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKyl7XG4gICAgbGV0IHN1YmJpZSA9IGJhc2Uuc3Vic3RyaW5nKGksIGkrIHJsZW4pO1xuICAgIGlmIChzdWJiaWUudG9Mb3dlckNhc2UoKSAhPSByZW1vdmUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBpZiAoYmFzZVtpXSA9PSBcIiBcIiAmJiByZXMuY2hhckF0KHJlcy5sZW5ndGgtMSkgPT0gXCIgXCIpe1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlW2ldO1xuICAgICAgICB9XG4gICAgfSAgZWxzZSB7XG4gICAgICBpICs9IHJsZW4tMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuc29sdXRpb25zLmVxdWFsSXNOb3QgPSBmdW5jdGlvbiBlcXVhbElzTm90KHN0cil7XG4gIGxldCBpcyA9IFwiaXNcIjtcbiAgbGV0IG5vdCA9IFwibm90XCI7XG5cbiAgbGV0IGlzQ291bnQgPSAwO1xuICBsZXQgbm90Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hlY2tJcyA9IHN0ci5zdWJzdHJpbmcoaSwgaStpcy5sZW5ndGgpO1xuICAgICAgbGV0IGNoZWNrTm90ID0gc3RyLnN1YnN0cmluZyhpLCBpK25vdC5sZW5ndGgpO1xuXG4gICAgICBpZiAoY2hlY2tJcyA9PSBpcyl7XG4gICAgICAgIGlzQ291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrTm90ID09IG5vdCl7XG4gICAgICAgIG5vdENvdW50ICs9IDE7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb3VudCA9PSBub3RDb3VudDtcblxufVxuXG5zb2x1dGlvbnMuZ0hhcHB5ID0gZnVuY3Rpb24gZ0hhcHB5KHN0cikge1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAoc3RyW2ldID09IFwiZ1wiICYmIChzdHJbaS0xXSAhPSBcImdcIiAmJiBzdHJbaSsxXSAhPSBcImdcIikpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLmNvdW50VHJpcGxlID0gZnVuY3Rpb24gY291bnRUcmlwbGUoc3RyKSB7XG5cbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBzdHIubGVuZ3RoLTI7IGkrKykge1xuICAgIGxldCB0cmlwbGUgPSBzdHIuc3Vic3RyaW5nKGksIGkrMyk7XG4gICAgaWYgKHRyaXBsZVswXSA9PSB0cmlwbGVbMV0gJiYgdHJpcGxlWzFdID09IHRyaXBsZVsyXSl7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy5zdW1EaWdpdHMgPSBmdW5jdGlvbiBzdW1EaWdpdHMoc3RyKSB7XG5cbiAgbGV0IGFkZCA9IChhLCBiKSA9PiBhK2I7XG5cbiAgbGV0IG51bXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludChzdHJbaV0pKSkge1xuICAgICAgICBudW1zLnB1c2gocGFyc2VJbnQoc3RyW2ldKSlcbiAgICB9XG4gIH1cblxuICAgIGlmIChudW1zLmxlbmd0aCAhPSAwKSB7XG4gICAgICByZXR1cm4gbnVtcy5yZWR1Y2UoYWRkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG5zb2x1dGlvbnMuc2FtZUVuZHMgPSBmdW5jdGlvbiBzYW1lRW5kcyhzdHJpbmcpIHtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aC8yKTtcbiAgICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aC8yO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoLzI7IGkrKyl7XG4gICAgICBpZiAoc3RyaW5nLnN1YnN0cmluZygwLCBlbmQpID09IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQpKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICBlbmQtLVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbnNvbHV0aW9ucy5taXJyb3JFbmRzID0gZnVuY3Rpb24gbWlycm9yRW5kcyhzdHJpbmcpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09IHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gaSAtIDFdKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnNvbHV0aW9ucy5tYXhCbG9jayA9IGZ1bmN0aW9uIG1heEJsb2NrKHN0cikge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3RpY2sgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAoaSA8IHN0ci5sZW5ndGgtMSAmJiBzdHJbaV0gPT0gc3RyW2krMV0pe1xuICAgICAgc3RpY2sgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RpY2sgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGljayA+IGNvdW50KXtcbiAgICAgIGNvdW50PSBzdGljaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG5cbn1cblxuc29sdXRpb25zLnN1bU51bWJlcnMgPSBmdW5jdGlvbiBzdW1OdW1iZXJzKHN0cikge1xuXG4gIGxldCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgdGVtcCA9IFwiXCI7XG4gIGxldCBzdW0gPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAocGFyc2VJbnQoc3RyW2ldKSl7XG4gICAgICBpZiAoaSA8IGxlbi0xICYmIHBhcnNlSW50KHN0cltpKzFdKSl7XG4gICAgICAgIHRlbXArPSBzdHJbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXArPSBzdHJbaV1cbiAgICAgICAgc3VtICs9IHBhcnNlSW50KHRlbXApO1xuICAgICAgICB0ZW1wPVwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbnNvbHV0aW9ucy5ub3RSZXBsYWNlID0gZnVuY3Rpb24gbm90UmVwbGFjZShzdHIpIHtcblxuICBsZXQgcmVzdWx0ID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8qIHVzaW5nIGNoYXJBdCBoZXJlIHJhdGhlciB0aGFuIGJyYWNrZXQgaW5kZXgsIGIvYyBicmFja2V0IGluZGV4IHNob3dzIHVuZGVmaW5lZCBmb3IgY2hhcnMgYXRcbiAgICAgIC0xIGluZGV4LCBjYXVzaW5nIGVycm9yLiBjaGFyQXQgc2hvd3MgXCJcIiwgc28gbm8gZXJyb3IqL1xuICAgICAgaWYgKChzdHIuY2hhckF0KGktMSkubWF0Y2goL1thLXpdL2kpXG4gICAgfHwgaSsyIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KGkrMikubWF0Y2goL1thLXpdL2kpKSl7XG4gICAgICAgIHJlc3VsdCArPSBzdHJbaV07XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHJpbmcoaSwgaSsyKSA9PSBcImlzXCIpe1xuICAgICAgICByZXN1bHQgKz0gXCJpcyBub3RcIjtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZXN1bHQgKz0gc3RyW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU2xlZXBJblwiLFxuICAgIHF1ZXN0aW9uOiBgVGhlIHBhcmFtZXRlciBXRUVLREFZIGlzIFRSVUUgaWYgaXQgaXMgYSB3ZWVrZGF5LCBhbmQgdGhlIHBhcmFtZXRlclxuICAgICAgICAgVkFDQVRJT04gaXMgRkFMU0UgaWYgd2UgYXJlIG9uIHZhY2F0aW9uLiBXZSBzbGVlcCBpbiBpZiBpdCBpcyBub3QgYSB3ZWVrZGF5IG9yXG4gICAgICAgICB3ZSdyZSBvbiB2YWNhdGlvbi4gT3V0cHV0IFRSVUUgaWYgd2Ugc2xlZXAgaW4sIEZBTFNFIGlmIHdlIGRvIG5vdC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIHNsZWVwSW4oV0VFS0RBWSwgVkFDQVRJT04pXG4gIGlmIE5PVCBXRUVLREFZIE9SIFZBQ0FUSU9OIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG5cbiAgICAgIFwiKFRSVUUsIFRSVUUpXCIsXG4gICAgICBcIihUUlVFLCBGQUxTRSlcIixcbiAgICAgIFwiKEZBTFNFLCBUUlVFKVwiLFxuICAgICAgXCIoRkFMU0UsIEZBTFNFKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTW9ua2V5VHJvdWJsZVwiLFxuICAgIHF1ZXN0aW9uOiBgV2UgaGF2ZSB0d28gbW9ua2V5cywgYSBhbmQgYiwgYW5kIHRoZSBwYXJhbWV0ZXJzIEFTTUlMRSBhbmRcbiAgICAgICAgICAgICAgQlNNSUxFIGluZGljYXRlIGlmIGVhY2ggaXMgc21pbGluZy4gV2UgYXJlIGluIHRyb3VibGUgaWYgdGhleSBhcmUgYm90aCBzbWlsaW5nXG4gICAgICAgICAgICAgIG9yIGlmIG5laXRoZXIgb2YgdGhlbSBpcyBzbWlsaW5nLiBPdXRwdXQgVFJVRSBpZiB3ZSBhcmUgaW4gdHJvdWJsZSwgRkFMU0Ugb3RoZXJ3aXNlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTW9ua2V5VHJvdWJsZShBU01JTEUsIEJTTUlMRSlcbiAgaWYgKEFTTUlMRSBBTkQgQlNNSUxFKSBPUiAoTk9UIEFTTUlMRSBBTkQgTk9UIEJTTUlMRSkgdGhlblxuICAvLyBhbHRlcm5hdGl2ZTogaWYgQVNNSUxFID0gQlNNSUxFIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihUUlVFLCBUUlVFKVwiLFxuICAgICAgXCIoRkFMU0UsIEZBTFNFKVwiLFxuICAgICAgXCIoVFJVRSwgRkFMU0UpXCIsXG4gICAgICBcIihGQUxTRSwgVFJVRSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN1bURvdWJsZVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdHdvIG51bWJlcnMsIG91dHB1dCB0aGVpciBzdW0uIFVubGVzcyB0aGUgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUsXG4gICAgICAgdGhlbiBvdXRwdXQgZG91YmxlIHRoZWlyIHN1bS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN1bURvdWJsZShBLCBCKVxuICBpZiBBID0gQiB0aGVuXG4gICAgb3V0cHV0IDIqIChBICsgQilcbiAgZWxzZVxuICAgIG91dHB1dCBBICsgQlxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMSwgMilcIixcbiAgICAgIFwiKDMsIDIpXCIsXG4gICAgICBcIigyLCAyKVwiLFxuICAgICAgXCIoLTEsIDApXCIsXG4gICAgICBcIigzLCAzKVwiLFxuICAgICAgXCIoMCwgMClcIixcbiAgICAgIFwiKDAsIDEpXCIsXG4gICAgICBcIigzLCA0KVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiRGlmZjIxXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBudW1iZXIsIE4sIG91dHB1dCB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIE4gYW5kIDIxLFxuICAgICAgICAgICAgICAgIGV4Y2VwdCBvdXRwdXQgZG91YmxlIHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGlmIE4gaXMgb3ZlciAyMS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIERpZmYyMShOKVxuICBpZiBOIDw9IDIxIHRoZW5cbiAgICBvdXRwdXQgMjEgLSBOXG4gIGVsc2VcbiAgICBvdXRwdXQgKE4gLSAyMSkgKiAyXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxOSlcIixcbiAgICAgIFwiKDEwKVwiLFxuICAgICAgXCIoMjEpXCIsXG4gICAgICBcIigyMilcIixcbiAgICAgIFwiKDI1KVwiLFxuICAgICAgXCIoMzApXCIsXG4gICAgICBcIigwKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIigtMSlcIixcbiAgICAgIFwiKC0yKVwiLFxuICAgICAgXCIoNTApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJQYXJyb3RUcm91YmxlXCIsXG4gICAgcXVlc3Rpb246IGBXZSBoYXZlIGEgbG91ZCB0YWxraW5nIHBhcnJvdC4gVGhlIFwiaG91clwiIHBhcmFtZXRlciBpcyB0aGUgY3VycmVudCBob3VyIHRpbWUgaW4gdGhlIHJhbmdlIDAuLjIzLlxuICAgIFdlIGFyZSBpbiB0cm91YmxlIGlmIHRoZSBwYXJyb3QgaXMgdGFsa2luZyBhbmQgdGhlIGhvdXIgaXMgYmVmb3JlIDcgb3IgYWZ0ZXIgMjAuXG4gICAgT3V0cHV0IFRSVUUgaWYgd2UgYXJlIGluIHRyb3VibGUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBQYXJyb3RUcm91YmxlKFRBTEtJTkcsIEhPVVIpXG4gIGlmIFRBTEtJTkcgQU5EIChIT1VSIDwgNyBPUiBIT1VSID4gMjApIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlIFxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoVFJVRSwgNilcIixcbiAgICAgIFwiKFRSVUUsIDcpXCIsXG4gICAgICBcIihGQUxTRSwgNilcIixcbiAgICAgIFwiKFRSVUUsIDIxKVwiLFxuICAgICAgXCIoRkFMU0UsIDIxKVwiLFxuICAgICAgXCIoVFJVRSwgMjMpXCIsXG4gICAgICBcIihGQUxTRSwgMjMpXCIsXG4gICAgICBcIihUUlVFLCAyMClcIixcbiAgICAgIFwiKEZBTFNFLCAxMilcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk1ha2VzMTBcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgbnVtYmVycywgQSBhbmQgQiwgT3V0cHV0IFRSVUUgaWYgb25lIGlmIHRoZW0gaXMgMTAgb3IgaWYgdGhlaXIgc3VtIGlzIDEwLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWFrZXMxMChBLCBCKVxuICBpZiBBID0gMTAgT1IgQiA9IDEwIE9SIChBICsgQiA9IDEwKSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoOSwgMTApXCIsXG4gICAgICBcIig5LCA5KVwiLFxuICAgICAgXCIoMSwgOSlcIixcbiAgICAgIFwiKDEwLCAxKVwiLFxuICAgICAgXCIoMTAsIDEwKVwiLFxuICAgICAgXCIoOCwgMilcIixcbiAgICAgIFwiKDgsIDMpXCIsXG4gICAgICBcIigxMCwgNDIpXCIsXG4gICAgICBcIigxMiwgLTIpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJOZWFySHVuZHJlZFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgTiwgT3V0cHV0IFRSVUUgaWYgaXQgaXMgd2l0aGluIDEwIG9mIDEwMCBvciAyMDAuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBuZWFySHVuZHJlZChOKSBcbiAgaWYgKDEwMCAtIE4pID49IC0xMCBBTkQgKDEwMCAtIE4pIDw9IDEwIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlIGlmICgyMDAgLSBOKSA+PSAtMTAgQU5EICgyMDAgLSBOKSA8PSAxMCB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoOTMpXCIsXG4gICAgICBcIig5MClcIixcbiAgICAgIFwiKDg5KVwiLFxuICAgICAgXCIoMTEwKVwiLFxuICAgICAgXCIoMTExKVwiLFxuICAgICAgXCIoMTIxKVwiLFxuICAgICAgXCIoMClcIixcbiAgICAgIFwiKDUpXCIsXG4gICAgICBcIigxOTEpXCIsXG4gICAgICBcIigxODkpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJQb3NOZWdcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgbnVtYmVyIHZhbHVlcywgT3V0cHV0IFRSVUUgaWYgb25lIGlzIG5lZ2F0aXZlIGFuZCBvbmUgaXMgcG9zaXRpdmUuXG4gICAgICAgICAgRXhjZXB0IGlmIHRoZSBwYXJhbWV0ZXIgTkVHQVRJVkUgaXMgVFJVRSwgdGhlbiBvdXRwdXQgVFJVRSBvbmx5IGlmIGJvdGggYXJlIG5lZ2F0aXZlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgUG9zTmVnKEEsIEIsIE5FR0FUSVZFKSBcbiAgaWYgTkVHQVRJVkUgdGhlblxuICAgIGlmIEEgPCAwIEFORCBCIDwgMCB0aGVuXG4gICAgICBvdXRwdXQgVFJVRVxuICAgIGVsc2VcbiAgICAgIG91dHB1dCBGQUxTRVxuICAgIGVuZCBpZlxuICBlbHNlIGlmIChBIDwgMCBBTkQgQiA+IDApIE9SIChBID4gMCBBTkQgQiA8IDApIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxLCAtMSwgRkFMU0UpXCIsXG4gICAgICBcIigtMSwgMSwgRkFMU0UpXCIsXG4gICAgICBcIigtNCwgLTUsIFRSVUUpXCIsXG4gICAgICBcIigtNCwgLTUsIEZBTFNFKVwiLFxuICAgICAgXCIoLTQsIDUsIEZBTFNFKVwiLFxuICAgICAgXCIoLTQsIDUsIFRSVUUpXCIsXG4gICAgICBcIigxLCAxLCBGQUxTRSlcIixcbiAgICAgIFwiKC0xLCAtMSwgRkFMU0UpXCIsXG4gICAgICBcIigxLCAtMSwgVFJVRSlcIixcbiAgICAgIFwiKC0xLCAxLCBUUlVFKVwiLFxuICAgICAgXCIoMSwgMSwgVFJVRSlcIixcbiAgICAgIFwiKC0xLCAtMSwgVFJVRSlcIixcbiAgICAgIFwiKDUsIC01LCBGQUxTRSlcIixcbiAgICAgIFwiKC02LCA2LCBGQUxTRSlcIixcbiAgICAgIFwiKC01LCAtNiwgRkFMU0UpXCIsXG4gICAgICBcIigtMiwgLTEsIEZBTFNFKVwiLFxuICAgICAgXCIoMSwgMiwgRkFMU0UpXCIsXG4gICAgICBcIigtNSwgNiwgVFJVRSlcIixcbiAgICAgIFwiKC01LCAtNSwgVFJVRSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk5vdFN0cmluZ1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIG91dHB1dCBhIG5ldyBzdHJpbmcgd2hlcmUgXCJub3QgXCIgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZyb250LiBIb3dldmVyLFxuICAgICAgaWYgdGhlIHN0cmluZyBhbHJlYWR5IGJlZ2lucyB3aXRoIFwibm90XCIsIG91dHB1dCB0aGUgc3RyaW5nIHVuY2hhbmdlZC4gWW91IGNhbiB1c2UgdGhlIG1ldGhvZCBTVFJJTkcuU3ViU3RyKFMsTClcbiAgICAgIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50YCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBOb3RTdHJpbmcoU1RSKVxuICBpZiBTVFIuU3ViU3RyKDAsMykgPSBcIm5vdFwiIHRoZW5cbiAgICBvdXRwdXQgU1RSXG4gIGVsc2UgXG4gICAgb3V0cHV0IFwibm90XCIrIFNUUlxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ2NhbmR5JylcIixcbiAgICAgIFwiKCd4JylcIixcbiAgICAgIFwiKCdub3QgYmFkJylcIixcbiAgICAgIFwiKCdiYWQnKVwiLFxuICAgICAgXCIoJ25vdCcpXCIsXG4gICAgICBcIignaXMgbm90JylcIixcbiAgICAgIFwiKCdubycpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJGcm9udDNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCB3ZSdsbCBzYXkgdGhhdCB0aGUgZnJvbnQgaXMgdGhlIGZpcnN0IDMgY2hhcnMgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgICAgICAgSWYgdGhlIHN0cmluZyBsZW5ndGggaXMgbGVzcyB0aGFuIDMsIHRoZSBmcm9udCBpcyB3aGF0ZXZlciBpcyB0aGVyZS4gT3V0cHV0IGEgbmV3XG4gICAgICAgICAgICAgIHN0cmluZyB3aGljaCBpcyAzIGNvcGllcyBvZiB0aGUgZnJvbnQuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gICAgICAgICAgICAgIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRnJvbnQzKFNUUikgXG4gIEZST05UID0gU1RSLlN1YlN0cigwLDMpXG4gIG91dHB1dCBGUk9OVCArIEZST05UICsgRlJPTlRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0phdmEnKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZScpXCIsXG4gICAgICBcIignYWJjJylcIixcbiAgICAgIFwiKCdhYmNYWVonKVwiLFxuICAgICAgXCIoJ2FiJylcIixcbiAgICAgIFwiKCdhJylcIixcbiAgICAgIFwiKCcnKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiT3IzNVwiLFxuICAgIHF1ZXN0aW9uOiBgT3V0cHV0IFRSVUUgaWYgdGhlIGdpdmVuIG5vbi0gbmVnYXRpdmUgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgMyBvciBhXG4gICAgICAgICAgICAgIG11bHRpcGxlIG9mIDUuKEhpbnQ6IFVzZSB0aGUgPCBjb2RlID4gbW9kIG9wZXJhdG9yKWAsXG4gICAgc29sdXRpb246IGBtZXRob2QgT3IzNShuKSBcbiAgaWYgbiBtb2QgMyA9IDAgT1IgbiBtb2QgNSA9IDAgdGhlbiBcbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigzKVwiLFxuICAgICAgXCIoMTApXCIsXG4gICAgICBcIig4KVwiLFxuICAgICAgXCIoMTUpXCIsXG4gICAgICBcIig1KVwiLFxuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDkpXCIsXG4gICAgICBcIig0KVwiLFxuICAgICAgXCIoNylcIixcbiAgICAgIFwiKDYpXCIsXG4gICAgICBcIigxNylcIixcbiAgICAgIFwiKDE4KVwiLFxuICAgICAgXCIoMjkpXCIsXG4gICAgICBcIigyMClcIixcbiAgICAgIFwiKDIxKVwiLFxuICAgICAgXCIoMjIpXCIsXG4gICAgICBcIig0NSlcIixcbiAgICAgIFwiKDk5KVwiLFxuICAgICAgXCIoMTAwKVwiLFxuICAgICAgXCIoMTAxKVwiLFxuICAgICAgXCIoMTIxKVwiLFxuICAgICAgXCIoMTIyKVwiLFxuICAgICAgXCIoMTIzKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiRnJvbnQyMlwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIHRha2UgdGhlIGZpcnN0IDIgY2hhcnMgYW5kIG91dHB1dCB0aGUgc3RyaW5nIHdpdGggdGhlIDJcbiAgY2hhcnMgYWRkZWQgYXQgYm90aCB0aGUgZnJvbnQgYW5kIGJhY2ssIHNvICdraXR0ZW4nIHlpZWxkcyAna2lraXR0ZW5raScuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRnJvbnQyMihTVFIpIFxuICBGUk9OVCA9IFNUUi5TdWJTdHIoMCwgMilcbiAgb3V0cHV0IEZST05UICsgU1RSICsgRlJPTlRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ2tpdHRlbicpXCIsXG4gICAgICBcIignSGEnKVwiLFxuICAgICAgXCIoJ2FiYycpXCIsXG4gICAgICBcIignYWInKVwiLFxuICAgICAgXCIoJ2EnKVwiLFxuICAgICAgXCIoJycpXCIsXG4gICAgICBcIignTG9naWMnKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU3RhcnRIaVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIE91dHB1dCBUUlVFIGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggJ2hpJ2FuZFxuICBGQUxTRSBvdGhlcndpc2UuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RhcnRIaShTVFIpIFxuICBGUk9OVCA9IFNUUi5TdWJTdHIoMCwyKTtcbiAgaWYgRlJPTlQgPSAnaGknIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIignaGkgdGhlcmUnKVwiLFxuICAgICAgXCIoJ2hpJylcIixcbiAgICAgIFwiKCdoZWxsbyBoaScpXCIsXG4gICAgICBcIignaGUnKVwiLFxuICAgICAgXCIoJ2gnKVwiLFxuICAgICAgXCIoJycpXCIsXG4gICAgICBcIignaG8gaGknKVwiLFxuICAgICAgXCIoJ2hpIGhvJylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkljeUhvdFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdHdvIHRlbXBlcmF0dXJlcywgT3V0cHV0IFRSVUUgaWYgb25lIGlzIGxlc3MgdGhhbiAwIGFuZCB0aGVcbiAgb3RoZXIgaXMgZ3JlYXRlciB0aGFuIDEwMC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEljeUhvdChURU1QMSwgVEVNUDIpIFxuICBpZiBURU1QMSA8IDAgQU5EIFRFTVAyID4gMTAwIE9SIFRFTVAyIDwgMCBBTkQgVEVNUDEgPiAxMDAgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVuZCBpZlxuICBvdXRwdXQgRkFMU0VcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMTIwLCAtMSlcIixcbiAgICAgIFwiKC0xLCAxMjApXCIsXG4gICAgICBcIigyLCAxMjApXCIsXG4gICAgICBcIigtMSwgMTAwKVwiLFxuICAgICAgXCIoLTIsIDEyMClcIixcbiAgICAgIFwiKDEyMCwgMTIwKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiSW4xMDIwXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIG51bWJlciB2YWx1ZXMsIE91dHB1dCBUUlVFIGlmIGVpdGhlciBvciBib3RoIG9mIHRoZW0gaXMgaW4gdGhlIHJhbmdlXG4gIDEwLi4yMCBpbmNsdXNpdmUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBJbjEwMjAoQSwgQikgXG4gIGlmIChBID49IDEwIEFORCBBIDw9IDIwKSBPUiAoQiA+PSAxMCBBTkQgQiA8PSAyMCkgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDEyLCA5OSlcIixcbiAgICAgIFwiKDIxLCAxMilcIixcbiAgICAgIFwiKDgsIDk5KVwiLFxuICAgICAgXCIoOTksIDEwKVwiLFxuICAgICAgXCIoMjAsIDIwKVwiLFxuICAgICAgXCIoMjEsIDIxKVwiLFxuICAgICAgXCIoOSwgOSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkhhc1RlZW5cIixcbiAgICBxdWVzdGlvbjogYFdlJ2xsIHNheSB0aGF0IGEgbnVtYmVyIGlzICd0ZWVuJyBpZiBpdCBpcyBpbiB0aGUgcmFuZ2UgMTMuLjE5IGluY2x1c2l2ZS4gR2l2ZW4gMyBpbnQgdmFsdWVzLFxuICBPdXRwdXQgVFJVRSBpZiAxIG9yIG1vcmUgb2YgdGhlbSBhcmUgdGVlbi5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEhhc1RlZW4oQSwgQiwgQykgXG4gIGlmIChBID49IDEzIEFORCBBIDw9IDE5KSBPUiAoQiA+PSAxMyBBTkQgQiA8PSAxOSkgT1IgKEMgPj0gMTMgQU5EIEMgPD0gMTkpIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxMywgMjAsIDEwKVwiLFxuICAgICAgXCIoMjAsIDE5LCAxMClcIixcbiAgICAgIFwiKDIwLCAxMCwgMTMpXCIsXG4gICAgICBcIigxLCAyMCwgMTIpXCIsXG4gICAgICBcIigxOSwgMjAsIDEyKVwiLFxuICAgICAgXCIoMTIsIDIwLCAxOSlcIixcbiAgICAgIFwiKDEyLCA5LCAyMClcIixcbiAgICAgIFwiKDEyLCAxOCwgMjApXCIsXG4gICAgICBcIigxNCwgMiwgMjApXCIsXG4gICAgICBcIig0LCAyLCAyMClcIixcbiAgICAgIFwiKDExLCAyMiwgMjIpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJMb25lVGVlblwiLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYSBudW1iZXIgaXMgJ3RlZW4nIGlmIGl0IGlzIGluIHRoZSByYW5nZSAxMy4uMTkgaW5jbHVzaXZlLlxuICBHaXZlbiAyIGludCB2YWx1ZXMsIE91dHB1dCBUUlVFIGlmIG9uZSBvciB0aGUgb3RoZXIgaXMgdGVlbiwgYnV0IG5vdCBib3RoLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTG9uZVRlZW4oQSwgQikgXG4gIGlmIEEgPj0xMyBBTkQgQSA8PTE5IEFORCAoQiA8IDEzIE9SIEIgPiAxOSkgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2UgaWYgKEEgPCAxMyBPUiBBID4gMTkpIEFORCBCID49IDEzIEFORCBCIDw9IDE5IHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxMywgOTkpXCIsXG4gICAgICBcIigyMSwgMTkpXCIsXG4gICAgICBcIigxMywgMTMpXCIsXG4gICAgICBcIigxNCwgMjApXCIsXG4gICAgICBcIigyMCwgMTUpXCIsXG4gICAgICBcIigxNiwgMTcpXCIsXG4gICAgICBcIigxNiwgOSlcIixcbiAgICAgIFwiKDE2LCAxOClcIixcbiAgICAgIFwiKDEzLCAxOSlcIixcbiAgICAgIFwiKDEzLCAyMClcIixcbiAgICAgIFwiKDYsIDE4KVwiLFxuICAgICAgXCIoOTksIDEzKVwiLFxuICAgICAgXCIoOTksIDk5KVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTWl4U3RhcnRcIixcbiAgICBxdWVzdGlvbjogYE91dHB1dCBUUlVFIGlmIHRoZSBnaXZlbiBzdHJpbmcgYmVnaW5zIHdpdGggJ21peCcsIGV4Y2VwdCB0aGUgJ20nIGNhbiBiZVxuICBhbnl0aGluZywgc28gJ3BpeCcsICc5aXgnLi5hbGwgY291bnQuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpIHRvIGdldCBhIHN1YnN0cmluZ1xuICB3aGVyZSBTIGlzIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgc3Vic3RyaW5nIChmaXJzdCBjaGFyIGlzIDAhKSBhbmQgTCBpcyBob3cgbWFueSBjaGFycyB5b3Ugd2FudCAoYXQgbWF4KS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1peFN0YXJ0KFNUUikgXG4gIGlmIFNUUi5sZW5ndGggPCAzIHRoZW5cbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG4gIFRXTyA9IFNUUi5TdWJTdHIoMSwgMik7XG4gIGlmIFRXTyA9ICdpeCcgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdtaXggc25hY2tzJylcIixcbiAgICAgIFwiKCdwaXggc25hY2tzJylcIixcbiAgICAgIFwiKCdwaXogc25hY2tzJylcIixcbiAgICAgIFwiKCduaXgnKVwiLFxuICAgICAgXCIoJ25pJylcIixcbiAgICAgIFwiKCduJylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkludE1heFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdGhyZWUgaW50IHZhbHVlcywgQSwgQiwgYW5kIEMsIG91dHB1dCB0aGUgbGFyZ2VzdC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEludE1heChBLCBCLCBDKSBcbiAgTUFYID0gMFxuICBpZiBBID4gQiB0aGVuXG4gICAgTUFYID0gQVxuICBlbHNlXG4gICAgTUFYID0gQlxuICBlbmQgaWZcbiAgaWYgQyA+IE1BWCB0aGVuXG4gICAgTUFYID0gQ1xuICBlbmQgaWZcbiAgb3V0cHV0IE1BWFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxLCAyLCAzKVwiLFxuICAgICAgXCIoMSwgMywgMilcIixcbiAgICAgIFwiKDMsIDIsIDEpXCIsXG4gICAgICBcIig5LCAzLCAzKVwiLFxuICAgICAgXCIoMywgOSwgMylcIixcbiAgICAgIFwiKDMsIDMsIDkpXCIsXG4gICAgICBcIig4LCAyLCAzKVwiLFxuICAgICAgXCIoLTMsIC0xLCAtMilcIixcbiAgICAgIFwiKDYsIDIsIDUpXCIsXG4gICAgICBcIig1LCA2LCAyKVwiLFxuICAgICAgXCIoNSwgMiwgNilcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkNsb3NlMTBcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50IHZhbHVlcywgb3V0cHV0IHdoaWNoZXZlciB2YWx1ZSBpcyBuZWFyZXN0IHRvIHRoZSB2YWx1ZSAxMCxcbiAgICBvciBvdXRwdXQgMCBpbiB0aGUgZXZlbnQgb2YgYSB0aWUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBDbG9zZTEwKEEsIEIpIFxuICBBREYgPSBBIC0gMTBcbiAgaWYgQURGIDwgMCB0aGVuXG4gICAgQURGID0gMTAgLSBBXG4gIGVuZCBpZlxuXG4gIEJERiA9IEIgLSAxMFxuICBpZiBCREYgPCAwIHRoZW5cbiAgICBCREYgPSAxMCAtIEJcbiAgZW5kIGlmXG5cbiAgaWYgQURGIDwgQkRGIHRoZW5cbiAgICBvdXRwdXQgQVxuICBlbHNlIGlmIEJERiA8IEFERiB0aGVuXG4gICAgb3V0cHV0IEJcbiAgZWxzZVxuICAgIG91dHB1dCAwXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIig4LCAxMylcIixcbiAgICAgIFwiKDEzLCA4KVwiLFxuICAgICAgXCIoMTMsIDcpXCIsXG4gICAgICBcIig3LCAxMylcIixcbiAgICAgIFwiKDksIDEzKVwiLFxuICAgICAgXCIoMTMsIDgpXCIsXG4gICAgICBcIigxMCwgMTIpXCIsXG4gICAgICBcIigxMSwgMTApXCIsXG4gICAgICBcIig1LCAyMSlcIixcbiAgICAgIFwiKDAsIDIwKVwiLFxuICAgICAgXCIoMCwgMjApXCIsXG4gICAgICBcIigxMCwgMTApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdHJpbmdFXCIsXG4gICAgcXVlc3Rpb246IGBPdXRwdXQgVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGJldHdlZW4gMSBhbmQgMyBlIGNoYXJzLiBcbiAgICAgIEhpbnQ6IHRoZSBsZW5ndGggb2YgYSBzdHJpbmcgY2FuIGJlIGZvdW5kIHVzaW5nIHRoZSBTVFIuTGVuZ3RoKCkgbWV0aG9kLCBhbmQgeW91IGNhbiBhY2Nlc3Mgb25lIGNoYXJcbiAgICAgIHdpdGhpbiBhIHN0cmluZyB1c2luZyBicmFja2V0cywgc28gaWYgU1QgPSBcIkFCQ1wiIHRoZW4gU1RbMV0gZ2l2ZXMgeW91IGEgQmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RyaW5nRShTVFIpIFxuICBDT1VOVCA9IDBcbiAgbG9vcCBJIGZyb20gMCB0byBTVFIuTGVuZ3RoKClcbiAgICBpZiBTVFJbSV0gPSAnZScgdGhlblxuICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgaWYgQ09VTlQgPj0gMSBBTkQgQ09VTlQgPD0gMyB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRSBcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIignSGVlbGxlJylcIixcbiAgICAgIFwiKCdIZWVsZWxlJylcIixcbiAgICAgIFwiKCdISUknKVwiLFxuICAgICAgXCIoJ2UnKVwiLFxuICAgICAgXCIoJycpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJMYXN0RGlnaXRcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIHR3byBub24gLSBuZWdhdGl2ZSBpbnQgdmFsdWVzLCBPdXRwdXQgVFJVRSBpZiB0aGV5IGhhdmUgdGhlIHNhbWVcbiAgbGFzdCBkaWdpdCwgc3VjaCBhcyB3aXRoIDI3IGFuZCA1Ny4gTm90ZSB0aGF0IHRoZSBtb2Qgb3BlcmF0b3IgY29tcHV0ZXNcbiAgcmVtYWluZGVycywgc28gMTcgbW9kIDEwIGlzIDcuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBMYXN0RGlnaXQoQSwgQikgXG4gIGlmIEEgbW9kIDEwID0gQiBtb2QgMTAgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDcsIDE3KVwiLFxuICAgICAgXCIoNiwgMTcpXCIsXG4gICAgICBcIigzLCAxMTMpXCIsXG4gICAgICBcIigxMTQsIDExMylcIixcbiAgICAgIFwiKDExNCwgNClcIixcbiAgICAgIFwiKDEwLCAwKVwiLFxuICAgICAgXCIoMTEsIDApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJFdmVyeU50aFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24gLSBlbXB0eSBzdHJpbmcgYW5kIGFuIGludCBOLCBvdXRwdXQgdGhlIHN0cmluZyBtYWRlIHN0YXJ0aW5nXG4gIHdpdGggY2hhciAwLCBhbmQgdGhlbiBldmVyeSBOdGggY2hhciBvZiB0aGUgc3RyaW5nLiBTbyBpZiBOIGlzIDMsIHVzZSBjaGFyIDAsIDMsIDYsXG4gICAgICAgICAgICAgICAgICAgICAuLi5hbmQgc28gb24uIE4gd2lsbCBhbHdheXMgYmUgMSBvciBtb3JlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRXZlcnlOdGgoU1RSLCBOKSBcbiAgUkVTVUxUID0gXCJcIlxuICBDT1VOVCA9IDBcbiAgbG9vcCB3aGlsZSBDT1VOVCA8IFNUUi5MZW5ndGgoKVxuICAgIFJFU1VMVCA9IFJFU1VMVCArIFNUUltDT1VOVF1cbiAgICBDT1VOVCA9IENPVU5UICsgTlxuICB9XG4gIG91dHB1dCBSRVNVTFRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ01pcmFjbGUnLCAyKVwiLFxuICAgICAgXCIoJ2FiY2RlZmcnLCAyKVwiLFxuICAgICAgXCIoJ2FiY2RlZmcnLCAzKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZScsIDMpXCIsXG4gICAgICBcIignQ2hvY29sYXRlcycsIDMpXCIsXG4gICAgICBcIignQ2hvY29sYXRlcycsIDQpXCIsXG4gICAgICBcIignQ2hvY29sYXRlcycsIDEwMClcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN0cmluZ1RpbWVzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHN0cmluZyBhbmQgYSBub24tbmVnYXRpdmUgaW50ZWdlciBOLCBvdXRwdXQgYSBsYXJnZXIgc3RyaW5nIHRoYXQgaXMgTlxuICBjb3BpZXMgb2YgdGhlIG9yaWdpbmFsIHN0cmluZy5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN0cmluZ1RpbWVzKFNUUiwgTikgXG4gIEZJTkFMID0gXCJcIlxuICBsb29wIEkgZnJvbSAxIHRvIE4gXG4gICAgRklOQUwgPSBGSU5BTCArIFNUUlxuICBlbmQgbG9vcFxuICBvdXRwdXQgRklOQUxcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0hpJywgMilcIixcbiAgICAgIFwiKCdIaScsIDMpXCIsXG4gICAgICBcIignSGknLCAxKVwiLFxuICAgICAgXCIoJ0hpJywgMClcIixcbiAgICAgIFwiKCdIaScsIDUpXCIsXG4gICAgICBcIignT2ggQm95IScsIDIpXCIsXG4gICAgICBcIigneCcsIDQpXCIsXG4gICAgICBcIignJywgNClcIixcbiAgICAgIFwiKCdjb2RlJywgMilcIixcbiAgICAgIFwiKCdjb2RlJywgMylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkZyb250VGltZXNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nIGFuZCBhIG5vbiAtIG5lZ2F0aXZlIGludCBuLCB3ZSdsbCBzYXkgdGhhdCB0aGUgZnJvbnQgb2YgdGhlIHN0cmluZyBpcyB0aGUgZmlyc3QgMyBjaGFycyxcbiAgb3Igd2hhdGV2ZXIgaXMgdGhlcmUgaWYgdGhlIHN0cmluZyBpcyBsZXNzIHRoYW4gbGVuZ3RoIDMuIE91dHB1dCBuIGNvcGllcyBvZiB0aGUgZnJvbnQuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGcm9udFRpbWVzKFNUUiwgTikgXG4gIEZST05UID0gU1RSLlN1YlN0cigwLDMpXG4gIFJFU1VMVCA9IFwiXCJcbiAgbG9vcCBYIGZyb20gMSB0byBOIFxuICAgIFJFU1VMVCA9IFJFU1VMVCArIEZST05UXG4gIGVuZCBsb29wXG4gIG91dHB1dCBSRVNVTFRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0Nob2NvbGF0ZScsIDIpXCIsXG4gICAgICBcIignQ2hvY29sYXRlJywgMylcIixcbiAgICAgIFwiKCdBYmMnLCAzKVwiLFxuICAgICAgXCIoJ0FiJywgNClcIixcbiAgICAgIFwiKCdBJywgNClcIixcbiAgICAgIFwiKCcnLDQpXCIsXG4gICAgICBcIignQWJjJywgMClcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN0cmluZ0JpdHNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCBvdXRwdXQgYSBuZXcgc3RyaW5nIG1hZGUgb2YgZXZlcnkgb3RoZXIgY2hhciBzdGFydGluZ1xuICB3aXRoIHRoZSBmaXJzdCwgc28gXCJIZWxsb1wiIHlpZWxkcyBcIkhsb1wiLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RyaW5nQml0cyhTVFIpIFxuICBPVVQgPSBcIlwiXG4gIFggPSAwXG4gIGxvb3Agd2hpbGUgWCA8IFNUUi5sZW5ndGhcbiAgICBPVVQgPSBPVVQgKyBTVFIuU3ViU3RyKFgsIDEpXG4gICAgWCA9IFggKyAyXG4gIGVuZCBsb29wXG4gIG91dHB1dCBPVVRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0hlbGxvJylcIixcbiAgICAgIFwiKCdIaScpXCIsXG4gICAgICBcIignSGVlb2xvbGVvJylcIixcbiAgICAgIFwiKCdIaUhpSGknKVwiLFxuICAgICAgXCIoJycpXCIsXG4gICAgICBcIignR3JlZXRpbmdzJylcIixcbiAgICAgIFwiKCdDaG9jb2xhdGUnKVwiLFxuICAgICAgXCIoJ3BpJylcIixcbiAgICAgIFwiKCdIZWxsbyBLaXR0ZW4nKVwiLFxuICAgICAgXCIoJ2h4YXhweHB4eScpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdHJpbmdTcGxvc2lvblwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24tZW1wdHkgc3RyaW5nIGxpa2UgXCJDb2RlXCIgb3V0cHV0IGEgc3RyaW5nIGxpa2UgXCJDQ29Db2RDb2RlXCIuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdHJpbmdTcGxvc2lvbihTVFIpIFxuICBSRVNVTFQgPSBcIlwiXG4gIGxvb3AgWCBmcm9tIDEgdG8gU1RSLkxlbmd0aCgpXG4gICAgUkVTVUxUID0gUkVTVUxUICsgU1RSLlN1YlN0cigwLCBYKVxuICBlbmQgbG9vcFxuICBvdXRwdXQgUkVTVUxUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoXCJDb2RlXCIpJyxcbiAgICAgICcoXCJCb2JcIiknLFxuICAgICAgJyhcIkFwcGxlXCIpJyxcbiAgICAgICcoXCJTdHJcIiknLFxuICAgICAgJyhcIjEyM1wiKSdcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheUNvdW50OVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgb3V0cHV0IHRoZSBudW1iZXIgb2YgOSdzIGluIHRoZSBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5Q291bnQ5KE5VTVMpIFxuICBDT1VOVCA9IDBcbiAgbG9vcCBYIGZyb20gMCB0byBOVU1TLkxlbmd0aCgpLTFcbiAgICBpZiBOVU1TW1hdID0gOSB0aGVuXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgQ09VTlRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsMiw5XSlcIixcbiAgICAgIFwiKFsxLDksOV0pXCIsXG4gICAgICBcIihbMSw5LDksMyw5XSlcIixcbiAgICAgIFwiKFsxLDIsM10pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs0LDIsNCwzLDFdKVwiLFxuICAgICAgXCIoWzksMiw0LDMsMV0pXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheUZyb250OVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgT3V0cHV0IFRSVUUgaWYgb25lIG9mIHRoZSBmaXJzdCA0IGVsZW1lbnRzIGluXG4gICAgICAgICAgICB0aGUgYXJyYXkgaXMgYSA5LiBUaGUgYXJyYXkgbGVuZ3RoIG1heSBiZSBsZXNzIHRoYW4gNC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5RnJvbnQ5KE5VTVMpIFxuICBFTkQgPSAzXG4gIEZPVU5EID0gRkFMU0VcbiAgaWYgTlVNUy5MZW5ndGgoKSA8IDQgdGhlblxuICAgIEVORCA9IE5VTVMuTGVuZ3RoKCkgLSAxXG4gIGVuZCBpZlxuICBsb29wIFggZnJvbSAwIHRvIEVORFxuICAgIGlmIE5VTVNbWF0gPSA5IHRoZW5cbiAgICAgIEZPVU5EID0gVFJVRVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgRk9VTkRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsMiw5LDMsNF0pXCIsXG4gICAgICBcIihbMSwyLDMsNCw5XSlcIixcbiAgICAgIFwiKFsxLDIsMyw0LDVdKVwiLFxuICAgICAgXCIoWzksMiwzXSlcIixcbiAgICAgIFwiKFsxLDksOV0pXCIsXG4gICAgICBcIihbMSwyLDNdKVwiLFxuICAgICAgXCIoWzEsOV0pXCIsXG4gICAgICBcIihbNSw1XSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFs5XSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzMsOSwyLDMsM10pXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheTEyM1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgT3V0cHV0IFRSVUUgaWYgdGhlIHNlcXVlbmNlIG9mIG51bWJlcnMgMSwgMiwgM1xuICAgICAgICAgIGFwcGVhcnMgaW4gdGhlIGFycmF5IHNvbWV3aGVyZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5MTIzKE5VTVMpIFxuICAgIEZPVU5EID0gRkFMU0VcbiAgICBsb29wIEkgZnJvbSAwIHRvIE5VTVMuTGVuZ3RoKCktM1xuICAgICAgaWYgTlVNU1tJXSA9IDEgQU5EIE5VTVNbSSsxXSA9IDIgQU5EIE5VTVNbSSsyXSA9IDMgdGhlblxuICAgICAgICBGT1VORCA9IFRSVUVcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IEZPVU5EXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsMiwzLDRdKScsXG4gICAgICAnKFs0LCA1LCAxLCAyLCAzLCA0XSknLFxuICAgICAgJyhbMSwgMiwgMSwgMywgM10pJyxcbiAgICAgICcoWzMsIDIsIDFdKScsXG4gICAgICAnKFswLCAwLCAxLCAyLCAwLCAxLCAyLCAzXSknXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU3RyaW5nWFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIG91dHB1dCBhIHZlcnNpb24gd2hlcmUgYWxsIHRoZSBcInhcIiBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgRXhjZXB0IGFuIFwieFwiIGF0IHRoZSB2ZXJ5IHN0YXJ0IG9yIGVuZCBzaG91bGQgbm90IGJlIHJlbW92ZWQuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdHJpbmdYKFNUUikgXG4gIFJFU1VMVD0gU1RSLlN1YlN0cigwLDEpXG4gIFxuICBsb29wIEkgZnJvbSAxIHRvIFNUUi5MZW5ndGgoKSAtIDJcbiAgICBpZiBTVFIuU3ViU3RyKEksMSkgIT0gXCJ4XCIgdGhlblxuICAgICAgUkVTVUxUID0gUkVTVUxUICsgU1RSLlN1YlN0cihJLDEpXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIFJFU1VMVCA9IFJFU1VMVCArIFNUUi5TdWJTdHIoU1RSLkxlbmd0aCgpIC0gMSwxKVxuICBvdXRwdXQgUkVTVUxUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCd4eEh4aXgnKVwiLFxuICAgICAgXCIoJ2FieHh4Y2QnKVwiLFxuICAgICAgXCIoJ3hhYnh4eGNkeCcpXCIsXG4gICAgICBcIigneEt4aXh0eHR4ZXhuJylcIixcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIigneHgnKVwiLFxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkFycmF5NjY3XCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRlZ2Vycywgb3V0cHV0IHRoZSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGUgYXJyYXkgaGFzIGEgNiBmb2xsb3dlZCBieSBlaXRoZXIgYSA2IG9yIGEgN2AsXG4gICAgc29sdXRpb246IGBtZXRob2QgQXJyYXk2NjcoTlVNUykgXG4gIENPVU5UID0gMFxuICBsb29wIFggZnJvbSAwIHRvIE5VTVMubGVuZ3RoIC0xXG4gICAgaWYgTlVNU1tYXSA9IDYgdGhlblxuICAgICAgaWYgTlVNU1tYICsgMV0gPSA2IE9SIE5VTVNbWCArIDFdID0gNyB0aGVuXG4gICAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgICBlbmQgaWZcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IENPVU5UXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs2LDYsMl0pXCIsXG4gICAgICBcIihbNiw2LDIsNl0pXCIsXG4gICAgICBcIihbNiw3LDIsNl0pXCIsXG4gICAgICBcIihbNiw2LDIsNyw2LDddKVwiLFxuICAgICAgXCIoWzEsNiwzXSlcIixcbiAgICAgIFwiKFs2LDFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMyw2LDcsNl0pXCIsXG4gICAgICBcIihbMyw2LDYsN10pXCIsXG4gICAgICBcIihbNiwzLDYsNl0pXCIsXG4gICAgICBcIihbNiw3LDYsNl0pXCIsXG4gICAgICBcIihbMSwyLDMsNSw2XSlcIixcbiAgICAgIFwiKFsxLDIsMyw2LDZdKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTm9UcmlwbGVzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRlZ2Vycywgd2UnbGwgc2F5IHRoYXQgYSB0cmlwbGUgaXMgYSB2YWx1ZSBhcHBlYXJpbmcgMyB0aW1lc1xuICAgICAgICAgICAgICAgICAgaW4gYSByb3cgaW4gdGhlIGFycmF5LiBPdXRwdXQgVFJVRSBpZiB0aGUgYXJyYXkgZG9lcyBub3QgY29udGFpbiBhbnkgdHJpcGxlcy5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE5vVHJpcGxlcyhOVU1TKSBcbiAgICBUUklQTEVGT1VORCA9IEZBTFNFXG4gICAgbG9vcCBYIGZyb20gMCB0byBOVU1TLmxlbmd0aCAtIDNcbiAgICBpZiBOVU1TW1hdID0gTlVNU1tYKzFdIEFORCBOVU1TW1hdID0gTlVNU1tYKzJdIHRoZW5cbiAgICAgICAgVFJJUExFRk9VTkQgPSBUUlVFXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wIFxuICBvdXRwdXQgTk9UIFRSSVBMRUZPVU5EXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLDEsMiwyLDFdKVwiLFxuICAgICAgXCIoWzEsMSwyLDIsMiwxXSlcIixcbiAgICAgIFwiKFsxLDEsMiwyLDIsMV0pXCIsXG4gICAgICBcIihbMSwyLDFdKVwiLFxuICAgICAgXCIoWzEsMSwxXSlcIixcbiAgICAgIFwiKFsxLDFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoW10pXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJIYXMyNzFcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIE91dHB1dCBUUlVFIGlmIGl0IGNvbnRhaW5zIGEgMiwgNywgMVxuICAgICAgICAgICAgICAgICAgcGF0dGVybiAtLSBhIHZhbHVlLCBmb2xsb3dlZCBieSB0aGUgdmFsdWUgcGx1cyA1LCBmb2xsb3dlZCBieSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgIG1pbnVzIDEuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBIYXMyNzEoTlVNUykgXG4gICAgRk9VTkQgPSBGQUxTRVxuICAgIGxvb3AgWCBmcm9tIDAgdG8gTlVNUy5sZW5ndGggLSAzXG4gICAgaWYgTlVNU1tYXSArIDUgPSBOVU1TW1ggKyAxXSBBTkQgTlVNU1tYXSAtIDEgPSBOVU1TW1grMl0gdGhlblxuICAgICAgICBGT1VORCA9IFRSVUVcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3AgXG4gIG91dHB1dCBGT1VORFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwyLDcsMV0pXCIsXG4gICAgICBcIihbMSwyLDgsMV0pXCIsXG4gICAgICBcIihbMiw3LDFdKVwiLFxuICAgICAgXCIoWzMsOCwyXSlcIixcbiAgICAgIFwiKFsyLDcsM10pXCIsXG4gICAgICBcIihbMiw3LDRdKVwiLFxuICAgICAgXCIoWzIsNywtMV0pXCIsXG4gICAgICBcIihbMiw3LC0yXSlcIixcbiAgICAgIFwiKFs0LDUsMyw4LDBdKVwiLFxuICAgICAgXCIoWzIsNyw1LDEwLDRdKVwiLFxuICAgICAgXCIoWzIsNywtMiw0LDksM10pXCIsXG4gICAgICBcIihbMiw3LDUsMTAsMV0pXCIsXG4gICAgICBcIihbMiw3LC0yLDEwLDJdKVwiXG4gICAgXSxcbiAgfSxcbl07IiwiY29uc3QgQ29kZU1pcnJvciA9IHJlcXVpcmUoXCJjb2RlbWlycm9yLW1pbmlmaWVkXCIpO1xuY29uc3QgcnVuUFMgPSByZXF1aXJlKFwiLi91dGlsaXR5L2NvbnZlcnRQU3RvSlNcIik7XG5jb25zdCBleGVyY2lzZXMgPSByZXF1aXJlKFwiLi9hbGxFeGVyY2lzZXNJbmNsdWRpbmdIaWRkZW4uanNcIik7XG5jb25zdCBzb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9zb2x1dGlvbnMuanNcIik7XG5jb25zdCBkZWZhdWx0SW5wdXQgPSByZXF1aXJlKFwiLi91dGlsaXR5L2RlZmF1bHRJbnB1dC5qc1wiKTtcbmNvbnN0IGRlUGFyYW0gPSByZXF1aXJlKFwiLi91dGlsaXR5L2RlUGFyYW0uanNcIik7XG5jb25zdCBpbnB1dFBhcnNlciA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvaW5wdXRQYXJzZXIuanNcIik7XG5jb25zdCB0YWJsZUhlYWRlciA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvdGFibGVIZWFkZXIuanNcIik7XG5jb25zdCBmb3JtYXRSZXN1bHRzID0gcmVxdWlyZShcIi4vdXRpbGl0eS9mb3JtYXRSZXN1bHRzLmpzXCIpO1xuY29uc3Qgc2V0SW5pdGlhbEVkaXRvckNvbnRlbnRzID0gcmVxdWlyZShcIi4vdXRpbGl0eS9zZXRJbml0aWFsRWRpdG9yQ29udGVudHMuanNcIik7XG5jb25zdCBkaXNwbGF5RXhhbXBsZVJ1bnMgPSByZXF1aXJlKFwiLi91dGlsaXR5L2Rpc3BsYXlFeGFtcGxlUnVucy5qc1wiKTtcbmNvbnN0IHByZXR0eVByaW50TWFwID0gcmVxdWlyZShcIi4vdXRpbGl0eS9wcmV0dHlQcmludE1hcC5qc1wiKTtcbmNvbnN0IGV4ZXJjaXNlTGlzdGVuZXJzID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2V4ZXJjaXNlTGlzdGVuZXJzXCIpO1xuY29uc3Qga2V5Ym9hcmRTaG9ydGN1dHMgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMva2V5Ym9hcmRTaG9ydGN1dHNcIik7XG5yZXF1aXJlKFwiLi9saXN0ZW5lcnMvZGFya01vZGVDaGVja2JveC5qc1wiKTtcblxuXG5yZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItbWluaWZpZWQvYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzLmpzXCIpO1xuY29uc3QgQ29kZU1pcnJvclBTSGlnaGxpZ2h0aW5nID0gcmVxdWlyZShcIi4vdXRpbGl0eS9jbXBzLmpzXCIpO1xuQ29kZU1pcnJvclBTSGlnaGxpZ2h0aW5nKENvZGVNaXJyb3IpO1xuLy8gZGVmaW5lIGNvZGVtaXJyb3IgZWRpdG9yIHRvIGludGVyYWN0IHdpdGggY29kZSBvbiBwYWdlXG5jb25zdCBlZGl0b3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFuc3dlclwiKSwge1xuICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgbWF0Y2hCcmFja2V0czogdHJ1ZSxcbiAgbW9kZTogXCJwc2V1ZG9jb2RlXCIsXG4gIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcbiAgbGluZVdyYXBwaW5nOiB0cnVlLFxuICBleHRyYUtleXM6IHtcbiAgICBcIkNtZC0vXCI6IFwidG9nZ2xlQ29tbWVudFwiLFxuICAgIFwiQ3RybC0vXCI6IFwidG9nZ2xlQ29tbWVudFwiLFxuICAgIFRhYjogY20gPT4gY20uZXhlY0NvbW1hbmQoXCJpbmRlbnRNb3JlXCIpLFxuICAgIFwiU2hpZnQtVGFiXCI6IGNtID0+IGNtLmV4ZWNDb21tYW5kKFwiaW5kZW50TGVzc1wiKSxcbiAgfSxcbn0pO1xuZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG5lZGl0b3Iuc2V0U2l6ZShcIjEwMCVcIiwgXCJhdXRvXCIpO1xuXG5jb25zdCBzb2x1dGlvbkFyZWEgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvbHV0aW9uXCIpLCB7XG4gIHJlYWRPbmx5OiB0cnVlLFxuICBtb2RlOiBcInBzZXVkb2NvZGVcIixcbiAgdmlld3BvcnRNYXJnaW46IEluZmluaXR5LFxuICBsaW5lV3JhcHBpbmc6IHRydWUsXG4gIGxpbmVOdW1iZXJzOiB0cnVlLFxuICBjdXJzb3JCbGlua1JhdGU6IC0xLFxufSk7XG5zb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cblxuLy8gV29yayBvdXQgd2hpY2ggZXhjZXJjaXNlIHRvIHNob3dcbmNvbnN0IHVybFBhcmFtcyA9IGRlUGFyYW0od2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5jb25zdCBleGVyY2lzZU5hbWUgPSB1cmxQYXJhbXMubmFtZSB8fCBleGVyY2lzZXNbMF0ubmFtZTtcbi8qKiBoZXJlIHdlIG1hdGNoIHRoZSBleGVyY2lzZU5hbWUgKGZyb20gcXVlcnlzdHJpbmcpIHRvIHRoZSBwcm9ibGVtIGluIGV4ZXJjaXNlIG9iaioqL1xuY29uc3QgZXhlcmNpc2UgPSBleGVyY2lzZXMuZmlsdGVyKGV4ID0+IGV4Lm5hbWUgPT09IGV4ZXJjaXNlTmFtZSlbMF07XG5sZXQgc29sdXRpb24gPSBleGVyY2lzZS5zb2x1dGlvbiB8fCBzb2x1dGlvbnNbZXhlcmNpc2VOYW1lXTtcblxuZXhlcmNpc2VMaXN0ZW5lcnMoZWRpdG9yLCBleGVyY2lzZU5hbWUpO1xua2V5Ym9hcmRTaG9ydGN1dHMoZWRpdG9yLCBleGVyY2lzZU5hbWUpO1xuXG4vLyBkaXNwbGF5IGV4ZXJjaXNlIHBhZ2VcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aXRsZScpLmlubmVyVGV4dCA9IGV4ZXJjaXNlLnRpdGxlO1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25hbWUnKS5pbm5lclRleHQgPSBleGVyY2lzZS5uYW1lO1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2JsZW0nKS5pbm5lckhUTUwgPSBleGVyY2lzZS5xdWVzdGlvbjtcblxuc2V0SW5pdGlhbEVkaXRvckNvbnRlbnRzKGVkaXRvciwgZXhlcmNpc2VOYW1lLCBleGVyY2lzZSk7XG5kaXNwbGF5RXhhbXBsZVJ1bnMoZXhlcmNpc2UsIGV4ZXJjaXNlTmFtZSk7XG5cblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWZhdWx0c1wiKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgZWRpdG9yLnNldFZhbHVlKGAke2RlZmF1bHRJbnB1dChleGVyY2lzZSl9YCk7XG59KTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb2x2ZVwiKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgndHInKS5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZSgpKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXN0c1wiKS5hcHBlbmQodGFibGVIZWFkZXIoKSk7XG4gIGNvbnN0IGFuc3dlciA9IGVkaXRvci5nZXRWYWx1ZSgpO1xuXG4gIC8vIHdoZW5ldmVyIHRoZSB1c2VyIGNoZWNrcyB0aGVpciBzb2x1dGlvbixcbiAgLy8gc2F2ZSB0aGUgbW9zdCByZWNlbnQgdmVyc2lvbiBvZiB0aGVpciBjb2RlIHRvIGxvY2FsU3RvcmFnZVxuICBjb25zdCBleGVyY2lzZUNvZGUgPSBgJHtleGVyY2lzZU5hbWV9IC0gY29kZWA7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGV4ZXJjaXNlTmFtZSwgXCJhdHRlbXB0ZWRcIik7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGV4ZXJjaXNlQ29kZSwgYW5zd2VyKTtcblxuXG4gIHRyeSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiXCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZXJyb3JNZXNzYWdlXCIpLmZvckVhY2goKGUpID0+IGUuaW5uZXJUZXh0ID0gXCJcIik7XG4gICAgY29uc3QgaW5wdXRzID0gZXhlcmNpc2UuaW5wdXRzO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dFN0cikgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFBhcnNlcihleGVyY2lzZSwgaW5wdXRTdHIpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGxldCBpZGVhbFJlc3VsdDtcblxuICAgICAgLy8gaWYgdGhlIGlucHV0IGlzIGFuIGFycmF5L29iamVjdCwgbWFrZSBhIGNvcHkgdG8gYXZvaWQgdXNlciBjaGFuZ2luZyB0aGUgcGFzc2VkIHZlcnNpb24uLi5cbiAgICAgIGNvbnN0IGlucHV0Q29weSA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBpbnB1dFN0cik7XG5cbiAgICAgIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwibWFwXCIpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5wdXQgPSBwcmV0dHlQcmludE1hcChpbnB1dCwgXCJwYXJlbnRoZXNlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc29sdXRpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy93ZSBoYXZlIGEgcHNldWRvY29kZSBzb2x1dGlvbiFcbiAgICAgICAgICBbaWRlYWxSZXN1bHQsIGlkZWFsT3V0XSA9IHJ1blBTKHNvbHV0aW9uLCBpbnB1dCwgZXhlcmNpc2UucHJlYW1ibGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkZWFsT3V0ID0gXCJcIjtcbiAgICAgICAgICBpZGVhbFJlc3VsdCA9IHNvbHV0aW9uKC4uLmlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBbcmVzdWx0LCBvdXRwdXRdID0gcnVuUFMoYW5zd2VyLCBpbnB1dCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE1hcElkZWFsUmVzdWx0ID0gcHJldHR5UHJpbnRNYXAoaWRlYWxSZXN1bHQpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRNYXBVc2VyUmVzdWx0ID0gcHJldHR5UHJpbnRNYXAocmVzdWx0KTtcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRlc3RzXCIpLmFwcGVuZChmb3JtYXRSZXN1bHRzKGV4ZXJjaXNlTmFtZSwgZm9ybWF0dGVkSW5wdXQsIGZvcm1hdHRlZE1hcElkZWFsUmVzdWx0LCBmb3JtYXR0ZWRNYXBVc2VyUmVzdWx0LCBpZGVhbE91dCwgb3V0cHV0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvL3dlIGhhdmUgYSBwc2V1ZG9jb2RlIHNvbHV0aW9uIVxuICAgICAgICAgIFtpZGVhbFJlc3VsdCwgaWRlYWxPdXRdID0gcnVuUFMoc29sdXRpb24sIGlucHV0Q29weSwgZXhlcmNpc2UucHJlYW1ibGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkZWFsT3V0ID0gXCJcIjtcbiAgICAgICAgICBpZGVhbFJlc3VsdCA9IHNvbHV0aW9uKC4uLmlucHV0Q29weSk7XG4gICAgICAgIH1cbiAgICAgICAgW3Jlc3VsdCwgb3V0cHV0XSA9IHJ1blBTKGFuc3dlciwgaW5wdXRDb3B5LCBleGVyY2lzZS5wcmVhbWJsZSk7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXN0c1wiKS5hcHBlbmQoZm9ybWF0UmVzdWx0cyhpbnB1dCwgaWRlYWxSZXN1bHQsIHJlc3VsdCwgaWRlYWxPdXQsIG91dHB1dCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRlYWxPdXQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCA9PT0gaWRlYWxSZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG91dHB1dCA9PT0gaWRlYWxPdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdHMuZXZlcnkoaXNUcnVlKSkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiMTAwJSBQYXNzaW5nLiBXZWxsIERvbmUhXCIpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZXhlcmNpc2VOYW1lLCBcInNvbHZlZFwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHRoZUVycm9yKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiXCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoJykuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5lcnJvck1lc3NhZ2VcIikuZm9yRWFjaCgoZSkgPT4gZS5pbm5lclRleHQgPSB0aGVFcnJvcik7XG4gICAgY29uc29sZS5sb2codGhlRXJyb3Iuc3RhY2spO1xuICB9XG59KTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dTb2x1dGlvblwiKS5pbm5lclRleHQgPT09IFwiU2hvdyBTb2x1dGlvblwiKSB7XG4gICAgY29uc3QgcyA9IHNvbHV0aW9uLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgciA9IG5ldyBSZWdFeHAoL2Z1bmN0aW9uLyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgY29uc3QgbiA9IHMucmVwbGFjZShyLCBgZnVuY3Rpb24gJHtleGVyY2lzZS5uYW1lfWApO1xuICAgIGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIHNvbHV0aW9uQXJlYS5zZXRWYWx1ZShzKTtcbiAgICBzb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHNvbHV0aW9uQXJlYS5zZXRTaXplKFwiMTAwJVwiLCBcImF1dG9cIik7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuaW5uZXJUZXh0ID0gXCJIaWRlIFNvbHV0aW9uXCI7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuaW5uZXJUZXh0ID0gXCJTaG93IFNvbHV0aW9uXCI7XG4gICAgZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBzb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpc1RydWUoc29tZVZhbHVlKSB7XG4gIHJldHVybiBzb21lVmFsdWUgPT09IHRydWU7XG59XG4iLCJcbmxldCB3YXJtdXBFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL3dhcm11cC5qc1wiKTtcbi8vbGV0IHN0cmluZ0V4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvc3RyaW5nLmpzXCIpO1xubGV0IHJlY3Vyc2lvbkV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVjdXJzaW9uLmpzXCIpO1xubGV0IGxvZ2ljRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9sb2dpYy5qc1wiKTtcbmxldCBhcnJheUV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvYXJyYXkuanNcIik7XG5sZXQgYXBFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL2FwLmpzXCIpO1xubGV0IGNvbGxlY3Rpb25zRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9jb2xsZWN0aW9ucy5qc1wiKTtcbi8vbGV0IG1hcEV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvbWFwLmpzXCIpO1xubGV0IGFkdkV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvYWR2YW5jZWREYXRhU3RydWN0dXJlcy5qc1wiKVxuXG5sZXQgbWFpblBhZ2VFeGVyY2lzZXMgPSBbLi4ud2FybXVwRXhlcmNpc2VzLCAuLi5hcnJheUV4ZXJjaXNlcyxcbi4uLmNvbGxlY3Rpb25zRXhlcmNpc2VzLCAuLi5hZHZFeGVyY2lzZXMsIC4uLmxvZ2ljRXhlcmNpc2VzLFxuLi4ucmVjdXJzaW9uRXhlcmNpc2VzLCAuLi5hcEV4ZXJjaXNlc107XG5cbm1vZHVsZS5leHBvcnRzID0gbWFpblBhZ2VFeGVyY2lzZXM7IiwibGV0IGRlUGFyYW0gPSByZXF1aXJlKFwiLi91dGlsaXR5L2RlUGFyYW0uanNcIik7XG5sZXQgZXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZXhlcmNpc2VzVG9TaG93T25JbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL2xpc3RlbmVycy9pbmRleFNhdmVMb2FkQWxsLmpzXCIpO1xucmVxdWlyZShcIi4vbGlzdGVuZXJzL2RhcmtNb2RlQ2hlY2tib3guanNcIik7XG5cbmZ1bmN0aW9uIHVuaXEoYSkge1xuICB2YXIgdGVtcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgdGVtcFthW2ldXSA9IHRydWU7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0ZW1wKTtcbn1cblxubGV0IHRpdGxlID0gZGVQYXJhbSh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS50aXRsZTtcbmxldCBhbGxUaXRsZXMgPSB1bmlxKGV4ZXJjaXNlcy5tYXAoZSA9PiBlLnRpdGxlKSk7XG5sZXQgdGl0bGVzID0gdGl0bGUgPyBbdGl0bGVdIDogYWxsVGl0bGVzO1xuXG4vLyBkaXNwbGF5IGFsbCBwcm9ibGVtc1xuZm9yICh0aXRsZSBvZiB0aXRsZXMpIHtcbiAgbGV0IG91dGVyRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4ZXJjaXNlSW5kZXgnKTtcbiAgb3V0ZXJEaXYuaW5uZXJIVE1MICs9IGA8aDMgY2xhc3M9XCJwcm9iVGl0bGVcIiBpZD1cIiR7dGl0bGV9XCI+JHt0aXRsZX08L2gzPmA7XG5cbiAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5jbGFzc0xpc3QuYWRkKFwicHJvYmxlbXNcIik7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXhlcmNpc2VJbmRleFwiKS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gIGxldCB4ID0gZXhlcmNpc2VzLmZpbHRlcigoZXgpID0+IGV4LnRpdGxlID09IHRpdGxlKTtcblxuICB4LmZvckVhY2goKGV4KSA9PiB7XG4gICAgbGV0IHNwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwXCIpO1xuICAgIHNwLmNsYXNzTGlzdC5hZGQoXCJleGVyY2lzZS1saW5rXCIpO1xuICAgIHNwLmlkID0gYCR7ZXgubmFtZX1gO1xuICAgIHNwLmlubmVySFRNTCA9IGA8YSBocmVmPSdleGVyY2lzZS5odG1sP25hbWU9JHtleC5uYW1lfSZ0aXRsZT0ke2V4LnRpdGxlfSc+JHtleC5uYW1lfTwvYT4mbmJzcDtgO1xuICAgIGRpdi5hcHBlbmRDaGlsZChzcCk7XG4gICAgc3AuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJlbmRcIiwgXCI8YnI+XCIpO1xuICAgIGlmIChsb2NhbFN0b3JhZ2VbZXgubmFtZV0gPT09IFwic29sdmVkXCIpIHtcbiAgICAgIHNwLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJzxzcGFuIGNsYXNzPVwidGlja1wiPjxiPuKckzwvYj48L3NwYW4+Jyk7XG4gICAgfSBlbHNlIGlmIChsb2NhbFN0b3JhZ2VbZXgubmFtZV0gPT09IFwiYXR0ZW1wdGVkXCIpIHtcbiAgICAgIHNwLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJzxzcGFuIGNsYXNzPVwid3JvbmdcIj48Yj7inJY8L2I+PC9zcGFuPicpXG4gICAgfVxuICB9KTtcblxufVxuXG4iLCJcbmZ1bmN0aW9uIGxvYWRBbGxTb2x1dGlvbnNGcm9tRmlsZSgpIHtcbiAgbGV0IGZpbGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlSW5wdXQnKTtcbiAgZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgbGV0IGZpbGUgPSBmaWxlSW5wdXQuZmlsZXNbMF07XG4gICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICAgIGxldCBwYXJzZWRGaWxlID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHdyaXRlTG9jYWxTdG9yYWdlKHBhcnNlZEZpbGUpO1xuICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICBmaWxlSW5wdXQudmFsdWUgPSAnJztcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9KTtcbiAgJChcIiNmaWxlSW5wdXRcIikuY2xpY2soKTsgLy8gYWN0aXZhdGUgdGhlIGhpZGRlbiBmaWxlIGlucHV0XG59XG5cbmZ1bmN0aW9uIHdyaXRlTG9jYWxTdG9yYWdlKGRhdGEpIHtcbiAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgZGF0YVtrZXldKSB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGU7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkQ29kZUZpbGUoZWRpdG9yKSB7XG4gIC8vIHJlbW92ZV9maWxlSW5wdXRfbGlzdGVuZXIoKTtcbiAgbGV0IGZpbGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlSW5wdXQnKTtcbiAgZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgbGV0IGZpbGUgPSBmaWxlSW5wdXQuZmlsZXNbMF07XG4gICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlZGl0b3Iuc2V0VmFsdWUocmVhZGVyLnJlc3VsdCk7XG4gICAgICBmaWxlSW5wdXQudmFsdWUgPSAnJztcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9KTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmaWxlSW5wdXRcIikuY2xpY2soKTsgLy8gYWN0aXZhdGUgdGhlIGhpZGRlbiBmaWxlIGlucHV0XG59IiwiLy9sZXQgRmlsZVNhdmVyID0gcmVxdWlyZSgnZmlsZS1zYXZlcicpO1xuXG5mdW5jdGlvbiBzYXZlQWxsU29sdXRpb25zVG9GaWxlKCkge1xuICBsZXQgYWxsU29sdXRpb25zID0gZ2V0TG9jYWxTdG9yYWdlKCk7XG4gIGxldCBibG9iID0gbmV3IEJsb2IoW2FsbFNvbHV0aW9uc10sIHtcbiAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04XCJcbiAgfSk7XG4gIC8vRmlsZVNhdmVyLnNhdmVBcyhibG9iLCBcImNvbWJpbmVkU29sdXRpb25zLmpzXCIsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhbFN0b3JhZ2UpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhdmVBbGxTb2x1dGlvbnNUb0ZpbGU7IiwiLy9sZXQgRmlsZVNhdmVyID0gcmVxdWlyZSgnZmlsZS1zYXZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhdmVDb2RlRmlsZShlZGl0b3IsIGV4ZXJjaXNlTmFtZSkge1xuICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpcyB0aGlzIG5lZWRlZD9cbiAgbGV0IGJsb2IgPSBuZXcgQmxvYihbZWRpdG9yLmdldFZhbHVlKCldLCB7XG4gICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOFwiXG4gIH0pO1xuICAvL0ZpbGVTYXZlci5zYXZlQXMoYmxvYiwgZXhlcmNpc2VOYW1lICsgXCIuanNcIiwgdHJ1ZSk7XG59XG4iLCJ2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Rhcmttb2RlY2hlY2tib3hcIik7XG5pZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJkYXJrTW9kZVwiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJsaWdodFwiKTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIikuY2xhc3NMaXN0LmFkZChcImRhcmtcIik7XG59IGVsc2Uge1xuICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLmNsYXNzTGlzdC5hZGQoXCJsaWdodFwiKTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIikuY2xhc3NMaXN0LnJlbW92ZShcImRhcmtcIik7XG59XG5cbmNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoZSkgPT4ge1xuICBpZiAoY2hlY2tib3guY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZGFya01vZGVcIiwgXCJ0cnVlXCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJsaWdodFwiKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKS5jbGFzc0xpc3QuYWRkKFwiZGFya1wiKTtcbiAgfSBlbHNlIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImRhcmtNb2RlXCIsIFwiZmFsc2VcIik7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIikuY2xhc3NMaXN0LmFkZChcImxpZ2h0XCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJkYXJrXCIpO1xuICB9XG59KTtcbiIsImxldCBleGVyY2lzZXMgPSByZXF1aXJlKFwiLi4vZXhlcmNpc2VzVG9TaG93T25JbmRleFwiKTtcbmxldCBzYXZlQ29kZUZpbGUgPSByZXF1aXJlKFwiLi4vaW8vc2F2ZUNvZGVGaWxlLmpzXCIpO1xubGV0IGxvYWRDb2RlRmlsZSA9IHJlcXVpcmUoXCIuLi9pby9sb2FkQ29kZUZpbGUuanNcIik7XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgbmFtZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlZGl0b3IsIGV4ZXJjaXNlTmFtZSkge1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI25leHQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgbGV0IGluZHggPSBmaW5kSW5kZXgoZXhlcmNpc2VzLCBleGVyY2lzZU5hbWUpICsgMTtcbiAgICAgICAgaWYgKGluZHggPj0gZXhlcmNpc2VzLmxlbmd0aCkgaW5keCA9IGV4ZXJjaXNlcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgeCA9IGV4ZXJjaXNlc1tpbmR4XTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnNlYXJjaCA9IGA/bmFtZT0ke3gubmFtZX0mdGl0bGU9JHt4LnRpdGxlfWBcbiAgICB9KVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ByZXZpb3VzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGxldCBpbmR4ID0gZmluZEluZGV4KGV4ZXJjaXNlcywgZXhlcmNpc2VOYW1lKSAtIDE7XG4gICAgICAgIGlmIChpbmR4IDwgMCkgaW5keCA9IDA7XG4gICAgICAgIGxldCB4ID0gZXhlcmNpc2VzW2luZHhdO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoID0gYD9uYW1lPSR7eC5uYW1lfSZ0aXRsZT0ke3gudGl0bGV9YFxuICAgIH0pXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2F2ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBzYXZlQ29kZUZpbGUoZWRpdG9yLCBleGVyY2lzZU5hbWUpO1xuICAgIH0pXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3BlbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBsb2FkQ29kZUZpbGUoZWRpdG9yKTtcbiAgICB9KVxuXG59OyIsIlxubGV0IHNhdmVBbGxTb2x1dGlvbnNUb0ZpbGUgPSByZXF1aXJlKFwiLi4vaW8vc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZS5qc1wiKTtcbmxldCBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGUgPSByZXF1aXJlKFwiLi4vaW8vbG9hZEFsbFNvbHV0aW9uc0Zyb21GaWxlLmpzXCIpO1xuXG5cbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXZlQWxsJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZSgpO1xufSlcblxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xvYWRBbGwnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGUoKTtcbn0pIiwibGV0IHNhdmVDb2RlRmlsZSA9IHJlcXVpcmUoXCIuLi9pby9zYXZlQ29kZUZpbGUuanNcIik7XG5sZXQgbG9hZENvZGVGaWxlID0gcmVxdWlyZShcIi4uL2lvL2xvYWRDb2RlRmlsZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWRpdG9yLCBleGVyY2lzZU5hbWUpIHtcbiAgLy9hbGxvdyB1c2VyIHRvIHNhdmUvb3BlbiBjb2RlIHdpdGgga2V5Ym9hcmQgc2hvcnRjdXRzXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSA4MyAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2F2ZUNvZGVGaWxlKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PSA3OSAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbG9hZENvZGVGaWxlKGVkaXRvcik7XG4gICAgfVxuICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaChcIk1hY1wiKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc29sdmVcIikuY2xpY2soKTsgLy9ydW4gY29kZSBvbiBjdHJsLWVudGVyXG4gICAgfVxuICAgIC8vIGlmIChlLmtleUNvZGUgPT0gNzQgJiYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaChcIk1hY1wiKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAvLyAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICQoXCIjanNyZWYtbGlua1wiKS5jbGljaygpOyAvL2hlbHAgc2NyZWVuIG9uIGN0cmwtalxuICAgIC8vIH1cbiAgICAvLyBpZiAoZS5rZXlDb2RlID09IDE5MSAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgIC8vICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgZWRpdG9yLnRvZ2dsZUNvbW1lbnQoKTtcbiAgICAvLyB9XG4gIH0pO1xufTsiLCJ2YXIgcGF0aFN1ZmZpeCA9IGxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KCcvJykuc3BsaWNlKC0xKVswXVxuaWYgKHBhdGhTdWZmaXggPT09IFwiXCIpIHtcbiAgLy8gbWFpbiBwYWdlXG4gIHJlcXVpcmUoXCIuL2luZGV4UGFnZS5qc1wiKTtcbn1cblxuZWxzZSBpZiAocGF0aFN1ZmZpeCA9PT0gXCJleGVyY2lzZS5odG1sXCIpIHtcbiAgLy8gaW5kaXZpZHVhbCBwcm9ibGVtL2V4ZXJjaXNlIHBhZ2VcbiAgcmVxdWlyZShcIi4vZXhlcmNpc2VQYWdlLmpzXCIpO1xufVxuXG4vLyB0aGlzIGxldHMgeW91IG5vdCBkaXNwbGF5IGFueXRoaW5nIHVudGlsIHRoZSBlbnRpcmUgcGFnZSBpcyByZWFkeSAoc2luY2Ugd2Ugc2V0IGh0bWxcbi8vICB0byBpbnZpc2libGUgaW4gc3R5bGUuY3NzKVxuLy8gdXNlZnVsLCBzaW5jZSBvdGhlcndpc2UgeW91IHNlZSB0aGUgdHJhbnNpdGlvbiBmcm9tIHRleHRhcmVhIHRvIGNvZGVtaXJyb3IsIGV0Yy4uLlxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJodG1sXCIpWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIik7IiwibGV0IHN0cmluZ1NvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvc3RyaW5nU29sdXRpb25zLmpzXCIpO1xubGV0IHJlY3Vyc2lvblNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVjdXJzaW9uU29sdXRpb25zLmpzXCIpO1xubGV0IGxvZ2ljU29sdXRpb25zID0gcmVxdWlyZShcIi4vZGF0YS9sb2dpY1NvbHV0aW9ucy5qc1wiKTtcbmxldCBhcnJheVNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvYXJyYXlTb2x1dGlvbnMuanNcIik7XG5sZXQgYXBTb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9kYXRhL2FwU29sdXRpb25zLmpzXCIpO1xubGV0IG1hcFNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvbWFwU29sdXRpb25zLmpzXCIpO1xubGV0IHF1aXpTb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9kYXRhL3F1aXpTb2x1dGlvbnMuanNcIik7XG4vLyB0aGlzIEVTMjAxOCBzcHJlYWQgc3ludGF4IHdhcyBjYXVzaW5nIGJyb3dzZXJpZnkgcHJvYmxlbXMsIHNvIEkgcmVwbGFjZWQgaXQgYmVsb3cuLi5cbi8vIGxldCBzb2x1dGlvbnMgPSB7Li4ud2FybXVwU29sdXRpb25zLCAuLi5zdHJpbmdTb2x1dGlvbnMgfTtcblxuLyoqIFRoZXJlJ3Mgbm8gbGltaXQgdG8gdGhlIG51bWJlciBvZiBvYmplY3RzIHlvdSBjYW4gbWVyZ2UuXG4gKiAgQWxsIG9iamVjdHMgZ2V0IG1lcmdlZCBpbnRvIHRoZSBmaXJzdCBvYmplY3QuIFxuICogIE9ubHkgdGhlIG9iamVjdCBpbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbXV0YXRlZCBhbmQgcmV0dXJuZWQuXG4gKiAgTGF0ZXIgcHJvcGVydGllcyBvdmVyd3JpdGUgZWFybGllciBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZS4gKi9cbmxldCBzb2x1dGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LFxuICBzdHJpbmdTb2x1dGlvbnMsXG4gIHJlY3Vyc2lvblNvbHV0aW9ucyxcbiAgbG9naWNTb2x1dGlvbnMsXG4gIGFycmF5U29sdXRpb25zLFxuICBhcFNvbHV0aW9ucyxcbiAgbWFwU29sdXRpb25zLFxuICBxdWl6U29sdXRpb25zXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENvZGVNaXJyb3JQU0hpZ2hsaWdodGluZyhDb2RlTWlycm9yKSB7XG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInBzZXVkb2NvZGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbmUgPSBbXCJtZXRob2RcIiwgXCJjbGFzc1wiXTtcbiAgICB2YXIga2V5d29yZHMgPSBbXCJvdmVycmlkZVwiLCBcIm92ZXJsb2FkXCIsIFwibmV3XCIsIFwibG9vcFwiLCBcImZyb21cIixcbiAgICAgIFwid2hpbGVcIiwgXCJpZlwiLCBcInRoZW5cIiwgXCJlbHNlXCIsIFwiQU5EXCIsIFwiT1JcIiwgXCJOT1RcIiwgXCJlbmRcIiwgXCJtZXRob2RcIiwgXCJtb2RcIiwgXCJkaXZcIl07XG4gICAgdmFyIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS87XG4gICAgdmFyIGJyYWNrZXQgPSAvXls6O1xcKFxcKVxcW1xcXVxce1xcfV0vO1xuICAgIHZhciBhdG9tID0gW1wiVFJVRVwiLCBcIkZBTFNFXCIsIFwib3V0cHV0XCIsIFwiaW5wdXRcIl07XG4gICAgdmFyIG51bWJlciA9IC9eKFxcZFsrXFwtXFwqXFwvXSk/XFxkKyhcXC5cXGQrKT8vO1xuICAgIHZhciB3b3JkID0gL15cXHcrKD86J1xcdyspPy87XG4gICAgdmFyIHV3b3JkID0gL15bQS1aX11bQS1aXzAtOV0rLztcblxuICAgIGRlZmluZSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgZGVmaW5lLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAga2V5d29yZHMgPSBuZXcgUmVnRXhwKFwiKChcIiArIGtleXdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAgYXRvbSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgYXRvbS5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGZ1bmN0aW9uIGludGVybmFsVG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RhdGUuZGVmaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuaW5jb21tZW50KSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0uc2tpcFRvKFwiKi9cIikpIHtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXCp8XFwvLyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiZG9jLW11bHRpbGluZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgaWYgKGNoID09IHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGNoO1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLmluY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS5za2lwVG8oXCIqL1wiKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcKnxcXC8vKTtcbiAgICAgICAgICAgICAgc3RhdGUuaW5jb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJkb2MtbXVsdGlsaW5lXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwuXFwuXFwuK1xccyokLykpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gXCJkb2NcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIgXCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc29sICYmIHN0cmVhbS5tYXRjaChkZWZpbmUpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZl9tb2RlID0gMTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZGVmaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZl9tb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChicmFja2V0KSkge1xuICAgICAgICAgICAgICBzdGF0ZS5kZWZpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc3RhdGUuZGVmX21vZGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHV3b3JkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCh3b3JkKSkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuZGVmaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gXCJkZWZcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIHN0YXRlLnNvbCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gaW50ZXJuYWxUb2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHN0YXRlLnNvbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXBzZXVkb2NvZGVcIiwgXCJwc2V1ZG9jb2RlXCIpO1xufSIsImNvbnN0IEpTT041ID0gcmVxdWlyZSgnanNvbjUnKTtcbmNvbnN0IHsgc3RyQ291bnQgfSA9IHJlcXVpcmUoJy4uL2RhdGEvcmVjdXJzaW9uU29sdXRpb25zJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENvbGxlY3Rpb24ge1xuXG4gIGVsZW1lbnRzID0gW107XG4gIGluZGV4ID0gMDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBJQiBzdHlsZSBjb2xsZWN0aW9uIGZyb20gdGhlIGVsZW1lbnRzIGluIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnI9W11dIC0gQXJyYXkgd2l0aCBzdGFydGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGVtcHR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gYXJyO1xuICAgIH1cbiAgfVxuXG4gIGFkZEl0ZW0oYSkge1xuICAgIHRoaXMuZWxlbWVudHMucHVzaChhKTtcbiAgfVxuXG4gIHJlc2V0TmV4dCgpIHtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgfVxuXG4gIGhhc05leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZGV4IDwgdGhpcy5lbGVtZW50cy5sZW5ndGgpXG4gIH1cblxuICBnZXROZXh0KCkge1xuICAgIHRoaXMuaW5kZXgrKztcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1t0aGlzLmluZGV4IC0gMV07XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBKU09ONS5zdHJpbmdpZnkodGhpcy5lbGVtZW50cyk7XG4gICAgc3RyID0gc3RyLnJlcGxhY2VBbGwoXCIsXCIsIFwiLCBcIikucmVwbGFjZUFsbChcIltcIiwgXCJ7XCIpLnJlcGxhY2VBbGwoXCJdXCIsIFwifVwiKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59IiwiY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zXCIpXG5jb25zdCBRdWV1ZSA9IHJlcXVpcmUoXCIuL3F1ZXVlc1wiKVxuY29uc3QgU3RhY2sgPSByZXF1aXJlKFwiLi9zdGFja3NcIilcbmNvbnN0IEpTT041ID0gcmVxdWlyZShcImpzb241XCIpO1xuLy8gdGhlc2UgdGhyZWUgdmFyaWFibGVzIGhlbHAgdGhlIHRyYW5zbGF0aW9uIHdvcmtcbnZhciBvdXQ7XG52YXIgVFJVRSA9IHRydWU7XG52YXIgRkFMU0UgPSBmYWxzZTtcblxuLyoqXG4gKiB0YWtlcyBwc2V1ZG9jb2RlLCBjb252ZXJ0cyB0byBqYXZhc2NyaXB0LCBhbmQgcnVucyBpdCBvbiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7YW55fSBpbnB1dFxuICogQHJldHVybiB7YW55fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJ1blBTKGNvZGUsIGksIHByZWFtYmxlKSB7XG4gIGlmIChwcmVhbWJsZSA9PT0gdW5kZWZpbmVkKSBwcmVhbWJsZSA9IFwiXCI7XG4gIGxldCBsaW5lcyA9IGdldExpbmVzKGNvZGUpO1xuICB2YXIgYyA9IFwiXCI7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGMgKz0gdHJhbnNsYXRlKGxpbmUpICsgXCJcXG5cIjtcbiAgfVxuICBsZXQgdXNlckNvZGU7XG4gIHRyeSB7XG4gICAgZXZhbChgJHtwcmVhbWJsZX07b3V0PVwiXCI7VFJVRT10cnVlO0ZBTFNFPWZhbHNlO3VzZXJDb2RlPSR7Y31gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3IsIGhlcmUgaXMgdGhlIHRyYW5zbGF0ZWQgZnVuY3Rpb25cIilcbiAgICBjb25zb2xlLmxvZyhjKTtcbiAgICB0aHJvdyAoZSk7XG4gIH1cbiAgdmFyIHJldCA9IHVzZXJDb2RlKC4uLmkpO1xuICByZXR1cm4gW3JldCwgb3V0XTtcbn1cblxuLy9UaGUgbmV4dCBiYXRjaCBvZiBmdW5jdGlvbnMgYXJlIHVzZWQgQlkgdGhlIHBzZXVkb2NvZGUuIERvbid0IGRlbGV0ZSB0aGVtIVxuXG5mdW5jdGlvbiBpbnB1dChzdHIpIHtcbiAgdmFyIGFuc3dlciA9IHByb21wdChzdHIpXG4gIGlmIChhbnN3ZXIgIT0gbnVsbCAmJiBhbnN3ZXIubGVuZ3RoID4gMCAmJiAhaXNOYU4oYW5zd2VyKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGFuc3dlcilcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gYW5zd2VyXG4gIH1cbn1cblxuZnVuY3Rpb24gb3V0cHV0KCkge1xuICB2YXIgYSA9IDA7XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBpZiAob3V0ICE9IFwiXCIpIHsgb3V0ICs9IFwiXFxuXCIgfVxuICBmb3IgKGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1thXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gfHxcbiAgICAgIGFyZ3VtZW50c1thXSBpbnN0YW5jZW9mIFN0YWNrIHx8XG4gICAgICBhcmd1bWVudHNbYV0gaW5zdGFuY2VvZiBRdWV1ZSkge1xuICAgICAgb3V0cHV0ID0gYXJndW1lbnRzW2FdLnRvU3RyaW5nKClcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gSlNPTjUuc3RyaW5naWZ5KGFyZ3VtZW50c1thXSlcbiAgICB9XG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2VBbGwoXCJ0cnVlXCIsIFwiVFJVRVwiKS5yZXBsYWNlQWxsKFwiZmFsc2VcIiwgXCJGQUxTRVwiKTtcbiAgICAvLyBTcGFjZXMgaW4gYXJyYXlzLi4uXG4gICAgaWYgKG91dHB1dC5zdWJzdHJpbmcoMCwgMSkgPT0gXCJbXCIgfHwgb3V0cHV0LnN1YnN0cmluZygwLCAxKSA9PSBcIntcIikge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2VBbGwoXCIsXCIsIFwiLCBcIilcbiAgICB9XG4gICAgaWYgKG91dHB1dC5zdWJzdHJpbmcoMCwgMikgPT0gXCJbW1wiKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZUFsbChcIl0sIFtcIiwgXCJdLFxcbiBbXCIpO1xuICAgIH1cbiAgICBvdXQgKz0gb3V0cHV0O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZGl2KEEsIEIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoQSAvIEIpXG59XG5cblxuXG5cbmZ1bmN0aW9uIEFycmF5MkQocm93cywgY29scykge1xuICBhMmQgPSBuZXcgQXJyYXkocm93cylcbiAgZm9yIChyID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgIGEyZFtyXSA9IG5ldyBBcnJheShjb2xzKVxuICB9XG4gIHJldHVybiBhMmRcbn1cblxuQXJyYXkucHJvdG90eXBlLkxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufVxuXG5BcnJheS5wcm90b3R5cGUuU2xpY2UgPSBmdW5jdGlvbiAoUywgTCkge1xuICByZXR1cm4gdGhpcy5zbGljZShTLCBTICsgTCk7XG59XG5cblN0cmluZy5wcm90b3R5cGUuTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59XG5cblN0cmluZy5wcm90b3R5cGUuU3ViU3RyID0gZnVuY3Rpb24gKFMsIEwpIHtcbiAgcmV0dXJuIHRoaXMuc3Vic3RyKFMsIEwpO1xufVxuXG4vKiogVHJhbnNsYXRlcyBhIHNpbmdsZSBsaW5lIGZyb20gUFMgKG9yIEpTKSB0byBKUyAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKGxpbmUpIHtcbiAgLy9kbyBhIHNhbml0eSBjaGVjayAtIGlmIHRoaXMgaXMgamF2YXNjcmlwdCwgbGVhdmUgaXQgYWxvbmVcbiAgaWYgKGxpbmUuaW5kZXhPZihcIntcIikgIT09IC0xKSByZXR1cm4gbGluZTtcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvIG1vZCAvZywgXCIgJSBcIilcbiAgLy9vb2YgdGhpcyBpcyB1Z2x5LiBIb3dldmVyLCBpdCBzaG91bGQgc3VjY2Vzc2Z1bGx5IG1hdGNoIGFsbCBkaXYgc3RhdGVtZW50cyAoPz8pXG4gIGxpbmUgPSBsaW5lLnJlcGxhY2VBbGwoLyhbMC05QS1aYS16XSt8IFxcKC4rXFwpfFswLTlBLVphLXpdK1xcLlswLTlBLVphLXpdK1xcKFxcKSkgZGl2IChbMC05QS1aYS16XSt8XFwoLitcXCl8WzAtOUEtWmEtel0rXFwuWzAtOUEtWmEtel0rXFwoXFwpKS9nLCBcImRpdigkMSwgJDIpXCIpO1xuXG4gIGxpbmUgPSBsaW5lLnJlcGxhY2VBbGwoLyhbXlwiXSlUUlVFL2csIFwiJDF0cnVlXCIpO1xuICBsaW5lID0gbGluZS5yZXBsYWNlQWxsKC8oW15cIl0pRkFMU0UvZywgXCIkMWZhbHNlXCIpO1xuICB2YXIgbGluID0gbGluZS50cmltKCk7XG4gIHZhciBzcCA9IGxpbi5pbmRleE9mKFwiIFwiKTtcbiAgdmFyIGZpcnN0ID0gXCJcIjtcbiAgaWYgKHN0YXJ0c3dpdGgobGluLCBcImlmXCIpKSB7IGZpcnN0ID0gXCJpZlwiIH1cbiAgZWxzZSBpZiAoc3RhcnRzd2l0aChsaW4sIFwicmV0dXJuXCIpKSB7IGZpcnN0ID0gXCJyZXR1cm5cIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcIm91dHB1dFwiKSkgeyBmaXJzdCA9IFwib3V0cHV0XCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJlbHNlIGlmXCIpKSB7IGZpcnN0ID0gXCJlbHNlIGlmXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJlbHNlXCIpKSB7IGZpcnN0ID0gXCJlbHNlXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJsb29wIHdoaWxlXCIpKSB7IGZpcnN0ID0gXCJsb29wIHdoaWxlXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJsb29wIGZvclwiKSkgeyBmaXJzdCA9IFwibG9vcCBmb3JcIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcImxvb3AgdW50aWxcIikpIHsgZmlyc3QgPSBcImxvb3AgdW50aWxcIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcImxvb3AgXCIpKSB7IGZpcnN0ID0gXCJsb29wXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJvdXRwdXRcIikpIHsgZmlyc3QgPSBcIm91dHB1dFwiIH1cbiAgZWxzZSBpZiAoc3RhcnRzd2l0aChsaW4sIFwibWV0aG9kIFwiKSkgeyBmaXJzdCA9IFwibWV0aG9kXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJDbGFzcyBcIikpIHsgZmlyc3QgPSBcImNsYXNzXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJpbnB1dFwiKSkgeyBmaXJzdCA9IFwiaW5wdXRcIiB9XG4gIGVsc2Uge1xuICAgIGlmIChzcCA+PSAwKSB7IGZpcnN0ID0gbGluLnN1YnN0cmluZygwLCBzcCk7IH1cbiAgfVxuICBpZiAoKGZpcnN0ID09IFwiaWZcIiB8fCBmaXJzdCA9PSBcImVsc2UgaWZcIiB8fCBmaXJzdCA9PSBcInJldHVyblwiIHx8IGZpcnN0ID09IFwib3V0cHV0XCIpKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIE5PVCAvZywgXCIgISBcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcImlmIFwiLCBcImlmICggXCIpO1xuICAgIGlmIChmaXJzdCA9PSBcImVsc2UgaWZcIikgeyBsaW5lID0gbGluZS5yZXBsYWNlKFwiZWxzZSBpZlwiLCBcIn0gZWxzZSBpZlwiKSB9XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcIiB0aGVuXCIsIFwiKXtcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIEFORCAvZywgXCIgJiYgXCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBPUiAvZywgXCIgfHwgXCIpO1xuXG5cbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC88Pi9nLCBcIiE9XCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyhbIFxcXVxcd10pPShbIFxcXVxcd10pL2csIFwiJDE9PSQyXCIpXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwiZWxzZVwiKSB7IGxpbmUgPSBsaW5lLnJlcGxhY2UoXCJlbHNlXCIsIFwifWVsc2V7XCIpIH1cbiAgaWYgKGZpcnN0ID09IFwibG9vcCB3aGlsZVwiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcImxvb3Agd2hpbGVcIiwgXCJ3aGlsZShcIikgKyBcIil7XCI7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIEFORCAvZywgXCIgJiYgXCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBPUiAvZywgXCIgfHwgXCIpO1xuXG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvTk9UL2csIFwiIVwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC88Pi9nLCBcIiE9XCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyA9IC9nLCBcIiA9PSBcIilcbiAgfVxuICBpZiAoZmlyc3QgPT0gXCJsb29wIGZvclwiKSB7XG4gICAgdmFyIHYgPSBsaW5lLmluZGV4T2YoXCJsb29wIGZvclwiKSArIDk7XG4gICAgdmFyIHZlID0gbGluZS5pbmRleE9mKFwiIFwiLCB2KTtcbiAgICB2YXIgdm5hbWUgPSBsaW5lLnN1YnN0cmluZyh2LCB2ZSk7XG5cbiAgICB2YXIgdnMgPSBsaW5lLmluZGV4T2YoXCIgZnJvbSBcIikgKyA2O1xuICAgIHZhciB2dCA9IGxpbmUuaW5kZXhPZihcIiB0byBcIik7XG4gICAgdmFyIHZzdGFydCA9IGxpbmUuc3Vic3RyaW5nKHZzLCB2dCk7XG5cbiAgICB2YXIgdmVuZCA9IGxpbmUuc3Vic3RyaW5nKHZ0ICsgNCk7XG5cbiAgICBsaW5lID0gXCJmb3IoXCIgKyB2bmFtZSArIFwiPVwiICsgdnN0YXJ0ICsgXCI7XCIgKyB2bmFtZSArIFwiPD1cIiArIHZlbmQgKyBcIjtcIiArIHZuYW1lICsgXCIrKyl7XCJcblxuICB9XG4gIGlmIChmaXJzdCA9PSBcImxvb3AgdW50aWxcIikge1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCJsb29wIHVudGlsXCIsIFwid2hpbGUoIShcIikgKyBcIikpe1wiO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBBTkQgL2csIFwiICYmIFwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gT1IgL2csIFwiIHx8IFwiKTtcblxuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL05PVC9nLCBcIiFcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvPD4vZywgXCIhPVwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gPSAvZywgXCIgPT0gXCIpXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwibG9vcFwiKSB7XG4gICAgdmFyIHYgPSBsaW5lLmluZGV4T2YoXCJsb29wXCIpICsgNTtcbiAgICB2YXIgdmUgPSBsaW5lLmluZGV4T2YoXCIgXCIsIHYpO1xuICAgIHZhciB2bmFtZSA9IGxpbmUuc3Vic3RyaW5nKHYsIHZlKTtcblxuICAgIHZhciB2cyA9IGxpbmUuaW5kZXhPZihcIiBmcm9tIFwiKSArIDY7XG4gICAgdmFyIHZ0ID0gbGluZS5pbmRleE9mKFwiIHRvIFwiKTtcbiAgICB2YXIgdnN0YXJ0ID0gbGluZS5zdWJzdHJpbmcodnMsIHZ0KTtcblxuICAgIHZhciB2ZW5kID0gbGluZS5zdWJzdHJpbmcodnQgKyA0KTtcblxuICAgIGxpbmUgPSBcImZvcihcIiArIHZuYW1lICsgXCI9XCIgKyB2c3RhcnQgKyBcIjtcIiArIHZuYW1lICsgXCI8PVwiICsgdmVuZCArIFwiO1wiICsgdm5hbWUgKyBcIisrKXtcIlxuXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwiZW5kXCIpIHsgbGluZSA9IFwifVwiOyB9XG4gIGlmIChmaXJzdCA9PSBcIm91dHB1dFwiKSB7XG4gICAgdmFyIHQgPSBsaW5lLmluZGV4T2YoXCJvdXRwdXRcIikgKyA2XG4gICAgbGluZSA9IFwib3V0cHV0KFwiICsgbGluZS5zdWJzdHJpbmcodCkgKyBcIilcIlxuICB9XG4gIGlmIChmaXJzdCA9PSBcImlucHV0XCIpIHtcbiAgICB2YXIgdiA9IGxpbmUuaW5kZXhPZihcImlucHV0XCIpICsgNlxuICAgIHZhciBuYW1lID0gbGluZS5zdWJzdHJpbmcodilcbiAgICBsaW5lID0gbmFtZSArIFwiID0gaW5wdXQoXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIlxuICB9XG4gIGlmIChmaXJzdCA9PSBcIm1ldGhvZFwiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvbWV0aG9kLywgXCJmdW5jdGlvblwiKSArIFwie1wiXG4gIH1cblxuICBpZiAoZmlyc3QgPT0gXCJjbGFzc1wiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvQ2xhc3MvLCBcImZ1bmN0aW9uXCIpICsgXCJ7XCJcbiAgfVxuXG4gIHJldHVybiBsaW5lXG59XG5cbmZ1bmN0aW9uIHN0YXJ0c3dpdGgod2hvbGUsIHBhcnQpIHtcbiAgdmFyIG4gPSBwYXJ0Lmxlbmd0aFxuICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIG4pID09IHBhcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGVsc2UgeyByZXR1cm4gZmFsc2UgfVxufVxuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgdmFyIGIgPSAwXG4gIHZhciBlID0gcy5sZW5ndGhcbiAgd2hpbGUgKGUgPiAwICYmIHMuY2hhckF0KGUgLSAxKSA8PSAnICcpIHsgZS0tIH1cbiAgd2hpbGUgKGIgPCBlICYmIHMuY2hhckF0KGIpIDw9ICcgJykgeyBiKysgfVxuICByZXR1cm4gcy5zdWJzdHJpbmcoYiwgZSlcbn1cblxuZnVuY3Rpb24gZ2V0TGluZXMoY29kZSkge1xuICB2YXIgbGluZXMgPSBjb2RlLnNwbGl0KFwiXFxuXCIpXG4gIGZvciAoYyA9IDA7IGMgPCBsaW5lcy5sZW5ndGg7IGMrKykgeyBsaW5lc1tjXSA9IHRyaW0obGluZXNbY10pIH1cblxuICByZXR1cm4gbGluZXNcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVBhaXJzKHMsIGEsIGIsIGFyLCBicikge1xuICB2YXIgcCA9IHMuaW5kZXhPZihhKVxuICB3aGlsZSAocCA+PSAwKSB7XG4gICAgcyA9IHMuc3Vic3RyaW5nKDAsIHApICsgYXIgKyBzLnN1YnN0cmluZyhwICsgYS5sZW5ndGgpXG4gICAgcCA9IHMuaW5kZXhPZihiKVxuICAgIGlmIChwIDwgMCkgeyBzID0gcyArIGJyIH1cbiAgICBlbHNlIHsgcyA9IHMuc3Vic3RyaW5nKDAsIHApICsgYnIgKyBzLnN1YnN0cmluZyhwICsgYi5sZW5ndGgpIH1cbiAgICBwID0gcy5pbmRleE9mKGEpXG4gIH1cbiAgcmV0dXJuIHNcbn0iLCIvKiogdGFrZXMgdXJsIHBhcmFtZXRlciBhbmQgdHJhbnNmb3JtcyBpbnRvIG9iamVjdCAqKi9cbmZ1bmN0aW9uIGRlUGFyYW0odXJsU3RyKSB7XG4gIGNvbnN0IHN1YmJpZSA9IHVybFN0ci5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IHggPSBzdWJiaWUuc3BsaXQoJyYnKS5tYXAocyA9PiBzLnNwbGl0KCc9JykpO1xuICByZXR1cm4geC5yZWR1Y2UoKGFjY3VtLCBhcnIpID0+IHsgYWNjdW1bYXJyWzBdXSA9IGFyclsxXTsgcmV0dXJuIGFjY3VtOyB9LCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVQYXJhbTsiLCIvKiogY3JlYXRlcyBkZWZhdWx0IGlucHV0IHRvIHN0YXJ0IGZ1bmN0aW9uICoqL1xuc29sdXRpb25zID0gcmVxdWlyZShcIi4uL3NvbHV0aW9ucy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZhdWx0SW5wdXQoZXhlcmNpc2UpIHtcbiAgbGV0IHNvbHV0aW9uID0gZXhlcmNpc2Uuc29sdXRpb24gfHwgc29sdXRpb25zW2V4ZXJjaXNlLm5hbWVdO1xuICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyB3ZSBoYXZlIGEgc3RyaW5nIHNvbHV0aW9uLCBsaWtlbHkgcHNldWRvY29kZVxuICAgIHZhciBsaW5lcyA9IHNvbHV0aW9uLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiAobGluZXNbMF0udHJpbSgpICsgXCJcXG4gXFxuIFxcbiBcXG5cIiArIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnRyaW0oKSk7XG4gIH1cbiAgbGV0IHNvbHV0aW9uRnVsbFRleHQgPSBzb2x1dGlvbi50b1N0cmluZygpO1xuICBsZXQgb3BlbmluZ0JyYWNrZXQgPSBzb2x1dGlvbkZ1bGxUZXh0LmluZGV4T2YoXCJ7XCIpXG4gIHJldHVybiBzb2x1dGlvbkZ1bGxUZXh0LnN1YnN0cmluZygwLCBvcGVuaW5nQnJhY2tldCkgKyBcIntcXG4gXFxuIFxcbn1cIjtcbn0iLCJcbmxldCBpbnB1dFBhcnNlciA9IHJlcXVpcmUoXCIuL2lucHV0UGFyc2VyLmpzXCIpO1xubGV0IHNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuLi9zb2x1dGlvbnMuanNcIik7XG5sZXQgcnVuUFMgPSByZXF1aXJlKFwiLi9jb252ZXJ0UFN0b0pTLmpzXCIpO1xubGV0IHByZXR0eVByaW50TWFwID0gcmVxdWlyZShcIi4vcHJldHR5UHJpbnRNYXAuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZXJjaXNlKSB7XG4gICAgLy8gZXhhbXBsZS9zYW1wbGUgcnVuc1xuICAgIGxldCBzb2x1dGlvbiA9IGV4ZXJjaXNlLnNvbHV0aW9uIHx8IHNvbHV0aW9uc1tleGVyY2lzZS5uYW1lXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBleGVyY2lzZS5pbnB1dHNbaV0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IHN5bnRheCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5leGFtcGxlc1wiKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBgPHA+PGVtPk5vdGUgdGhhdCB0aGUgTWFwIHN5bnRheCBmb3IgdGhlIGV4YW1wbGUgcnVucyBhbmQgb3V0cHV0IGhhcyBiZWVuIHNpbXBsaWZpZWQgZm9yIHVzZXIgcmVhZGFiaWxpdHksIGJ1dCB3b3VsZCBub3QgYWN0dWFsbHkgY3JlYXRlIGEgTWFwKCkgcHJvcGVybHkuPC9lbT48L3A+YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0Q29weSA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBleGVyY2lzZS5pbnB1dHNbaV0pO1xuICAgICAgICAgICAgICAgIGxldCBmb3JtYXR0ZWRJbnB1dCA9IHByZXR0eVByaW50TWFwKGlucHV0Q29weSwgXCJwYXJlbnRoZXNlc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgW3Jlc3VsdCwgb3V0XSA9IHJ1blBTKHNvbHV0aW9uLCBpbnB1dENvcHksIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IG91dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzb2x1dGlvbihpbnB1dENvcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJldHR5UHJpbnRNYXAocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXhhbXBsZXMnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYDxsaT4ke2V4ZXJjaXNlTmFtZX0ke2Zvcm1hdHRlZElucHV0fSDihpIgJHtmb3JtYXR0ZWRSZXN1bHR9PC9saT5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHNvbHV0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBbcmVzdWx0LCBvdXRdID0gcnVuUFMoc29sdXRpb24sIGlucHV0LCBleGVyY2lzZS5wcmVhbWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBvdXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc29sdXRpb24oLi4uaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXhhbXBsZXMnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYDxsaT4ke2V4ZXJjaXNlLm5hbWV9JHtleGVyY2lzZS5pbnB1dHNbaV19IOKGkiAke3Jlc3VsdH08L2xpPmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsImNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKVxuY29uc3QgUXVldWUgPSByZXF1aXJlKFwiLi9xdWV1ZXNcIilcbmNvbnN0IFN0YWNrID0gcmVxdWlyZShcIi4vc3RhY2tzXCIpXG4vKiogUmV0dXJuIHJvdyBmb3IgaHRtbCB0YWJsZSAqKi9cbmZ1bmN0aW9uIGZvcm1hdFJlc3VsdHMoaW5wdXQsIGlkZWFsUmVzdWx0LCByZXN1bHQsIGlkZWFsT3V0cHV0LCBvdXRwdXQpIHtcbiAgICB2YXIgaW5wdXRTdHIgPSBcIlwiO1xuICAgIGlmIChpZGVhbE91dHB1dCAhPT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBvdXRwdXQ7XG4gICAgICAgIGlkZWFsUmVzdWx0ID0gaWRlYWxPdXRwdXQ7XG4gICAgfVxuICAgIGNvbnN0IG9rID0gKGlkZWFsUmVzdWx0ID09PSByZXN1bHQpO1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbGxlY3Rpb24gfHxcbiAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBTdGFjayB8fFxuICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIFF1ZXVlKSB7XG4gICAgICAgIGlucHV0U3RyID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlucHV0U3RyID0gaW5wdXRTdHIucmVwbGFjZUFsbChcIixcIiwgXCIsIFwiKTtcbiAgICAgICAgaW5wdXRTdHIgPSBpbnB1dFN0ci5yZXBsYWNlQWxsKFwiXSwgW1wiLCBcIl0sIFxcbiBbXCIpO1xuICAgICAgICBpbnB1dFN0ciA9IGlucHV0U3RyLnN1YnN0cmluZygxLCBpbnB1dFN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaW5wdXRTdHIgPSBpbnB1dFN0ci5yZXBsYWNlQWxsKFwidHJ1ZVwiLCBcIlRSVUVcIik7XG4gICAgaW5wdXRTdHIgPSBpbnB1dFN0ci5yZXBsYWNlQWxsKFwiZmFsc2VcIiwgXCJGQUxTRVwiKTtcbiAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuICAgIHJvdy5pbm5lckhUTUwgPSBgPHRkPiR7aW5wdXRTdHJ9PC90ZD5cbiAgICAgICAgICAgIDx0ZD4ke2lkZWFsUmVzdWx0fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+JHtyZXN1bHR9PC90ZD5cbiAgICAgICAgICAgIDx0ZD4ke29rID8gJ+KclCcgOiAn4pyWJ308L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwic3RhdHVzLWJveFwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke29rID8gJyMzMThkMDcnIDogJyNjZTAzMDMnfVwiPjwvdGQ+YDtcbiAgICByZXR1cm4gcm93O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdFJlc3VsdHM7IiwiXG5jb25zdCB7IGFyZ3MgfSA9IHJlcXVpcmUoXCJ3YXRjaGlmeVwiKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi9jb2xsZWN0aW9ucy5qc1wiKTtcbmNvbnN0IFN0YWNrID0gcmVxdWlyZShcIi4vc3RhY2tzLmpzXCIpXG5jb25zdCBRdWV1ZSA9IHJlcXVpcmUoXCIuL3F1ZXVlcy5qc1wiKVxuXG4vKipcbiAqIGl0IGNvbnZlcnRzIG5vZGluZ2JhdCBpbnB1dCAoYXMgc3RvcmVkKSB0byBqc1xuICogICAgIGUuZy4gaW5wdXRQYXJzZXIoJygxLDIpJyk9PlsxLDJdXG4gKiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnB1dFBhcnNlcihleGVyY2lzZSwgaW5wdXRTdHIpIHtcbiAgLyoqXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKi9cbiAgdmFyIGFyZ3NXaXRob3V0UGFyZW50aGVzZXMgPSBpbnB1dFN0ci5zbGljZSgxLCAtMSk7XG4gIGFyZ3NXaXRob3V0UGFyZW50aGVzZXMgPSBhcmdzV2l0aG91dFBhcmVudGhlc2VzLnJlcGxhY2VBbGwoXCJUUlVFXCIsIFwidHJ1ZVwiKTtcbiAgYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyA9IGFyZ3NXaXRob3V0UGFyZW50aGVzZXMucmVwbGFjZUFsbChcIkZBTFNFXCIsIFwiZmFsc2VcIik7XG4gIGxldCBmdW5jdGlvbklucHV0O1xuXG4gIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwibWFwXCIpIHtcbiAgICBpZiAoYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyA9PT0gXCJbW11dXCIpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGV0IHRlbXBBcnJheU9mQXJncyA9IEpTT04ucGFyc2UoYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyk7XG4gICAgICBmdW5jdGlvbklucHV0ID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgaXRlbSBvZiB0ZW1wQXJyYXlPZkFyZ3MpIHtcbiAgICAgICAgZnVuY3Rpb25JbnB1dC5zZXQoaXRlbVswXSwgaXRlbVsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4ZXJjaXNlLmlucHV0VHlwZSA9PT0gXCJjb2xsZWN0aW9uXCIpIHtcbiAgICBsZXQgYXJyYXlJbnB1dFN0cmluZyA9IGFyZ3NXaXRob3V0UGFyZW50aGVzZXMucmVwbGFjZUFsbChcIntcIiwgXCJbXCIpLnJlcGxhY2VBbGwoXCJ9XCIsIFwiXVwiKTtcbiAgICBsZXQgYXJyYXlJbnB1dCA9IEpTT04ucGFyc2UoYXJyYXlJbnB1dFN0cmluZyk7XG4gICAgZnVuY3Rpb25JbnB1dCA9IFtuZXcgQ29sbGVjdGlvbihhcnJheUlucHV0KV07XG4gIH0gZWxzZSBpZiAoZXhlcmNpc2UuaW5wdXRUeXBlID09PSBcInN0YWNrXCIpIHtcbiAgICBsZXQgYXJyYXlJbnB1dFN0cmluZyA9IGFyZ3NXaXRob3V0UGFyZW50aGVzZXNcbiAgICAgIC5zdWJzdHJpbmcoYXJnc1dpdGhvdXRQYXJlbnRoZXNlcy5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgYXJnc1dpdGhvdXRQYXJlbnRoZXNlcy5pbmRleE9mKFwiXVwiKSArIDEpO1xuICAgIGxldCBhcnJheUlucHV0ID0gSlNPTi5wYXJzZShhcnJheUlucHV0U3RyaW5nKTtcbiAgICBmdW5jdGlvbklucHV0ID0gW25ldyBTdGFjayhhcnJheUlucHV0KV1cbiAgfSBlbHNlIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwicXVldWVcIikge1xuICAgIGxldCBhcnJheUlucHV0U3RyaW5nID0gYXJnc1dpdGhvdXRQYXJlbnRoZXNlc1xuICAgICAgLnN1YnN0cmluZyhhcmdzV2l0aG91dFBhcmVudGhlc2VzLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICBhcmdzV2l0aG91dFBhcmVudGhlc2VzLmluZGV4T2YoXCJdXCIpICsgMSk7XG4gICAgbGV0IGFycmF5SW5wdXQgPSBKU09OLnBhcnNlKGFycmF5SW5wdXRTdHJpbmcpO1xuICAgIGZ1bmN0aW9uSW5wdXQgPSBbbmV3IFF1ZXVlKGFycmF5SW5wdXQpXVxuICB9XG4gIGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsZXQgYXJyYXlPZkFyZ3MgPSAnWycgKyBhcmdzV2l0aG91dFBhcmVudGhlc2VzICsgJ10nO1xuICAgICAgZXZhbChcImZ1bmN0aW9uSW5wdXQgPSBcIiArIGFycmF5T2ZBcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBmdW5jdGlvbklucHV0ID0gZS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb25JbnB1dDtcbn0iLCIvLyBmdW5jdGlvbiB0byBzaG93IHRoZSBNYXAgZGF0YSB0eXBlIGluIGEgdXNlci1mcmllbmRseSB3YXlcbi8vICAtIHdpdGhvdXQgZG9pbmcgc29tZXRoaW5nIGxpa2UgdGhpcywgaXQganVzdCBzaG93cyB1cCBhcyBPYmplY3QoKVxuXG5cbmZ1bmN0aW9uIHByZXR0eVByaW50TWFwKHRoZU1hcCwgc3R5bGUgPSBcIm5vX3BhcmVudGhlc2VzXCIpIHtcbiAgbGV0IGZvcm1hdHRlZE1hcFJlc3VsdCA9IFwiXCI7XG4gIGlmIChzdHlsZSA9PSBcInBhcmVudGhlc2VzXCIpIHtcbiAgICBmb3JtYXR0ZWRNYXBSZXN1bHQgPSBcIihcIjtcbiAgfVxuICBmb3JtYXR0ZWRNYXBSZXN1bHQgPSBmb3JtYXR0ZWRNYXBSZXN1bHQgKyBcIntcIjtcblxuICAvL2NoZWNrIGlmIGl0IGlzIGFuIGVtcHR5IG1hcFxuICBsZXQgZW10cHlNYXAgPSBuZXcgTWFwKCk7XG4gIGxldCBpc0VtcHR5ID0gKHRoZU1hcCA9PT0gZW10cHlNYXApO1xuICBpZiAoIWlzRW1wdHkpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoZU1hcCkge1xuICAgICAgZm9ybWF0dGVkTWFwUmVzdWx0ICs9IGAnJHtpdGVtWzBdfSc6ICcke2l0ZW1bMV19JywgYDtcbiAgICB9XG5cbiAgICBmb3JtYXR0ZWRNYXBSZXN1bHQgPSBmb3JtYXR0ZWRNYXBSZXN1bHQuc2xpY2UoMCwgLTIpO1xuICB9XG5cbiAgZm9ybWF0dGVkTWFwUmVzdWx0ID0gZm9ybWF0dGVkTWFwUmVzdWx0ICsgXCJ9XCI7XG5cbiAgaWYgKHN0eWxlID09IFwicGFyZW50aGVzZXNcIikge1xuICAgIGZvcm1hdHRlZE1hcFJlc3VsdCA9IGZvcm1hdHRlZE1hcFJlc3VsdCArIFwiKVwiO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZWRNYXBSZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJldHR5UHJpbnRNYXA7XG4iLCJjb25zdCBKU09ONSA9IHJlcXVpcmUoXCJqc29uNVwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUXVldWUge1xyXG4gIHZhbHVlcyA9IG5ldyBBcnJheSgpO1xyXG4gIG5leHQgPSAwO1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcnIpIHtcclxuICAgIGlmIChhcnIgJiYgQXJyYXkuaXNBcnJheShhcnIpKVxyXG4gICAgICB0aGlzLnZhbHVlcyA9IGFycjtcclxuICB9XHJcblxyXG4gIGlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZXMubGVuZ3RoIDwgMSlcclxuICAgIH1cclxuICAgIGVsc2UgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgfVxyXG5cclxuICBlbnF1ZXVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMuc2hpZnQoKTtcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFwiRnJcIiArIEpTT041LnN0cmluZ2lmeSh0aGlzLnZhbHVlcykucmVwbGFjZUFsbChcIixcIiwgXCIsIFwiKSArIFwiQmtcIjtcclxuICB9XHJcbn0iLCJsZXQgZGVmYXVsdElucHV0ID0gcmVxdWlyZShcIi4vZGVmYXVsdElucHV0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlZGl0b3IsIGV4ZXJjaXNlTmFtZSwgZXhlcmNpc2UpIHtcbiAgICBsZXQgZXhlcmNpc2VDb2RlID0gZXhlcmNpc2VOYW1lICsgXCIgLSBjb2RlXCI7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGV4ZXJjaXNlQ29kZSkpIHtcbiAgICAgICAgLy9sb2FkIHByZXZpb3VzIHNvbHV0aW9uIGZyb20gbG9jYWxTdG9yYWdlLCBpZiBwb3NzaWJsZVxuICAgICAgICBlZGl0b3Iuc2V0VmFsdWUobG9jYWxTdG9yYWdlLmdldEl0ZW0oZXhlcmNpc2VDb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gcHJldmlvdXMgc29sdXRpb24sIGp1c3QgZGlzcGxheSB0aGUgZGVmYXVsdC4uLlxuICAgICAgICBlZGl0b3Iuc2V0VmFsdWUoZGVmYXVsdElucHV0KGV4ZXJjaXNlKSk7XG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHtcbiAgICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgICBjaDogMlxuICAgICAgICB9KTtcbiAgICB9XG59OyIsImNvbnN0IEpTT041ID0gcmVxdWlyZShcImpzb241XCIpXHJcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3RhY2sge1xyXG4gIHZhbHVlcyA9IG5ldyBBcnJheSgpO1xyXG4gIG5leHQgPSAwO1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcnIpIHtcclxuICAgIGlmIChhcnIgJiYgQXJyYXkuaXNBcnJheShhcnIpKVxyXG4gICAgICB0aGlzLnZhbHVlcyA9IGFycjtcclxuICB9XHJcblxyXG4gIHB1c2ggPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgIHRoaXMudmFsdWVzLnB1c2goZWwpO1xyXG4gIH1cclxuICBwb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMucG9wKCk7XHJcbiAgfVxyXG4gIGlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZXMubGVuZ3RoIDwgMSlcclxuICAgIH1cclxuICAgIGVsc2UgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBvdXQgPSBcIkJcIiArIEpTT041LnN0cmluZ2lmeSh0aGlzLnZhbHVlcykucmVwbGFjZUFsbChcIixcIiwgXCIsIFwiKSArIFwiVFwiO1xyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcblxyXG59XHJcbiIsImZ1bmN0aW9uIHRhYmxlSGVhZGVyKCkge1xuICAgIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIik7XG4gICAgcm93LmlubmVySFRNTCA9IGA8dGg+SW5wdXRzPC90aD5cbiAgICAgICAgICAgICAgICA8dGg+RXhwZWN0ZWQgcmVzdWx0PC90aD5cbiAgICAgICAgICAgICAgICA8dGg+WW91ciByZXN1bHQ8L3RoPlxuICAgICAgICAgICAgICAgIDx0aCBjb2xzcGFuPVwiMlwiPkNvcnJlY3Q/PC90aD5gO1xuICAgIHJldHVybiByb3c7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGFibGVIZWFkZXI7Il19
